>> QA Polish Flywheel
>> Usage: mlld run polish [--tier 1] [--max-iterations 10]
>>
>> Runs the full QA → reconcile → analyze → fix loop until stable.
>> Auto-approves fixes where Opus confidence >= 0.9 and design_fit is high/medium.
>> Uses git worktrees for isolated parallel fix application.

import { @claude } from @mlld/claude

>> Payload options
import "@payload" as @p
var @tier = @p.tier ? @p.tier : "1"
var @maxIterations = @p.maxIterations ? @p.maxIterations : 10

>> Configuration
var @qaDir = "@base/qa"

>> Get current branch for worktree base
var @baseBranch = sh {git branch --show-current}

>> === PROMPT TEMPLATES ===

var @reconcilePromptTemplate = <@base/llm/run/qa-reconcile-prompt.att>
var @analyzePromptTemplate = <@base/llm/run/qa-analyze-prompt.att>
var @applyPromptTemplate = <@base/llm/run/qa-apply-prompt.att>
var @mergePromptTemplate = <@base/llm/run/qa-merge-prompt.att>
var @verifyPromptTemplate = <@base/llm/run/qa-verify-prompt.att>

>> === BUILD PROMPT FUNCTIONS ===

exe @buildReconcilePrompt(tmpl, result) = [
  let @issues = @result.issues ? `@result.issues` : "[]"
  let @s1 = @tmpl.replace("@topic", @result.topic)
  let @s2 = @s1.replace("@experiment", @result.experiment)
  let @s3 = @s2.replace("@status", @result.status)
  let @s4 = @s3.replace("@summary", @result.summary)
  let @s5 = @s4.replace("@issues", @issues)
  => @s5.replace("@outputDir", @qaDir)
]

exe @buildAnalyzePrompt(tmpl, item) = [
  let @s1 = @tmpl.replace("@topic", @item.topic)
  let @s2 = @s1.replace("@experiment", @item.experiment)
  let @s3 = @s2.replace("@resultsPath", @item.resultsPath)
  let @s4 = @s3.replace("@reconciliationPath", @item.reconciliationPath)
  let @s5 = @s4.replace("@outputDir", @item.experimentDir)
  => @s5.replace("@experimentDir", @item.experimentDir)
]

exe @buildApplyPrompt(tmpl, item, baseBranch) = [
  let @fix = @item.fix
  let @proposedFix = @fix.proposed_fixes[0]
  let @s1 = @tmpl.replace("@topic", @item.topic)
  let @s2 = @s1.replace("@experiment", @item.experiment)
  let @s3 = @s2.replace("@baseBranch", @baseBranch)
  let @s4 = @s3.replace("@experimentDir", @item.experimentDir)
  let @s5 = @s4.replace("@rootCause", @fix.investigation.root_cause)
  let @s6 = @s5.replace("@rootCauseLocation", @fix.investigation.root_cause_location)
  let @s7 = @s6.replace("@fixId", @fix.recommendation.fix_id)
  let @s8 = @s7.replace("@confidence", `@fix.recommendation.confidence`)
  let @s9 = @s8.replace("@designFit", @fix.recommendation.design_fit)
  => @s9.replace("@proposedFixes", `@fix.proposed_fixes`)
]

exe @buildMergePrompt(tmpl, items, baseBranch, qaDir) = [
  let @s1 = @tmpl.replace("@baseBranch", @baseBranch)
  let @s2 = @s1.replace("@qaDir", @qaDir)
  => @s2.replace("@mergeItems", `@items`)
]

exe @buildVerifyPrompt(tmpl, items, baseBranch, qaDir, iteration) = [
  let @s1 = @tmpl.replace("@baseBranch", @baseBranch)
  let @s2 = @s1.replace("@qaDir", @qaDir)
  let @s3 = @s2.replace("@mergeCount", `@items.length`)
  let @s4 = @s3.replace("@iteration", `@iteration`)
  => @s4.replace("@mergedItems", `@items`)
]

>> === MAIN LOOP ===

show `=== QA Polish Flywheel ===`
show `Tier: @tier`
show `Max iterations: @maxIterations`
show `Base branch: @baseBranch`
show ``

var @iteration = 0
var @stable = false

>> Check for failed verification before starting
var @prevVerification = <@qaDir/verification-result.json>
when @prevVerification && @prevVerification.status == "fail" => show `WARNING: Previous verification failed. See @qaDir/verification-result.json`

loop until @stable || @iteration >= @maxIterations [
  let @iteration = @iteration + 1
  show `--- Iteration @iteration ---`

  >> Load all state files fresh each iteration
  let @allResults = <@qaDir/**/results.json>
  let @allReconciliations = <@qaDir/**/reconciliation.json>
  let @allProposedFixes = <@qaDir/**/proposed-fix.json>
  let @allFixedFiles = <@qaDir/**/fixed.json>

  >> Build lookup sets
  let @reconciledDirs = for @r in @allReconciliations => @r.mx.absoluteDir
  let @analyzedDirs = for @f in @allProposedFixes => @f.mx.absoluteDir
  let @fixedDirs = for @f in @allFixedFiles => @f.mx.absoluteDir

  >> Count status
  let @passing = for @r in @allResults when @r.status == "pass" => @r
  let @failing = for @r in @allResults when @r.status == "fail" => @r

  show `State: @allResults.length total, @passing.length passing, @failing.length failing`

  >> ========== PHASE 1: RECONCILE ==========
  let @needsReconcile = for @r in @allResults
    when (@r.status == "fail" || @r.status == "partial")
      && !@reconciledDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      status: @r.status,
      summary: @r.summary,
      issues: @r.issues,
      experimentDir: @r.mx.absoluteDir
    }

  show `Phase 1: Reconciling @needsReconcile.length failures...`

  let @reconcileLimit = @needsReconcile.slice(0, 20)
  for parallel(20) @item in @reconcileLimit [
    let @prompt = @buildReconcilePrompt(@reconcilePromptTemplate, @item)
    show `  Reconciling: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep") | log
    => @item.topic
  ]

  >> Reload reconciliations after phase 1
  let @freshReconciliations = <@qaDir/**/reconciliation.json>

  >> ========== PHASE 2: ANALYZE ==========
  let @needsAnalyze = for @r in @freshReconciliations
    when @r.verdict == "genuine-bug"
      && @r.action == "implement"
      && !@analyzedDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      experimentDir: @r.mx.absoluteDir,
      resultsPath: `@r.mx.absoluteDir/results.json`,
      reconciliationPath: @r.mx.absolute
    }

  show `Phase 2: Analyzing @needsAnalyze.length genuine bugs...`

  let @analyzeLimit = @needsAnalyze.slice(0, 10)
  for parallel(10) @item in @analyzeLimit [
    let @prompt = @buildAnalyzePrompt(@analyzePromptTemplate, @item)
    show `  Analyzing: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep") | log
    => @item.topic
  ]

  >> Reload proposed fixes after phase 2
  let @freshProposedFixes = <@qaDir/**/proposed-fix.json>

  >> ========== PHASE 3a: APPLY (Parallel in Worktrees) ==========
  let @needsApply = for @f in @freshProposedFixes
    when @f.recommendation.auto_approve == true
      && !@fixedDirs.includes(@f.mx.absoluteDir)
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      fix: @f
    }

  show `Phase 3a: Applying @needsApply.length fixes in worktrees...`

  >> Apply fixes in parallel worktrees (limit 5 to avoid git overhead)
  for parallel(5) @item in @needsApply [
    let @prompt = @buildApplyPrompt(@applyPromptTemplate, @item, @baseBranch)
    show `  Applying: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
    => @item.topic
  ]

  >> ========== PHASE 3b: MERGE (Sequential) ==========
  >> Reload fixed files to see what was applied
  let @freshFixed = <@qaDir/**/fixed.json>
  let @needsMerge = for @f in @freshFixed
    when @f.applied == true
      && @f.verified == true
      && !@f.merged
      && @f.worktree_branch
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      worktree_branch: @f.worktree_branch,
      commit_sha: @f.commit_sha
    }

  show `Phase 3b: Merging @needsMerge.length verified fixes...`

  when @needsMerge.length > 0 [
    let @mergePrompt = @buildMergePrompt(@mergePromptTemplate, @needsMerge, @baseBranch, @qaDir)
    show `  Running merge phase...`
    let @mergeResponse = @claude(@mergePrompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
  ]

  >> ========== PHASE 3c: VERIFY ==========
  >> Reload to get merge results
  let @postMergeFixed = <@qaDir/**/fixed.json>
  let @justMerged = for @f in @postMergeFixed
    when @f.merged == true
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      test_fixture: @f.test_fixture,
      merge_commit: @f.merge_commit
    }

  when @justMerged.length > 0 [
    show `Phase 3c: Verifying @justMerged.length merged fixes...`
    let @verifyPrompt = @buildVerifyPrompt(@verifyPromptTemplate, @justMerged, @baseBranch, @qaDir, @iteration)
    let @verifyResponse = @claude(@verifyPrompt, "opus", @base, "Read,Bash,Glob,Grep,Write") | log
  ]

  >> Check if stable (no work done this iteration)
  let @workDone = @reconcileLimit.length + @analyzeLimit.length + @needsApply.length
  when @workDone == 0 [
    let @stable = true
  ]

  show `Work done: @workDone items`
  show ``
]

>> Final summary
var @finalResults = <@qaDir/**/results.json>
var @finalReconciliations = <@qaDir/**/reconciliation.json>
var @finalProposedFixes = <@qaDir/**/proposed-fix.json>
var @finalFixed = <@qaDir/**/fixed.json>

var @finalPassing = for @r in @finalResults when @r.status == "pass" => @r
var @finalFailing = for @r in @finalResults when @r.status == "fail" => @r
var @finalGenuineBugs = for @r in @finalReconciliations when @r.verdict == "genuine-bug" => @r
var @finalMerged = for @f in @finalFixed when @f.merged == true => @f

show `=== Polish Complete ===`
show `Iterations: @iteration`
show `Stable: @stable`
show ``
show `Final state:`
show `  Total: @finalResults.length`
show `  Passing: @finalPassing.length`
show `  Failing: @finalFailing.length`
show `  Reconciled: @finalReconciliations.length`
show `  Genuine bugs: @finalGenuineBugs.length`
show `  Analyzed: @finalProposedFixes.length`
show `  Fixed & Merged: @finalMerged.length`
