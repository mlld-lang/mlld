>> QA Polish Flywheel
>> Usage: mlld run polish [--tier 1] [--max-iterations 10] [--run <YYYY-MM-DD>]
>>
>> Runs the full QA → reconcile → analyze → fix loop until stable.
>> Auto-approves fixes where Opus confidence >= 0.9 and design_fit is high/medium.
>> Uses git worktrees for isolated parallel fix application.
>> Operates on a specific QA run directory (defaults to latest).
>>
>> Strategy-aware: if the QA run has a trend-report.json (and optionally
>> strategy-questions.md with human answers), Phase 0 generates strategy.json
>> which routes topics to code-fix, doc-fix, defer, or skip actions.
>> Doc fixes are handled separately without worktrees.
>> Without a trend report, runs in legacy mode (all items as potential code fixes).

import { @claude } from @mlld/claude
import { @claudePoll } from @mlld/claude-poll

>> Payload options
import "@payload" as @p
var @tier = @p.tier ? @p.tier : "1"
var @maxIterations = @p.maxIterations ? @p.maxIterations * 1 : 10
var @run = @p.run ? @p.run : ""

>> Configuration
var @qaRoot = "@base/qa"

>> Resolve which QA run to polish (explicit --run or latest dated directory)
exe @latestRunName(qaRoot) = cmd {ls "@qaRoot" | grep '^20' | sort -r | head -1}
var @runName = @run ? @run : @latestRunName(@qaRoot)
var @qaDir = `@qaRoot/@runName`
when !@runName => show `Error: No QA run found. Run 'mlld run qa' first.`

>> Get current branch for worktree base
var @baseBranch = sh {git branch --show-current}

>> Tool permissions for polish agents
var @reconcileTools = "Read,Write,Glob,Grep,Bash(mlld:*),Bash(cat:*)"
var @applyTools = "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(wt:*),Bash(npm run:*),Bash(npm test:*),Bash(cat:*),Bash(pwd),Bash(head:*)"
var @verifyTools = "Read,Write,Glob,Grep,Bash(git:*),Bash(wt:*),Bash(npm run:*),Bash(npm test:*),Bash(cat:*),Bash(tee:*),Bash(head:*)"
var @docFixTools = "Read,Write,Edit,Glob,Grep,Bash(mlld:*),Bash(cat:*),Bash(git diff:*),Bash(git status)"
var @strategyTools = "Read,Write,Glob,Grep"

>> === BUILD PROMPT FUNCTIONS (using template auto-interpolation) ===

exe @buildReconcilePrompt(topic, experiment, status, summary, issues, outputDir) = template "./qa-reconcile-prompt.att"

exe @buildAnalyzePrompt(topic, experiment, resultsPath, reconciliationPath, experimentDir) = template "./qa-analyze-prompt.att"

exe @buildApplyPrompt(topic, experiment, baseBranch, experimentDir, rootCause, rootCauseLocation, fixId, confidence, designFit, proposedFixes) = template "./qa-apply-prompt.att"

exe @buildMergePrompt(baseBranch, qaDir, mergeItems) = template "./qa-merge-prompt.att"

exe @buildVerifyPrompt(baseBranch, qaDir, mergeCount, iteration, mergedItems) = template "./qa-verify-prompt.att"

exe @buildTriagePrompt(topic, experiment, baseBranch, worktreeBranch, experimentDir, errors) = template "./qa-triage-prompt.att"

exe @buildStrategyInterpretPrompt(qaDir, hasStrategyQuestions) = template "./qa-strategy-interpret-prompt.att"
exe @buildDocFixPrompt(topics, stratId, description, qaDir) = template "./qa-doc-fix-prompt.att"

>> === MAIN LOOP ===

show `=== QA Polish Flywheel ===`
show `Run: @runName`
show `Dir: @qaDir`
show `Tier: @tier`
show `Max iterations: @maxIterations`
show `Base branch: @baseBranch`
show ``

>> Check for failed verification before starting - HALT if previous run broke things
var @prevVerificationFiles = <@qaDir/**/verification-result.json>
var @prevVerification = @prevVerificationFiles.length > 0 ? @prevVerificationFiles[0] : null
var @halted = @prevVerification && @prevVerification.status == "fail"

when @halted [
  show `ERROR: Previous verification failed. Resolve before continuing.`
  show `See: @qaDir/verification-result.json`
  show ``
  show `Recommended actions:`
  show `  1. Review the failures in verification-result.json`
  show `  2. Either revert the problematic merge or fix manually`
  show `  3. Delete verification-result.json to resume`
]

>> ========== PHASE 0: STRATEGY INTERPRETATION ==========
>> Read trend report + strategy questions to produce strategy.json

var @trendReportFiles = <@qaDir/trend-report.json>
var @hasTrendReport = @trendReportFiles.length > 0
var @strategyFileCheck = <@qaDir/strategy.json>
var @hasStrategy = @strategyFileCheck.length > 0
var @strategyQuestionsFiles = <@qaDir/strategy-questions.md>
var @hasStrategyQuestions = @strategyQuestionsFiles.length > 0

>> Generate strategy.json if we have a trend report but no strategy yet
when @hasTrendReport && !@hasStrategy && !@halted [
  show `=== PHASE 0: STRATEGY INTERPRETATION ===`
  show `Interpreting trend report + strategy questions...`
  show ``

  let @phase0Prompt = @buildStrategyInterpretPrompt(@qaDir, @hasStrategyQuestions)
  let @phase0Marker = `@qaDir/strategy.json`

  show `Starting strategy interpretation agent...`
  show `  Trend report: found`
  show `  Strategy questions: @hasStrategyQuestions`
  show `  Polling for: @phase0Marker`
  let @response = @claudePoll(@phase0Prompt, "opus", @base, @strategyTools, @phase0Marker)

  show `Phase 0 complete.`
  show `  Strategy: @qaDir/strategy.json`
  show ``
]

>> Load strategy (may be null if no trend report -- backwards compatible)
var @strategyFiles = <@qaDir/strategy.json>
var @strategy = @strategyFiles.length > 0 ? @strategyFiles[0] : null
var @useStrategy = @strategy != null

when @useStrategy [
  let @codeFixes = for @c in @strategy.classifications when @c.action == "code-fix" => @c
  let @docFixes = for @c in @strategy.classifications when @c.action == "doc-fix" => @c
  let @deferred = for @c in @strategy.classifications when @c.action == "defer" => @c
  let @skipped = for @c in @strategy.classifications when @c.action == "skip" => @c
  show `Strategy loaded: @strategy.classifications.length classifications`
  show `  Code fixes: @codeFixes.length`
  show `  Doc fixes: @docFixes.length`
  show `  Deferred: @deferred.length`
  show `  Skipped: @skipped.length`
  show ``
]

when !@useStrategy && !@halted [
  show `No strategy.json found. Running in legacy mode (all items treated as potential code fixes).`
  show ``
]

>> Helper to check if a topic's strategy action is skip or defer
exe @topicIsSkipped(topic) = [
  when !@useStrategy => false
  let @actionIds = @strategy.topic_actions && @strategy.topic_actions[@topic]
    ? @strategy.topic_actions[@topic]
    : []
  when @actionIds.length == 0 => false
  let @actions = for @id in @actionIds
    => for @c in @strategy.classifications when @c.id == @id => @c.action
  let @flatActions = for @a in @actions => @a
  let @nonSkipped = for @a in @flatActions when @a != "skip" && @a != "defer" => @a
  => @nonSkipped.length == 0
]

>> Helper to check if a topic has code-fix classification
exe @topicIsCodeFix(topic) = [
  when !@useStrategy => true
  let @actionIds = @strategy.topic_actions && @strategy.topic_actions[@topic]
    ? @strategy.topic_actions[@topic]
    : []
  when @actionIds.length == 0 => true
  let @actions = for @id in @actionIds
    => for @c in @strategy.classifications when @c.id == @id => @c.action
  let @flatActions = for @a in @actions => @a
  let @codeActions = for @a in @flatActions when @a == "code-fix" => @a
  => @codeActions.length > 0
]

>> Helper to check if a self-review has genuine bugs
exe @hasGenuineBug(selfReview) = [
  let @bugs = for @issue in (@selfReview.issues_reviewed ? @selfReview.issues_reviewed : [])
    when @issue.revised_verdict == "genuine-bug" => @issue
  => @bugs.length > 0
]

show `DEBUG: before loop, maxIterations=@maxIterations, halted=@halted`
var @loopResult = loop(@maxIterations) [
  >> Check exit conditions
  when @halted => done { iteration: 0, stable: false, halted: true }
  when @input && @input.stable => done @input

  let @iteration = @mx.loop.iteration
  show `--- Iteration @iteration (max=@maxIterations) ---`

  >> Load all state files fresh each iteration
  let @allResults = <@qaDir/**/results.json>
  let @allReconciliations = <@qaDir/**/reconciliation.json>
  let @allSelfReviews = <@qaDir/**/self_review.json>
  let @allProposedFixes = <@qaDir/**/proposed-fix.json>
  let @allFixedFiles = <@qaDir/**/fixed.json>

  >> Build lookup sets
  >> Self-reviews from qa.mld Phase 2 act as reconciliation
  let @selfReviewedDirs = for @sr in @allSelfReviews when @sr.reviewed => @sr.mx.absoluteDir
  let @reconciledDirs = for @r in @allReconciliations => @r.mx.absoluteDir
  let @analyzedDirs = for @f in @allProposedFixes => @f.mx.absoluteDir
  let @fixedDirs = for @f in @allFixedFiles => @f.mx.absoluteDir

  >> Count status
  let @passing = for @r in @allResults when @r.status == "pass" => @r
  let @failing = for @r in @allResults when @r.status == "fail" => @r

  show `State: @allResults.length total, @passing.length passing, @failing.length failing`

  >> ========== PHASE 1: RECONCILE ==========
  >> Skip experiments that have self_review.json (qa.mld Phase 2 already did reconciliation)
  >> Skip experiments whose topic is fully classified as defer/skip in strategy.json
  let @needsReconcile = for @r in @allResults
    when (@r.status == "fail" || @r.status == "partial")
      && !@reconciledDirs.includes(@r.mx.absoluteDir)
      && !@selfReviewedDirs.includes(@r.mx.absoluteDir)
      && !@topicIsSkipped(@r.topic)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      status: @r.status,
      summary: @r.summary,
      issues: @r.issues,
      experimentDir: @r.mx.absoluteDir
    }

  show `Phase 1: Reconciling @needsReconcile.length failures (skipping @selfReviewedDirs.length self-reviewed)...`

  let @reconcileLimit = @needsReconcile.slice(0, 20)
  show `  DEBUG: reconcileLimit has @reconcileLimit.length items`
  for parallel(20, 10s) @item in @reconcileLimit [
    let @issuesJson = @item.issues ? `@item.issues` : "[]"
    let @prompt = @buildReconcilePrompt(@item.topic, @item.experiment, @item.status, @item.summary, @issuesJson, @qaDir)
    show `  Reconciling: @item.topic/@item.experiment`
    let @idx = @mx.for.index + 1
    let @markerFile = `@item.experimentDir/reconciliation.json`
    show `  Phase 1/6 - Reconcile: @idx of @mx.for.total (@item.topic/@item.experiment)`
    let @response = @claudePoll(@prompt, "opus", @base, @reconcileTools, @markerFile)
    => @item.topic
  ]

  >> Reload reconciliations and self-reviews after phase 1
  let @freshReconciliations = <@qaDir/**/reconciliation.json>
  let @freshSelfReviews = <@qaDir/**/self_review.json>

  >> ========== PHASE 2: ANALYZE ==========
  >> Check both reconciliation.json AND self_review.json for genuine bugs

  >> From traditional reconciliation
  let @bugsFromReconcile = for @r in @freshReconciliations
    when @r.verdict == "genuine-bug"
      && @r.action == "implement"
      && !@analyzedDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      experimentDir: @r.mx.absoluteDir,
      resultsPath: `@r.mx.absoluteDir/results.json`,
      reconciliationPath: @r.mx.absolute,
      source: "reconciliation"
    }

  >> From self-reviews (any issue with revised_verdict == "genuine-bug")
  let @bugsFromSelfReview = for @sr in @freshSelfReviews
    when @sr.reviewed && @hasGenuineBug(@sr) && !@analyzedDirs.includes(@sr.mx.absoluteDir)
    => {
      topic: @sr.topic,
      experiment: @sr.experiment,
      experimentDir: @sr.mx.absoluteDir,
      resultsPath: `@sr.mx.absoluteDir/results.json`,
      reconciliationPath: @sr.mx.absolute,
      source: "self-review"
    }

  >> Combine both sources, filtering to code-fix topics when strategy exists
  let @needsAnalyzeRaw = @bugsFromReconcile.concat(@bugsFromSelfReview)
  let @needsAnalyze = for @item in @needsAnalyzeRaw when @topicIsCodeFix(@item.topic) => @item

  show `Phase 2: Analyzing @needsAnalyze.length genuine bugs (@bugsFromReconcile.length from reconcile, @bugsFromSelfReview.length from self-review)...`

  let @analyzeLimit = @needsAnalyze.slice(0, 10)
  show `  DEBUG: analyzeLimit has @analyzeLimit.length items`
  show `  DEBUG: entering analyze loop...`
  for parallel(10, 10s) @item in @analyzeLimit [
    show `  DEBUG: loop body for @item.topic/@item.experiment`
    show `  DEBUG: calling buildAnalyzePrompt...`
    let @prompt = @buildAnalyzePrompt(@item.topic, @item.experiment, @item.resultsPath, @item.reconciliationPath, @item.experimentDir)
    show `  DEBUG: prompt built, length=@prompt.length`
    show `  Analyzing: @item.topic/@item.experiment`
    let @idx = @mx.for.index + 1
    let @markerFile = `@item.experimentDir/proposed-fix.json`
    show `  Phase 2/6 - Analyze: @idx of @mx.for.total (@item.topic/@item.experiment)`
    let @response = @claudePoll(@prompt, "opus", @base, @reconcileTools, @markerFile)
    => @item.topic
  ]
  show `  DEBUG: exited analyze loop`

  >> Reload proposed fixes after phase 2
  let @freshProposedFixes = <@qaDir/**/proposed-fix.json>

  >> ========== PHASE 2b: DOC FIXES ==========
  >> Handle doc-fix classifications from strategy -- no worktree needed
  let @docFixCount = 0

  when @useStrategy [
    let @docFixClassifications = for @c in @strategy.classifications
      when @c.action == "doc-fix" => @c

    >> Check which doc fixes have already been done
    let @existingDocFixes = <@qaDir/doc-fix-*.json>
    let @docFixedIds = for @df in @existingDocFixes when @df.strat_id => @df.strat_id

    let @needsDocFix = for @c in @docFixClassifications
      when !@docFixedIds.includes(@c.id) => @c

    show `Phase 2b: @needsDocFix.length doc fixes to apply...`
    var @docFixCount = @needsDocFix.length

    for parallel(5, 10s) @item in @needsDocFix [
      let @topicsStr = @item.topics.join(",")
      let @prompt = @buildDocFixPrompt(
        @topicsStr,
        @item.id,
        @item.description,
        @qaDir
      )
      let @idx = @mx.for.index + 1
      let @markerFile = `@qaDir/doc-fix-@item.id.json`
      show `  Phase 2b - Doc Fix: @idx of @mx.for.total (@item.description)`
      let @response = @claudePoll(@prompt, "sonnet", @base, @docFixTools, @markerFile)
      => @item.id
    ]
  ]

  >> ========== PHASE 3a: APPLY (Parallel in Worktrees) ==========
  let @needsApply = for @f in @freshProposedFixes
    when @f.recommendation.auto_approve == true
      && !@fixedDirs.includes(@f.mx.absoluteDir)
      && @topicIsCodeFix(@f.topic)
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      fix: @f
    }

  show `Phase 3a: Applying @needsApply.length fixes in worktrees...`
  show `  DEBUG: needsApply has @needsApply.length items`

  >> Apply fixes in parallel worktrees (5 concurrent, 1m delay to avoid rate limits)
  show `  DEBUG: entering apply loop...`
  for parallel(5, 10s) @item in @needsApply [
    show `  DEBUG: apply loop body for @item.topic/@item.experiment`
    let @fix = @item.fix
    let @prompt = @buildApplyPrompt(
      @item.topic,
      @item.experiment,
      @baseBranch,
      @item.experimentDir,
      @fix.investigation.root_cause,
      @fix.investigation.root_cause_location,
      @fix.recommendation.fix_id,
      `@fix.recommendation.confidence`,
      @fix.recommendation.design_fit,
      `@fix.proposed_fixes`
    )
    show `  DEBUG: prompt built, length=@prompt.length`
    show `  Applying: @item.topic/@item.experiment`
    let @idx = @mx.for.index + 1
    let @markerFile = `@item.experimentDir/fixed.json`
    show `  Phase 3/6 - Apply: @idx of @mx.for.total (@item.topic/@item.experiment)`
    let @response = @claudePoll(@prompt, "opus", @base, @applyTools, @markerFile)
    => @item.topic
  ]
  show `  DEBUG: exited apply loop`

  >> ========== PHASE 3a.5: TRIAGE FAILED FIXES ==========
  >> Reload fixed files to see apply results
  let @postApplyFixed = <@qaDir/**/fixed.json>
  let @needsTriage = for @f in @postApplyFixed
    when @f.applied == true
      && @f.verified == false
      && !@f.escalated
      && @f.worktree_branch
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      worktree_branch: @f.worktree_branch,
      errors: @f.errors
    }

  show `Phase 3a.5: Triaging @needsTriage.length failed fixes...`
  show `  DEBUG: needsTriage has @needsTriage.length items`

  >> Triage sequentially to avoid worktree conflicts
  for @item in @needsTriage [
    let @errorsJson = @item.errors ? `@item.errors` : "[]"
    let @prompt = @buildTriagePrompt(
      @item.topic,
      @item.experiment,
      @baseBranch,
      @item.worktree_branch,
      @item.experimentDir,
      @errorsJson
    )
    show `  Triaging: @item.topic/@item.experiment`
    let @idx = @mx.for.index + 1
    >> Can't use fixed.json as marker - it already exists from the apply phase
    let @markerFile = `@item.experimentDir/triage-complete.json`
    show `  Phase 4/6 - Triage: @idx of @mx.for.total (@item.topic/@item.experiment)`
    let @response = @claudePoll(@prompt, "opus", @base, @applyTools, @markerFile)
  ]

  >> ========== PHASE 3b: MERGE (Sequential) ==========
  >> Reload fixed files to see triage results
  let @freshFixed = <@qaDir/**/fixed.json>
  let @needsMerge = for @f in @freshFixed
    when @f.applied == true
      && @f.verified == true
      && !@f.merged
      && @f.worktree_branch
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      worktree_branch: @f.worktree_branch,
      commit_sha: @f.commit_sha
    }

  show `Phase 3b: Merging @needsMerge.length verified fixes...`

  when @needsMerge.length > 0 [
    let @mergePrompt = @buildMergePrompt(@baseBranch, @qaDir, `@needsMerge`)
    >> Can't use fixed.json as marker - it already exists from the apply phase
    let @mergeMarker = `@qaDir/merge-complete.json`
    show `  Running merge phase...`
    show `  Phase 5/6 - Merge: @needsMerge.length items`
    let @mergeResponse = @claudePoll(@mergePrompt, "opus", @base, @applyTools, @mergeMarker)
  ]

  >> ========== PHASE 3c: VERIFY ==========
  >> Reload to get merge results
  let @postMergeFixed = <@qaDir/**/fixed.json>
  let @justMerged = for @f in @postMergeFixed
    when @f.merged == true
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      test_fixture: @f.test_fixture,
      merge_commit: @f.merge_commit
    }

  when @justMerged.length > 0 [
    show `Phase 3c: Verifying @justMerged.length merged fixes...`
    let @verifyPrompt = @buildVerifyPrompt(@baseBranch, @qaDir, `@justMerged.length`, @iteration, `@justMerged`)
    let @verifyMarker = `@qaDir/verification-result.json`
    show `  Phase 6/6 - Verify: @justMerged.length items`
    let @verifyResponse = @claudePoll(@verifyPrompt, "opus", @base, @verifyTools, @verifyMarker)
  ]

  >> Check if stable (no work done this iteration)
  let @workDone = @reconcileLimit.length + @analyzeLimit.length + @docFixCount + @needsApply.length + @needsTriage.length
  let @isStable = @workDone == 0
  show `DEBUG: workDone=@workDone, stable=@isStable`

  show `Work done: @workDone items (reconcile: @reconcileLimit.length, analyze: @analyzeLimit.length, doc-fix: @docFixCount, apply: @needsApply.length, triage: @needsTriage.length)`
  show `--- End iteration @iteration ---`
  show ``

  >> Exit with done when stable, otherwise continue to next iteration
  when @isStable => done { iteration: @iteration, stable: true }
  continue { iteration: @iteration, stable: false }
]

>> Final summary
var @finalResults = <@qaDir/**/results.json>
var @finalReconciliations = <@qaDir/**/reconciliation.json>
var @finalProposedFixes = <@qaDir/**/proposed-fix.json>
var @finalFixed = <@qaDir/**/fixed.json>

var @finalPassing = for @r in @finalResults when @r.status == "pass" => @r
var @finalFailing = for @r in @finalResults when @r.status == "fail" => @r
var @finalGenuineBugs = for @r in @finalReconciliations when @r.verdict == "genuine-bug" => @r
var @finalMerged = for @f in @finalFixed when @f.merged == true => @f
var @finalEscalated = for @f in @finalFixed when @f.escalated == true => @f
var @finalPendingRetry = for @f in @finalFixed when @f.verified == false && !@f.escalated => @f

var @finalIteration = @loopResult.iteration ?? 0
var @finalStable = @loopResult.stable ?? true

show `=== Polish Complete ===`
show `Iterations: @finalIteration`
show `Stable: @finalStable`
show ``
show `Final state:`
show `  Total: @finalResults.length`
show `  Passing: @finalPassing.length`
show `  Failing: @finalFailing.length`
show `  Reconciled: @finalReconciliations.length`
show `  Genuine bugs: @finalGenuineBugs.length`
show `  Analyzed: @finalProposedFixes.length`
show `  Fixed & Merged: @finalMerged.length`
show `  Escalated (need human): @finalEscalated.length`
show `  Pending retry: @finalPendingRetry.length`

>> ========== DOC IMPROVEMENT AGGREGATION ==========
>> Collect insights from reconciliations AND self-reviews to improve docs and QA prompts

>> From reconciliation.json (doc_clarity at top level)
var @docClarityFromReconcile = for @r in @finalReconciliations when @r.doc_clarity && @r.doc_clarity.issue && @r.doc_clarity.issue != "none" => {
  topic: @r.topic,
  experiment: @r.experiment,
  verdict: @r.verdict,
  issue: @r.doc_clarity.issue,
  explanation: @r.doc_clarity.explanation,
  suggestion: @r.doc_clarity.suggestion,
  affected_doc: @r.doc_clarity.affected_doc,
  source: "reconciliation"
}

>> From self_review.json (doc_clarity per issue in issues_reviewed)
var @finalSelfReviews = <@qaDir/**/self_review.json>
var @docClarityFromSelfReview = for @sr in @finalSelfReviews
  when @sr.issues_reviewed => for @issue in @sr.issues_reviewed
    when @issue.doc_clarity && @issue.doc_clarity.issue && @issue.doc_clarity.issue != "genuine-bug" => {
      topic: @sr.topic,
      experiment: @sr.experiment,
      verdict: @issue.revised_verdict,
      issue: @issue.doc_clarity.issue,
      explanation: @issue.doc_clarity.explanation,
      suggestion: @issue.doc_clarity.suggestion,
      affected_doc: @issue.doc_clarity.affected_doc,
      source: "self-review"
    }

>> Combine both sources
var @docClarityItems = @docClarityFromReconcile.concat(@docClarityFromSelfReview)

var @qaInsufficientExploration = for @item in @docClarityItems when @item.issue == "qa-insufficient-exploration" => @item
var @docsCouldBeClearer = for @item in @docClarityItems when @item.issue == "docs-could-be-clearer" => @item
var @docsGenuinelyMisleading = for @item in @docClarityItems when @item.issue == "docs-genuinely-misleading" => @item

show ``
show `=== Doc Improvement Insights ===`
show `  QA needs better exploration: @qaInsufficientExploration.length (improve QA prompts)`
show `  Docs could be clearer: @docsCouldBeClearer.length (add clarifying notes)`
show `  Docs genuinely misleading: @docsGenuinelyMisleading.length (fix docs)`

>> Write aggregated doc improvement report
var @docImprovementReport = {
  generated_at: @now,
  summary: {
    qa_insufficient_exploration: @qaInsufficientExploration.length,
    docs_could_be_clearer: @docsCouldBeClearer.length,
    docs_genuinely_misleading: @docsGenuinelyMisleading.length
  },
  qa_prompt_feedback: @qaInsufficientExploration,
  doc_clarifications_needed: @docsCouldBeClearer,
  doc_fixes_needed: @docsGenuinelyMisleading
}

when @docClarityItems.length > 0 [
  show ``
  show `Writing doc improvement report to @qaDir/doc-improvement-report.json`
  output @docImprovementReport to "@qaDir/doc-improvement-report.json"

  >> Show actionable items
  when @docsGenuinelyMisleading.length > 0 [
    show ``
    show `ACTION REQUIRED - Docs need fixing:`
    for @item in @docsGenuinelyMisleading => show `  - @item.topic/@item.experiment: @item.suggestion`
  ]

  when @docsCouldBeClearer.length > 0 [
    show ``
    show `SUGGESTED - Docs could be clearer:`
    for @item in @docsCouldBeClearer => show `  - @item.topic/@item.experiment: @item.suggestion`
  ]

  when @qaInsufficientExploration.length > 0 [
    show ``
    show `QA FEEDBACK - Consider improving QA prompts to encourage exploration of:`
    for @item in @qaInsufficientExploration => show `  - @item.affected_doc: @item.suggestion`
  ]
]
