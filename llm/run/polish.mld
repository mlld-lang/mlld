>> QA Polish Flywheel
>> Usage: mlld run polish [--tier 1] [--max-iterations 10]
>>
>> Runs the full QA → reconcile → analyze → fix loop until stable.
>> Auto-approves fixes where Opus confidence >= 0.9 and design_fit is high/medium.
>> Uses git worktrees for isolated parallel fix application.

import { @claude } from @mlld/claude

>> Payload options
import "@payload" as @p
var @tier = @p.tier ? @p.tier : "1"
var @maxIterations = @p.maxIterations ? @p.maxIterations * 1 : 10

>> Configuration
var @qaDir = "@base/qa"

>> Get current branch for worktree base
var @baseBranch = sh {git branch --show-current}

>> === BUILD PROMPT FUNCTIONS (using template auto-interpolation) ===

exe @buildReconcilePrompt(topic, experiment, status, summary, issues, outputDir) = template "./qa-reconcile-prompt.att"

exe @buildAnalyzePrompt(topic, experiment, resultsPath, reconciliationPath, experimentDir) = template "./qa-analyze-prompt.att"

exe @buildApplyPrompt(topic, experiment, baseBranch, experimentDir, rootCause, rootCauseLocation, fixId, confidence, designFit, proposedFixes) = template "./qa-apply-prompt.att"

exe @buildMergePrompt(baseBranch, qaDir, mergeItems) = template "./qa-merge-prompt.att"

exe @buildVerifyPrompt(baseBranch, qaDir, mergeCount, iteration, mergedItems) = template "./qa-verify-prompt.att"

exe @buildTriagePrompt(topic, experiment, baseBranch, worktreeBranch, experimentDir, errors) = template "./qa-triage-prompt.att"

>> === MAIN LOOP ===

show `=== QA Polish Flywheel ===`
show `Tier: @tier`
show `Max iterations: @maxIterations`
show `Base branch: @baseBranch`
show ``

>> Check for failed verification before starting - HALT if previous run broke things
var @prevVerificationFiles = <@qaDir/verification-result.json?>
var @prevVerification = @prevVerificationFiles.length > 0 ? @prevVerificationFiles[0] : null
var @halted = @prevVerification && @prevVerification.status == "fail"

when @halted [
  show `ERROR: Previous verification failed. Resolve before continuing.`
  show `See: @qaDir/verification-result.json`
  show ``
  show `Recommended actions:`
  show `  1. Review the failures in verification-result.json`
  show `  2. Either revert the problematic merge or fix manually`
  show `  3. Delete verification-result.json to resume`
]

>> Helper to check if a self-review has genuine bugs
exe @hasGenuineBug(selfReview) = [
  let @bugs = for @issue in (@selfReview.issues_reviewed ? @selfReview.issues_reviewed : [])
    when @issue.revised_verdict == "genuine-bug" => @issue
  => @bugs.length > 0
]

show `DEBUG: before loop, maxIterations=@maxIterations, halted=@halted`
var @loopResult = loop(@maxIterations) [
  >> Check exit conditions
  when @halted => done { iteration: 0, stable: false, halted: true }
  when @input && @input.stable => done @input

  let @iteration = @mx.loop.iteration
  show `--- Iteration @iteration (max=@maxIterations) ---`

  >> Load all state files fresh each iteration
  let @allResults = <@qaDir/**/results.json>
  let @allReconciliations = <@qaDir/**/reconciliation.json>
  let @allSelfReviews = <@qaDir/**/self_review.json>
  let @allProposedFixes = <@qaDir/**/proposed-fix.json>
  let @allFixedFiles = <@qaDir/**/fixed.json>

  >> Build lookup sets
  >> Self-reviews from qa.mld Phase 2 act as reconciliation
  let @selfReviewedDirs = for @sr in @allSelfReviews when @sr.reviewed => @sr.mx.absoluteDir
  let @reconciledDirs = for @r in @allReconciliations => @r.mx.absoluteDir
  let @analyzedDirs = for @f in @allProposedFixes => @f.mx.absoluteDir
  let @fixedDirs = for @f in @allFixedFiles => @f.mx.absoluteDir

  >> Count status
  let @passing = for @r in @allResults when @r.status == "pass" => @r
  let @failing = for @r in @allResults when @r.status == "fail" => @r

  show `State: @allResults.length total, @passing.length passing, @failing.length failing`

  >> ========== PHASE 1: RECONCILE ==========
  >> Skip experiments that have self_review.json (qa.mld Phase 2 already did reconciliation)
  let @needsReconcile = for @r in @allResults
    when (@r.status == "fail" || @r.status == "partial")
      && !@reconciledDirs.includes(@r.mx.absoluteDir)
      && !@selfReviewedDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      status: @r.status,
      summary: @r.summary,
      issues: @r.issues,
      experimentDir: @r.mx.absoluteDir
    }

  show `Phase 1: Reconciling @needsReconcile.length failures (skipping @selfReviewedDirs.length self-reviewed)...`

  let @reconcileLimit = @needsReconcile.slice(0, 20)
  show `  DEBUG: reconcileLimit has @reconcileLimit.length items`
  for parallel(20, 10s) @item in @reconcileLimit [
    let @issuesJson = @item.issues ? `@item.issues` : "[]"
    let @prompt = @buildReconcilePrompt(@item.topic, @item.experiment, @item.status, @item.summary, @issuesJson, @qaDir)
    show `  Reconciling: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep") | log
    => @item.topic
  ]

  >> Reload reconciliations and self-reviews after phase 1
  let @freshReconciliations = <@qaDir/**/reconciliation.json>
  let @freshSelfReviews = <@qaDir/**/self_review.json>

  >> ========== PHASE 2: ANALYZE ==========
  >> Check both reconciliation.json AND self_review.json for genuine bugs

  >> From traditional reconciliation
  let @bugsFromReconcile = for @r in @freshReconciliations
    when @r.verdict == "genuine-bug"
      && @r.action == "implement"
      && !@analyzedDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      experimentDir: @r.mx.absoluteDir,
      resultsPath: `@r.mx.absoluteDir/results.json`,
      reconciliationPath: @r.mx.absolute,
      source: "reconciliation"
    }

  >> From self-reviews (any issue with revised_verdict == "genuine-bug")
  let @bugsFromSelfReview = for @sr in @freshSelfReviews
    when @sr.reviewed && @hasGenuineBug(@sr) && !@analyzedDirs.includes(@sr.mx.absoluteDir)
    => {
      topic: @sr.topic,
      experiment: @sr.experiment,
      experimentDir: @sr.mx.absoluteDir,
      resultsPath: `@sr.mx.absoluteDir/results.json`,
      reconciliationPath: @sr.mx.absolute,
      source: "self-review"
    }

  >> Combine both sources
  let @needsAnalyze = @bugsFromReconcile.concat(@bugsFromSelfReview)

  show `Phase 2: Analyzing @needsAnalyze.length genuine bugs (@bugsFromReconcile.length from reconcile, @bugsFromSelfReview.length from self-review)...`

  let @analyzeLimit = @needsAnalyze.slice(0, 10)
  show `  DEBUG: analyzeLimit has @analyzeLimit.length items`
  show `  DEBUG: entering analyze loop...`
  for parallel(10, 10s) @item in @analyzeLimit [
    show `  DEBUG: loop body for @item.topic/@item.experiment`
    show `  DEBUG: calling buildAnalyzePrompt...`
    let @prompt = @buildAnalyzePrompt(@item.topic, @item.experiment, @item.resultsPath, @item.reconciliationPath, @item.experimentDir)
    show `  DEBUG: prompt built, length=@prompt.length`
    show `  Analyzing: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep") | log
    show `  DEBUG: @claude returned`
    => @item.topic
  ]
  show `  DEBUG: exited analyze loop`

  >> Reload proposed fixes after phase 2
  let @freshProposedFixes = <@qaDir/**/proposed-fix.json>

  >> ========== PHASE 3a: APPLY (Parallel in Worktrees) ==========
  let @needsApply = for @f in @freshProposedFixes
    when @f.recommendation.auto_approve == true
      && !@fixedDirs.includes(@f.mx.absoluteDir)
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      fix: @f
    }

  show `Phase 3a: Applying @needsApply.length fixes in worktrees...`
  show `  DEBUG: needsApply has @needsApply.length items`

  >> Apply fixes in parallel worktrees (5 concurrent, 1m delay to avoid rate limits)
  show `  DEBUG: entering apply loop...`
  for parallel(5, 10s) @item in @needsApply [
    show `  DEBUG: apply loop body for @item.topic/@item.experiment`
    let @fix = @item.fix
    let @prompt = @buildApplyPrompt(
      @item.topic,
      @item.experiment,
      @baseBranch,
      @item.experimentDir,
      @fix.investigation.root_cause,
      @fix.investigation.root_cause_location,
      @fix.recommendation.fix_id,
      `@fix.recommendation.confidence`,
      @fix.recommendation.design_fit,
      `@fix.proposed_fixes`
    )
    show `  DEBUG: prompt built, length=@prompt.length`
    show `  Applying: @item.topic/@item.experiment`
    show `  DEBUG: calling @claude...`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
    show `  DEBUG: apply @claude returned: @response`
    => @item.topic
  ]
  show `  DEBUG: exited apply loop`

  >> ========== PHASE 3a.5: TRIAGE FAILED FIXES ==========
  >> Reload fixed files to see apply results
  let @postApplyFixed = <@qaDir/**/fixed.json>
  let @needsTriage = for @f in @postApplyFixed
    when @f.applied == true
      && @f.verified == false
      && !@f.escalated
      && @f.worktree_branch
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      worktree_branch: @f.worktree_branch,
      errors: @f.errors
    }

  show `Phase 3a.5: Triaging @needsTriage.length failed fixes...`
  show `  DEBUG: needsTriage has @needsTriage.length items`

  >> Triage sequentially to avoid worktree conflicts
  for @item in @needsTriage [
    let @errorsJson = @item.errors ? `@item.errors` : "[]"
    let @prompt = @buildTriagePrompt(
      @item.topic,
      @item.experiment,
      @baseBranch,
      @item.worktree_branch,
      @item.experimentDir,
      @errorsJson
    )
    show `  Triaging: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
  ]

  >> ========== PHASE 3b: MERGE (Sequential) ==========
  >> Reload fixed files to see triage results
  let @freshFixed = <@qaDir/**/fixed.json>
  let @needsMerge = for @f in @freshFixed
    when @f.applied == true
      && @f.verified == true
      && !@f.merged
      && @f.worktree_branch
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      worktree_branch: @f.worktree_branch,
      commit_sha: @f.commit_sha
    }

  show `Phase 3b: Merging @needsMerge.length verified fixes...`

  when @needsMerge.length > 0 [
    let @mergePrompt = @buildMergePrompt(@baseBranch, @qaDir, `@needsMerge`)
    show `  Running merge phase...`
    let @mergeResponse = @claude(@mergePrompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
  ]

  >> ========== PHASE 3c: VERIFY ==========
  >> Reload to get merge results
  let @postMergeFixed = <@qaDir/**/fixed.json>
  let @justMerged = for @f in @postMergeFixed
    when @f.merged == true
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      test_fixture: @f.test_fixture,
      merge_commit: @f.merge_commit
    }

  when @justMerged.length > 0 [
    show `Phase 3c: Verifying @justMerged.length merged fixes...`
    let @verifyPrompt = @buildVerifyPrompt(@baseBranch, @qaDir, `@justMerged.length`, @iteration, `@justMerged`)
    let @verifyResponse = @claude(@verifyPrompt, "opus", @base, "Read,Bash,Glob,Grep,Write") | log
  ]

  >> Check if stable (no work done this iteration)
  let @workDone = @reconcileLimit.length + @analyzeLimit.length + @needsApply.length + @needsTriage.length
  let @isStable = @workDone == 0
  show `DEBUG: workDone=@workDone, stable=@isStable`

  show `Work done: @workDone items (reconcile: @reconcileLimit.length, analyze: @analyzeLimit.length, apply: @needsApply.length, triage: @needsTriage.length)`
  show `--- End iteration @iteration ---`
  show ``

  >> Exit with done when stable, otherwise continue to next iteration
  when @isStable => done { iteration: @iteration, stable: true }
  continue { iteration: @iteration, stable: false }
]

>> Final summary
var @finalResults = <@qaDir/**/results.json>
var @finalReconciliations = <@qaDir/**/reconciliation.json>
var @finalProposedFixes = <@qaDir/**/proposed-fix.json>
var @finalFixed = <@qaDir/**/fixed.json>

var @finalPassing = for @r in @finalResults when @r.status == "pass" => @r
var @finalFailing = for @r in @finalResults when @r.status == "fail" => @r
var @finalGenuineBugs = for @r in @finalReconciliations when @r.verdict == "genuine-bug" => @r
var @finalMerged = for @f in @finalFixed when @f.merged == true => @f
var @finalEscalated = for @f in @finalFixed when @f.escalated == true => @f
var @finalPendingRetry = for @f in @finalFixed when @f.verified == false && !@f.escalated => @f

var @finalIteration = @loopResult.iteration ?? 0
var @finalStable = @loopResult.stable ?? true

show `=== Polish Complete ===`
show `Iterations: @finalIteration`
show `Stable: @finalStable`
show ``
show `Final state:`
show `  Total: @finalResults.length`
show `  Passing: @finalPassing.length`
show `  Failing: @finalFailing.length`
show `  Reconciled: @finalReconciliations.length`
show `  Genuine bugs: @finalGenuineBugs.length`
show `  Analyzed: @finalProposedFixes.length`
show `  Fixed & Merged: @finalMerged.length`
show `  Escalated (need human): @finalEscalated.length`
show `  Pending retry: @finalPendingRetry.length`

>> ========== DOC IMPROVEMENT AGGREGATION ==========
>> Collect insights from reconciliations AND self-reviews to improve docs and QA prompts

>> From reconciliation.json (doc_clarity at top level)
var @docClarityFromReconcile = for @r in @finalReconciliations when @r.doc_clarity && @r.doc_clarity.issue && @r.doc_clarity.issue != "none" => {
  topic: @r.topic,
  experiment: @r.experiment,
  verdict: @r.verdict,
  issue: @r.doc_clarity.issue,
  explanation: @r.doc_clarity.explanation,
  suggestion: @r.doc_clarity.suggestion,
  affected_doc: @r.doc_clarity.affected_doc,
  source: "reconciliation"
}

>> From self_review.json (doc_clarity per issue in issues_reviewed)
var @finalSelfReviews = <@qaDir/**/self_review.json>
var @docClarityFromSelfReview = for @sr in @finalSelfReviews
  when @sr.issues_reviewed => for @issue in @sr.issues_reviewed
    when @issue.doc_clarity && @issue.doc_clarity.issue && @issue.doc_clarity.issue != "genuine-bug" => {
      topic: @sr.topic,
      experiment: @sr.experiment,
      verdict: @issue.revised_verdict,
      issue: @issue.doc_clarity.issue,
      explanation: @issue.doc_clarity.explanation,
      suggestion: @issue.doc_clarity.suggestion,
      affected_doc: @issue.doc_clarity.affected_doc,
      source: "self-review"
    }

>> Combine both sources
var @docClarityItems = @docClarityFromReconcile.concat(@docClarityFromSelfReview)

var @qaInsufficientExploration = for @item in @docClarityItems when @item.issue == "qa-insufficient-exploration" => @item
var @docsCouldBeClearer = for @item in @docClarityItems when @item.issue == "docs-could-be-clearer" => @item
var @docsGenuinelyMisleading = for @item in @docClarityItems when @item.issue == "docs-genuinely-misleading" => @item

show ``
show `=== Doc Improvement Insights ===`
show `  QA needs better exploration: @qaInsufficientExploration.length (improve QA prompts)`
show `  Docs could be clearer: @docsCouldBeClearer.length (add clarifying notes)`
show `  Docs genuinely misleading: @docsGenuinelyMisleading.length (fix docs)`

>> Write aggregated doc improvement report
var @docImprovementReport = {
  generated_at: @mx.now,
  summary: {
    qa_insufficient_exploration: @qaInsufficientExploration.length,
    docs_could_be_clearer: @docsCouldBeClearer.length,
    docs_genuinely_misleading: @docsGenuinelyMisleading.length
  },
  qa_prompt_feedback: @qaInsufficientExploration,
  doc_clarifications_needed: @docsCouldBeClearer,
  doc_fixes_needed: @docsGenuinelyMisleading
}

when @docClarityItems.length > 0 [
  show ``
  show `Writing doc improvement report to @qaDir/doc-improvement-report.json`
  output @docImprovementReport to "@qaDir/doc-improvement-report.json"

  >> Show actionable items
  when @docsGenuinelyMisleading.length > 0 [
    show ``
    show `ACTION REQUIRED - Docs need fixing:`
    for @item in @docsGenuinelyMisleading => show `  - @item.topic/@item.experiment: @item.suggestion`
  ]

  when @docsCouldBeClearer.length > 0 [
    show ``
    show `SUGGESTED - Docs could be clearer:`
    for @item in @docsCouldBeClearer => show `  - @item.topic/@item.experiment: @item.suggestion`
  ]

  when @qaInsufficientExploration.length > 0 [
    show ``
    show `QA FEEDBACK - Consider improving QA prompts to encourage exploration of:`
    for @item in @qaInsufficientExploration => show `  - @item.affected_doc: @item.suggestion`
  ]
]
