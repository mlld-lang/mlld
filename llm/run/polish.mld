>> QA Polish Flywheel
>> Usage: mlld run polish [--tier 1] [--max-iterations 10]
>>
>> Runs the full QA → reconcile → analyze → fix loop until stable.
>> Auto-approves fixes where Opus confidence >= 0.9 and design_fit is high/medium.

import { @claude } from @mlld/claude

>> Payload options
import "@payload" as @p
var @tier = @p.tier ? @p.tier : "1"
var @maxIterations = @p.maxIterations ? @p.maxIterations : 10

>> Configuration
var @qaDir = "@base/qa"

>> === PROMPT TEMPLATES ===

var @reconcilePromptTemplate = <@base/llm/run/qa-reconcile-prompt.att>
var @analyzePromptTemplate = <@base/llm/run/qa-analyze-prompt.att>

>> === BUILD PROMPT FUNCTIONS ===

exe @buildReconcilePrompt(tmpl, result) = [
  let @issues = @result.issues ? `@result.issues` : "[]"
  let @s1 = @tmpl.replace("@topic", @result.topic)
  let @s2 = @s1.replace("@experiment", @result.experiment)
  let @s3 = @s2.replace("@status", @result.status)
  let @s4 = @s3.replace("@summary", @result.summary)
  let @s5 = @s4.replace("@issues", @issues)
  => @s5.replace("@outputDir", @qaDir)
]

exe @buildAnalyzePrompt(tmpl, item) = [
  let @s1 = @tmpl.replace("@topic", @item.topic)
  let @s2 = @s1.replace("@experiment", @item.experiment)
  let @s3 = @s2.replace("@resultsPath", @item.resultsPath)
  let @s4 = @s3.replace("@reconciliationPath", @item.reconciliationPath)
  let @s5 = @s4.replace("@outputDir", @item.experimentDir)
  => @s5.replace("@experimentDir", @item.experimentDir)
]

exe @buildApplyPrompt(item) = `Apply this fix to the mlld codebase:

## Context

Topic: @item.topic
Experiment: @item.experiment

Investigation:
  Root cause: @item.fix.investigation.root_cause
  Location: @item.fix.investigation.root_cause_location

Recommended fix: @item.fix.recommendation.fix_id
Confidence: @item.fix.recommendation.confidence
Design fit: @item.fix.recommendation.design_fit

Proposed changes:
@item.fix.proposed_fixes

## Instructions

Apply the fix in this order:

### 1. Code Changes
- Read each file in code_changes
- Apply the changes exactly as specified
- If changes don't apply cleanly, adapt to current code state

### 2. Test Fixture (REQUIRED)
Create the test fixture specified in test_changes:
- Create directory: the fixture_dir path
- Create example.md with the mlld code
- Create expected.md with expected output
- Run: npm run build:fixtures
- Note: Support file names must be unique across all tests (prefix with test name)

### 3. CHANGELOG.md Entry (REQUIRED)
Add entry to CHANGELOG.md under the current unreleased version:
- Find the topmost version section (e.g., ## [2.0.0-rc82])
- Add under the appropriate subsection (### Fixed, ### Added, ### Changed)
- Use format from changelog_entry field
- If subsection doesn't exist, create it

### 4. Documentation Updates (if doc_changes is not empty)
For each item in doc_changes:
- Edit the atom file specified
- Make the described change
- Only edit atoms in docs/src/atoms/ (never docs/llm/*.txt directly)

### 5. Verify
Run the full test suite:
- npm test
- If tests fail, fix the issues before proceeding

### 6. Write Result
Write fixed.json to @item.experimentDir/ with:
{
  "applied": true,
  "verified": <true if all tests pass>,
  "test_fixture": "<path to created fixture>",
  "changelog_added": true,
  "docs_updated": <true if doc_changes were applied>,
  "errors": [] or ["list", "of", "issues"]
}

## Commit Requirements

DO NOT commit yet. The fix result will be reviewed and committed in a separate step.
If tests don't pass, still write fixed.json with verified: false and list the errors.
`

>> === MAIN LOOP ===

show `=== QA Polish Flywheel ===`
show `Tier: @tier`
show `Max iterations: @maxIterations`
show ``

var @iteration = 0
var @stable = false

loop until @stable || @iteration >= @maxIterations [
  let @iteration = @iteration + 1
  show `--- Iteration @iteration ---`

  >> Load all state files fresh each iteration
  let @allResults = <@qaDir/**/results.json>
  let @allReconciliations = <@qaDir/**/reconciliation.json>
  let @allProposedFixes = <@qaDir/**/proposed-fix.json>
  let @allFixedFiles = <@qaDir/**/fixed.json>

  >> Build lookup sets
  let @reconciledDirs = for @r in @allReconciliations => @r.mx.absoluteDir
  let @analyzedDirs = for @f in @allProposedFixes => @f.mx.absoluteDir
  let @fixedDirs = for @f in @allFixedFiles => @f.mx.absoluteDir

  >> Count status
  let @passing = for @r in @allResults when @r.status == "pass" => @r
  let @failing = for @r in @allResults when @r.status == "fail" => @r

  show `State: @allResults.length total, @passing.length passing, @failing.length failing`

  >> Phase 1: Find & reconcile new failures
  let @needsReconcile = for @r in @allResults
    when (@r.status == "fail" || @r.status == "partial")
      && !@reconciledDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      status: @r.status,
      summary: @r.summary,
      issues: @r.issues,
      experimentDir: @r.mx.absoluteDir
    }

  show `Phase 1: Reconciling @needsReconcile.length failures...`

  let @reconcileLimit = @needsReconcile.slice(0, 20)
  for parallel(20) @item in @reconcileLimit [
    let @prompt = @buildReconcilePrompt(@reconcilePromptTemplate, @item)
    show `  Reconciling: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep") | log
    => @item.topic
  ]

  >> Reload reconciliations after phase 1
  let @freshReconciliations = <@qaDir/**/reconciliation.json>

  >> Phase 2: Find & analyze genuine bugs
  let @needsAnalyze = for @r in @freshReconciliations
    when @r.verdict == "genuine-bug"
      && @r.action == "implement"
      && !@analyzedDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      experimentDir: @r.mx.absoluteDir,
      resultsPath: `@r.mx.absoluteDir/results.json`,
      reconciliationPath: @r.mx.absolute
    }

  show `Phase 2: Analyzing @needsAnalyze.length genuine bugs...`

  let @analyzeLimit = @needsAnalyze.slice(0, 10)
  for parallel(10) @item in @analyzeLimit [
    let @prompt = @buildAnalyzePrompt(@analyzePromptTemplate, @item)
    show `  Analyzing: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep") | log
    => @item.topic
  ]

  >> Reload proposed fixes after phase 2
  let @freshProposedFixes = <@qaDir/**/proposed-fix.json>

  >> Phase 3: Find & apply auto-approved fixes
  let @needsApply = for @f in @freshProposedFixes
    when @f.recommendation.auto_approve == true
      && !@fixedDirs.includes(@f.mx.absoluteDir)
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      fix: @f
    }

  show `Phase 3: Applying @needsApply.length auto-approved fixes...`

  >> Apply fixes sequentially to avoid conflicts
  for @item in @needsApply [
    let @prompt = @buildApplyPrompt(@item)
    show `  Applying: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
    => @item.topic
  ]

  >> Check if stable (no work done this iteration)
  let @workDone = @reconcileLimit.length + @analyzeLimit.length + @needsApply.length
  when @workDone == 0 [
    let @stable = true
  ]

  show `Work done: @workDone items`
  show ``
]

>> Final summary
var @finalResults = <@qaDir/**/results.json>
var @finalReconciliations = <@qaDir/**/reconciliation.json>
var @finalProposedFixes = <@qaDir/**/proposed-fix.json>
var @finalFixed = <@qaDir/**/fixed.json>

var @finalPassing = for @r in @finalResults when @r.status == "pass" => @r
var @finalFailing = for @r in @finalResults when @r.status == "fail" => @r
var @finalGenuineBugs = for @r in @finalReconciliations when @r.verdict == "genuine-bug" => @r

show `=== Polish Complete ===`
show `Iterations: @iteration`
show `Stable: @stable`
show ``
show `Final state:`
show `  Total: @finalResults.length`
show `  Passing: @finalPassing.length`
show `  Failing: @finalFailing.length`
show `  Reconciled: @finalReconciliations.length`
show `  Genuine bugs: @finalGenuineBugs.length`
show `  Analyzed: @finalProposedFixes.length`
show `  Fixed: @finalFixed.length`
