>> QA Polish Flywheel
>> Usage: mlld run polish [--tier 1] [--max-iterations 10]
>>
>> Runs the full QA → reconcile → analyze → fix loop until stable.
>> Auto-approves fixes where Opus confidence >= 0.9 and design_fit is high/medium.
>> Uses git worktrees for isolated parallel fix application.

import { @claude } from @mlld/claude

>> Payload options
import "@payload" as @p
var @tier = @p.tier ? @p.tier : "1"
var @maxIterations = @p.maxIterations ? @p.maxIterations * 1 : 10

>> Configuration
var @qaDir = "@base/qa"

>> Get current branch for worktree base
var @baseBranch = sh {git branch --show-current}

>> === BUILD PROMPT FUNCTIONS (using template auto-interpolation) ===

exe @buildReconcilePrompt(topic, experiment, status, summary, issues, outputDir) = template "./qa-reconcile-prompt.att"

exe @buildAnalyzePrompt(topic, experiment, resultsPath, reconciliationPath, experimentDir) = template "./qa-analyze-prompt.att"

exe @buildApplyPrompt(topic, experiment, baseBranch, experimentDir, rootCause, rootCauseLocation, fixId, confidence, designFit, proposedFixes) = template "./qa-apply-prompt.att"

exe @buildMergePrompt(baseBranch, qaDir, mergeItems) = template "./qa-merge-prompt.att"

exe @buildVerifyPrompt(baseBranch, qaDir, mergeCount, iteration, mergedItems) = template "./qa-verify-prompt.att"

exe @buildTriagePrompt(topic, experiment, baseBranch, worktreeBranch, experimentDir, errors) = template "./qa-triage-prompt.att"

>> === MAIN LOOP ===

show `=== QA Polish Flywheel ===`
show `Tier: @tier`
show `Max iterations: @maxIterations`
show `Base branch: @baseBranch`
show ``

>> Check for failed verification before starting - HALT if previous run broke things
var @prevVerificationFiles = <@qaDir/verification-result.json?>
var @prevVerification = @prevVerificationFiles.length > 0 ? @prevVerificationFiles[0] : null
var @halted = @prevVerification && @prevVerification.status == "fail"

when @halted => show `ERROR: Previous verification failed. Resolve before continuing.`
when @halted => show `See: @qaDir/verification-result.json`
when @halted => show ``
when @halted => show `Recommended actions:`
when @halted => show `  1. Review the failures in verification-result.json`
when @halted => show `  2. Either revert the problematic merge or fix manually`
when @halted => show `  3. Delete verification-result.json to resume`

show `DEBUG: before loop, maxIterations=@maxIterations, halted=@halted`
var @loopResult = loop(@maxIterations) [
  >> Check exit conditions
  when @halted => done { iteration: 0, stable: false, halted: true }
  when @input && @input.stable => done @input

  let @iteration = @mx.loop.iteration
  show `--- Iteration @iteration (max=@maxIterations) ---`

  >> Load all state files fresh each iteration
  let @allResults = <@qaDir/**/results.json>
  let @allReconciliations = <@qaDir/**/reconciliation.json>
  let @allProposedFixes = <@qaDir/**/proposed-fix.json>
  let @allFixedFiles = <@qaDir/**/fixed.json>

  >> Build lookup sets
  let @reconciledDirs = for @r in @allReconciliations => @r.mx.absoluteDir
  let @analyzedDirs = for @f in @allProposedFixes => @f.mx.absoluteDir
  let @fixedDirs = for @f in @allFixedFiles => @f.mx.absoluteDir

  >> Count status
  let @passing = for @r in @allResults when @r.status == "pass" => @r
  let @failing = for @r in @allResults when @r.status == "fail" => @r

  show `State: @allResults.length total, @passing.length passing, @failing.length failing`

  >> ========== PHASE 1: RECONCILE ==========
  let @needsReconcile = for @r in @allResults
    when (@r.status == "fail" || @r.status == "partial")
      && !@reconciledDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      status: @r.status,
      summary: @r.summary,
      issues: @r.issues,
      experimentDir: @r.mx.absoluteDir
    }

  show `Phase 1: Reconciling @needsReconcile.length failures...`

  let @reconcileLimit = @needsReconcile.slice(0, 20)
  show `  DEBUG: reconcileLimit has @reconcileLimit.length items`
  for parallel(20, 10s) @item in @reconcileLimit [
    let @issuesJson = @item.issues ? `@item.issues` : "[]"
    let @prompt = @buildReconcilePrompt(@item.topic, @item.experiment, @item.status, @item.summary, @issuesJson, @qaDir)
    show `  Reconciling: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep") | log
    => @item.topic
  ]

  >> Reload reconciliations after phase 1
  let @freshReconciliations = <@qaDir/**/reconciliation.json>

  >> ========== PHASE 2: ANALYZE ==========
  let @needsAnalyze = for @r in @freshReconciliations
    when @r.verdict == "genuine-bug"
      && @r.action == "implement"
      && !@analyzedDirs.includes(@r.mx.absoluteDir)
    => {
      topic: @r.topic,
      experiment: @r.experiment,
      experimentDir: @r.mx.absoluteDir,
      resultsPath: `@r.mx.absoluteDir/results.json`,
      reconciliationPath: @r.mx.absolute
    }

  show `Phase 2: Analyzing @needsAnalyze.length genuine bugs...`

  let @analyzeLimit = @needsAnalyze.slice(0, 10)
  show `  DEBUG: analyzeLimit has @analyzeLimit.length items`
  show `  DEBUG: entering analyze loop...`
  for parallel(10, 10s) @item in @analyzeLimit [
    show `  DEBUG: loop body for @item.topic/@item.experiment`
    show `  DEBUG: calling buildAnalyzePrompt...`
    let @prompt = @buildAnalyzePrompt(@item.topic, @item.experiment, @item.resultsPath, @item.reconciliationPath, @item.experimentDir)
    show `  DEBUG: prompt built, length=@prompt.length`
    show `  Analyzing: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep") | log
    show `  DEBUG: @claude returned`
    => @item.topic
  ]
  show `  DEBUG: exited analyze loop`

  >> Reload proposed fixes after phase 2
  let @freshProposedFixes = <@qaDir/**/proposed-fix.json>

  >> ========== PHASE 3a: APPLY (Parallel in Worktrees) ==========
  let @needsApply = for @f in @freshProposedFixes
    when @f.recommendation.auto_approve == true
      && !@fixedDirs.includes(@f.mx.absoluteDir)
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      fix: @f
    }

  show `Phase 3a: Applying @needsApply.length fixes in worktrees...`
  show `  DEBUG: needsApply has @needsApply.length items`

  >> Apply fixes in parallel worktrees (5 concurrent, 1m delay to avoid rate limits)
  show `  DEBUG: entering apply loop...`
  for parallel(5, 10s) @item in @needsApply [
    show `  DEBUG: apply loop body for @item.topic/@item.experiment`
    let @fix = @item.fix
    let @prompt = @buildApplyPrompt(
      @item.topic,
      @item.experiment,
      @baseBranch,
      @item.experimentDir,
      @fix.investigation.root_cause,
      @fix.investigation.root_cause_location,
      @fix.recommendation.fix_id,
      `@fix.recommendation.confidence`,
      @fix.recommendation.design_fit,
      `@fix.proposed_fixes`
    )
    show `  DEBUG: prompt built, length=@prompt.length`
    show `  Applying: @item.topic/@item.experiment`
    show `  DEBUG: calling @claude...`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
    show `  DEBUG: apply @claude returned: @response`
    => @item.topic
  ]
  show `  DEBUG: exited apply loop`

  >> ========== PHASE 3a.5: TRIAGE FAILED FIXES ==========
  >> Reload fixed files to see apply results
  let @postApplyFixed = <@qaDir/**/fixed.json>
  let @needsTriage = for @f in @postApplyFixed
    when @f.applied == true
      && @f.verified == false
      && !@f.escalated
      && @f.worktree_branch
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      worktree_branch: @f.worktree_branch,
      errors: @f.errors
    }

  show `Phase 3a.5: Triaging @needsTriage.length failed fixes...`
  show `  DEBUG: needsTriage has @needsTriage.length items`

  >> Triage sequentially to avoid worktree conflicts
  for @item in @needsTriage [
    let @errorsJson = @item.errors ? `@item.errors` : "[]"
    let @prompt = @buildTriagePrompt(
      @item.topic,
      @item.experiment,
      @baseBranch,
      @item.worktree_branch,
      @item.experimentDir,
      @errorsJson
    )
    show `  Triaging: @item.topic/@item.experiment`
    let @response = @claude(@prompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
  ]

  >> ========== PHASE 3b: MERGE (Sequential) ==========
  >> Reload fixed files to see triage results
  let @freshFixed = <@qaDir/**/fixed.json>
  let @needsMerge = for @f in @freshFixed
    when @f.applied == true
      && @f.verified == true
      && !@f.merged
      && @f.worktree_branch
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      experimentDir: @f.mx.absoluteDir,
      worktree_branch: @f.worktree_branch,
      commit_sha: @f.commit_sha
    }

  show `Phase 3b: Merging @needsMerge.length verified fixes...`

  when @needsMerge.length > 0 [
    let @mergePrompt = @buildMergePrompt(@baseBranch, @qaDir, `@needsMerge`)
    show `  Running merge phase...`
    let @mergeResponse = @claude(@mergePrompt, "opus", @base, "Read,Write,Edit,Bash,Glob,Grep") | log
  ]

  >> ========== PHASE 3c: VERIFY ==========
  >> Reload to get merge results
  let @postMergeFixed = <@qaDir/**/fixed.json>
  let @justMerged = for @f in @postMergeFixed
    when @f.merged == true
    => {
      topic: @f.topic,
      experiment: @f.experiment,
      test_fixture: @f.test_fixture,
      merge_commit: @f.merge_commit
    }

  when @justMerged.length > 0 [
    show `Phase 3c: Verifying @justMerged.length merged fixes...`
    let @verifyPrompt = @buildVerifyPrompt(@baseBranch, @qaDir, `@justMerged.length`, @iteration, `@justMerged`)
    let @verifyResponse = @claude(@verifyPrompt, "opus", @base, "Read,Bash,Glob,Grep,Write") | log
  ]

  >> Check if stable (no work done this iteration)
  let @workDone = @reconcileLimit.length + @analyzeLimit.length + @needsApply.length + @needsTriage.length
  let @isStable = @workDone == 0
  show `DEBUG: workDone=@workDone, stable=@isStable`

  show `Work done: @workDone items (reconcile: @reconcileLimit.length, analyze: @analyzeLimit.length, apply: @needsApply.length, triage: @needsTriage.length)`
  show `--- End iteration @iteration ---`
  show ``

  >> Exit with done when stable, otherwise continue to next iteration
  when @isStable => done { iteration: @iteration, stable: true }
  continue { iteration: @iteration, stable: false }
]

>> Final summary
var @finalResults = <@qaDir/**/results.json>
var @finalReconciliations = <@qaDir/**/reconciliation.json>
var @finalProposedFixes = <@qaDir/**/proposed-fix.json>
var @finalFixed = <@qaDir/**/fixed.json>

var @finalPassing = for @r in @finalResults when @r.status == "pass" => @r
var @finalFailing = for @r in @finalResults when @r.status == "fail" => @r
var @finalGenuineBugs = for @r in @finalReconciliations when @r.verdict == "genuine-bug" => @r
var @finalMerged = for @f in @finalFixed when @f.merged == true => @f
var @finalEscalated = for @f in @finalFixed when @f.escalated == true => @f
var @finalPendingRetry = for @f in @finalFixed when @f.verified == false && !@f.escalated => @f

var @finalIteration = @loopResult.iteration ?? 0
var @finalStable = @loopResult.stable ?? true

show `=== Polish Complete ===`
show `Iterations: @finalIteration`
show `Stable: @finalStable`
show ``
show `Final state:`
show `  Total: @finalResults.length`
show `  Passing: @finalPassing.length`
show `  Failing: @finalFailing.length`
show `  Reconciled: @finalReconciliations.length`
show `  Genuine bugs: @finalGenuineBugs.length`
show `  Analyzed: @finalProposedFixes.length`
show `  Fixed & Merged: @finalMerged.length`
show `  Escalated (need human): @finalEscalated.length`
show `  Pending retry: @finalPendingRetry.length`
