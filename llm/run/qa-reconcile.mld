>> QA Reconciliation - Assess whether failures are doc bugs or code bugs
>> Usage: mlld run qa-reconcile [--topic <filter>] [--limit <n>] [--dryrun]
>>
>> Reviews QA failures with Opus to determine:
>>   - doc-hallucination: Docs claim something that was never real
>>   - genuine-bug: Code that should work but doesn't
>>   - missing-feature: Feature that could exist but doesn't
>>   - qa-error: The QA test itself was flawed
>>
>> Prevents hallucinated docs from accidentally steering the roadmap.

import { @claude } from @mlld/claude

>> Get options from payload
import "@payload" as @p
var @topicFilter = @p.topic ? @p.topic : ""
var @limit = @p.limit ? @p.limit : 10
var @dryrun = @p.dryrun ? true : false

>> Configuration
var @qaDir = "@base/qa"
var @promptTemplate = <@base/llm/run/qa-reconcile-prompt.att>

>> Find failed experiments that need reconciliation
>> Uses shell because we need to find results.json files, check status, and exclude already-reconciled
exe @findNeedsReconciliation(qaDir, topicFilter, limit) = sh {
  find "$qaDir" -name "results.json" -type f | while read f; do
    dir=$(dirname "$f")
    topic=$(basename $(dirname "$dir"))
    exp=$(basename "$dir")

    # Apply topic filter if specified
    if [ -n "$topicFilter" ] && ! echo "$topic" | grep -q "$topicFilter"; then
      continue
    fi

    # Skip if already reconciled
    if [ -f "$dir/reconciliation.json" ]; then
      continue
    fi

    # Check if status is fail or partial
    status=$(jq -r '.status' "$f" 2>/dev/null)
    if [ "$status" = "fail" ] || [ "$status" = "partial" ]; then
      echo "$topic/$exp"
    fi
  done | head -n "$limit"
}

var @needsReconciliation = @findNeedsReconciliation(@qaDir, @topicFilter, @limit)

>> Parse the list into structured data
exe @parseExperiments(list) = js {
  if (!list || !list.trim()) return [];
  return list.trim().split('\n').filter(Boolean).map(line => {
    const [topic, experiment] = line.split('/');
    return { topic, experiment };
  });
}

var @experiments = @parseExperiments(@needsReconciliation)

when @experiments.length == 0 => show "No experiments need reconciliation."

show `Found @experiments.length experiments needing reconciliation:`
for @e in @experiments => show `  - @e.topic/@e.experiment`
show ``

>> Clear experiments list if dryrun to skip processing
exe @maybeClear(list, isDryrun) = js { return isDryrun ? [] : list; }
var @toProcess = @maybeClear(@experiments, @dryrun)

when @dryrun => show `Dry run mode - not processing.`

>> Build prompt for each experiment
exe @buildPrompt(template, topic, experiment, results, qaDir) = js {
  const issuesStr = JSON.stringify(results.issues || [], null, 2);
  return template
    .replace(/@topic/g, topic)
    .replace(/@experiment/g, experiment)
    .replace(/@status/g, results.status || 'unknown')
    .replace(/@summary/g, results.summary || 'No summary')
    .replace(/@issues/g, issuesStr)
    .replace(/@outputDir/g, qaDir);
}

>> Process experiments in parallel (20 concurrent)
show `Processing with Opus (parallel)...`
show ``

>> Load results.json for an experiment (sh{} returns JSON which mlld auto-parses)
exe @loadResults(qaDir, topic, experiment) = sh {
  cat "$qaDir/$topic/$experiment/results.json" 2>/dev/null || echo "null"
}

var @processed = for parallel(20) @e in @toProcess [
  let @results = @loadResults(@qaDir, @e.topic, @e.experiment)
  when @results == null => show `Skipping @e.topic/@e.experiment - could not load results`

  let @prompt = @buildPrompt(@promptTemplate, @e.topic, @e.experiment, @results, @qaDir)

  show `Reconciling: @e.topic/@e.experiment`
  show `  Status: @results.status`
  show `  Summary: @results.summary`

  let @response = @claude(@prompt, "opus", @base, "Read,Write,Bash,Glob,Grep")

  show `  Done.`
  => @e.topic + "/" + @e.experiment
]

>> Summary
exe @countNonNull(arr) = js { return arr.filter(x => x !== null).length; }

show `Reconciliation complete.`
show `Processed: @countNonNull(@processed) experiments`
show ``
show `Results in: @qaDir/<topic>/<experiment>/reconciliation.json`
show ``
show `To review verdicts:`
show `  find qa/ -name "reconciliation.json" -exec jq '{topic,experiment,verdict,action}' {} \\;`
