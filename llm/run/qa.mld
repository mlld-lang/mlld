>> QA Testing Orchestrator
>> Usage: mlld run qa [--tier 1] [--topic <filter>] [--topics <list>]
>> Runs parallel QA testing across mlld howto topics
>> Examples:
>>   mlld run qa --tier 1                           # Test tier 1 only (core syntax)
>>   mlld run qa --tier 1,2                         # Test tier 1 and 2
>>   mlld run qa --topic variables                  # Test variables-* topics
>>   mlld run qa --topics when-simple,for-arrow     # Test specific list

import { @claude } from @mlld/claude

>> Get filters from payload (with safe defaults)
import "@payload" as @payload
var @filterTopic = @payload.topic ? @payload.topic : ""
var @topicsList = @payload.topics ? @payload.topics : ""
var @tierFilter = @payload.tier ? @payload.tier : ""

>> Load all atoms dynamically from docs/src/atoms
var @atomFiles = <@base/docs/src/atoms/**/*.md>

>> Extract topics with qa_tier from atom frontmatter
>> Only atoms with qa_tier are eligible for QA testing
exe @extractQaTopics(files, tierFilter) = js {
  // Parse tier filter (e.g., "1" or "1,2")
  let allowedTiers = null;
  if (tierFilter && tierFilter !== '') {
    allowedTiers = new Set(tierFilter.split(',').map(t => parseInt(t.trim(), 10)));
  }

  return files
    .filter(f => {
      const tier = f.fm?.qa_tier;
      if (!tier) return false;  // No qa_tier = skip
      if (allowedTiers && !allowedTiers.has(tier)) return false;
      return true;
    })
    .map(f => f.fm.id)
    .filter(id => id && !id.startsWith('_'));
}
var @topics = @extractQaTopics(@atomFiles, @tierFilter)

>> Configuration
var @outputDir = "@base/qa"
var @parallelLimit = 10

>> Filter topics based on --topic (prefix) or --topics (comma list)
exe @filterTopics(allTopics, filter, list) = js {
  // --topics takes precedence: comma-separated explicit list
  if (list && list !== '') {
    const requested = list.split(',').map(t => t.trim());
    return allTopics.filter(t => requested.includes(t));
  }
  // --topic: prefix/exact match filter
  if (filter && filter !== '') {
    return allTopics.filter(t => t === filter || t.startsWith(filter + '-') || t.startsWith(filter));
  }
  return allTopics;
}

var @activeTopics = @filterTopics(@topics, @filterTopic, @topicsList)

>> Load the prompt template
var @promptTemplate = <@base/llm/run/qa-prompt.att>

>> Build prompt for a specific topic
exe @buildPrompt(template, topic, outputDir) = js {
  return template
    .replace(/@topic/g, topic)
    .replace(/@outputDir/g, outputDir);
}

>> Validate results.json schema
exe @validateResult(jsonStr) = js {
  try {
    const result = JSON.parse(jsonStr);
    const errors = [];

    if (!result.experiment) errors.push("missing 'experiment' field");
    if (!result.topic) errors.push("missing 'topic' field");
    if (!['pass', 'fail', 'partial'].includes(result.status)) {
      errors.push("'status' must be pass, fail, or partial");
    }
    if (!result.summary) errors.push("missing 'summary' field");
    if (!Array.isArray(result.issues)) errors.push("'issues' must be an array");

    const validCategories = ['broken-promise', 'unclear-error', 'unclear-docs', 'friction'];
    const validSeverities = ['blocker', 'major', 'minor', 'enhancement'];

    for (const issue of (result.issues || [])) {
      if (!validCategories.includes(issue.category)) {
        errors.push(`invalid category: ${issue.category}`);
      }
      if (!validSeverities.includes(issue.severity)) {
        errors.push(`invalid severity: ${issue.severity}`);
      }
      if (!issue.title) errors.push("issue missing 'title'");
      if (!issue.input) errors.push("issue missing 'input'");
      if (!issue.expected) errors.push("issue missing 'expected'");
      if (!issue.actual) errors.push("issue missing 'actual'");
    }

    return { valid: errors.length === 0, errors };
  } catch (e) {
    return { valid: false, errors: [`JSON parse error: ${e.message}`] };
  }
}

>> Create output directory
run cmd {mkdir -p @outputDir}

>> Run QA for a single topic
exe @runTopicQA(topic, prompt, outputDir) = js {
  // This returns the prompt - actual execution happens via @claude
  return { topic, prompt, outputDir: `${outputDir}/${topic}` };
}

>> Check if we have topics to test
exe @checkTopics(topics, filter) = js {
  if (topics.length === 0) {
    return `No topics match filter: ${filter}`;
  }
  return null;
}

var @topicError = @checkTopics(@activeTopics, @filterTopic)
when @topicError => show `@topicError\nAvailable: @topics.join(", ")`

>> Process each topic
show `Starting QA testing for @activeTopics.length topics...`
show `Output directory: @outputDir`
show `Parallel limit: @parallelLimit`
show ``

var @results = for parallel(10) @topic in @activeTopics [
  let @prompt = @buildPrompt(@promptTemplate, @topic, @outputDir)
  let @topicDir = `@outputDir/@topic`
  run cmd {mkdir -p @topicDir}
  show `Starting: @topic`
  let @response = @claude(@prompt, "sonnet", @base, "Read,Write,Bash,Glob,Grep")
  => @topic
]

>> Summary
show ``
show `QA testing complete.`
show `Tested @results.length topics`
show ``
show `Results in: @outputDir`
show ``
show `To aggregate results:`
show `  find qa/ -name "results.json" -exec cat {} \\; | jq -s '.'`
