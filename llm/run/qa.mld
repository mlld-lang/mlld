>> QA Testing Orchestrator
>> Usage: mlld run qa [--tier 1] [--topic <filter>] [--topics <list>]
>> Runs parallel QA testing across mlld howto topics
>> Examples:
>>   mlld run qa --tier 1                           # Test tier 1 only (core syntax)
>>   mlld run qa --tier 1,2                         # Test tier 1 and 2
>>   mlld run qa --topic variables                  # Test variables-* topics
>>   mlld run qa --topics when-simple,for-arrow     # Test specific list

import { @claude } from @mlld/claude

>> Get filters from payload (namespace import for optional fields)
import "@payload" as @p
var @topic = @p.topic ? @p.topic : ""
var @topics = @p.topics ? @p.topics : ""
var @tier = @p.tier ? @p.tier : ""

>> Load all atoms dynamically from docs/src/atoms
var @atomFiles = <@base/docs/src/atoms/**/*.md>

>> Extract topics with qa_tier from atom frontmatter
>> Note: Uses JS because mlld's for-loop doesn't support .fm access on iteration vars
>> This is a known limitation - @files[0].fm works but for @f in @files => @f.fm doesn't
exe @extractQaTopics(files, tierFilter) = js {
  const tiers = tierFilter ? tierFilter.split(',') : [];
  return files
    .filter(f => f.fm?.qa_tier && f.fm?.id && !f.fm.id.startsWith('_'))
    .filter(f => tiers.length === 0 || tiers.includes(String(f.fm.qa_tier)))
    .map(f => f.fm.id);
}
var @allTopics = @extractQaTopics(@atomFiles, @tier)

>> Configuration
var @outputDir = "@base/qa"
var @parallelLimit = 10

>> Filter topics based on --topic (prefix) or --topics (comma list)
>> Uses native when-first and for-when instead of JS
exe @filterTopics(all, filter, list) = when first [
  >> --topics (comma list) takes precedence
  @list => for @t in @all when @list.split(",").includes(@t) => @t
  >> --topic: prefix/exact match filter
  @filter => for @t in @all when @t == @filter || @t.startsWith(@filter) => @t
  >> No filter: return all
  * => @all
]

var @activeTopics = @filterTopics(@allTopics, @topic, @topics)

>> Load prompt template (not using `template` directive - it executes mlld code blocks)
var @promptTemplate = <@base/llm/run/qa-prompt.att>

>> Build prompt by replacing placeholders
exe @buildPrompt(tmpl, topic, outputDir) = js {
  return tmpl.replace(/@topic/g, topic).replace(/@outputDir/g, outputDir);
}

>> Validate results.json schema (kept as JS - complex validation logic)
exe @validateResult(jsonStr) = js {
  try {
    const result = JSON.parse(jsonStr);
    const errors = [];

    if (!result.experiment) errors.push("missing 'experiment' field");
    if (!result.topic) errors.push("missing 'topic' field");
    if (!['pass', 'fail', 'partial'].includes(result.status)) {
      errors.push("'status' must be pass, fail, or partial");
    }
    if (!result.summary) errors.push("missing 'summary' field");
    if (!Array.isArray(result.issues)) errors.push("'issues' must be an array");

    const validCategories = ['broken-promise', 'unclear-error', 'unclear-docs', 'friction'];
    const validSeverities = ['blocker', 'major', 'minor', 'enhancement'];

    for (const issue of (result.issues || [])) {
      if (!validCategories.includes(issue.category)) {
        errors.push(`invalid category: ${issue.category}`);
      }
      if (!validSeverities.includes(issue.severity)) {
        errors.push(`invalid severity: ${issue.severity}`);
      }
      if (!issue.title) errors.push("issue missing 'title'");
      if (!issue.input) errors.push("issue missing 'input'");
      if (!issue.expected) errors.push("issue missing 'expected'");
      if (!issue.actual) errors.push("issue missing 'actual'");
    }

    return { valid: errors.length === 0, errors };
  } catch (e) {
    return { valid: false, errors: [`JSON parse error: ${e.message}`] };
  }
}

>> Create output directory
run cmd {mkdir -p @outputDir}

>> Check if we have topics to test
when @activeTopics.length == 0 => show `No topics match filter: @topic\nAvailable: @allTopics.join(", ")`

>> Process each topic
show `Starting QA testing for @activeTopics.length topics...`
show `Output directory: @outputDir`
show `Parallel limit: @parallelLimit`
show ``

var @results = for parallel(10) @t in @activeTopics [
  let @prompt = @buildPrompt(@promptTemplate, @t, @outputDir)
  let @topicDir = `@outputDir/@t`
  run cmd {mkdir -p @topicDir}
  show `Starting: @t`
  let @response = @claude(@prompt, "sonnet", @base, "Read,Write,Bash,Glob,Grep")
  => @t
]

>> Summary
show ``
show `QA testing complete.`
show `Tested @results.length topics`
show ``
show `Results in: @outputDir`
show ``
show `To aggregate results:`
show `  find qa/ -name "results.json" -exec cat {} \\; | jq -s '.'`
