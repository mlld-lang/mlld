>> QA Fix Orchestrator
>> Usage: mlld run qa-fixes [--topic <filter>] [--limit <n>] [--dryrun]
>> Applies fixes for analyzed QA failures

import { @claude } from @mlld/claude

>> Get filters from payload
import "@payload" as @p
var @topicFilter = @p.topic ? @p.topic : ""
var @limit = @p.limit ? @p.limit : 50
var @dryRun = @p.dryrun ? true : false

>> Configuration
var @qaDir = "@base/qa"

>> Find experiments with proposed fixes ready to apply
exe @findToFix(qaDir, topicFilter, limit) = sh {
  node -e "
    const fs = require('fs');
    const path = require('path');
    const qaDir = '@qaDir';
    const topicFilter = '@topicFilter';
    const limit = parseInt('@limit');
    const fixable = [];

    function walkDir(dir) {
      if (!fs.existsSync(dir)) return;
      for (const item of fs.readdirSync(dir)) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        if (stat.isDirectory()) {
          walkDir(fullPath);
        } else if (item === 'proposed-fixes.json') {
          try {
            const content = JSON.parse(fs.readFileSync(fullPath, 'utf-8'));
            if (content.decision &&
                !content.fixed &&
                content.decision !== 'docs-only' &&
                (!topicFilter || content.topic.startsWith(topicFilter))) {
              const fix = content.proposed_fixes.find(f => f.id === content.decision);
              fixable.push({
                topic: content.topic,
                experiment: content.experiment,
                proposedPath: fullPath,
                experimentDir: path.dirname(fullPath),
                fixId: content.decision,
                fixDescription: fix ? fix.description : 'unknown',
                fixEffort: fix ? fix.effort : 'unknown'
              });
            }
          } catch (e) {}
        }
      }
    }
    walkDir(qaDir);
    console.log(JSON.stringify(fixable.slice(0, limit)));
  "
}

var @jsonStr = @findToFix(@qaDir, @topicFilter, @limit)
var @toFix = @jsonStr.data

>> Load prompt template
var @promptTemplate = <@base/llm/run/qa-fixes-prompt.att>

>> Build prompt
exe @buildPrompt(tmpl, item) = js {
  return tmpl
    .replace(/@topic/g, item.topic)
    .replace(/@experiment/g, item.experiment)
    .replace(/@proposedPath/g, item.proposedPath)
    .replace(/@experimentDir/g, item.experimentDir)
    .replace(/@fixId/g, item.fixId);
}

>> Report
show `Found @toFix.length experiments with pending fixes`
when @topicFilter => show `  (filtered by: @topicFilter)`
show ``

>> Dry run - just show what would be fixed
when @dryRun => show `DRY RUN:`
var @dryOutput = for @item in @toFix when @dryRun => `@item.topic/@item.experiment: @item.fixDescription`
for @line in @dryOutput => show `  @line`

>> Apply mode - run fixes sequentially (avoid git conflicts)
exe @shouldApply(dryRun) = js { return !dryRun }
var @applyMode = @shouldApply(@dryRun)

>> Filter items for apply mode
exe @getApplyItems(items, apply) = js { return apply ? items : [] }
var @itemsToApply = @getApplyItems(@toFix, @applyMode)

when @applyMode && @toFix.length == 0 => show `Nothing to fix.`
when @applyMode && @toFix.length > 0 => show `Applying @toFix.length fixes sequentially...`

var @results = for @item in @itemsToApply [
  let @prompt = @buildPrompt(@promptTemplate, @item)
  show `Fixing: @item.topic/@item.experiment (@item.fixEffort effort)`
  let @response = @claude(@prompt, "sonnet", @base, "Read,Write,Edit,Bash,Glob,Grep")
  => `@item.topic/@item.experiment`
]

when @results.length > 0 => show ``
when @results.length > 0 => show `Done. Fixed @results.length experiments.`
