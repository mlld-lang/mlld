>> Claude Session Helpers
>> Session-aware claude invocation with poll-based completion detection
>> Extends @mlld/claude-poll with --session-id and --resume support

/needs { sh }

>> Poll-based session creation: starts a new session with --session-id
>> timeout parameter is max elapsed seconds (default: 1800 = 30 min)
exe @claudeSession(prompt, model, tools, markerFile, sessionId, timeout) = sh {
  PROMPT_FILE=$(mktemp)
  printf '%s' "$prompt" > "$PROMPT_FILE"
  TIMEOUT=${timeout:-1800}

  claude -p --model "$model" --session-id "$sessionId" --allowedTools "$tools" < "$PROMPT_FILE" > /dev/null 2>&1 &
  CLAUDE_PID=$!
  START_TIME=$(date +%s)

  while ! test -f "$markerFile"; do
    sleep 5
    if ! kill -0 $CLAUDE_PID 2>/dev/null; then break; fi
    ELAPSED=$(( $(date +%s) - START_TIME ))
    if [ "$ELAPSED" -ge "$TIMEOUT" ]; then
      echo "TIMEOUT after ${ELAPSED}s" >&2
      kill $CLAUDE_PID 2>/dev/null
      break
    fi
  done

  sleep 15
  kill $CLAUDE_PID 2>/dev/null
  wait $CLAUDE_PID 2>/dev/null
  rm -f "$PROMPT_FILE"
  cat "$markerFile" 2>/dev/null
}

>> Poll-based session resume: continues an existing session with --resume
>> timeout parameter is max elapsed seconds (default: 1800 = 30 min)
exe @claudeResume(prompt, model, tools, markerFile, sessionId, timeout) = sh {
  PROMPT_FILE=$(mktemp)
  printf '%s' "$prompt" > "$PROMPT_FILE"
  TIMEOUT=${timeout:-1800}

  claude -p --model "$model" --resume "$sessionId" --allowedTools "$tools" < "$PROMPT_FILE" > /dev/null 2>&1 &
  CLAUDE_PID=$!
  START_TIME=$(date +%s)

  while ! test -f "$markerFile"; do
    sleep 5
    if ! kill -0 $CLAUDE_PID 2>/dev/null; then break; fi
    ELAPSED=$(( $(date +%s) - START_TIME ))
    if [ "$ELAPSED" -ge "$TIMEOUT" ]; then
      echo "TIMEOUT after ${ELAPSED}s" >&2
      kill $CLAUDE_PID 2>/dev/null
      break
    fi
  done

  sleep 15
  kill $CLAUDE_PID 2>/dev/null
  wait $CLAUDE_PID 2>/dev/null
  rm -f "$PROMPT_FILE"
  cat "$markerFile" 2>/dev/null
}

/export {
  @claudeSession,
  @claudeResume
}
