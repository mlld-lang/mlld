>> Aggregation Library
>> Pre-aggregation for Phase 3 trend analysis and run summaries

import { @flat } from @mlld/array

>> Build phase3-input.json for trend analysis agent
exe @aggregateForTrends(runDir, topics) = [
  let @allResults = <@runDir/topics/**/results.json>
  let @allSelfReviews = <@runDir/topics/**/self_review.json>

  let @activeResults = for @r in @allResults when @topics.includes(@r.topic) => @r
  let @activeReviews = for @sr in @allSelfReviews when @topics.includes(@sr.topic) => @sr

  let @phase1IssuesNested = for @r in @activeResults when @r.issues => for @i in @r.issues => {
    topic: @r.topic,
    experiment: @r.experiment,
    status: @r.status,
    category: @i.category,
    severity: @i.severity,
    title: @i.title
  }
  let @phase1Issues = @flat(@phase1IssuesNested)

  let @phase2ReviewsNested = for @sr in @activeReviews when @sr.issues_reviewed => for @i in @sr.issues_reviewed => {
    topic: @sr.topic,
    experiment: @sr.experiment,
    revised_verdict: @i.revised_verdict,
    revised_severity: @i.revised_severity,
    doc_clarity_issue: @i.doc_clarity ? @i.doc_clarity.issue : null,
    doc_clarity_suggestion: @i.doc_clarity ? @i.doc_clarity.suggestion : null,
    what_i_thought: @i.what_i_thought,
    what_i_found: @i.what_i_found
  }
  let @phase2Reviews = @flat(@phase2ReviewsNested)

  let @passing = for @r in @activeResults when @r.status == "pass" => @r
  let @failing = for @r in @activeResults when @r.status == "fail" => @r
  let @partial = for @r in @activeResults when @r.status == "partial" => @r

  let @phase3Input = {
    generated_at: @now,
    topics: @topics,
    topic_count: @topics.length,
    experiment_count: @activeResults.length,
    passing: @passing.length,
    failing: @failing.length,
    partial: @partial.length,
    self_reviews: @activeReviews.length,
    phase1_issues: @phase1Issues,
    phase2_reviews: @phase2Reviews
  }

  output @phase3Input to "@runDir/phase3-input.json"
  => @phase3Input
]

>> Build per-topic summaries for run-summary.json
exe @buildRunSummary(runDir, topics) = [
  let @allResults = <@runDir/topics/**/results.json>
  let @allSelfReviews = <@runDir/topics/**/self_review.json>

  => for @t in @topics [
    let @topicResults = for @r in @allResults when @r.topic == @t => @r
    let @tPass = for @r in @topicResults when @r.status == "pass" => @r
    let @tFail = for @r in @topicResults when @r.status == "fail" => @r
    let @tPartial = for @r in @topicResults when @r.status == "partial" => @r

    let @topicIssuesNested = for @r in @topicResults when @r.issues => for @i in @r.issues => @i
    let @topicIssues = @flat(@topicIssuesNested)
    let @tMajor = for @i in @topicIssues when @i.severity == "major" || @i.severity == "blocker" => @i
    let @tMinor = for @i in @topicIssues when @i.severity == "minor" => @i

    let @topicReviewsNested = for @sr in @allSelfReviews when @sr.topic == @t && @sr.issues_reviewed => for @i in @sr.issues_reviewed => @i
    let @topicReviews = @flat(@topicReviewsNested)
    let @tBugs = for @i in @topicReviews when @i.revised_verdict == "genuine-bug" => @i
    let @tDocNeeded = for @i in @topicReviews when @i.revised_verdict == "doc-improvement-needed" => @i
    let @tNotBug = for @i in @topicReviews when @i.revised_verdict == "not-a-bug" => @i

    => {
      topic: @t,
      experiments: @topicResults.length,
      pass: @tPass.length,
      fail: @tFail.length,
      partial: @tPartial.length,
      phase1_major: @tMajor.length,
      phase1_minor: @tMinor.length,
      phase2_genuine_bug: @tBugs.length,
      phase2_doc_improvement: @tDocNeeded.length,
      phase2_not_a_bug: @tNotBug.length
    }
  ]
]

>> Build doc clarity report from self-reviews
exe @buildDocClarityReport(runDir) = [
  let @allSelfReviews = <@runDir/topics/**/self_review.json>

  let @docClarityNested = for @sr in @allSelfReviews when @sr.issues_reviewed => for @issue in @sr.issues_reviewed when @issue.doc_clarity && @issue.doc_clarity.issue && @issue.doc_clarity.issue != "genuine-bug" => { topic: @sr.topic, experiment: @sr.experiment, issue: @issue.doc_clarity.issue, suggestion: @issue.doc_clarity.suggestion, affected_doc: @issue.doc_clarity.affected_doc }
  let @docClarityItems = @flat(@docClarityNested)

  let @qaInsufficient = for @item in @docClarityItems when @item.issue == "qa-insufficient-exploration" => @item
  let @docsClearer = for @item in @docClarityItems when @item.issue == "docs-could-be-clearer" => @item
  let @docsMisleading = for @item in @docClarityItems when @item.issue == "docs-genuinely-misleading" => @item

  => {
    generated_at: @now,
    summary: {
      qa_insufficient_exploration: @qaInsufficient.length,
      docs_could_be_clearer: @docsClearer.length,
      docs_genuinely_misleading: @docsMisleading.length
    },
    qa_prompt_feedback: @qaInsufficient,
    doc_clarifications: @docsClearer,
    doc_fixes: @docsMisleading
  }
]

/export {
  @aggregateForTrends,
  @buildRunSummary,
  @buildDocClarityReport
}
