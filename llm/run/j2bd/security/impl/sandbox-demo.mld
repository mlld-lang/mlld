>>
>> Sandbox Demo: Restricting Agent Capabilities
>>
>> ENFORCEMENT STATUS (as of 2026-02-03):
>>
>> WITH Docker provider (@mlld/env-docker):
>> - Filesystem limits: ENFORCED BY DOCKER PROVIDER via -v mounts with :ro (lines 67-85)
>> - Network restrictions: ENFORCED BY DOCKER PROVIDER via --network flag (lines 45-51)
>> - Resource limits: ENFORCED BY DOCKER PROVIDER via --memory and --cpus (lines 53-65)
>> - Credential protection: ENFORCED via policy label flow rules
>> - Tool attenuation: ENFORCED - child envs cannot expand parent's tool scope
>> - Tool restrictions: NOT ENFORCED at mlld level (ticket m-3ad1)
>> - MCP restrictions: NOT ENFORCED at mlld level (ticket m-289d)
>>
>> WITHOUT a provider (local execution):
>> - Credential protection: ENFORCED via policy label flow rules
>> - Tool attenuation: ENFORCED - child envs cannot expand parent's tool scope
>> - ALL OTHER RESTRICTIONS: NOT ENFORCED (require provider for isolation)
>>
>> Demonstrates environment-based sandboxing for AI agents:
>> 1. Tool restrictions (Read/Write only, no Bash)
>> 2. Filesystem access limits (specific directories only)
>> 3. Network disabled
>> 4. No MCP servers
>> 5. Credential injection via sealed paths
>>

>> ============================================================
>> STEP 1: Configure sandbox environment
>> ============================================================

>> Sandbox with Docker provider for process isolation.
>> Tools limited to Read and Write - Bash is NOT available.
var @sandbox = {
  provider: "@mlld/env-docker",
  tools: ["Read", "Write"],
  fs: { read: [".:/app"], write: ["/tmp"] },
  net: "none",
  mcps: []
}

log "Sandbox config: tools=Read,Write fs.read=.:/app fs.write=/tmp net=none mcps=[]"

>> ============================================================
>> STEP 2: Alternative configs showing different restrictions
>> ============================================================

>> Local execution (no provider) with auth and limited tools.
>> Commands run locally but tool access is restricted.
var @localRestricted = {
  auth: "claude",
  tools: ["Read", "Write"],
  fs: { read: ["@base/**"], write: ["@base/tmp/**", "@base/workspace/**"] }
}

log "Local restricted config: tools=Read,Write fs.write=tmp,workspace"

>> Read-only sandbox - agent can only observe, not modify.
var @readOnly = @sandbox with { tools: ["Read"], fs: { read: [".:/app"], write: [] } }

log "Read-only config derived from sandbox: tools=Read fs.write=[]"

>> Workspace-limited sandbox - agent can only work in /workspace.
var @workspaceSandbox = {
  provider: "@mlld/env-docker",
  tools: ["Read", "Write", "Bash"],
  fs: { read: ["/workspace:/workspace"], write: ["/workspace:/workspace"] },
  net: "none",
  mcps: []
}

log "Workspace sandbox: tools=Read,Write,Bash limited to /workspace"

>> ============================================================
>> STEP 3: Policy with credential configuration
>> ============================================================

>> Define policy with auth credentials.
>> Credentials flow through sealed paths - never exposed as strings.
var @policyConfig = {
  auth: {
    claude: { from: "keychain:mlld-env-myproject/claude", as: "ANTHROPIC_API_KEY" },
    openai: { from: "env:OPENAI_API_KEY", as: "OPENAI_API_KEY" }
  },
  capabilities: {
    allow: ["cmd:git:*", "fs:r:**", "fs:w:@base/tmp/**"],
    deny: ["sh"]
  }
}
policy @p = union(@policyConfig)

log "Policy configured with sealed auth paths"

>> ============================================================
>> STEP 4: Demonstrate environment block usage
>> ============================================================

>> The env block scopes tool access.
>> Inside this block, only Read and Write tools are available.
>> Bash commands would be blocked.

var @demoConfig = { tools: ["Read", "Write"] }

var @envResult = env @demoConfig [
  >> Inside env block, tools are restricted
  log "Inside env block with tools: Read, Write"
  => "env block completed"
]

show @envResult

>> ============================================================
>> STEP 5: Credential injection pattern
>> ============================================================

>> The 'using auth:name' syntax injects credentials as env vars.
>> The secret flows directly from source to env var - never a string.
>>
>> run cmd { claude -p @task } using auth:claude
>>
>> This would inject ANTHROPIC_API_KEY from keychain.
>> The agent cannot read the credential as a string variable.

log "Credential injection uses 'using auth:name' syntax"
log "Example: run cmd { tool } using auth:claude"

>> For explicit variable injection (computed secrets):
>> run cmd { tool } using @token as TOOL_KEY

>> ============================================================
>> SUMMARY
>> ============================================================

show ::

Sandbox Demo Complete
=====================

This demonstrated environment-based agent sandboxing:

1. FILESYSTEM LIMITS
   - WITH Docker provider: ENFORCED via -v mounts with :ro flag
   - Docker @create() adds :ro suffix to read-only mounts (lines 76-78)
   - WITHOUT provider: NOT ENFORCED (local execution)

2. NETWORK RESTRICTIONS
   - WITH Docker provider: ENFORCED via --network flag
   - Docker @create() passes net: "none"|"host"|"bridge" (lines 45-51)
   - WITHOUT provider: NOT ENFORCED (local execution)

3. RESOURCE LIMITS
   - WITH Docker provider: ENFORCED via --memory and --cpus flags
   - Docker @create() passes limits.mem and limits.cpu (lines 53-65)
   - WITHOUT provider: NOT ENFORCED (local execution)

4. CREDENTIAL INJECTION (ENFORCED)
   - policy.auth defines sealed credential paths
   - 'using auth:name' injects as env var
   - Secret never becomes interpolatable string
   - Policy label flow blocks secret interpolation into commands
   - keychain.get() outputs are labeled 'secret' automatically

5. TOOL RESTRICTIONS (NOT ENFORCED - ticket m-3ad1)
   - tools: ["Read", "Write"] sets tool scope
   - isToolAllowed() exists but is never called during execution
   - WORKAROUND: Use policy capabilities.deny for actual enforcement

6. MCP RESTRICTIONS (NOT ENFORCED - ticket m-289d)
   - mcps: [] syntax is parsed but not enforced
   - No MCP filtering code exists in the codebase

Environment configs are composable values:
- Use 'with' to derive restricted variants
- Use 'new' for child environments
- Policy controls overall capabilities

WHAT WORKS NOW:
- Filesystem isolation (with Docker provider)
- Network isolation (with Docker provider)
- Resource limits (with Docker provider)
- Tool attenuation (child cannot expand parent tools)
- Secret label flow protection via policy
- Credential injection via sealed paths
- Policy capabilities.allow/deny

KNOWN LIMITATIONS (m-3ad1, m-289d):
- env-level tool enforcement (isToolAllowed exists but not called)
- env-level MCP filtering (no code exists)

::
