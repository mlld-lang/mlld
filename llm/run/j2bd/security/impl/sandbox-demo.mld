>>
>> Sandbox Demo: Restricting Agent Capabilities
>>
>> ENFORCEMENT STATUS (as of 2026-02-03):
>>
>> WITH Docker provider (@mlld/env-docker):
>> - Filesystem limits: ENFORCED BY DOCKER PROVIDER via -v mounts with :ro
>> - Network restrictions: ENFORCED BY DOCKER PROVIDER via --network flag
>> - Resource limits: ENFORCED BY DOCKER PROVIDER via --memory and --cpus
>> - Credential protection: REQUIRES EXPLICIT GUARDS (labels work, defaults.rules not implemented)
>> - capabilities.allow: ENFORCED via policy-generated guards
>> - capabilities.deny: NOT IMPLEMENTED (denylist does not block)
>> - defaults.rules: NOT IMPLEMENTED (rules like "no-secret-exfil" don't activate)
>> - Tool restrictions: NOT ENFORCED at mlld level (ticket m-3ad1)
>> - MCP restrictions: NOT ENFORCED at mlld level (ticket m-289d)
>>
>> WITHOUT a provider (local execution):
>> - Credential protection: REQUIRES EXPLICIT GUARDS (same as above)
>> - capabilities.allow: ENFORCED via policy-generated guards
>> - capabilities.deny: NOT IMPLEMENTED
>> - defaults.rules: NOT IMPLEMENTED
>> - ALL OTHER RESTRICTIONS: NOT ENFORCED (require provider for isolation)
>>
>> Demonstrates environment-based sandboxing for AI agents:
>> 1. Tool restrictions (Read/Write only, no Bash)
>> 2. Filesystem access limits (specific directories only)
>> 3. Network disabled
>> 4. No MCP servers
>> 5. Credential injection via sealed paths
>>

>> ============================================================
>> STEP 1: Configure sandbox environment
>> ============================================================

>> Sandbox with Docker provider for process isolation.
>> Tools limited to Read and Write - Bash is NOT available.
var @sandbox = {
  provider: "@mlld/env-docker",
  tools: ["Read", "Write"],
  fs: { read: [".:/app"], write: ["/tmp"] },
  net: "none",
  mcps: []
}

log "Sandbox config: tools=Read,Write fs.read=.:/app fs.write=/tmp net=none mcps=[]"

>> ============================================================
>> STEP 2: Alternative configs showing different restrictions
>> ============================================================

>> Local execution (no provider) with auth and limited tools.
>> Commands run locally but tool access is restricted.
var @localRestricted = {
  auth: "claude",
  tools: ["Read", "Write"],
  fs: { read: ["@base/**"], write: ["@base/tmp/**", "@base/workspace/**"] }
}

log "Local restricted config: tools=Read,Write fs.write=tmp,workspace"

>> Read-only sandbox - agent can only observe, not modify.
var @readOnly = @sandbox with { tools: ["Read"], fs: { read: [".:/app"], write: [] } }

log "Read-only config derived from sandbox: tools=Read fs.write=[]"

>> Workspace-limited sandbox - agent can only work in /workspace.
var @workspaceSandbox = {
  provider: "@mlld/env-docker",
  tools: ["Read", "Write", "Bash"],
  fs: { read: ["/workspace:/workspace"], write: ["/workspace:/workspace"] },
  net: "none",
  mcps: []
}

log "Workspace sandbox: tools=Read,Write,Bash limited to /workspace"

>> ============================================================
>> STEP 3: Policy with credential configuration
>> ============================================================

>> Define policy with auth credentials.
>> Credentials flow through sealed paths - never exposed as strings.
>> NOTE: capabilities.deny is NOT IMPLEMENTED - only allow works.
var @policyConfig = {
  auth: {
    claude: { from: "keychain:mlld-env-myproject/claude", as: "ANTHROPIC_API_KEY" },
    openai: { from: "env:OPENAI_API_KEY", as: "OPENAI_API_KEY" }
  },
  capabilities: {
    allow: ["cmd:git:*", "fs:r:**", "fs:w:@base/tmp/**"]
  }
}

log "Policy configured with sealed auth paths"
log "NOTE: capabilities.deny removed - it is not enforced"

>> ============================================================
>> STEP 4: Guard for secret protection (REQUIRED for enforcement)
>> ============================================================

>> Secret labels propagate correctly but do NOT block by default.
>> You MUST define explicit guards to block secret exfiltration.
>> This guard blocks showing or interpolating secret-labeled data:

guard @noSecretShow before op:show = when [
  @mx.labels.includes("secret") => deny "Cannot show secret-labeled data"
  * => allow
]

guard @noSecretInCmd before op:cmd = when [
  @mx.labels.includes("secret") => deny "Cannot interpolate secrets into commands"
  * => allow
]

>> Test the guard with a secret variable:
var secret @testSecret = "sk-test-secret-value"
log "Defined secret variable (value hidden because guards are active)"

>> WITHOUT GUARDS: The secret would be shown/interpolated freely.
>> WITH GUARDS (above): Attempting to show @testSecret will be blocked.
>> Uncomment the line below to test blocking (will error):
>> show @testSecret

>> ============================================================
>> STEP 5: Demonstrate environment block usage
>> ============================================================

>> The env block scopes tool access.
>> Inside this block, only Read and Write tools are available.
>> NOTE: Tool enforcement (m-3ad1) not implemented - this is declarative only.

var @demoConfig = { tools: ["Read", "Write"] }

var @envResult = env @demoConfig [
  >> Inside env block, tools are restricted
  log "Inside env block with tools: Read, Write"
  => "env block completed"
]

show @envResult

>> ============================================================
>> STEP 6: Credential injection pattern
>> ============================================================

>> The 'using auth:name' syntax injects credentials as env vars.
>> The secret flows directly from source to env var - never a string.
>>
>> run cmd { claude -p @task } using auth:claude
>>
>> This would inject ANTHROPIC_API_KEY from keychain.
>> The agent cannot read the credential as a string variable.

log "Credential injection uses 'using auth:name' syntax"
log "Example: run cmd { tool } using auth:claude"

>> For explicit variable injection (computed secrets):
>> run cmd { tool } using @token as TOOL_KEY

>> ============================================================
>> SUMMARY
>> ============================================================

show ::

Sandbox Demo Complete
=====================

This demonstrated environment-based agent sandboxing:

1. FILESYSTEM LIMITS
   - WITH Docker provider: ENFORCED via -v mounts with :ro flag
   - Docker create() adds :ro suffix to read-only mounts
   - WITHOUT provider: NOT ENFORCED (local execution)

2. NETWORK RESTRICTIONS
   - WITH Docker provider: ENFORCED via --network flag
   - Docker create() passes net: "none"|"host"|"bridge"
   - WITHOUT provider: NOT ENFORCED (local execution)

3. RESOURCE LIMITS
   - WITH Docker provider: ENFORCED via --memory and --cpus flags
   - Docker create() passes limits.mem and limits.cpu
   - WITHOUT provider: NOT ENFORCED (local execution)

4. CREDENTIAL INJECTION
   - policy.auth defines sealed credential paths
   - 'using auth:name' injects as env var
   - Secret never becomes interpolatable string in that flow
   - HOWEVER: bare secret labels do NOT block show/interpolation
   - You MUST define explicit guards to block secret exfiltration
   - defaults.rules: ["no-secret-exfil"] is NOT IMPLEMENTED

5. TOOL RESTRICTIONS (NOT ENFORCED - ticket m-3ad1)
   - tools: ["Read", "Write"] sets tool scope
   - isToolAllowed() exists but is never called during execution
   - capabilities.deny does NOT work as a workaround
   - capabilities.allow DOES work (allowlist model enforced)

6. MCP RESTRICTIONS (NOT ENFORCED - ticket m-289d)
   - mcps: [] syntax is parsed but not enforced
   - No MCP filtering code exists in the codebase

Environment configs are composable values:
- Use 'with' to derive restricted variants
- Use 'new' for child environments
- Policy controls overall capabilities

WHAT WORKS NOW:
- Filesystem isolation (with Docker provider)
- Network isolation (with Docker provider)
- Resource limits (with Docker provider)
- Policy capabilities.allow (allowlist model)
- Credential injection via sealed 'using auth:name' paths
- User-defined guards for label-based blocking

WHAT DOES NOT WORK:
- capabilities.deny (denylist not enforced)
- defaults.rules (built-in rules not implemented)
- Automatic secret label blocking (requires explicit guards)

KNOWN LIMITATIONS (m-3ad1, m-289d):
- env-level tool enforcement (isToolAllowed exists but not called)
- env-level MCP filtering (no code exists)

::
