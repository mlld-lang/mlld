>> J2BD V3 Orchestrator
>> Usage: mlld run j2bd --topic <topic> [--job <job>] [--new] [--run <run-id>] [--max <n>] [--dryRun]
>>
>> LLM-first orchestration: decision agent makes all choices, orchestrator executes
>>
>> Examples:
>>   mlld run j2bd --topic security                     # Resume most recent run (or create first)
>>   mlld run j2bd --topic security --new              # Start a new run
>>   mlld run j2bd --topic security --run 2026-01-31-2 # Resume specific run
>>   mlld run j2bd --topic security --job prevent-exfil # Specific job only
>>   mlld run j2bd --topic security --dryRun            # Dry run (no commits)
>>   mlld run j2bd --topic security --max 10            # Limit iterations

>> Imports
import { @claudePoll } from @local/claude-poll
import { @buildContext, @loadRunState, @saveRunState, @countIterations, @loadTickets } from "./lib/context.mld"
import { @writeQuestionsFile, @logEvent } from "./lib/questions.mld"
import "@payload" as @p

>> Tool permissions for agents
var @decisionTools = "Read,Write,Glob,Grep"
var @workerTools = "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(npm:*),Bash(tk:*)"

>> Parse arguments (--topic is required)
var @topic = @p.topic
var @jobFilter = @p.job ?? null
var @runId = @p.run ?? null
var @newRun = @p.new ?? false
var @maxIterations = @p.max ? @p.max * 1 : null
var @dryRun = @p.dryRun ?? false

>> Load topic config
var @configPath = `@base/j2bd/@topic/config.mld`
import { @config } from "@configPath"

>> Shell helpers
exe @countRunsForDate(dir, date) = sh { ls "$dir" 2>/dev/null | grep "^$date" | wc -l | tr -d ' ' }
exe @mkdirp(dir) = sh { mkdir -p "$dir" }
exe @wtExists(branch) = sh { wt list --format=json | grep -q "\"branch\":\"$branch\"" && echo "true" || echo "false" }
exe @wtCreate(branch, baseBranch) = sh { wt switch --create "$branch" --base="$baseBranch" -y 2>&1 }
exe @wtPath(branch) = sh { wt list --format=json | jq -r ".[] | select(.branch==\"$branch\") | .path" }
exe @wtSwitch(branch) = sh { wt switch "$branch" -y }
exe @wtRemove(branch) = sh { wt remove "$branch" -y }
exe @wtMerge(branch, target) = sh { wt merge "$target" --stage tracked -y }
exe @getCurrentBranch() = sh { git branch --show-current }
exe @gitAddInWorktree(wtPath, file) = sh { cd "$wtPath" && git add "$file" }
exe @gitCommitInWorktree(wtPath, msg) = sh { cd "$wtPath" && git commit -m "$msg" }
exe @runTestsInWorktree(wtPath, testCmd) = sh { cd "$wtPath" && $testCmd }

>> Resolve or create run directory
var @today = @now.slice(0, 10)
var @j2bdRoot = `@base/j2bd/@topic/runs`

exe @nextRunId(root, today) = [
  let @existing = @countRunsForDate(@root, @today)
  let @count = @existing * 1
  => `@today-@count`
]

>> Find most recent run directory (by name, which sorts chronologically)
exe @mostRecentRun(root) = sh { ls -1d "$root"/*/ 2>/dev/null | xargs -n1 basename | sort -r | head -1 | tr -d '\n' }

>> Capture current branch at startup (for worktree base and merge target)
var @parentBranch = @getCurrentBranch()

>> Resolve run ID: --run <id> > --new > resume most recent > create first
exe @resolveRunId(root, today, runId, newRun) = when [
  @runId => @runId
  @newRun => @nextRunId(@root, @today)
  * => [
    let @recent = @mostRecentRun(@root)
    if @recent.length > 0 [
      => @recent
    ]
    => @nextRunId(@root, @today)
  ]
]

var @resolvedRunId = @resolveRunId(@j2bdRoot, @today, @runId, @newRun)
var @runDir = `@j2bdRoot/@resolvedRunId`

>> Ensure run directory exists
run @mkdirp(@runDir)

>> Load or initialize run state
var @run = @loadRunState(@runDir)
var @worktree = when [@run.worktree => @run.worktree; * => `@config.worktree_prefix-@resolvedRunId`]

if !@run.id [
  >> Create worktree for this run (branched from current branch, not main)
  let @wtExistsResult = @wtExists(@worktree)
  if @wtExistsResult == "false" [
    show `Creating worktree: @worktree (from @parentBranch)`
    run @wtCreate(@worktree, @parentBranch)
  ]

  >> Get worktree path
  let @worktreePath = @wtPath(@worktree)
  show `Worktree path: @worktreePath`

  let @newRun = {
    id: @resolvedRunId,
    topic: @topic,
    worktree: @worktree,
    worktreePath: @worktreePath,
    parentBranch: @parentBranch,
    created: @now
  }
  @saveRunState(@runDir, @newRun)
  @logEvent(@runDir, "run_start", { topic: @topic, worktree: @worktree, path: @worktreePath, parentBranch: @parentBranch })
]

>> Ensure we have the worktree path (for resumed runs)
var @worktreePath = when [@run.worktreePath => @run.worktreePath; * => @wtPath(@worktree)]

>> Load jobs (TODO: for-when loses file metadata - use direct access for now)
var @jobs = <@base/j2bd/@topic/jobs/*.md>

if @jobs.length == 0 [
  show `No jobs found for topic @topic`
  done
]

>> Filter to specific job if requested, otherwise use first
var @jobFilterMd = `@jobFilter\.md`
var @matchingJobs = when [
  @jobFilter => for @j in @jobs when @j.mx.filename == @jobFilter || @j.mx.filename == @jobFilterMd => @j
  * => @jobs
]
var @job = @matchingJobs[0]

if !@job [
  show `Job not found: @jobFilter`
  done
]

>> Shared prompt snippets
var @onboarding = <@base/llm/prompts/mlld-onboarding.md>
var @chestertonsFence = <@base/llm/prompts/chestertons-fence.md>

>> Prompt templates
exe @decisionPrompt(spec, job, tickets, recentEvents, lastWorkerResult, testResults, lastError, humanAnswers, chestertonsFence) = template "./prompts/decision.att"
exe @docWorkerPrompt(ticket, guidance, spec, existingAtoms, relatedCode, onboarding, chestertonsFence) = template "./prompts/doc-worker.att"
exe @implWorkerPrompt(ticket, guidance, spec, job, relevantCode, testFiles, onboarding, chestertonsFence) = template "./prompts/impl-worker.att"
exe @frictionWorkerPrompt(ticket, guidance, parentTicket, spec, relevantCode, relevantDocs, onboarding, chestertonsFence) = template "./prompts/friction-worker.att"
exe @mergeWorkerPrompt(sourceBranch, targetBranch, worktreePath, testCommand) = template "./prompts/merge-worker.att"

>> Build worker prompt based on task type
exe @buildWorkerPrompt(taskType, ticket, guidance, config, job, onboarding, chestertonsFence) = [
  let @spec = <@config.spec>
  >> Pre-load atoms for doc type (workaround for m-d777: nested when blocks don't return)
  let @existingAtoms = <@config.docs_dir/*.md>
  let @prompt = when @taskType [
    "doc" => @docWorkerPrompt(@ticket, @guidance, @spec, @existingAtoms, "", @onboarding, @chestertonsFence)
    "impl" => @implWorkerPrompt(@ticket, @guidance, @spec, @job, "", "", @onboarding, @chestertonsFence)
    "improvement" => @implWorkerPrompt(@ticket, @guidance, @spec, @job, "", "", @onboarding, @chestertonsFence)
    "friction" => @frictionWorkerPrompt(@ticket, @guidance, "", @spec, "", "", @onboarding, @chestertonsFence)
    * => `ERROR: Unknown task type: @taskType`
  ]
  => @prompt
]

>> Main loop
show `═══════════════════════════════════════════════════════════════════`
show `J2BD @topic - Run @resolvedRunId`
show `═══════════════════════════════════════════════════════════════════`
show `Job: @job.mx.filename`
show `Worktree: @worktree`
show `Run dir: @runDir`
show `───────────────────────────────────────────────────────────────────`

loop(endless) [
  >> Check max iterations (hard guard)
  let @iterationCount = @countIterations(@runDir)
  if @maxIterations && @iterationCount >= @maxIterations [
    @logEvent(@runDir, "run_stopped", { reason: "max_iterations", count: @iterationCount })
    show `Max iterations (@maxIterations) reached. Stopping.`
    done
  ]

  >> 1. Gather context
  let @context = @buildContext(@config, @runDir, @topic, @run)

  >> 2. Call decision agent
  let @decisionPromptText = @decisionPrompt(
    @context.spec,
    @job,
    @context.tickets ?? [],
    @context.recentEvents ?? [],
    @context.lastWorkerResult,
    @context.testResults,
    @context.lastError,
    @context.humanAnswers,
    @chestertonsFence
  )

  let @decisionOutputPath = `@runDir/decision-@iterationCount\.json`
  let @decisionFullPrompt = `@decisionPromptText

IMPORTANT: Write your JSON response to @decisionOutputPath using the Write tool. Write ONLY valid JSON.`
  @logEvent(@runDir, "decision_prompt", {
    length: @decisionPromptText.length,
    output_path: @decisionOutputPath,
    model: "opus",
    tools: @decisionTools
  })
  let @_ = @claudePoll(@decisionFullPrompt, "opus", "@base", @decisionTools, @decisionOutputPath)
  let @decision = <@decisionOutputPath>?

  if !@decision [
    show `Decision agent failed: no output at @decisionOutputPath`
    @logEvent(@runDir, "error", { type: "decision_agent", error: "no output" })
    continue
  ]

  show `Decision: @decision.action - @decision.reasoning`

  >> Log iteration
  @logEvent(@runDir, "iteration", {
    decision: @decision.action,
    ticket: @decision.ticket,
    reasoning: @decision.reasoning
  })

  >> 3. Execute action
  when @decision.action [
    "work" => [
      show `Working on ticket @decision.ticket (@decision.task_type)`

      >> Get ticket content
      let @ticket = cmd { tk show @decision.ticket --json }

      >> Build and run worker (in worktree)
      let @workerPrompt = @buildWorkerPrompt(@decision.task_type, @ticket, @decision.guidance, @config, @job, @onboarding, @chestertonsFence)
      let @workerOutputPath = `@runDir/worker-@decision.ticket-@iterationCount\.json`
      let @workerPromptPath = `@runDir/worker-@decision.ticket-@iterationCount\.prompt.md`

      >> Debug: check if prompt was built
      let @promptLength = @workerPrompt.length
      show `  Prompt built: @promptLength chars`
      if @promptLength < 100 [
        show `  WARNING: Prompt suspiciously short!`
        show `  Prompt content: @workerPrompt`
      ]

      let @workerFullPrompt = `@workerPrompt

IMPORTANT: Write your JSON response to @workerOutputPath using the Write tool. Write ONLY valid JSON.`

      >> Save prompt for debugging
      output @workerFullPrompt to "@workerPromptPath"
      show `  Prompt saved: @workerPromptPath`
      show `  Output expected: @workerOutputPath`
      show `  Working dir: @worktreePath`
      show `  Tools: @workerTools`
      @logEvent(@runDir, "worker_prompt", {
        ticket: @decision.ticket,
        task_type: @decision.task_type,
        length: @promptLength,
        prompt_path: @workerPromptPath,
        output_path: @workerOutputPath,
        model: "sonnet",
        tools: @workerTools
      })

      >> Run worker and capture result
      let @pollResult = @claudePoll(@workerFullPrompt, "sonnet", @worktreePath, @workerTools, @workerOutputPath)
      show `  Poll result: @pollResult`

      >> Try to read output
      let @result = <@workerOutputPath>?

      if !@result [
        show `Worker failed: no output at @workerOutputPath`
        let @rawContent = <@workerOutputPath>? ?? "[file not found or empty]"
        show `  Raw file content: @rawContent`
        @logEvent(@runDir, "error", {
          type: "worker",
          ticket: @decision.ticket,
          error: "no output",
          poll_result: @pollResult,
          raw_content: @rawContent,
          prompt_path: @workerPromptPath
        })
        >> Persist error state
        let @run = {
          ...@run,
          lastError: `Worker failed: no output for @decision.ticket`,
          lastWorkerResult: null
        }
        @saveRunState(@runDir, @run)
        continue
      ]

      >> Workers write files and commit themselves, then report what they did
      @logEvent(@runDir, "worker_result", {
        ticket: @decision.ticket,
        status: @result.status,
        work_done: @result.work_done,
        standup: @result.standup
      })

      >> Log friction points for decision agent to see
      if @result.friction_points && @result.friction_points.length > 0 [
        @logEvent(@runDir, "friction_reported", { ticket: @decision.ticket, points: @result.friction_points })
      ]

      show `Worker status: @result.status`
      if @result.work_done && @result.work_done.commit_hash [
        show `Committed: @result.work_done.commit_hash - @result.work_done.commit_message`
      ]

      >> Persist worker result state
      let @run = {
        ...@run,
        lastWorkerResult: @result,
        lastError: null
      }
      @saveRunState(@runDir, @run)
    ]

    "create_ticket" => [
      show `Creating ticket: @decision.title`
      let @ticketId = cmd { tk create --dir "j2bd-@topic" "@decision.title" -d "@decision.body" }
      >> Add tags if present
      if @decision.tags [
        for @tag in @decision.tags [
          cmd { tk tag @ticketId @tag }
        ]
      ]
      @logEvent(@runDir, "ticket_created", {
        id: @ticketId,
        type: @decision.type,
        title: @decision.title,
        parent: @decision.parent_ticket
      })
    ]

    "close_ticket" => [
      show `Closing ticket: @decision.ticket - @decision.reason`
      if @decision.note [
        cmd { tk add-note @decision.ticket "@decision.note" }
      ]
      cmd { tk close @decision.ticket "@decision.reason" }
      @logEvent(@runDir, "ticket_closed", { ticket: @decision.ticket, reason: @decision.reason })
    ]

    "update_ticket" => [
      show `Updating ticket: @decision.ticket`
      if @decision.add_note [
        cmd { tk add-note @decision.ticket "@decision.add_note" }
      ]
      if @decision.add_tags [
        for @tag in @decision.add_tags [
          cmd { tk tag @decision.ticket @tag }
        ]
      ]
      @logEvent(@runDir, "ticket_updated", { ticket: @decision.ticket })
    ]

    "blocked" => [
      show `Blocked - writing questions.md`
      @writeQuestionsFile(@runDir, @decision.blocking_tickets, @decision.questions, @topic, @resolvedRunId)
      @logEvent(@runDir, "run_paused", { reason: "needs_human", tickets: @decision.blocking_tickets })
      show `Human input needed. See: @runDir/questions.md`
      show `Resume with: mlld run j2bd @topic --run @resolvedRunId`
      done
    ]

    "complete" => [
      >> Hard guards before merge
      let @openTickets = @loadTickets(`j2bd-@topic`)
      let @openList = for @t in @openTickets when @t.status != "closed" => @t
      let @openCount = @openList.length
      if @openCount > 0 [
        show `Cannot complete: @openCount open tickets remain`
        @logEvent(@runDir, "error", { type: "complete_blocked", reason: "open_tickets", count: @openCount })
        >> Persist error state so decision agent sees it
        let @run = {
          ...@run,
          lastError: `Cannot complete: @openCount open tickets remain`
        }
        @saveRunState(@runDir, @run)
        continue
      ]

      show `Job complete: @decision.summary`
      @logEvent(@runDir, "job_complete", { summary: @decision.summary })

      >> Merge worktree using an agent (if not dry run)
      if !@dryRun [
        >> Get target branch from run state or fallback to captured parent branch
        let @targetBranch = @run.parentBranch ?? @parentBranch
        show `Merging worktree @worktree to @targetBranch (agent-driven)`

        >> Build and run merge worker
        let @mergePromptText = @mergeWorkerPrompt(@worktree, @targetBranch, @worktreePath, @config.test_command)
        let @mergeOutputPath = `@runDir/merge-@iterationCount\.json`
        let @mergeFullPrompt = `@mergePromptText

IMPORTANT: Write your JSON response to @mergeOutputPath using the Write tool. Write ONLY valid JSON.`

        @logEvent(@runDir, "merge_worker_start", {
          source: @worktree,
          target: @targetBranch,
          output_path: @mergeOutputPath
        })

        >> Run merge worker
        let @mergePollResult = @claudePoll(@mergeFullPrompt, "sonnet", @worktreePath, @workerTools, @mergeOutputPath)
        let @mergeResult = <@mergeOutputPath>?

        if !@mergeResult [
          show `Merge worker failed: no output`
          @logEvent(@runDir, "error", { type: "merge_worker", error: "no output" })
          let @run = {
            ...@run,
            lastError: "Merge worker failed to produce output"
          }
          @saveRunState(@runDir, @run)
          continue
        ]

        if @mergeResult.status == "completed" [
          show `Merge successful: @mergeResult.merge_result.commits_merged commits merged`
          @logEvent(@runDir, "worktree_merged", {
            worktree: @worktree,
            target: @targetBranch,
            commits: @mergeResult.merge_result.commits_merged,
            merge_commit: @mergeResult.merge_result.merge_commit
          })
        ]

        if @mergeResult.status == "blocked" || @mergeResult.status == "needs_human" [
          show `Merge blocked: @mergeResult.standup.blockers`
          >> Create urgent ticket for merge failure
          let @frictionDesc = @mergeResult.friction_points[0].description ?? "Merge failed"
          let @frictionDetails = @mergeResult.friction_points[0].details ?? ""
          let @ticketBody = `Merge of @worktree to @targetBranch failed.

**Issue**: @frictionDesc

**Details**:
@frictionDetails

**Suggested action**: @mergeResult.friction_points[0].suggested_action`
          let @ticketId = cmd { tk create --dir "j2bd-@topic" "URGENT: Merge failed - @frictionDesc" -d "@ticketBody" }
          cmd { tk tag @ticketId urgency-critical }
          @logEvent(@runDir, "merge_failed", {
            worktree: @worktree,
            target: @targetBranch,
            reason: @frictionDesc,
            ticket: @ticketId
          })
          let @run = {
            ...@run,
            lastError: `Merge failed: @frictionDesc - see ticket @ticketId`
          }
          @saveRunState(@runDir, @run)
          continue
        ]
      ]

      done
    ]

    * => [
      show `Unknown action: @decision.action`
      @logEvent(@runDir, "error", { type: "unknown_action", action: @decision.action })
    ]
  ]

  >> Small delay between iterations
  cmd { sleep 1 }
]
