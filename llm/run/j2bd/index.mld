>> J2BD V3 Orchestrator
>> Usage: mlld run j2bd --topic <topic> [--job <job>] [--max <n>] [--polish <level>]
>>
>> LLM-first orchestration: decision agent makes all choices, orchestrator executes
>> Workers commit directly to the current branch (no worktrees)
>>
>> Resilience: exe llm labels enable automatic caching. Decision loop is naturally
>> idempotent — the decision agent sees prior events and adjusts.
>>   mlld run j2bd --topic security              # auto-resumes via cache
>>   mlld run j2bd --topic security --new        # fresh checkpoint cache
>>   mlld run j2bd --topic security --max 10     # limit iterations
>>
>> Examples:
>>   mlld run j2bd --topic security                       # Resume or start
>>   mlld run j2bd --topic security --job prevent-exfil  # Specific job only
>>   mlld run j2bd --topic security --polish med         # Set quality bar

>> Imports
import { @claudePoll } from @mlld/claude-poll
import { @buildContext, @loadRecentEvents, @loadTickets, @buildReferenceMaterial, @extractJobSections } from "./lib/context.mld"
import { @writeQuestionsFile, @logEvent } from "./lib/questions.mld"
import "@payload" as @p

>> Tool permissions for agents
var @decisionTools = "Read,Write,Glob,Grep"
var @workerTools = "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(npm:*),Bash(tk:*)"

>> Parse arguments (--topic is required)
var @topic = @p.topic
var @jobFilter = @p.job ?? null
var @maxIterations = @p.max ? @p.max * 1 : null
var @polishArg = @p.polish ?? "false"

>> Validate and normalize polish level
var @polishValid = @polishArg == "false" || @polishArg == "med" || @polishArg == "medium" || @polishArg == "high"
if !@polishValid [
  show `Invalid --polish value: @polishArg (must be: false, med, high)`
  done
]
var @polish = when @polishArg [ "medium" => "med"; * => @polishArg ]

>> Load topic config
var @configPath = `@base/j2bd/@topic/config.mld`
import { @config } from "@configPath"

>> Shell helpers
exe @mkdirp(dir) = sh { mkdir -p "$dir" }
exe @getCurrentBranch() = sh { git branch --show-current }

>> LLM call wrappers — llm label enables automatic caching
exe llm @callDecision(prompt, model, dir, tools, outPath) = @claudePoll(@prompt, @model, @dir, @tools, @outPath)
exe llm @callWorker(prompt, model, dir, tools, outPath) = @claudePoll(@prompt, @model, @dir, @tools, @outPath)

>> Run directory — fixed per-topic (no dated suffix)
var @today = @now.slice(0, 10)
var @j2bdRoot = `@base/j2bd/@topic/runs`
var @runDir = `@j2bdRoot/@today`

>> Capture current branch at startup
var @currentBranch = @getCurrentBranch()

>> Ensure run directory exists
run @mkdirp(@runDir)

>> Load jobs
var @jobs = <@base/j2bd/@topic/jobs/*.md>

if @jobs.length == 0 [
  show `No jobs found for topic @topic`
  done
]

>> Filter to specific job if requested, otherwise use first
var @jobFilterMd = `@jobFilter\.md`
var @matchingJobs = when [
  @jobFilter => for @j in @jobs when @j.mx.filename == @jobFilter || @j.mx.filename == @jobFilterMd => @j
  * => @jobs
]
var @job = @matchingJobs[0]

if !@job [
  show `Job not found: @jobFilter`
  done
]

>> Shared prompt snippets
var @onboarding = <@base/llm/prompts/mlld-onboarding.md>
var @chestertonsFence = <@base/llm/prompts/chestertons-fence.md>

>> Decision prompt modules
var @phaseGuidance = <@base/llm/run/j2bd/prompts/decision/phases/impl.md>
var @qualityDefault = <@base/llm/run/j2bd/prompts/decision/quality/default.md>
var @qualityMed = <@base/llm/run/j2bd/prompts/decision/quality/med.md>?
var @qualityHigh = <@base/llm/run/j2bd/prompts/decision/quality/high.md>?

>> Build quality bar based on polish level (additive)
var @qualityBar = when @polish [
  "false" => @qualityDefault
  "med" => `@qualityDefault\n\n@qualityMed`
  "high" => `@qualityDefault\n\n@qualityMed\n\n@qualityHigh`
  * => @qualityDefault
]

>> Prompt templates
exe @decisionPrompt(jobSections, referenceMaterial, tickets, recentEvents, lastWorkerResult, testResults, lastError, humanAnswers, chestertonsFence, phaseGuidance, qualityBar) = template "./prompts/decision/core.att"
exe @docWorkerPrompt(ticket, guidance, spec, existingAtoms, relatedCode, onboarding, chestertonsFence) = template "./prompts/workers/doc.att"
exe @implWorkerPrompt(ticket, guidance, spec, job, relevantCode, testFiles, onboarding, chestertonsFence) = template "./prompts/workers/impl.att"
exe @frictionWorkerPrompt(ticket, guidance, parentTicket, spec, relevantCode, relevantDocs, onboarding, chestertonsFence) = template "./prompts/workers/friction.att"
exe @adversarialWorkerPrompt(ticket, guidance, spec, job, onboarding, chestertonsFence) = template "./prompts/workers/adversarial.att"
exe @finalReviewWorkerPrompt(ticket, guidance, spec, job, onboarding, chestertonsFence) = template "./prompts/workers/final-review.att"
exe @excellenceWorkerPrompt(ticket, guidance, spec, job, onboarding, chestertonsFence) = template "./prompts/workers/excellence.att"

>> Build worker prompt based on task type
exe @buildWorkerPrompt(taskType, ticket, guidance, config, job, onboarding, chestertonsFence) = [
  >> Scope spec and atoms to job-relevant sections instead of full dump
  let @ref = @buildReferenceMaterial(@config, @job)
  let @specParts = for @s in @ref.specSections => `## @s.name\n\n@s.content`
  let @spec = @specParts.join("\n\n---\n\n")
  let @atomParts = for @a in @ref.atoms => @a.content
  let @existingAtoms = @atomParts.join("\n\n---\n\n")
  let @prompt = when @taskType [
    "doc" => @docWorkerPrompt(@ticket, @guidance, @spec, @existingAtoms, "", @onboarding, @chestertonsFence)
    "impl" => @implWorkerPrompt(@ticket, @guidance, @spec, @job, "", "", @onboarding, @chestertonsFence)
    "improvement" => @implWorkerPrompt(@ticket, @guidance, @spec, @job, "", "", @onboarding, @chestertonsFence)
    "friction" => @frictionWorkerPrompt(@ticket, @guidance, "", @spec, "", "", @onboarding, @chestertonsFence)
    "adversarial" => @adversarialWorkerPrompt(@ticket, @guidance, @spec, @job, @onboarding, @chestertonsFence)
    "final_review" => @finalReviewWorkerPrompt(@ticket, @guidance, @spec, @job, @onboarding, @chestertonsFence)
    "excellence" => @excellenceWorkerPrompt(@ticket, @guidance, @spec, @job, @onboarding, @chestertonsFence)
    * => `ERROR: Unknown task type: @taskType`
  ]
  => @prompt
]

>> Main loop
show `═══════════════════════════════════════════════════════════════════`
show `J2BD @topic`
show `═══════════════════════════════════════════════════════════════════`
show `Job: @job.mx.filename`
show `Branch: @currentBranch`
show `Polish: @polish`
show `Run dir: @runDir`
show `───────────────────────────────────────────────────────────────────`

>> Track last worker result and errors in-memory (no run.json persistence needed)
var @lastWorkerResult = null
var @lastError = null

loop(endless) [
  >> Check max iterations via event count
  let @events = @loadRecentEvents(@runDir, 1000)
  let @iterations = for @e in @events when @e.event == "iteration" => @e
  let @iterationCount = @iterations.length
  if @maxIterations && @iterationCount >= @maxIterations [
    @logEvent(@runDir, "run_stopped", { reason: "max_iterations", count: @iterationCount })
    show `Max iterations (@maxIterations) reached. Stopping.`
    done
  ]

  >> 1. Gather context
  let @context = @buildContext(@config, @runDir, @topic, { lastWorkerResult: @lastWorkerResult, lastError: @lastError })

  >> 2. Build structured job context
  let @jobSections = @extractJobSections(@job)
  let @referenceMaterial = @buildReferenceMaterial(@config, @job)

  >> 3. Call decision agent
  let @decisionPromptText = @decisionPrompt(
    @jobSections,
    @referenceMaterial,
    @context.tickets ?? [],
    @context.recentEvents ?? [],
    @context.lastWorkerResult,
    @context.testResults,
    @context.lastError,
    @context.humanAnswers,
    @chestertonsFence,
    @phaseGuidance,
    @qualityBar
  )

  let @decisionOutputPath = `@runDir/decision-@iterationCount\.json`
  let @decisionFullPrompt = `@decisionPromptText

IMPORTANT: Write your JSON response to @decisionOutputPath using the Write tool. Write ONLY valid JSON.`
  @callDecision(@decisionFullPrompt, "opus", "@base", @decisionTools, @decisionOutputPath)
  let @decision = <@decisionOutputPath>?

  if !@decision [
    show `Decision agent failed: no output at @decisionOutputPath`
    @logEvent(@runDir, "error", { type: "decision_agent", error: "no output" })
    continue
  ]

  show `Decision: @decision.action - @decision.reasoning`

  >> Log iteration
  @logEvent(@runDir, "iteration", {
    decision: @decision.action,
    ticket: @decision.ticket,
    reasoning: @decision.reasoning
  })

  >> 3. Execute action
  when @decision.action [
    "work" => [
      show `Working on ticket @decision.ticket (@decision.task_type)`

      >> Get ticket content
      let @ticket = cmd { tk show @decision.ticket --json }

      >> Build and run worker
      let @workerPrompt = @buildWorkerPrompt(@decision.task_type, @ticket, @decision.guidance, @config, @job, @onboarding, @chestertonsFence)
      let @workerOutputPath = `@runDir/worker-@decision.ticket-@iterationCount\.json`
      let @workerPromptPath = `@runDir/worker-@decision.ticket-@iterationCount\.prompt.md`

      let @promptLength = @workerPrompt.length
      show `  Prompt built: @promptLength chars`

      let @workerFullPrompt = `@workerPrompt

IMPORTANT: Write your JSON response to @workerOutputPath using the Write tool. Write ONLY valid JSON.`

      >> Save prompt for debugging
      output @workerFullPrompt to "@workerPromptPath"
      show `  Prompt saved: @workerPromptPath`
      show `  Output expected: @workerOutputPath`
      show `  Tools: @workerTools`

      >> Run worker in repo root
      let @pollResult = @callWorker(@workerFullPrompt, "opus", "@base", @workerTools, @workerOutputPath)

      >> Try to read output
      let @result = <@workerOutputPath>?

      if !@result [
        show `Worker failed: no output at @workerOutputPath`
        @logEvent(@runDir, "error", {
          type: "worker",
          ticket: @decision.ticket,
          error: "no output"
        })
        let @lastError = `Worker failed: no output for @decision.ticket`
        let @lastWorkerResult = null
        continue
      ]

      >> Workers write files and commit themselves, then report what they did
      @logEvent(@runDir, "worker_result", {
        ticket: @decision.ticket,
        status: @result.status,
        work_done: @result.work_done,
        standup: @result.standup
      })

      >> Log friction points for decision agent to see
      if @result.friction_points && @result.friction_points.length > 0 [
        @logEvent(@runDir, "friction_reported", { ticket: @decision.ticket, points: @result.friction_points })
      ]

      show `Worker status: @result.status`
      if @result.work_done && @result.work_done.commit_hash [
        show `Committed: @result.work_done.commit_hash - @result.work_done.commit_message`
      ]

      let @lastWorkerResult = @result
      let @lastError = null
    ]

    "create_ticket" => [
      show `Creating ticket: @decision.title`
      let @ticketId = cmd { tk create --dir "j2bd-@topic" "@decision.title" -d "@decision.body" }
      >> Add tags if present
      if @decision.tags [
        for @tag in @decision.tags [
          cmd { tk tag @ticketId @tag }
        ]
      ]
      @logEvent(@runDir, "ticket_created", {
        id: @ticketId,
        type: @decision.type,
        title: @decision.title,
        parent: @decision.parent_ticket
      })
    ]

    "close_ticket" => [
      show `Closing ticket: @decision.ticket - @decision.reason`
      if @decision.note [
        cmd { tk add-note @decision.ticket "@decision.note" }
      ]
      cmd { tk close @decision.ticket "@decision.reason" }
      @logEvent(@runDir, "ticket_closed", { ticket: @decision.ticket, reason: @decision.reason })
    ]

    "update_ticket" => [
      show `Updating ticket: @decision.ticket`
      if @decision.add_note [
        cmd { tk add-note @decision.ticket "@decision.add_note" }
      ]
      if @decision.add_tags [
        for @tag in @decision.add_tags [
          cmd { tk tag @decision.ticket @tag }
        ]
      ]
      @logEvent(@runDir, "ticket_updated", { ticket: @decision.ticket })
    ]

    "blocked" => [
      show `Blocked - writing questions.md`
      @writeQuestionsFile(@runDir, @decision.blocking_tickets, @decision.questions, @topic, @today)
      @logEvent(@runDir, "run_paused", { reason: "needs_human", tickets: @decision.blocking_tickets })
      show `Human input needed. See: @runDir/questions.md`
      show `Resume with: mlld run j2bd --topic @topic`
      done
    ]

    "complete" => [
      >> Hard guards before completion
      let @openTickets = @loadTickets(`j2bd-@topic`)
      let @openList = for @t in @openTickets when @t.status != "closed" => @t
      let @openCount = @openList.length
      if @openCount > 0 [
        show `Cannot complete: @openCount open tickets remain`
        @logEvent(@runDir, "error", { type: "complete_blocked", reason: "open_tickets", count: @openCount })
        let @lastError = `Cannot complete: @openCount open tickets remain`
        continue
      ]

      show `Job complete: @decision.summary`
      @logEvent(@runDir, "job_complete", { summary: @decision.summary })
      done
    ]

    * => [
      show `Unknown action: @decision.action`
      @logEvent(@runDir, "error", { type: "unknown_action", action: @decision.action })
    ]
  ]

  >> Small delay between iterations
  cmd { sleep 1 }
]
