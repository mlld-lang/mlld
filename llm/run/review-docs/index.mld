>> Review Docs Orchestrator
>> Usage: mlld run review-docs [--parallel 10] [--priority high] [--docs name1,name2]
>>
>> Reviews docs/user/ and website/ against authoritative atom ground truth.
>> Three phases: review (candidates) → verify (with codebase access) → revise (confirmed only).
>> Then writes back revised docs to original locations for clean git diff.
>>
>> Resilience: exe llm labels + checkpoint directives. Crash recovery is automatic.
>>   mlld run review-docs                       # auto-resumes via cache
>>   mlld run review-docs --resume "verify"     # skip to verification phase
>>   mlld run review-docs --new                 # fresh run

import { @claudePoll } from @mlld/claude-poll
import { @flatName, @loadAtoms } from "./lib/context.mld"
import "@payload" as @p

>> ─── Config ───

var @parallelism = @p.parallel ? @p.parallel * 1 : 10
var @priorityFilter = @p.priority ?? ""
var @docsFilter = @p.docs ?? ""
var @reviewTools = "Read,Write,Glob,Grep"
var @verifyTools = "Read,Write,Glob,Grep,Bash(mlld:*),Bash(ls:*),Bash(cat:*),Bash(find:*)"
var @reviseTools = "Read,Write"

>> ─── Prompt templates ───

exe @reviewPrompt(targetPath, targetDoc, allAtoms) = template "./prompts/workers/review.att"
exe @verifyPrompt(targetPath, targetDoc, review, allAtoms) = template "./prompts/workers/verify.att"
exe @revisePrompt(targetPath, targetDoc, allAtoms, verifiedFindings) = template "./prompts/workers/revise.att"

>> ─── Helpers ───

exe @mkdirp(dir) = sh { mkdir -p "$dir" }
exe @copyFile(src, dest) = sh { cp "$src" "$dest" }
exe @countConfirmed(text) = [
  let @data = @text | @parse.llm
  when [
    @data.summary => @data.summary.confirmed ?? 0
    @data.verified_findings => [
      let @matched = for @f in @data.verified_findings when @f.classification == "confirmed" => @f
      => @matched.length
    ]
    * => 0
  ]
]

>> ─── LLM call wrappers — llm label enables automatic caching ───

exe llm @callReview(prompt, tools, outPath) = @claudePoll(@prompt, "sonnet", "@root", @tools, @outPath)
exe llm @callVerify(prompt, tools, outPath) = @claudePoll(@prompt, "sonnet", "@root", @tools, @outPath)
exe llm @callRevise(prompt, tools, outPath) = @claudePoll(@prompt, "sonnet", "@root", @tools, @outPath)

>> ─── Load manifest & filter targets ───

var @manifest = <./manifest.json> | @json
var @allDocs = for @d in @manifest.docs when @d.atoms.length > 0 => @d

var @priorityFiltered = when @priorityFilter [
  "" => @allDocs
  * => for @d in @allDocs when @d.priority == @priorityFilter => @d
]

var @targets = when @docsFilter [
  "" => @priorityFiltered
  * => [
    let @names = @docsFilter.split(",")
    let @matched = for @d in @priorityFiltered [
      let @hits = for @name in @names when @d.target.includes(@name.trim()) => 1
      if @hits.length > 0 [ => @d ]
      => null
    ]
    => for @m in @matched when @m => @m
  ]
]

>> ─── Set up run directory ───

var @runDir = `@root/runs/review-docs`
run @mkdirp(@runDir)
run @mkdirp(`@runDir/reviews`)
run @mkdirp(`@runDir/verified`)
run @mkdirp(`@runDir/finals`)

show `═══════════════════════════════════════════════════════════════════`
show `Review Docs: @targets.length targets`
show `═══════════════════════════════════════════════════════════════════`
show `Parallelism: @parallelism`
show `Priority filter: @priorityFilter`
show `Docs filter: @docsFilter`
show `Run dir: @runDir`
show `───────────────────────────────────────────────────────────────────`

>> ═══════════════════════════════════════════════════════════════════
>> Phase 1: Review — compare each doc against mapped atoms
>> Produces candidate findings (unverified)
>> ═══════════════════════════════════════════════════════════════════

show `\nPhase 1: Review (@targets.length docs, parallel @parallelism)`
show `───────────────────────────────────────────────────────────────────`

checkpoint "review"

var @reviewBatch = for parallel(@parallelism) @entry in @targets [
  let @targetPath = @entry.target
  let @flatTarget = @flatName(@targetPath)
  let @outPath = `@runDir/reviews/@flatTarget\.json`

  show `  [@mx.for.index] @targetPath: reviewing...`
  let @targetDoc = <@root/@targetPath>
  let @allAtoms = @loadAtoms(@entry)

  let @prompt = @reviewPrompt(@targetPath, @targetDoc, @allAtoms)
  let @fullPrompt = `@prompt

IMPORTANT: Write your JSON response to @outPath using the Write tool. Write ONLY valid JSON.`

  @callReview(@fullPrompt, @reviewTools, @outPath)

  let @result = <@outPath>?
  if !@result [
    show `  [@mx.for.index] @targetPath: FAILED`
    => null
  ]

  show `  [@mx.for.index] @targetPath: done`
  => null
]

>> Filter to docs that need changes
var @needsChanges = for @entry in @targets [
  let @flatTarget = @flatName(@entry.target)
  let @reviewFile = <@runDir/reviews/@flatTarget\.json>?
  if !@reviewFile [ => null ]

  let @reviewData = @reviewFile | @parse.llm
  let @verdict = @reviewData.verdict ?? "needs-changes"
  if @verdict == "up-to-date" [ => null ]

  => @entry
]
var @toVerify = for @e in @needsChanges when @e => @e

show `\nPhase 1 complete: @toVerify.length docs need changes`

>> ═══════════════════════════════════════════════════════════════════
>> Phase 2: Verify — check each finding against the full codebase
>> Workers get expanded tool access (Glob, Grep, Bash for mlld validate)
>> ═══════════════════════════════════════════════════════════════════

show `\nPhase 2: Verify (@toVerify.length docs, parallel @parallelism)`
show `───────────────────────────────────────────────────────────────────`

checkpoint "verify"

var @verifyBatch = for parallel(@parallelism) @entry in @toVerify [
  let @targetPath = @entry.target
  let @flatTarget = @flatName(@targetPath)
  let @outPath = `@runDir/verified/@flatTarget\.json`

  show `  [@mx.for.index] @targetPath: verifying...`
  let @targetDoc = <@root/@targetPath>
  let @allAtoms = @loadAtoms(@entry)
  let @review = <@runDir/reviews/@flatTarget\.json>

  let @prompt = @verifyPrompt(@targetPath, @targetDoc, @review, @allAtoms)
  let @fullPrompt = `@prompt

IMPORTANT: Write your JSON response to @outPath using the Write tool. Write ONLY valid JSON.`

  @callVerify(@fullPrompt, @verifyTools, @outPath)

  let @result = <@outPath>?
  if !@result [
    show `  [@mx.for.index] @targetPath: FAILED`
    => null
  ]

  show `  [@mx.for.index] @targetPath: done`
  => null
]

>> Filter to docs with confirmed findings
var @toRevise = for @entry in @toVerify [
  let @flatTarget = @flatName(@entry.target)
  let @verifyFile = <@runDir/verified/@flatTarget\.json>?
  if !@verifyFile [ => null ]

  let @confirmed = @countConfirmed(@verifyFile)
  if @confirmed == 0 [ => null ]

  => @entry
]
var @reviseTargets = for @e in @toRevise when @e => @e

show `\nPhase 2 complete: @reviseTargets.length docs have confirmed findings`

>> ═══════════════════════════════════════════════════════════════════
>> Phase 3: Revise — apply only confirmed findings
>> ═══════════════════════════════════════════════════════════════════

show `\nPhase 3: Revise (@reviseTargets.length docs, parallel @parallelism)`
show `───────────────────────────────────────────────────────────────────`

checkpoint "revise"

var @reviseBatch = for parallel(@parallelism) @entry in @reviseTargets [
  let @targetPath = @entry.target
  let @flatTarget = @flatName(@targetPath)
  let @outPath = `@runDir/finals/@flatTarget\.md`

  show `  [@mx.for.index] @targetPath: revising...`
  let @targetDoc = <@root/@targetPath>
  let @allAtoms = @loadAtoms(@entry)
  let @verifiedFindings = <@runDir/verified/@flatTarget\.json>

  let @prompt = @revisePrompt(@targetPath, @targetDoc, @allAtoms, @verifiedFindings)
  let @fullPrompt = `@prompt

IMPORTANT: Write the complete revised document to @outPath using the Write tool.`

  @callRevise(@fullPrompt, @reviseTools, @outPath)

  let @result = <@outPath>?
  if !@result [
    show `  [@mx.for.index] @targetPath: FAILED`
    => null
  ]

  show `  [@mx.for.index] @targetPath: done`
  => null
]

>> ═══════════════════════════════════════════════════════════════════
>> Phase 4: Write back — copy revised docs to original locations
>> ═══════════════════════════════════════════════════════════════════

show `\nPhase 4: Write back`
show `───────────────────────────────────────────────────────────────────`

exe @fileExists(path) = sh { test -f "$path" && echo "yes" || echo "no" }

var @writeBackResults = for @entry in @reviseTargets [
  let @flatTarget = @flatName(@entry.target)
  let @revisedPath = `@runDir/finals/@flatTarget\.md`
  let @exists = @fileExists(@revisedPath)
  if @exists != "yes" [
    show `  @entry.target: skipped (no revision)`
    => null
  ]

  let @dest = `@root/@entry.target`
  run @copyFile(@revisedPath, @dest)
  show `  @entry.target: updated`
  => @entry.target
]
var @writtenBack = for @w in @writeBackResults when @w => @w

show `\n  @writtenBack.length docs written to source`

>> ─── Summary ───

var @revisedCount = @writtenBack.length
var @errorCount = @reviseTargets.length - @revisedCount

show `\n═══════════════════════════════════════════════════════════════════`
show `Review Docs Complete`
show `═══════════════════════════════════════════════════════════════════`
show `  Total targets: @targets.length`
show `  Needed changes: @toVerify.length`
show `  Confirmed findings: @reviseTargets.length`
show `  Revised & written back: @revisedCount`
show `  Errors: @errorCount`
show `  Run dir: @runDir`
show `═══════════════════════════════════════════════════════════════════`

exe @writeJson(data, path) = [
  let @str = @data | @json
  output @str to "@path"
]

var @summary = {
  runDate: @now,
  total: @targets.length,
  neededChanges: @toVerify.length,
  confirmedFindings: @reviseTargets.length,
  revised: @revisedCount,
  errors: @errorCount
}
run @writeJson(@summary, `@runDir/summary\.json`)
