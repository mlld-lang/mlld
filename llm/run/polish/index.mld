>> Polish Pipeline v2
>> Usage: mlld run polish [options]
>>
>> Options:
>>   --batch N           Process N items per run (default: 5)
>>   --parallel N        Concurrent Claude calls in apply stage (default: 10)
>>   --timeout Ns        Timeout per parallel item, e.g. 60s (default: 1s)
>>   --loop              Keep processing until all items complete
>>   --skipEnrich        Skip enrich phase (use existing enriched-items.json)
>>   --docs-only         Only process doc fixes
>>   --qa                Include QA signals (requires prior mlld run qa + answered strategy-questions.md)
>>   --retry-failed      Re-attempt escalated items
>>   --dryRun true       Test mode: haiku model, batch of 2, skip actual changes
>>
>> Resilience: exe llm labels + checkpoint directives. Crash recovery is automatic.
>>   mlld run polish                       # auto-resumes via cache
>>   mlld run polish --resume "enrich"     # skip to enrich phase
>>   mlld run polish --new                 # fresh run
>>
>> Phases:
>>   0. interpret   - Parse human answers from strategy-questions.md (--qa only)
>>   1. reconcile   - Merge QA signals with existing tickets (or tickets only)
>>   2. enrich      - Assess stale/scope/impl status
>>   3. rank        - Prioritize and cluster work items
>>   4. execute     - Implement fixes in worktrees
>>   5. docs        - Process documentation fixes

import { @logEvent } from "./lib/events.mld"
import { @runInterpret } from "./phases/interpret.mld"
import { @runReconcile } from "./phases/reconcile.mld"
import { @runEnrich } from "./phases/enrich.mld"
import { @runRank } from "./phases/rank.mld"
import { @runExecute } from "./phases/execute.mld"
import { @runDocs } from "./phases/docs.mld"

/needs { sh }

>> Parse payload options
import "@payload" as @p

var @batchSize = @p.batch ? @p.batch * 1 : 5
var @pl = @p.parallel ? @p.parallel * 1 : 10
var @pt = @p.timeout ? @p.timeout : "1s"
var @loopMode = @p.loop ? true : false
var @skipEnrich = @p.skipEnrich ? true : false
var @docsOnly = @p.docsOnly ? true : false
var @useQa = @p.qa ? true : false
var @retryFailed = @p.retryFailed ? true : false
var @dryRun = @p.dryRun ? true : false

>> Pipeline root directory
var @pipelineRoot = `@base/pipeline`

>> Run directory â€” fixed (no dated suffix, checkpoint handles resumption)
exe @mkdirp(dir) = sh { mkdir -p "$dir" }
exe @getLatestQaRun(qaRoot) = sh {ls "$qaRoot" 2>/dev/null | grep '^20' | sort -r | head -1}

>> Find latest QA run for interpret phase
var @qaRoot = `@base/qa`
var @latestQa = @getLatestQaRun(@qaRoot)
var @latestQaTrimmed = @latestQa.trim()
var @qaRun = @latestQaTrimmed ? `@qaRoot/@latestQaTrimmed` : null

>> Set up run directory
var @runDir = `@pipelineRoot/current-run`
run @mkdirp(`@runDir/sources`)
run @mkdirp(`@runDir/interpret`)
run @mkdirp(`@runDir/reconcile`)
run @mkdirp(`@runDir/enrich`)
run @mkdirp(`@runDir/rank`)
run @mkdirp(`@runDir/execute`)
run @mkdirp(`@runDir/docs`)

>> Main entry point
show `=== Polish Pipeline v2 ===`
show ``
show `Config:`
show `  Batch size: @batchSize`
show `  Parallel: @pl concurrent, @pt timeout`
when @loopMode => show `  Loop mode: run until all items complete`
when @skipEnrich => show `  Skip enrich: requires existing enriched-items.json`
when @docsOnly => show `  Docs only: true`
when @useQa => show `  QA mode: including QA signals`
when @dryRun => show `  DRY RUN: haiku model, batch 2, no actual changes`
show ``
show `Run directory: @runDir`
show ``

>> Log run start
var @_1 = @logEvent(@runDir, { event: "run_start" })

>> Execute phases
var @phaseResults = {}

>> Phase 0: Interpret (only with --qa flag)
checkpoint "interpret"

when @useQa && !@docsOnly => [
  show `=== Phase 0: Interpret ===`
  let @result = @runInterpret(@runDir, @qaRun)
  @phaseResults += { interpret: @result }
  show ``
]

>> Phase 1: Reconcile
checkpoint "reconcile"

when !@docsOnly => [
  show `=== Phase 1: Reconcile ===`
  let @skipQa = !@useQa || !@qaRun
  let @result = @runReconcile(@runDir, @skipQa)
  @phaseResults += { reconcile: @result }
  show ``
]

>> Phase 2: Enrich
checkpoint "enrich"

when !@docsOnly && !@skipEnrich => [
  show `=== Phase 2: Enrich ===`
  let @result = @runEnrich(@runDir, @pl, @pt)
  @phaseResults += { enrich: @result }
  show ``
]

>> Phase 3: Rank
checkpoint "rank"

when !@docsOnly => [
  show `=== Phase 3: Rank ===`
  let @result = @runRank(@runDir)
  @phaseResults += { rank: @result }
  show ``
]

>> Phase 4: Execute
checkpoint "execute"

when !@docsOnly => [
  when @loopMode => [
    >> Loop mode: keep processing until all items complete
    show `=== Phase 4: Execute (loop mode) ===`
    let @loopResult = loop [
      let @iteration = @mx.loop.iteration
      let @prevRemaining = @input ? @input.remaining : null
      show `--- Batch @iteration ---`
      let @result = @runExecute(@runDir, { batch: @batchSize, parallel: @pl, timeout: @pt, dryRun: @dryRun })
      let @remaining = @result.remaining ? @result.remaining : 0

      >> Exit when no items remaining
      when @remaining == 0 => done { remaining: 0, last_result: @result }

      >> Continue if more items
      show `  @remaining items remaining, continuing...`
      continue { remaining: @remaining, last_result: @result }
    ]
    @phaseResults += { execute: @loopResult.last_result }
    show ``
  ]

  when !@loopMode => [
    >> Single batch mode
    show `=== Phase 4: Execute ===`
    let @result = @runExecute(@runDir, { batch: @batchSize, parallel: @pl, timeout: @pt, dryRun: @dryRun })
    @phaseResults += { execute: @result }
    show ``
  ]
]

>> Phase 5: Docs
checkpoint "docs"

when true => [
  show `=== Phase 5: Docs ===`
  let @result = @runDocs(@runDir, @pl, @pt)
  @phaseResults += { docs: @result }
  show ``
]

>> Log run completion
var @_2 = @logEvent(@runDir, { event: "run_complete", phases: @phaseResults })

>> Summary
show `=== Polish Complete ===`
show `Output: @runDir`

>> Show phase summaries
when @phaseResults.reconcile => [
  let @items = @phaseResults.reconcile.items ? @phaseResults.reconcile.items : []
  show `  Reconciled: @items.length items`
]
when @phaseResults.enrich => [
  let @items = @phaseResults.enrich.items ? @phaseResults.enrich.items : []
  show `  Enriched: @items.length items`
]
when @phaseResults.rank => [
  let @items = @phaseResults.rank.ranked_items ? @phaseResults.rank.ranked_items : []
  show `  Ranked: @items.length items`
]
when @phaseResults.execute => [
  let @results = @phaseResults.execute.results ? @phaseResults.execute.results : []
  show `  Executed: @results.length items`
]
when @phaseResults.docs => [
  let @results = @phaseResults.docs.results ? @phaseResults.docs.results : []
  show `  Docs: @results.length fixes`
]

show ``
show `Next steps:`
show `  Review results: @runDir/`
show `  Re-run with more: mlld run polish --batch @batchSize`
