>> Phase 1: Reconcile
>> Merges QA signals with existing tickets into unified work list
>>
>> Input: pipeline/<run>/interpret/strategy.json, .tickets/*.md
>> Output: pipeline/<run>/reconcile/merged-items.json

import { @claudePoll } from @mlld/claude-poll
import { @updatePhaseStatus } from "../lib/state.mld"
import { @logPhaseStart, @logPhaseComplete } from "../lib/events.mld"
import { @getOpenTickets } from "../lib/tickets.mld"

/needs { sh }

>> Tool permissions for reconcile agent
var @reconcileTools = "Read,Write,Glob,Grep,Bash(tk:*),Bash(cat:*)"

>> Build prompt from template
exe @buildReconcilePrompt(strategyJson, existingTicketsJson, outputPath) = template "../prompts/reconcile.att"

>> Main reconcile function
exe @runReconcile(runDir, noQa) = [
  >> Check for existing output (skip if already done)
  let @outputPath = `@runDir/reconcile/merged-items.json`
  let @existingOutput = <@outputPath>

  when @existingOutput [
    show `  Merged items already exist at @outputPath`
    show `  Skipping reconcile phase`
    => @existingOutput
  ]

  >> Load strategy if available (may be null in --no-qa mode)
  let @strategyPath = `@runDir/interpret/strategy.json`
  let @strategy = <@strategyPath>

  when !@strategy && !@noQa [
    show `  No strategy.json found and --no-qa not specified`
    show `  Run interpret phase first or use --no-qa`
    => null
  ]

  >> Load existing tickets
  let @existingTickets = @getOpenTickets()
  let @existingJson = @existingTickets | @json

  >> Log phase start
  let @_ = @logPhaseStart(@runDir, "reconcile")

  show `  Existing tickets: @existingTickets.length`
  when @strategy => show `  Strategy classifications: @strategy.classifications.length`

  >> If no QA data, just use existing tickets
  when @noQa || !@strategy [
    show `  Running in ticket-only mode (no QA reconciliation)`

    >> Build items from existing tickets only
    let @items = for @t in @existingTickets => {
      ticket_id: @t.id,
      source: "existing",
      topics: [],
      action: @t.type == "bug" ? "code-fix" : @t.type == "task" ? "doc-fix" : "code-fix",
      matched_existing: false
    }

    let @result = {
      generated_at: @now,
      items: @items,
      deferred: [],
      ticket_sources: {},
      summary: {
        total_items: @items.length,
        from_qa_new: 0,
        from_qa_matched: 0,
        from_existing: @items.length,
        deferred: 0
      }
    }

    output @result to "@outputPath"
    let @_ = @logPhaseComplete(@runDir, "reconcile", { items: @items.length })
    show `  Generated @items.length items (ticket-only mode)`
    => @result
  ]

  >> Full reconciliation with QA data
  let @strategyJson = @strategy | @json

  let @prompt = @buildReconcilePrompt(@strategyJson, @existingJson, @outputPath)
  let @fullPrompt = `@prompt\n\nIMPORTANT: Write your JSON response to @outputPath using the Write tool. Write ONLY the JSON object as its contents.`

  show `  Starting reconcile agent...`
  let @response = @claudePoll(@fullPrompt, "sonnet", @base, @reconcileTools, @outputPath)

  >> Load and return result
  let @result = <@outputPath>

  when !@result [
    show `  ERROR: Failed to generate merged-items.json`
    => null
  ]

  >> Also save ticket_sources separately for easy lookup
  when @result.ticket_sources [
    let @sourcesPath = `@runDir/reconcile/ticket-sources.json`
    output @result.ticket_sources to "@sourcesPath"
  ]

  >> Log completion
  let @itemCount = @result.items ? @result.items.length : 0
  let @_ = @logPhaseComplete(@runDir, "reconcile", { items: @itemCount })

  show `  Merged @itemCount items`
  when @result.summary [
    show `    From QA (new): @result.summary.from_qa_new`
    show `    From QA (matched): @result.summary.from_qa_matched`
    show `    From existing: @result.summary.from_existing`
    show `    Deferred: @result.summary.deferred`
  ]

  => @result
]

/export { @runReconcile }
