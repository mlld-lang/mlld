>> Phase 3: Rank
>> Groups related items into clusters and ranks by priority
>>
>> Input: pipeline/<run>/enrich/enriched-items.json
>> Output: pipeline/<run>/rank/work-plan.json

import { @claudePoll } from @local/claude-poll
import { @updatePhaseStatus } from "../lib/state.mld"
import { @logPhaseStart, @logPhaseComplete } from "../lib/events.mld"
import { @createTicket } from "../lib/tickets.mld"
import { @debuglog, @dbg } from "../lib/debug.mld"

/needs { sh }

>> Tool permissions for rank agent
var @rankTools = "Read,Write,Glob,Grep"
var @ticketTools = "Read,Write,Glob,Grep,Bash(tk:*),Bash(cat:*)"

>> Shell helper (sh blocks need $var via exe params)
exe @tkCreateEpic(title, tickets, rationale) = sh {tk create "$title" -t epic -p 2 --tags "triage-cluster" -d "Grouped work items: $tickets. Rationale: $rationale"}

>> Build prompts from templates
exe @buildGroupPrompt(itemsJson) = template "../prompts/rank-group.att"
exe @buildRankPrompt(assignmentsJson, itemDetailsJson) = template "../prompts/rank-order.att"

>> Main rank function
exe @runRank(runDir) = [
  >> Check for existing output (skip if already done)
  let @outputPath = `@runDir/rank/work-plan.json`
  let @existingOutput = <@outputPath>?

  >> Load enriched items, fall back to merged items if not enriched
  let @enrichedPath = `@runDir/enrich/enriched-items.json`
  let @mergedPath = `@runDir/reconcile/merged-items.json`
  let @enriched = <@enrichedPath>?
  let @merged = <@mergedPath>?

  >> Use enriched if available, otherwise fall back to merged
  let @source = @enriched ? "enriched" : "merged"
  let @items = when [
    @enriched && @enriched.items => @enriched.items
    @merged && @merged.items => @merged.items
    * => []
  ]

  >> Handle skip/error conditions
  when @existingOutput => [
    show `  Work plan already exists at @outputPath`
    show `  Skipping rank phase`
  ]
  when !@enriched && !@merged && !@existingOutput => [
    show `  No enriched-items.json or merged-items.json found`
    show `  Run reconcile phase first`
  ]
  when !@enriched && @merged && !@existingOutput => [
    show `  Using merged-items.json (enrich skipped)`
  ]
  let @itemCount = for @i in @items => 1
  when @itemCount.length == 0 && !@existingOutput => [
    show `  No items to rank`
    let @emptyPlan = { created: @now, ranked_items: [] }
    output @emptyPlan to "@outputPath"
  ]

  >> Use when for the entire function return
  => when [
    @existingOutput => @existingOutput
    !@enriched && !@merged => null
    @itemCount.length == 0 => { created: @now, ranked_items: [] }
    * => @_doRank(@runDir, @outputPath, @items)
  ]
]

>> Internal function to do the actual ranking work
exe @_doRank(runDir, outputPath, items) = [

  >> Log phase start
  @logPhaseStart(@runDir, "rank")

  show `  Ranking @items.length items...`

  >> Step 1: Group items
  let @itemsJson = @items | @json
  let @groupPrompt = @buildGroupPrompt(@itemsJson)
  let @groupMarker = `@runDir/rank/groups.json`
  let @groupFullPrompt = `@groupPrompt\n\nIMPORTANT: Write your JSON response to @groupMarker using the Write tool. Write ONLY the JSON array as its contents.`

  show `    Step 1: Grouping items...`
  let @groupResponse = @claudePoll(@groupFullPrompt, "opus", @base, @rankTools, @groupMarker)

  let @groups = <@groupMarker>?
  >> Count via for since .length is buggy on loaded JSON arrays
  let @groupCount = for @g in @groups => 1
  show `    [rank] group count = @groupCount.length`

  >> Handle group failure - show error message if failed
  when !@groups => show `  ERROR: Failed to generate groups`

  >> Use when for conditional return
  => when [
    @groups => @_continueWithGroups(@runDir, @outputPath, @items, @groups, @groupMarker)
    * => null
  ]
]

>> Continue ranking after successful grouping
exe @_continueWithGroups(runDir, outputPath, items, groups, groupMarker) = [
  >> Count groups
  let @singles = for @grp in @groups when @grp.type == "single" => @grp
  let @clusters = for @grp in @groups when @grp.type == "cluster" => @grp
  show `    Generated @singles.length singles, @clusters.length clusters`

  >> Step 2: Create epic tickets for clusters and build updated list
  let @clustersWithEpics = when [
    @clusters.length == 0 => []
    * => [
      show `    Creating epic tickets for clusters...`
      => for @cluster in @clusters [
        let @epicTitle = `[@cluster.area] Grouped work`
        let @ticketList = @cluster.tickets.join(", ")
        let @epicId = @tkCreateEpic(@epicTitle, @ticketList, @cluster.rationale)
        let @epicIdTrimmed = @epicId.trim()

        >> Reparent children under the epic
        for @childId in @cluster.tickets [
          let @ext = ".md"
          let @childPath = `@base/.tickets/@childId@ext`
          let @childContent = <@childPath>?
          when @childContent => [
            let @hasParent = @childContent.includes("parent:")
            let @updated = when [
              @hasParent => @childContent.replace(/^parent:.*$/m, `parent: @epicIdTrimmed`)
              * => @childContent.replace(/^(priority:.*)$/m, `$1\nparent: @epicIdTrimmed`)
            ]
            output @updated to "@childPath"
          ]
        ]

        show `      Created epic @epicIdTrimmed for @cluster.area (@cluster.tickets.length items)`
        => { ...@cluster, epic_id: @epicIdTrimmed }
      ]
    ]
  ]

  >> Combine singles and clusters with epic IDs
  let @allGroups = @singles.concat(@clustersWithEpics)

  >> Step 3: Rank groups
  let @groupsToUse = @allGroups
  let @assignmentsJson = @groupsToUse | @json
  let @itemDetailsJson = @items | @json
  let @rankPromptText = @buildRankPrompt(@assignmentsJson, @itemDetailsJson)
  let @rankMarker = `@runDir/rank/ranked.json`
  let @rankFullPrompt = `@rankPromptText\n\nIMPORTANT: Write your JSON response to @rankMarker using the Write tool. Write ONLY the JSON array as its contents.`

  show `    Step 2: Ranking assignments...`
  let @rankResponse = @claudePoll(@rankFullPrompt, "sonnet", @base, @rankTools, @rankMarker)

  let @ranked = <@rankMarker>?
  show `    [rank] ranked.length = @ranked.length`
  when @ranked.length > 100 => show `    [rank] WARNING: length > 100 suggests string not array`

  >> Handle rank failure - show error message if failed
  when !@ranked => show `  ERROR: Failed to generate ranking`

  >> Use when for conditional return
  => when [
    @ranked => @_finishRanking(@runDir, @outputPath, @ranked)
    * => null
  ]
]

>> Finish ranking after successful ranking call
exe @_finishRanking(runDir, outputPath, ranked) = [
  >> Build final work plan
  let @workPlan = {
    created: @now,
    ranked_items: @ranked
  }

  output @workPlan to "@outputPath"

  >> Log completion
  @logPhaseComplete(@runDir, "rank", { items: @ranked.length })

  show `  Ranked @ranked.length items`

  >> Show top 5
  let @top5 = @ranked.slice(0, 5)
  show `  Top 5:`
  for @rankedItem in @top5 [
    let @itemId = @rankedItem.ticket_id ? @rankedItem.ticket_id : @rankedItem.epic_id
    show `    @rankedItem.rank. [@rankedItem.type] @itemId (@rankedItem.points pts) - @rankedItem.rationale`
  ]

  => @workPlan
]

/export { @runRank }
