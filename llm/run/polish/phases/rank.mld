>> Phase 3: Rank
>> Groups related items into clusters and ranks by priority
>>
>> Input: pipeline/<run>/enrich/enriched-items.json
>> Output: pipeline/<run>/rank/work-plan.json

import { @claudePoll } from @mlld/claude-poll
import { @updatePhaseStatus } from "../lib/state.mld"
import { @logPhaseStart, @logPhaseComplete } from "../lib/events.mld"
import { @createTicket } from "../lib/tickets.mld"

/needs { sh }

>> Tool permissions for rank agent
var @rankTools = "Read,Write,Glob,Grep"
var @ticketTools = "Read,Write,Glob,Grep,Bash(tk:*),Bash(cat:*)"

>> Shell helper (sh blocks need $var via exe params)
exe @tkCreateEpic(title, tickets, rationale) = sh {tk create "$title" -t epic -p 2 --tags "triage-cluster" -d "Grouped work items: $tickets. Rationale: $rationale"}

>> Build prompts from templates
exe @buildGroupPrompt(itemsJson) = template "../prompts/rank-group.att"
exe @buildRankPrompt(assignmentsJson, itemDetailsJson) = template "../prompts/rank-order.att"

>> Main rank function
exe @runRank(runDir) = [
  >> Check for existing output (skip if already done)
  let @outputPath = `@runDir/rank/work-plan.json`
  let @existingOutput = <@outputPath>?

  >> Load enriched items
  let @enrichedPath = `@runDir/enrich/enriched-items.json`
  let @enriched = <@enrichedPath>?
  let @items = @enriched.items ? @enriched.items : []

  >> Handle skip/error conditions
  when @existingOutput => [
    show `  Work plan already exists at @outputPath`
    show `  Skipping rank phase`
  ]
  when !@enriched && !@existingOutput => [
    show `  No enriched-items.json found`
    show `  Run enrich phase first`
  ]
  when @items.length == 0 && @enriched && !@existingOutput => [
    show `  No items to rank`
    let @emptyPlan = { created: @now, ranked_items: [] }
    output @emptyPlan to "@outputPath"
  ]

  >> Use when first for the entire function return
  => when first [
    @existingOutput => @existingOutput
    !@enriched => null
    @items.length == 0 => { created: @now, ranked_items: [] }
    * => @_doRank(@runDir, @outputPath, @items)
  ]
]

>> Internal function to do the actual ranking work
exe @_doRank(runDir, outputPath, items) = [

  >> Log phase start
  @logPhaseStart(@runDir, "rank")

  show `  Ranking @items.length items...`

  >> Step 1: Group items
  let @itemsJson = @items | @json
  let @groupPrompt = @buildGroupPrompt(@itemsJson)
  let @groupMarker = `@runDir/rank/groups.json`
  let @groupFullPrompt = `@groupPrompt\n\nIMPORTANT: Write your JSON response to @groupMarker using the Write tool. Write ONLY the JSON array as its contents.`

  show `    Step 1: Grouping items...`
  let @groupResponse = @claudePoll(@groupFullPrompt, "opus", @base, @rankTools, @groupMarker)

  let @groups = <@groupMarker>?

  >> Handle group failure - show error message if failed
  when !@groups => show `  ERROR: Failed to generate groups`

  >> Use when first for conditional return
  => when first [
    @groups => @_continueWithGroups(@runDir, @outputPath, @items, @groups, @groupMarker)
    * => null
  ]
]

>> Continue ranking after successful grouping
exe @_continueWithGroups(runDir, outputPath, items, groups, groupMarker) = [
  >> Count groups
  let @singles = for @grp in @groups when @grp.type == "single" => @grp
  let @clusters = for @grp in @groups when @grp.type == "cluster" => @grp
  show `    Generated @singles.length singles, @clusters.length clusters`

  >> Step 2: Create epic tickets for clusters
  when @clusters.length > 0 => [
    show `    Creating epic tickets for clusters...`
    for @cluster in @clusters [
      let @epicTitle = `[@cluster.area] Grouped work`
      let @ticketList = @cluster.tickets.join(", ")
      let @epicId = @tkCreateEpic(@epicTitle, @ticketList, @cluster.rationale)
      let @epicIdTrimmed = @epicId.trim()

      >> Update cluster with epic ID
      let @cluster = { ...@cluster, epic_id: @epicIdTrimmed }

      >> Reparent children under the epic
      for @childId in @cluster.tickets [
        let @ext = ".md"
        let @childPath = `@base/.tickets/@childId@ext`
        let @childContent = <@childPath>?
        when @childContent => [
          let @hasParent = @childContent.includes("parent:")
          let @updated = when first [
            @hasParent => @childContent.replace(/^parent:.*$/m, `parent: @epicIdTrimmed`)
            * => @childContent.replace(/^(priority:.*)$/m, `$1\nparent: @epicIdTrimmed`)
          ]
          output @updated to "@childPath"
        ]
      ]

      show `      Created epic @epicIdTrimmed for @cluster.area (@cluster.tickets.length items)`
    ]
  ]

  >> Reload groups with epic IDs
  let @updatedGroups = <@groupMarker>?

  >> Step 3: Rank groups
  let @groupsToUse = @updatedGroups ? @updatedGroups : @groups
  let @assignmentsJson = @groupsToUse | @json
  let @itemDetailsJson = @items | @json
  let @rankPromptText = @buildRankPrompt(@assignmentsJson, @itemDetailsJson)
  let @rankMarker = `@runDir/rank/ranked.json`
  let @rankFullPrompt = `@rankPromptText\n\nIMPORTANT: Write your JSON response to @rankMarker using the Write tool. Write ONLY the JSON array as its contents.`

  show `    Step 2: Ranking assignments...`
  let @rankResponse = @claudePoll(@rankFullPrompt, "sonnet", @base, @rankTools, @rankMarker)

  let @ranked = <@rankMarker>?

  >> Handle rank failure - show error message if failed
  when !@ranked => show `  ERROR: Failed to generate ranking`

  >> Use when first for conditional return
  => when first [
    @ranked => @_finishRanking(@runDir, @outputPath, @ranked)
    * => null
  ]
]

>> Finish ranking after successful ranking call
exe @_finishRanking(runDir, outputPath, ranked) = [
  >> Build final work plan
  let @workPlan = {
    created: @now,
    ranked_items: @ranked
  }

  output @workPlan to "@outputPath"

  >> Log completion
  @logPhaseComplete(@runDir, "rank", { items: @ranked.length })

  show `  Ranked @ranked.length items`

  >> Show top 5
  let @top5 = @ranked.slice(0, 5)
  show `  Top 5:`
  for @rankedItem in @top5 => show `    @rankedItem.rank. [@rankedItem.type] @rankedItem.ticket_id ? @rankedItem.ticket_id : @rankedItem.epic_id (@rankedItem.points pts) - @rankedItem.rationale`

  => @workPlan
]

/export { @runRank }
