>> Phase 4: Execute
>> Orchestrates the three execute stages: apply, merge, verify
>>
>> Stages:
>>   4a. Apply   - Analyze + apply fixes in worktrees (parallel)
>>   4b. Merge   - Merge verified worktrees to main (sequential)
>>   4c. Verify  - Run tests on main after merges
>>
>> Input: pipeline/<run>/rank/work-plan.json
>> Output: pipeline/<run>/execute/results.json

import { @processTicket, @processCluster } from "./execute/apply.mld"
import { @mergeVerified } from "./execute/merge.mld"
import { @verifyMain } from "./execute/verify.mld"
import { @logPhaseStart, @logPhaseComplete, @logBatchStart, @logBatchDone } from "../lib/events.mld"

/needs { sh }

>> Main execute function
exe @runExecute(runDir, batchSize, dryRun) = [
  let @outputPath = `@runDir/execute/results.json`

  >> Load work plan
  let @workPlanPath = `@runDir/rank/work-plan.json`
  let @workPlan = <@workPlanPath>?

  let @items = @workPlan && @workPlan.ranked_items ? @workPlan.ranked_items : []

  >> Show status messages
  when !@workPlan => [
    show `  No work-plan.json found`
    show `  Run rank phase first`
  ]
  when @workPlan && @items.length == 0 => show `  No items to execute`

  >> Use when first for proper early returns
  => when first [
    !@workPlan => null
    @items.length == 0 => [
      let @emptyResults = { created: @now, results: [] }
      output @emptyResults to "@outputPath"
      => @emptyResults
    ]
    * => @_doExecute(@runDir, @outputPath, @items, @batchSize, @dryRun)
  ]
]

>> Internal function to do the actual execute work
exe @_doExecute(runDir, outputPath, items, batchSize, dryRun) = [
  >> Log phase start
  let @_ = @logPhaseStart(@runDir, "execute")

  >> Get base branch
  let @baseBranch = sh {git branch --show-current}
  let @baseBranchTrimmed = @baseBranch.trim()

  show `  Executing @items.length ranked items...`
  show `  Base branch: @baseBranchTrimmed`
  when @dryRun => show `  [DRY RUN MODE] Using haiku, skipping actual changes`

  >> Apply batch limit (dry-run forces batch of 2)
  let @effectiveBatchSize = @dryRun ? 2 : (@batchSize ? @batchSize * 1 : @items.length)
  let @batch = @items.slice(0, @effectiveBatchSize)

  show `  Processing batch of @batch.length items`
  let @_ = @logBatchStart(@runDir, @batch.length)

  >> === STAGE 4a: APPLY (parallel) ===
  show ``
  show `  --- Stage 4a: Apply (parallel, concurrency: 5) ---`

  >> Process items in parallel - each gets its own worktree
  let @results = for parallel(5) @item in @batch [
    let @itemId = @item.ticket_id ? @item.ticket_id : @item.epic_id
    log `  [start] @item.type: @itemId`

    let @itemResult = when first [
      @item.type == "cluster" => @processCluster(@runDir, @item, @baseBranchTrimmed, @dryRun)
      * => @processTicket(@runDir, @item.ticket_id, @baseBranchTrimmed, @dryRun)
    ]

    log `  [done] @itemId`
    => @itemResult
  ]

  let @_ = @logBatchDone(@runDir, @results.length)

  >> === STAGE 4b: MERGE ===
  show ``
  show `  --- Stage 4b: Merge ---`

  let @batchNum = 1
  let @mergeResult = @mergeVerified(@runDir, @results, @baseBranchTrimmed, @batchNum, @dryRun)

  >> === STAGE 4c: VERIFY ===
  show ``
  show `  --- Stage 4c: Verify ---`

  let @verifyResult = @verifyMain(@runDir, @mergeResult, @baseBranchTrimmed, @dryRun)

  >> Check verification status
  when @verifyResult.status == "fail" => show `  WARNING: Verification failed after merge!`

  >> Build final results
  let @mergedCount = @mergeResult.merged_count ? @mergeResult.merged_count : 0
  let @isDryRun = when first [@dryRun => true; * => false]
  let @executeResults = { created: @now, base_branch: @baseBranchTrimmed, batch_size: @batch.length, total_items: @items.length, dry_run: @isDryRun, results: @results, merge: @mergeResult, verification: @verifyResult }

  output @executeResults to "@outputPath"

  >> Log completion
  let @completed = for @r in @results when @r.verified => @r
  let @_ = @logPhaseComplete(@runDir, "execute", { processed: @results.length, completed: @completed.length, merged: @mergedCount, verified: @verifyResult.status })

  >> Summary
  let @singles = for @r in @results when @r.ticket_id && !@r.epic_id => @r
  let @clusters = for @r in @results when @r.epic_id => @r
  let @verified = for @r in @singles when @r.verified => @r
  let @needsReview = for @r in @singles when @r.status == "needs-review" => @r
  let @failed = for @r in @singles when @r.error => @r
  let @skipped = for @r in @singles when @r.skipped => @r

  show ``
  show `  Execute complete:`
  show `    Apply:  @singles.length singles (@verified.length verified, @needsReview.length needs-review, @failed.length failed, @skipped.length skipped)`
  show `            @clusters.length clusters processed`
  show `    Merge:  @mergedCount merged`
  show `    Verify: @verifyResult.status`

  => @executeResults
]

/export { @runExecute }
