>> mlld howto - self-documenting help system
>> Usage: mlld howto [topic] [subtopic]
>>
>> This script is called by the CLI with topic/subtopic passed via payload

>> Strip frontmatter from content
exe @stripFrontmatter(text) = js {
  if (typeof text !== 'string') {
    text = text && text.text ? text.text : String(text);
  }
  return text.replace(/^---[\s\S]*?---\n*/, '').trim();
}

>> Build tree display from all categories
exe @buildTree(allAtoms, introAtom) = js {
  const lines = ['MLLD HELP TOPICS', ''];
  const COL_WIDTH = 36; // Wide enough for longest IDs

  // Show intro brief at top
  if (introAtom) {
    const text = typeof introAtom === 'string' ? introAtom : (introAtom.text || '');
    const match = text.match(/^---\n([\s\S]*?)\n---/);
    if (match) {
      const briefMatch = match[1].match(/^brief:\s*(.+)$/m);
      if (briefMatch) {
        lines.push('  ' + 'intro'.padEnd(COL_WIDTH) + briefMatch[1].trim());
        lines.push('');
      }
    }
  }

  const categories = [
    { name: 'syntax', atoms: allAtoms.syntax },
    { name: 'commands', atoms: allAtoms.commands },
    { name: 'control-flow', atoms: allAtoms.controlFlow },
    { name: 'modules', atoms: allAtoms.modules },
    { name: 'patterns', atoms: allAtoms.patterns },
    { name: 'configuration', atoms: allAtoms.configuration },
    { name: 'security', atoms: allAtoms.security },
    { name: 'mistakes', atoms: allAtoms.mistakes }
  ];

  for (const cat of categories) {
    lines.push(cat.name + '                              (--all for full content)');
    for (const atom of cat.atoms) {
      const text = typeof atom === 'string' ? atom : (atom.text || '');
      const match = text.match(/^---\n([\s\S]*?)\n---/);
      if (match) {
        const idMatch = match[1].match(/^id:\s*(.+)$/m);
        const briefMatch = match[1].match(/^brief:\s*(.+)$/m);
        if (idMatch) {
          const id = idMatch[1].trim();
          // Skip _index files
          if (id.startsWith('_')) continue;
          const brief = briefMatch ? briefMatch[1].trim() : '';
          lines.push('  ' + id.padEnd(COL_WIDTH) + brief);
        }
      }
    }
    lines.push('');
  }

  lines.push('Usage:');
  lines.push('  mlld howto <section>           Show section index (e.g., howto syntax)');
  lines.push('  mlld howto <section> --all     Show full section content');
  lines.push('  mlld howto <topic>             Show specific topic (e.g., howto for-parallel)');
  lines.push('  mlld howto <topic> --section   Find topic then show its entire section');
  lines.push('  mlld howto grep <pattern>      Search all docs for pattern');
  lines.push('');
  lines.push('Tip: Use `mlld mcp-dev` to start an MCP server with language introspection tools');
  lines.push('     (mlld_validate, mlld_analyze, mlld_ast) for editor/agent integration.');
  return lines.join('\n');
}

>> Flatten allAtoms into single array
exe @flattenAtoms(allAtoms) = js {
  const all = [];
  for (const key of Object.keys(allAtoms)) {
    all.push(...allAtoms[key]);
  }
  return all;
}

>> Filter atoms by topic (matches id, parent, category, or aliases)
exe @filterByTopic(atoms, topicId) = js {
  if (!topicId) return [];
  const lowerTopic = topicId.toLowerCase();
  return atoms.filter(atom => {
    const text = typeof atom === 'string' ? atom : (atom.text || '');
    const match = text.match(/^---\n([\s\S]*?)\n---/);
    if (!match) return false;
    const idMatch = match[1].match(/^id:\s*(.+)$/m);
    const parentMatch = match[1].match(/^parent:\s*(.+)$/m);
    const categoryMatch = match[1].match(/^category:\s*(.+)$/m);
    const aliasMatch = match[1].match(/^aliases:\s*\[([^\]]*)\]/m);
    const id = idMatch ? idMatch[1].trim() : '';
    const parent = parentMatch ? parentMatch[1].trim() : '';
    const category = categoryMatch ? categoryMatch[1].trim() : '';
    // Parse aliases array from frontmatter
    const aliases = aliasMatch
      ? aliasMatch[1].split(',').map(a => a.trim().toLowerCase())
      : [];
    // Skip index files
    if (id.startsWith('_')) return false;
    return id === topicId || parent === topicId || category === topicId || aliases.includes(lowerTopic);
  });
}

>> Filter atoms by exact id
exe @filterById(atoms, id) = js {
  if (!id) return [];
  return atoms.filter(atom => {
    const text = typeof atom === 'string' ? atom : (atom.text || '');
    const match = text.match(/^---\n([\s\S]*?)\n---/);
    if (!match) return false;
    const idMatch = match[1].match(/^id:\s*(.+)$/m);
    return idMatch && idMatch[1].trim() === id;
  });
}

>> Get category from an atom's frontmatter
exe @getCategory(atom) = js {
  const text = typeof atom === 'string' ? atom : (atom.text || '');
  const match = text.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return '';
  const catMatch = match[1].match(/^category:\s*(.+)$/m);
  return catMatch ? catMatch[1].trim() : '';
}

>> Get content from atom (handles both string and object)
exe @getContent(atom) = js {
  if (typeof atom === 'string') return atom;
  if (atom && atom.text) return atom.text;
  return '';
}

>> Join stripped atoms into single output
exe @joinStripped(atoms) = js {
  return atoms.map(a => {
    const text = typeof a === 'string' ? a : (a.text || '');
    return text.replace(/^---[\s\S]*?---\n*/, '').trim();
  }).join('\n\n');
}

>> Search atoms for pattern, return matching lines with context
exe @grepAtoms(atoms, pattern) = js {
  if (!pattern) return 'Usage: mlld howto grep <pattern>';
  const results = [];
  const regex = new RegExp(pattern, 'gi');

  for (const atom of atoms) {
    const text = typeof atom === 'string' ? atom : (atom.text || '');
    const fmMatch = text.match(/^---\n([\s\S]*?)\n---/);
    if (!fmMatch) continue;

    const idMatch = fmMatch[1].match(/^id:\s*(.+)$/m);
    if (!idMatch) continue;
    const id = idMatch[1].trim();
    if (id.startsWith('_')) continue;

    const content = text.replace(/^---[\s\S]*?---\n*/, '');
    const lines = content.split('\n');
    const matches = [];

    for (let i = 0; i < lines.length; i++) {
      if (regex.test(lines[i])) {
        matches.push('  ' + (i + 1) + ': ' + lines[i].trim());
      }
    }

    if (matches.length > 0) {
      results.push(id + ':');
      results.push(...matches);
      results.push('');
    }
  }

  if (results.length === 0) {
    return 'No matches for "' + pattern + '"';
  }
  return results.join('\n');
}

>> Load intro atom (standalone at top level)
var @introAtom = <@base/docs/src/atoms/intro.md>

>> Load atoms from all categories
var @syntaxAtoms = <@base/docs/src/atoms/syntax/*.md>
var @commandsAtoms = <@base/docs/src/atoms/commands/*.md>
var @controlFlowAtoms = <@base/docs/src/atoms/control-flow/*.md>
var @modulesAtoms = <@base/docs/src/atoms/modules/*.md>
var @patternsAtoms = <@base/docs/src/atoms/patterns/*.md>
var @configurationAtoms = <@base/docs/src/atoms/configuration/*.md>
var @securityAtoms = <@base/docs/src/atoms/security/*.md>
var @mistakesAtoms = <@base/docs/src/atoms/mistakes/*.md>

>> Bundle all atoms into object for tree display
exe @bundleAtoms(syntax, commands, controlFlow, modules, patterns, configuration, security, mistakes) = js {
  return { syntax, commands, controlFlow, modules, patterns, configuration, security, mistakes };
}

var @allAtoms = @bundleAtoms(@syntaxAtoms, @commandsAtoms, @controlFlowAtoms, @modulesAtoms, @patternsAtoms, @configurationAtoms, @securityAtoms, @mistakesAtoms)
var @flatAtoms = @flattenAtoms(@allAtoms)

>> Add intro to flat atoms for searching
exe @addIntro(flatAtoms, introAtom) = js {
  return [introAtom, ...flatAtoms];
}
var @allFlatAtoms = @addIntro(@flatAtoms, @introAtom)

>> Get topic from payload (injected by SDK via dynamicModules)
import { @topic, @subtopic, @section, @all } from @payload

>> Build fullId for subtopic lookup
exe @buildFullId(topic, subtopic) = js {
  if (!topic || !subtopic) return '';
  return topic + '-' + subtopic;
}

>> Check if topic is a section name
exe @isSection(topic) = js {
  const sections = ['syntax', 'commands', 'control-flow', 'modules', 'patterns', 'configuration', 'security', 'mistakes'];
  return sections.includes(topic);
}

>> Compute values
var @fullId = @buildFullId(@topic, @subtopic)
var @hasTopic = @topic != ""
var @hasSubtopic = @subtopic != ""
var @isGrep = @topic == "grep"
var @isIntro = @topic == "intro"
var @wantSection = @section == true
var @wantAll = @all == true
var @isSectionTopic = @isSection(@topic)

>> Get matches
var @exactMatches = @filterById(@allFlatAtoms, @fullId)
var @topicMatches = @filterByTopic(@allFlatAtoms, @topic)

>> Get section matches when --section flag is used
>> First, find the category of the matched atom
exe @getSectionMatches(atoms, topicMatches, exactMatches, fullId, topic) = js {
  // Try to find the category from exact match first, then topic matches
  let targetAtom = null;
  if (exactMatches && exactMatches.length > 0) {
    targetAtom = exactMatches[0];
  } else if (topicMatches && topicMatches.length > 0) {
    targetAtom = topicMatches[0];
  }

  if (!targetAtom) return [];

  const text = typeof targetAtom === 'string' ? targetAtom : (targetAtom.text || '');
  const match = text.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return [];

  const catMatch = match[1].match(/^category:\s*(.+)$/m);
  if (!catMatch) return [];

  const category = catMatch[1].trim();

  // Filter all atoms by this category
  return atoms.filter(atom => {
    const t = typeof atom === 'string' ? atom : (atom.text || '');
    const m = t.match(/^---\n([\s\S]*?)\n---/);
    if (!m) return false;
    const idMatch = m[1].match(/^id:\s*(.+)$/m);
    const cMatch = m[1].match(/^category:\s*(.+)$/m);
    // Skip index files
    if (idMatch && idMatch[1].trim().startsWith('_')) return false;
    return cMatch && cMatch[1].trim() === category;
  });
}

var @sectionMatches = @getSectionMatches(@allFlatAtoms, @topicMatches, @exactMatches, @fullId, @topic)

>> Build not-found message with tree
exe @notFoundMsg(topic, tree) = js {
  return 'Topic "' + topic + '" not found.\n\n' + tree;
}

>> Build section index (list of topics in a section)
exe @buildSectionIndex(atoms, sectionName) = js {
  const COL_WIDTH = 36;
  const lines = [sectionName.toUpperCase(), ''];

  for (const atom of atoms) {
    const text = typeof atom === 'string' ? atom : (atom.text || '');
    const match = text.match(/^---\n([\s\S]*?)\n---/);
    if (match) {
      const idMatch = match[1].match(/^id:\s*(.+)$/m);
      const briefMatch = match[1].match(/^brief:\s*(.+)$/m);
      if (idMatch) {
        const id = idMatch[1].trim();
        if (id.startsWith('_')) continue;
        const brief = briefMatch ? briefMatch[1].trim() : '';
        lines.push('  ' + id.padEnd(COL_WIDTH) + brief);
      }
    }
  }

  lines.push('');
  lines.push('Usage:');
  lines.push('  mlld howto ' + sectionName + ' --all    Show full content');
  lines.push('  mlld howto <topic>              Show specific topic');
  return lines.join('\n');
}

>> Main output logic - use when first to ensure only one branch executes
when first [
  @isGrep => show @grepAtoms(@allFlatAtoms, @subtopic)
  @isIntro => show @stripFrontmatter(@introAtom)
  @wantSection && @sectionMatches.length > 0 => show @joinStripped(@sectionMatches)
  @hasSubtopic && @exactMatches.length > 0 => show @joinStripped(@exactMatches)
  @hasSubtopic => show `Subtopic "@fullId" not found.`
  @isSectionTopic && !@wantAll && @topicMatches.length > 0 => show @buildSectionIndex(@topicMatches, @topic)
  @hasTopic && @topicMatches.length > 0 => show @joinStripped(@topicMatches)
  @hasTopic => show @notFoundMsg(@topic, @buildTree(@allAtoms, @introAtom))
  * => show @buildTree(@allAtoms, @introAtom)
]
