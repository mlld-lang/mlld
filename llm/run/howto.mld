>> mlld howto - self-documenting help system
>> Usage: mlld howto [topic] [subtopic]
>>
>> This script is called by the CLI with topic/subtopic passed via payload

>> Strip frontmatter from content
exe @stripFrontmatter(text) = js {
  if (typeof text !== 'string') {
    text = text && text.content ? text.content : String(text);
  }
  return text.replace(/^---[\s\S]*?---\n*/, '').trim();
}

>> Build tree display from atoms
exe @buildTree(atoms) = js {
  const lines = ['MLLD HELP TOPICS', '', 'control-flow/'];
  for (const atom of atoms) {
    const text = typeof atom === 'string' ? atom : (atom.content || '');
    const match = text.match(/^---\n([\s\S]*?)\n---/);
    if (match) {
      const idMatch = match[1].match(/^id:\s*(.+)$/m);
      const briefMatch = match[1].match(/^brief:\s*(.+)$/m);
      if (idMatch) {
        const id = idMatch[1].trim();
        const brief = briefMatch ? briefMatch[1].trim() : '';
        lines.push('  ' + id.padEnd(25) + brief);
      }
    }
  }
  lines.push('');
  lines.push('Use: mlld howto <topic> for details');
  return lines.join('\n');
}

>> Filter atoms by topic (matches id or parent)
exe @filterByTopic(atoms, topicId) = js {
  if (!topicId) return [];
  return atoms.filter(atom => {
    const text = typeof atom === 'string' ? atom : (atom.content || '');
    const match = text.match(/^---\n([\s\S]*?)\n---/);
    if (!match) return false;
    const idMatch = match[1].match(/^id:\s*(.+)$/m);
    const parentMatch = match[1].match(/^parent:\s*(.+)$/m);
    const id = idMatch ? idMatch[1].trim() : '';
    const parent = parentMatch ? parentMatch[1].trim() : '';
    return id === topicId || parent === topicId;
  });
}

>> Filter atoms by exact id
exe @filterById(atoms, id) = js {
  if (!id) return [];
  return atoms.filter(atom => {
    const text = typeof atom === 'string' ? atom : (atom.content || '');
    const match = text.match(/^---\n([\s\S]*?)\n---/);
    if (!match) return false;
    const idMatch = match[1].match(/^id:\s*(.+)$/m);
    return idMatch && idMatch[1].trim() === id;
  });
}

>> Get content from atom (handles both string and object)
exe @getContent(atom) = js {
  if (typeof atom === 'string') return atom;
  if (atom && atom.content) return atom.content;
  return '';
}

>> Join stripped atoms into single output
exe @joinStripped(atoms) = js {
  return atoms.map(a => {
    const text = typeof a === 'string' ? a : (a.content || '');
    return text.replace(/^---[\s\S]*?---\n*/, '').trim();
  }).join('\n\n');
}

>> Load all control-flow atoms
var @controlFlowAtoms = <@base/docs/src/atoms/control-flow/*.md>

>> Get topic from payload (injected by SDK via dynamicModules)
import { @topic, @subtopic } from @payload

>> Build fullId for subtopic lookup
exe @buildFullId(topic, subtopic) = js {
  if (!topic || !subtopic) return '';
  return topic + '-' + subtopic;
}

>> Compute values
var @fullId = @buildFullId(@topic, @subtopic)
var @hasTopic = @topic != ""
var @hasSubtopic = @subtopic != ""

>> Get matches
var @exactMatches = @filterById(@controlFlowAtoms, @fullId)
var @topicMatches = @filterByTopic(@controlFlowAtoms, @topic)

>> Build not-found message with tree
exe @notFoundMsg(topic, tree) = js {
  return 'Topic "' + topic + '" not found.\n\n' + tree;
}

>> Main output logic - use when first to ensure only one branch executes
when first [
  @hasSubtopic && @exactMatches.length > 0 => show @joinStripped(@exactMatches)
  @hasSubtopic => show `Subtopic "@fullId" not found.`
  @hasTopic && @topicMatches.length > 0 => show @joinStripped(@topicMatches)
  @hasTopic => show @notFoundMsg(@topic, @buildTree(@controlFlowAtoms))
  * => show @buildTree(@controlFlowAtoms)
]
