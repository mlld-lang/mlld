// See also text.peggy, data.peggy, path.peggy, exec.peggy

Variable
  = InterpolationVar
  / AtVar

// InterpolationVar for string interpolation (uses {{var}})
InterpolationVar
  = InterpolationTextVar
  / InterpolationDataVar

// AtVar for direct variable references (uses @var)
// But don't match if this is a directive keyword starting a line
AtVar
  = "@" !{
      // Don't match if we're at a directive keyword
      const directiveKeywords = ['path', 'text', 'run', 'import', 'data', 'var', 'exec', 'add'];
      const pos = offset();
      const isAtLineStart = helpers.isLogicalLineStart(input, pos - 1); // -1 because we've already matched @
      
      if (!isAtLineStart) return false; // Not at line start, so can't be a directive
      
      // Look ahead to see if we have a directive keyword after the @
      const nextText = input.substring(pos, pos + 10); // Max directive keyword length + space
      for (const keyword of directiveKeywords) {
        if (nextText.startsWith(keyword) && 
            (nextText.length === keyword.length || /\s/.test(nextText[keyword.length]))) {
          return true; // This is a directive, don't match as AtVar
        }
      }
      return false;
    } id:(SpecialPathChar / Identifier) {
      const normalizedId = helpers.normalizePathVar(id);
      const node = helpers.createVariableReferenceNode('varIdentifier', {
        identifier: normalizedId,
      }, location());
      helpers.debug('CreateVAR', { rule: 'AtVar', node });
      return node;
    }

// {{var}} syntax for text interpolation
InterpolationTextVar
  = "{{" _ id:Identifier format:VarFormat? _ "}}" {
      const node = helpers.createVariableReferenceNode('varInterpolation', {
        identifier: id,
        ...(format ? { format } : {})
      }, location());
      helpers.debug('CreateVAR', { rule: 'InterpolationTextVar', node });
      helpers.debug('VAR_CREATE', `Created {{${id}}} node`, JSON.stringify(node));
      return node;
  }

// {{var.field}} syntax for data interpolation
InterpolationDataVar
  = "{{" _ id:Identifier accessElements:(FieldAccess / NumericFieldAccess / ArrayAccess)* format:VarFormat? _ "}}" {
    const node = helpers.createVariableReferenceNode('varInterpolation', {
      identifier: id,
      fields: accessElements || [],
      ...(format ? { format } : {})
    }, location());
    helpers.debug('CreateVAR', { rule: 'InterpolationDataVar', node });
    return node;
  }

// Legacy PathVar for backward compatibility during transition
// This will be removed after full implementation of AtVar
PathVar
  = "$" id:(SpecialPathChar / Identifier) {
      const normalizedId = helpers.normalizePathVar(id);
      const node = helpers.createVariableReferenceNode('varIdentifier', {
        identifier: normalizedId,
      }, location());
      helpers.debug('CreateVAR', { rule: 'PathVar', node });
      return node;
    }

VarDirective
  = "var" _ id:Identifier _ "=" _ value:VarValue DirectiveEOL {
    return helpers.createDirective('var', {
      identifier: id,
      value: {
        type: typeof value === 'string' ? 'string' :
              typeof value === 'number' ? 'number' :
              typeof value === 'boolean' ? 'boolean' :
              value === null ? 'null' :
              Array.isArray(value) ? 'array' :
              'object',
        value
      }
    }, location());
  }

VarValue
  = StringLiteral
  / NumberLiteral
  / BooleanLiteral
  / NullLiteral
  / DataObjectLiteral
  / ArrayLiteral

VarFormat
  = ">>" format:Identifier {
    return format;
  }