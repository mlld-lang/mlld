// --- Interpolated Literal Rules ---

PathStringLiteral "String literal with potential path variables"
  = '"' content:PathStringContent '"' { return content; }
  / "'" content:PathStringContent "'" { return content; }
  / "`" content:PathStringContent "`" { return content; }

PathStringContent "Path string content"
  = parts:(AtVar / PathVar / PathText / PathSeparator)+ {
      return parts;
    }

PathText "Path text"
  = chars:PathAllowedChar+ {
      return helpers.createNode(NodeType.Text, { content: chars.join('') }, location());
    }

PathAllowedChar
  = !('"' / "'" / '`' / '$' / '@' / '/' / '\\') char:. { return char; }
  / '\\' esc:. { return '\\' + esc; }

PathSeparator
  = '/' { return helpers.createNode(NodeType.PathSeparator, { value: '/' }, location()); }

InterpolatedStringLiteral "String literal with potential variable interpolation"
  = '"' content:DoubleQuoteInterpolatableContentOrEmpty '"' { return content; }
  / "'" content:SingleQuoteInterpolatableContentOrEmpty "'" { return content; }
  / "`" content:BacktickInterpolatableContentOrEmpty "`" { return content; }

InterpolatedMultilineTemplate "Multiline template with potential variable interpolation"
  = "[[" content:MultilineInterpolatableContentOrEmpty "]]" { return content; }

// --- Interpolation Rules ---

// Double Quotes
DoubleQuoteAllowedLiteralChar
  = !('"' / '{{' / '\\\\') char:. { return char; }
  / '\\\\' esc:. { return '\\\\' + esc; }

DoubleQuoteLiteralTextSegment
  = chars:DoubleQuoteAllowedLiteralChar+ {
      return helpers.createNode(NodeType.Text, { content: chars.join('') }, location());
    }

DoubleQuoteInterpolatableContent
  = parts:(DoubleQuoteLiteralTextSegment / Variable)+ {
      return parts;
    }

DoubleQuoteInterpolatableContentOrEmpty
  = result:DoubleQuoteInterpolatableContent? {
      return result || [];
    }

// Single Quotes
SingleQuoteAllowedLiteralChar
  = !('\'' / '{{' / '\\\\') char:. { return char; }
  / '\\\\' esc:. { return '\\\\' + esc; }

SingleQuoteLiteralTextSegment
  = chars:SingleQuoteAllowedLiteralChar+ {
      return helpers.createNode(NodeType.Text, { content: chars.join('') }, location());
    }

SingleQuoteInterpolatableContent
  = parts:(SingleQuoteLiteralTextSegment / Variable)+ {
      return parts;
    }

SingleQuoteInterpolatableContentOrEmpty
  = result:SingleQuoteInterpolatableContent? {
      return result || [];
    }

// Backticks (Template Literals)
BacktickAllowedLiteralChar
  = !('`' / '{{' / '\\\\') char:. { return char; }
  / '\\\\' esc:. { return '\\\\' + esc; }

BacktickLiteralTextSegment
  = chars:BacktickAllowedLiteralChar+ {
      return helpers.createNode(NodeType.Text, { content: chars.join('') }, location());
    }

BacktickInterpolatableContent
  = parts:(BacktickLiteralTextSegment / Variable)+ {
      return parts;
    }

BacktickInterpolatableContentOrEmpty
  = result:BacktickInterpolatableContent? {
      return result || [];
    }

// Multiline [[...]]
MultilineAllowedLiteralChar
  = !']]' !'{{' !('\\\\') char:. { return char; }
  / '\\\\' esc:. { return '\\\\' + esc; }

MultilineLiteralTextSegment
  = chars:MultilineAllowedLiteralChar+ {
      return helpers.createNode(NodeType.Text, { content: chars.join('') }, location());
    }

MultilineInterpolatableContent
  = parts:(MultilineLiteralTextSegment / Variable)+ {
      return parts;
    }

MultilineInterpolatableContentOrEmpty
  = result:MultilineInterpolatableContent? {
      return result || [];
    }


// Brackets [...] Interpolation
// For interpolated content, we only want to split on variables
BracketLiteralTextSegment
  = value:$(!(']' / '{{' / '$' / '@') .)+ { 
      return helpers.createNode(NodeType.Text, { content: value }, location());
    }

// Define a single part that can appear inside brackets, guarded by lookahead
BracketPart
  = !']' part:(
        Variable
      / BracketLiteralTextSegment // Everything else as plain text
    ) { return part; }

BracketInterpolatableContent
  = parts:BracketPart+ {
      return parts;
    }

BracketInterpolatableContentOrEmpty
  = parts:BracketPart+ { return parts; }
  / ""                 { return []; }
  
// For code blocks, we want to capture the entire content as a single text node
CodeBlockContent
  = content:$(!']' .)* { 
      return [helpers.createNode(NodeType.Text, { content }, location())];
    }
