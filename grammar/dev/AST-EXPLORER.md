# AST Explorer and Type Generation Framework

## Overview

The AST Explorer is a comprehensive framework for:

1. Exploring and visualizing the Abstract Syntax Tree (AST) generated by the Mlld grammar
2. Generating TypeScript type definitions from real-world examples
3. Creating consolidated type systems with discriminated unions
4. Automating E2E test case creation and validation

The system uses a convention-over-configuration approach with a structured directory layout that drives both AST exploration and type generation, ensuring that our type definitions accurately reflect the actual grammar implementation.

## Design Goals

1. **Single Source of Truth**: Use real-world examples as the source for both AST inspection and type generation
2. **Accuracy**: Ensure that type definitions accurately reflect the actual structure of parsed directives
3. **Discoverability**: Make it easy to understand the structure of different directive types
4. **Maintainability**: Provide a system that automatically updates types when the grammar changes
5. **Completeness**: Support all directive types and their variations
6. **Developer Experience**: Improve developer workflow with better tooling and type support

## Architecture

The framework consists of the following components:

### 1. Directory Structure

```
core/
  â”œâ”€â”€ ast/
  â”‚   â”œâ”€â”€ grammar/       # Built grammar parser
  â”‚   â”œâ”€â”€ parser.ts      # Main parser
  â”‚   â””â”€â”€ explorer/      # Explorer tools
  â”‚       â”œâ”€â”€ src/       # Explorer source code
  â”‚       â”œâ”€â”€ tests/     # Explorer tests
  â”‚       â””â”€â”€ ...
  â”œâ”€â”€ examples/          # Test cases organized by directive type
  â”‚   â”œâ”€â”€ valid/
  â”‚   â”‚   â”œâ”€â”€ text/
  â”‚   â”‚   â”‚   â”œâ”€â”€ assignment/
  â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ example.md   # Example document
  â”‚   â”‚   â”‚   â”‚   â””â”€â”€ expected.md  # Expected output
  â”‚   â”‚   â”‚   â””â”€â”€ template/
  â”‚   â”‚   â”‚       â””â”€â”€ ...
  â”‚   â”‚   â””â”€â”€ ...other directives
  â”‚   â”œâ”€â”€ invalid/       # Invalid test cases
  â”‚   â””â”€â”€ snapshots/     # Generated AST snapshots
  â””â”€â”€ types/             # Type definitions
      â”œâ”€â”€ ast-nodes.ts   # Generated AST node types
      â””â”€â”€ ...other types

grammar/                 # Grammar definitions
  â”œâ”€â”€ base/              # Base grammar patterns
  â”œâ”€â”€ core/              # Core grammar components
  â”œâ”€â”€ directives/        # Directive-specific grammar
  â””â”€â”€ ...
```

### 2. Core Components

#### Directive Extractor

- Parses Mlld documents to extract individual directives
- Handles multiline directives with complex structures
- Supports nesting and various quoting styles

```typescript
function extractDirectives(content: string): string[] {
  // Implementation supports various types of directives:
  // - Single-line directives (@text name = "value")
  // - Multiline bracket directives (@text content = [[...]])
  // - Quoted multiline directives (@text message = "...")
  // - Nested object structures (@data config = {...})
}
```

#### AST Parser Integration

- Connects to the core Mlld parser
- Converts parsed directives to a normalized AST structure
- Handles errors and provides fallback mechanisms

```typescript
function parseDirective(directive: string): DirectiveNode {
  // Uses the real Mlld parser
  // Falls back to mock AST in test environments
}
```

#### Type Generator

- Creates TypeScript interfaces from AST nodes
- Generates discriminated union types by directive kind
- Produces consistent naming and structure

```typescript
function generateTypeInterface(node: DirectiveNode): string {
  // Creates TypeScript interfaces with:
  // - Proper type names based on directive kind and subtype
  // - Accurate representation of values, raw, and meta fields
  // - Type guards for runtime type checking
}
```

#### Snapshot Generator

- Creates JSON snapshots of AST structures
- Enables tracking grammar changes over time
- Supports visual diffing of AST changes

#### Consolidated Type System

- Aggregates individual type definitions by directive kind
- Creates discriminated union types for easy type narrowing
- Generates a complete type hierarchy for the entire grammar

```typescript
// Example of generated type system
export type TextDirectiveNode = 
  | TextAssignmentDirectiveNode 
  | TextTemplateDirectiveNode;

export type DirectiveNodeUnion = 
  | TextDirectiveNode
  | RunDirectiveNode
  | ImportDirectiveNode
  | ...;
```

### 3. Workflow

1. **Example Creation**: Define example Mlld documents in the appropriate directory
2. **Fixture Generation**: Extract directives from examples to create test fixtures
3. **AST Snapshots**: Generate AST snapshots for each directive
4. **Type Generation**: Create TypeScript interfaces from AST snapshots
5. **Type Consolidation**: Aggregate interfaces by directive kind
6. **Documentation**: Generate documentation from types and examples

## Current Implementation Status

### Completed

- âœ… Directory structure for core components
- âœ… Directive extraction with support for multiline directives
- âœ… Basic AST parser integration (with mock option for testing)
- âœ… Type generation from AST nodes
- âœ… Snapshot generation for AST structures
- âœ… Test cases for directive extraction

### In Progress

- ğŸ”„ Full parser integration without mocking
- ğŸ”„ Complete consolidated type generation
- ğŸ”„ Command-line interface for developer usage

### To Do

- ğŸ“ Integration with build process
- ğŸ“ Example document generation from AST snapshots
- ğŸ“ Documentation generation from types
- ğŸ“ E2E test integration

## Known Issues

1. **Mock AST Usage**: The current implementation falls back to using mock AST structures in some cases, which don't fully reflect the real parser output. We need to ensure the system always uses the real parser in production mode.

2. **Limited Type Coverage**: The generated types don't yet cover all directive variants, particularly complex nested structures and directive combinations.

3. **Test Environment Issues**: Testing complex AST structures requires better mocking or testable real parser integration.

4. **Consolidated Type Generation**: The system correctly generates individual type definitions but needs improvement on consolidating them into a properly structured type hierarchy.

5. **Missing Integration**: The explorer needs to be integrated with the build process to automatically update types when the grammar changes.

## Usage

### Command Line Interface

```bash
# Process examples and generate types
node ./core/ast/explorer/src/command.js process-examples

# Generate consolidated type system
node ./core/ast/explorer/src/command.js consolidated-types

# Extract directives from a file
node ./core/ast/explorer/src/command.js extract ./path/to/file.md
```

### Programmatic Usage

```typescript
import { Explorer } from '@core/ast/explorer';

// Create explorer instance
const explorer = new Explorer({
  outputDir: './core/types/generated',
  examplesDir: './core/examples',
  snapshotsDir: './core/examples/snapshots'
});

// Parse a directive
const ast = explorer.parseDirective('@text greeting = "Hello, world!"');

// Generate type definition
explorer.generateTypes(directive, 'text-assignment');

// Generate AST snapshot
explorer.generateSnapshot(directive, 'text-assignment');

// Process all examples
explorer.processExampleDirs();

// Generate consolidated types
explorer.generateConsolidatedTypes();
```

## Next Steps

1. **Fix Parser Integration**: Ensure the explorer uses the real parser in production, not the mock implementation
2. **Complete Type System**: Finish the consolidated type generation functionality
3. **Build Integration**: Add scripts to run the explorer during build
4. **Documentation**: Generate documentation from examples and types
5. **Extended Example Coverage**: Add examples for all directive types and edge cases

## Conclusion

The AST Explorer framework is a powerful tool for understanding and leveraging the Mlld grammar. By using real-world examples as the source of truth for type generation, we ensure that our type system accurately reflects the actual behavior of the parser. The convention-based approach makes it easy to extend and maintain, while the automated processes ensure consistency and completeness.

Once fully implemented, this framework will significantly improve developer experience, reduce type-related bugs, and make the grammar more maintainable and discoverable.