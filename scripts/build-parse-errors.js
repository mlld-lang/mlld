#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const errorsDir = path.join(__dirname, '../errors/parse');
const outputPath = path.join(__dirname, '../core/errors/patterns/parse-errors.generated.js');

/**
 * Find all pattern directories containing pattern.js and error.md
 */
function findPatterns(dir, patterns = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    if (entry.isDirectory()) {
      const patternPath = path.join(dir, entry.name, 'pattern.js');
      const errorPath = path.join(dir, entry.name, 'error.md');
      
      if (fs.existsSync(patternPath) && fs.existsSync(errorPath)) {
        patterns.push({
          name: entry.name,
          patternPath,
          errorPath,
          // Read the files
          patternCode: fs.readFileSync(patternPath, 'utf-8'),
          errorTemplate: fs.readFileSync(errorPath, 'utf-8').trim()
        });
      }
    }
  }
  
  return patterns;
}

/**
 * Extract the pattern object from pattern.js code
 * Since we can't dynamically import, we'll parse the export
 */
function extractPatternCode(code, patternName) {
  // Extract the pattern object - looking for export const pattern = { ... }
  const match = code.match(/export\s+const\s+pattern\s*=\s*\{([\s\S]*)\};?$/m);
  if (!match) {
    throw new Error('Could not find pattern export');
  }
  
  // Extract just the functions, not the name property
  const patternBody = match[1];
  
  // Remove the name property line if it exists
  const cleanedBody = patternBody
    .split('\n')
    .filter(line => !line.trim().match(/^name:\s*['"].*['"]/))
    .map(line => '    ' + line) // Re-indent
    .join('\n');
  
  return `  {\n    ${cleanedBody.trim()}\n  }`;
}

/**
 * Generate the TypeScript file with all patterns
 */
function generatePatternFile(patterns) {
  const patternCount = patterns.length;
  const date = new Date().toISOString().split('T')[0];
  
  // Sort patterns by name for consistent output
  patterns.sort((a, b) => a.name.localeCompare(b.name));
  
  // Generate pattern objects
  const patternObjects = patterns.map(p => {
    try {
      const patternCode = extractPatternCode(p.patternCode, p.name);
      
      // Escape the template for embedding in JS
      const escapedTemplate = p.errorTemplate
        .replace(/\\/g, '\\\\')
        .replace(/`/g, '\\`')
        .replace(/\$/g, '\\$');
      
      return `  {
    name: '${p.name}',
    template: \`${escapedTemplate}\`,
${patternCode.slice(3)}`;
    } catch (e) {
      console.error(`Error processing pattern ${p.name}:`, e.message);
      throw e;
    }
  }).join(',\n\n');
  
  const content = `/**
 * Generated Error Patterns v1
 * 
 * Pattern count: ${patternCount}
 * Last updated: ${date}
 * 
 * When this hits 50+ patterns, consider meta-pattern extraction
 * 
 * This file is generated by scripts/build-parse-errors.js
 * DO NOT EDIT MANUALLY - run 'npm run build:errors' to regenerate
 */

import { MlldParseError } from '../MlldParseError';

/**
 * Interpolate template with variables
 */
function interpolateTemplate(template, variables) {
  return template.replace(/\\$\\{(\\w+)\\}/g, (match, varName) => {
    return variables[varName] || match;
  });
}

/**
 * All compiled error patterns
 */
const patterns = [
${patternObjects}
];

/**
 * Create error context from parse error
 */
function createErrorContext(error, source) {
  const lines = source.split('\\n');
  const lineNumber = error.location?.start?.line || 1;
  const line = lines[lineNumber - 1] || '';
  
  return {
    line,
    lines,
    lineNumber,
    source
  };
}

/**
 * Enhance a parse error using compiled patterns
 */
export function enhanceParseError(error, source, filePath) {
  const ctx = createErrorContext(error, source);
  
  // Try each pattern
  for (const pattern of patterns) {
    try {
      if (pattern.test(error, ctx)) {
        const variables = pattern.enhance(error, ctx);
        const message = interpolateTemplate(pattern.template, variables);
        
        const location = error.location;
        if (location && filePath) {
          location.filePath = filePath;
        }
        
        return new MlldParseError(message, location, {
          filePath,
          cause: error,
          patternName: pattern.name,
          variables
        });
      }
    } catch (e) {
      console.warn(\`Pattern '\${pattern.name}' threw error:\`, e);
    }
  }
  
  // No pattern matched, return simplified fallback
  return simplifyPeggyError(error, filePath);
}

/**
 * Fallback enhancement for unmatched errors
 */
function simplifyPeggyError(error, filePath) {
  const expectations = error.expected || [];
  const hasDirectives = expectations.some(e => e.text?.startsWith('/'));
  const hasVariables = expectations.some(e => e.text?.includes('@'));
  
  let message = error.message;
  
  if (hasDirectives && expectations.length > 5) {
    message = 'Syntax error: Expected a directive or content';
  } else if (hasVariables && expectations.length > 3) {
    message = 'Syntax error: Invalid variable syntax';
  } else if (expectations.length > 10) {
    message = 'Syntax error at this location';
  }
  
  if (error.found && error.found.length < 20) {
    message += \`, but found "\${error.found}"\`;
  }
  
  const location = error.location;
  if (location && filePath) {
    location.filePath = filePath;
  }
  
  return new MlldParseError(message, location, {
    filePath,
    cause: error
  });
}

// Export pattern metadata for testing/debugging
export const patternMetadata = {
  count: patterns.length,
  names: patterns.map(p => p.name),
  version: 1,
  generated: '${date}'
};
`;
  
  return content;
}

// Main execution
function main() {
  console.log('Building error patterns...');
  
  try {
    const patterns = findPatterns(errorsDir);
    
    if (patterns.length === 0) {
      console.warn('No error patterns found in', errorsDir);
      return;
    }
    
    console.log(`Found ${patterns.length} patterns:`, patterns.map(p => p.name).join(', '));
    
    const content = generatePatternFile(patterns);
    
    // Ensure output directory exists
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    
    // Write the file
    fs.writeFileSync(outputPath, content);
    
    console.log(`âœ“ Generated ${outputPath} with ${patterns.length} patterns`);
    
  } catch (error) {
    console.error('Error building patterns:', error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${__filename}`) {
  main();
}