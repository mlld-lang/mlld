---
description: Migrate 29 factory callers from old to new format
author: adam
version: 1.0.0
---

>> Load audit results
/var @audit = <@base/tmp/factory-audit-detailed.json>

>> Filter to files needing migration (oldFormat > 0)
/exe @needsMigration(analyses) = js {
  return analyses.filter(a => a.oldFormat > 0);
}

/var @filesToMigrate = @needsMigration(@audit)
/show "Files needing migration: @filesToMigrate.length"

>> Show breakdown
/exe @showBreakdown(files) = js {
  files.forEach(f => {
    console.log(`\n${f.filepath}: ${f.oldFormat} calls (${f.summary.split('Total')[1] || f.summary.split('Estimated')[1] || 'see details'})`);
  });
  return '';
}

/var @_ = @showBreakdown(@filesToMigrate)

>> Build migration request for each file
/exe @buildMigrationRequest(fileAnalysis) = `
You are migrating Variable factory calls from old metadata format to new { ctx, internal } format.

<file_context>
File: @fileAnalysis.filepath
Old format calls: @fileAnalysis.oldFormat
Already migrated: @fileAnalysis.newFormat

Summary: @fileAnalysis.summary
</file_context>

<calls_to_migrate>
@fileAnalysis.calls | @json
</calls_to_migrate>

<migration_patterns>
CRITICAL - Factory Parameter Positions:
- Most factories: (name, value, source, metadataOrOptions?)
  - Position 4 is the metadata
- createPathVariable: (name, path, originalPath, isURL, isAbsolute, source, metadataOrOptions?)
  - Position 7 is the metadata
- createArrayVariable: (name, value, isComplex, source, metadataOrOptions?)
  - Position 5 is the metadata

OLD FORMAT (what you're migrating FROM):
1. Plain object: { isSystem: true, isParameter: true }
2. Plain object: { isPipelineInput: true, pipelineStage: 0 }
3. Just source: Pass VariableSource where metadata should be
4. Complex internal: { isPipelineParameter: true, pipelineOriginal: x, customToString: fn }

NEW FORMAT (what you're migrating TO):
All become: { internal: { ...all the flags } }
OR: { ctx: { ...user-facing }, internal: { ...implementation } }

SEMANTIC CLASSIFICATION:
.internal (implementation flags):
- isSystem, isReserved, isParameter, isPipelineParameter, isPipelineInput
- arrayType, isBatchInput, pipelineStage, isPipelineContext
- pipelineOriginal, pipelineFormat, pipelineType, pipelineInput
- customToString, customToJSON
- isFullyEvaluated, transformedBy

.ctx (user-facing metadata):
- definedAt, source, importPath
- labels, taint, sources (security)
- filename, url, tokens (content)

MIGRATION RULES:
1. Simple flags (isSystem, isParameter, etc.) → { internal: { flag: value } }
2. Source only (no metadata) → { ctx: { source: sourceObj } } (if source has metadata)
3. Complex objects → split into ctx + internal based on field semantics
4. Existing 'internal' variable → { internal: internalObj }

EXAMPLES:
// OLD: { isSystem: true, isParameter: true }
// NEW: { internal: { isSystem: true, isParameter: true } }

// OLD: { isPipelineInput: true, pipelineStage: 0 }
// NEW: { internal: { isPipelineInput: true, pipelineStage: 0 } }

// OLD: source (when passed as 4th param where metadata should be)
// NEW: No change OR { ctx: sourceObj } if source has definedAt/etc

// OLD: internal (variable named 'internal' with object)
// NEW: { internal: internalObj }

// OLD: { definedAt: location }
// NEW: { ctx: { definedAt: location } }
</migration_patterns>

<file_content>
<@base/@fileAnalysis.filepath>
</file_content>

<strict_requirements>
1. Use Edit tool ONLY
2. Migrate ONLY the factory calls identified in calls_to_migrate
3. Match exact line numbers from the audit
4. Apply correct pattern based on old format
5. Preserve all other code unchanged
6. Make one Edit call per factory call migration
7. Double-check you're wrapping in 'internal' not 'metadata'
</strict_requirements>

<verification>
After each edit:
- Verify the factory call now uses { internal: {...} } or { ctx: {...}, internal: {...} }
- Verify no new 'metadata:' keys introduced
- Verify flags go to correct namespace (implementation → internal, user-facing → ctx)
- Do not build or attempt to run tests -- other Claudes are working on this in parallel
</verification>
`

>> Execute migrations with Sonnet (these are code changes, need accuracy)
/exe @sonnet(request) = run @request | { claude -p --model claude-sonnet-4-5 --allowedTools Edit }

/show "Migrating @filesToMigrate.length files with Sonnet..."

>> Process files 
/var @result = for @file in @filesToMigrate => @sonnet(@buildMigrationRequest(@file)) | log
/output @result to "result.txt"

/show ""
/show "✅ Migration complete!"
/show ""
/show "Verification:"
/show "1. Review changes: git diff"
/show "2. Check specific files:"
/show "   - git diff interpreter/eval/pipeline/command-execution.ts (biggest: 14 calls)"
/show "   - git diff interpreter/eval/for.ts"
/show "   - git diff interpreter/eval/exe.ts"
/show "3. Run tests: npm test"
/show "4. Expected: All tests still passing, old format calls converted"
