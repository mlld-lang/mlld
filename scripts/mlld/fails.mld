>> Run tests
/var @testOutput = run {NODE_ENV=test MLLD_NO_STREAMING=true CI=true npx vitest --reporter=json --outputFile=./test-output.json --no-coverage --silent}

>> Load the JSON output (the file loader should auto-parse JSON files)
/var @results = <test-output.json>

>> Debug: Show structure of what we loaded
/show `=== DEBUG: Results structure ===`
/show @results | @json

>> Helper functions for string manipulation (workaround for chaining limitation)
/exe @beforeText(str, marker) = @str.split(@marker)[0]
/exe @stripTrailing(text) = @text.trim()

>> Combined helper: split at marker and trim result
/exe @stripStackTrace(message) = when [
  @message.includes("at /Users/adam/dev/mlld/interpreter/interpreter.fixture.test.ts") => @stripTrailing(@beforeText(@message, "at /Users/adam/dev/mlld/interpreter/interpreter.fixture.test.ts"))
  * => @message
]

>> Helper to process a single failure message array (using /for workaround since foreach doesn't work in /exe yet)
>> Check if messages is an array first
/exe @processMessages(messages) = when [
  @messages && @messages.length() > 0 => for @msg in @messages => @stripStackTrace(@msg)
  * => []
]

>> Filter to only keep failed assertions
/exe @filterFailed(assertion) = when [
  @assertion.status == "failed" => { fullName: @assertion.fullName, messages: @processMessages(@assertion.failureMessages) }
  * => null
]

>> Helper to extract assertions from a test result
/exe @extractAssertions(testResult) = when [
  @testResult.assertionResults && @testResult.assertionResults.length() > 0 => @testResult.assertionResults
  * => []
]

>> Helper to safely get test results
/exe @getTestResults(results) = when [
  @results.testResults => @results.testResults
  * => []
]

>> Process all test results - collect all assertions
/var @testResults = @getTestResults(@results)

>> Flatten all assertions from all test results
>> The issue is that nested for with empty arrays returns {} instead of []
>> Also, we need to call the function correctly
/var @allAssertionsRaw = for @testResult in @testResults => for @assertion in @extractAssertions(@testResult) => @assertion

>> Convert {} to [] if needed
>> Check if it's an array by checking for length method
/exe @ensureArray(value) = when [
  @value.length => @value  >> It has length, so it's an array
  * => []                  >> It's {} or null, return empty array
]

/var @allAssertions = @ensureArray(@allAssertionsRaw)

>> Debug: Check allAssertions
/show `=== DEBUG: allAssertions ===`
/show @allAssertions | @json
/show `=== DEBUG: allAssertions type check ===`

>> Now filter to only get failures and remove nulls
>> TEMPORARILY COMMENT OUT TO FIND ERROR
>> /var @failuresWithNulls = foreach @filterFailed(@allAssertions)
/var @failuresWithNulls = []

>> Helper to keep only non-null items (workaround since when doesn't work directly in /for)
>> Returns the item if non-null, nothing otherwise (which gets filtered out)
/exe @keepNonNull(item) = when [
  @item != null => @item
]

>> Helper to filter out nulls from the failures list
/exe @filterNulls(failures) = when [
  @failures.length() > 0 => for @item in @failures => @keepNonNull(@item)
  * => []
]

>> Final filtered list without nulls
/var @fails = @filterNulls(@failuresWithNulls)

>> Display the filtered failures
/show @fails | @json

