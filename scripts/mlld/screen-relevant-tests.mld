---
description: Screen tests for relevance to StructuredValue/DATA.md analysis
author: mlld-team
version: 1.0.0
---

>> This script quickly screens all tests to identify which ones are relevant to StructuredValue behavior and DATA.md contract. Uses Haiku for fast, cheap yes/no decisions.

>> Set to positive number to limit screening to subset (0 = all tests)
/var @limit = 0

## Find Test Directories

/var @testFiles = <@base/tests/cases/**/example.md>
/show "Found @testFiles.length test files"

>> Extract directory paths from file metadata
/exe @getDirs(files) = node {
  const path = require('path');
  const dirs = files.map(f => {
    // Use absolute path, then extract just the tests/cases/... part
    const abs = f.absolute;
    const match = abs.match(/(tests\/cases\/.+)\/example\.md$/);
    return match ? match[1] : abs.replace('/example.md', '');
  });
  return [...new Set(dirs)].sort();
}

/var @allTestDirs = @getDirs(@testFiles)
/show "Screening @allTestDirs.length test directories"

>> Apply limit if set
/exe @applyLimit(dirs, limit) = js {
  const lim = Number(limit) || 0;
  return lim > 0 ? dirs.slice(0, lim) : dirs;
}

/var @testDirs = @applyLimit(@allTestDirs, @limit)

## Screening Prompt

/exe @buildScreenPrompt(dir, testInput) = `
Screen this test for relevance to StructuredValue/DATA.md analysis.

<test_directory>
@dir
</test_directory>

<test_code>
@testInput
</test_code>

<relevance_criteria>
A test is RELEVANT if it involves ANY of:
- Arrays, objects, or JSON data (e.g., [1,2,3], {"key":"value"})
- Pipelines with data transformations using pipe operator
- File loading with structured formats (JSON, YAML, CSV files)
- foreach iteration or /for loops over collections
- .ctx property access or metadata handling
- Display/output of structured data
- Variable assignments from structured data sources

A test is NOT RELEVANT if it only involves:
- Pure text/string operations
- Basic shell commands without data processing
- Simple control flow without structured data
- Import/module mechanics (unless loading structured data)
- Syntax/grammar edge cases
- Error handling without data structures
</relevance_criteria>

<task>
You MUST return ONLY valid JSON with no other text. Do not include markdown fences, explanations, or commentary.

Required JSON structure:
{
  "testPath": "@dir",
  "relevant": true,
  "reason": "Brief explanation"
}

Example valid responses:
{"testPath": "tests/cases/feat/arrays", "relevant": true, "reason": "Tests array operations"}
{"testPath": "tests/cases/slash/show", "relevant": false, "reason": "Simple text display"}

Return JSON now:
</task>
`

## Claude Wrapper (Haiku for speed/cost)

/exe @claude(prompt) = {claude -p "@prompt" --model claude-haiku-4-5 --allowedTools Read}

## Load Test Files

/exe @loadTest(dir) = node {
  const fs = require('fs');
  const path = require('path');
  const examplePath = path.join(dir, 'example.md');

  return {
    dir: dir,
    example: fs.existsSync(examplePath) ? fs.readFileSync(examplePath, 'utf8') : '[File not found]'
  };
}

>> Run Screening in Parallel

/var @testData = foreach @loadTest(@testDirs)

/var @responses = for 12 parallel @test in @testData => @claude(@buildScreenPrompt(@test.dir, @test.example)) | log

/show "Got @responses.length responses"
/output @responses to "raw-responses.json"

## Process Responses

/exe @parseResponses(responses) = node {
  return responses.map((response, idx) => {
    let text = String(response).trim();

    // Try 1: Parse as-is
    try {
      return JSON.parse(text);
    } catch (e1) {
      // Try 2: Strip markdown fences
      const fenceMarker = '```';
      if (text.includes(fenceMarker)) {
        const fenceStart = text.indexOf(fenceMarker);
        const fenceEnd = text.lastIndexOf(fenceMarker);
        if (fenceStart !== -1 && fenceEnd > fenceStart) {
          const jsonBlock = text.substring(fenceStart + 3, fenceEnd);
          const jsonText = jsonBlock.replace(/^json\n?/, '').trim();
          try {
            return JSON.parse(jsonText);
          } catch (e2) {}
        }
      }

      // Try 3: Find first { or [ and parse from there (Haiku added explanatory text)
      const jsonStart = text.search(/[{\[]/);
      if (jsonStart !== -1) {
        const jsonText = text.substring(jsonStart);
        try {
          return JSON.parse(jsonText);
        } catch (e3) {}
      }

      // Failed all attempts - return fallback
      console.error(`Warning: Failed to parse response ${idx}, treating as irrelevant`);
      return {
        testPath: `parse-error-${idx}`,
        relevant: false,
        reason: `Parse error: ${text.substring(0, 50)}...`,
        _parseError: true
      };
    }
  });
}

/var @screeningResults = @parseResponses(@responses)

## Filter to Relevant Tests Only

/exe @filterRelevant(results) = js {
  return results
    .filter(r => r.relevant === true)
    .map(r => r.testPath)
    .sort();
}

/var @relevantTests = @filterRelevant(@screeningResults)

## Generate Summary

/exe @generateSummary(allResults, relevantDirs) = js {
  const total = allResults.length;
  const relevant = relevantDirs.length;
  const irrelevant = total - relevant;
  const relevantPct = Math.round((relevant / total) * 100);

  return {
    totalScreened: total,
    relevant: relevant,
    irrelevant: irrelevant,
    relevantPercentage: relevantPct,
    relevantTests: relevantDirs,
    timestamp: new Date().toISOString()
  };
}

/var @summary = @generateSummary(@screeningResults, @relevantTests)

## Save Results

/output @summary to "relevant-tests.json"
/output @screeningResults to "screening-details.json"

## Display Summary

/show `
# Test Screening Complete

- **Total Screened**: @summary.totalScreened tests
- **Relevant**: @summary.relevant tests (@summary.relevantPercentage%)
- **Irrelevant**: @summary.irrelevant tests

## Output Files

- relevant-tests.json - List of relevant test directories
- screening-details.json - Full screening results with reasons

## Next Step

Run the audit script to analyze the @summary.relevant relevant tests:

  mlld run audit-test-expectations
`
