#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const errorsDir = path.join(__dirname, '../errors/js');
const outputPath = path.join(__dirname, '../core/errors/patterns/js-errors.generated.js');

/**
 * Find all pattern directories containing pattern.js and error.md
 */
function findPatterns(dir, patterns = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    if (entry.isDirectory()) {
      const patternPath = path.join(dir, entry.name, 'pattern.js');
      const errorPath = path.join(dir, entry.name, 'error.md');
      
      if (fs.existsSync(patternPath) && fs.existsSync(errorPath)) {
        patterns.push({
          name: entry.name,
          patternPath,
          errorPath,
          // Read the files
          patternCode: fs.readFileSync(patternPath, 'utf-8'),
          errorTemplate: fs.readFileSync(errorPath, 'utf-8').trim()
        });
      }
    }
  }
  
  return patterns;
}

/**
 * Extract the pattern object from pattern.js code
 * Since we can't dynamically import, we'll parse the export
 */
function extractPatternCode(code, patternName) {
  // Extract the pattern object - looking for export const pattern = { ... }
  const match = code.match(/export\s+const\s+pattern\s*=\s*\{([\s\S]*)\};?$/m);
  if (!match) {
    throw new Error('Could not find pattern export');
  }
  
  // Extract just the functions, not the name property
  const patternBody = match[1];
  
  // Remove the name property line if it exists
  const cleanedBody = patternBody
    .split('\n')
    .filter(line => !line.trim().match(/^name:\s*['"].*['"]/))
    .map(line => '    ' + line) // Re-indent
    .join('\n');
  
  return `  {\n    ${cleanedBody.trim()}\n  }`;
}

/**
 * Generate the JavaScript file with all patterns
 */
function generatePatternFile(patterns) {
  const patternCount = patterns.length;
  const date = new Date().toISOString().split('T')[0];
  
  // Sort patterns by name for consistent output
  patterns.sort((a, b) => a.name.localeCompare(b.name));
  
  // Generate pattern objects
  const patternObjects = patterns.map(p => {
    try {
      const patternCode = extractPatternCode(p.patternCode, p.name);
      
      // Escape the template for embedding in JS
      const escapedTemplate = p.errorTemplate
        .replace(/\\/g, '\\\\')
        .replace(/`/g, '\\`')
        .replace(/\$/g, '\\$');
      
      return `  {
    name: '${p.name}',
    template: \`${escapedTemplate}\`,
${patternCode.slice(3)}`;
    } catch (e) {
      console.error(`Error processing pattern ${p.name}:`, e.message);
      throw e;
    }
  }).join(',\n\n');
  
  const content = `/**
 * Generated JavaScript Error Patterns v1
 * 
 * Pattern count: ${patternCount}
 * Last updated: ${date}
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * Edit the source patterns in errors/js/
 */

// Pattern definitions
const patterns = [
${patternObjects}
];

/**
 * Interpolate variables into template
 */
function interpolateTemplate(template, variables) {
  return template.replace(/\\$\\{(\\w+)\\}/g, (match, varName) => {
    return variables[varName] !== undefined ? variables[varName] : match;
  });
}

/**
 * Enhance JavaScript execution error with pattern matching
 */
export function enhanceJSError(error, code, params, metadata) {
  const ctx = {
    code: code || '',
    error: error,
    params: params || {},
    metadata: metadata || {}
  };
  
  // Try each pattern
  for (const pattern of patterns) {
    try {
      if (pattern.test(error, ctx)) {
        const variables = pattern.enhance(error, ctx);
        const message = interpolateTemplate(pattern.template, variables);
        
        // Return enhanced error details
        return {
          type: 'js-execution',
          pattern: pattern.name,
          message,
          originalError: error.message,
          code: code
        };
      }
    } catch (e) {
      // Pattern failed, try next one
      continue;
    }
  }
  
  // No pattern matched
  return null;
}
`;
  
  return content;
}

// Main execution
console.log('Building JavaScript error patterns...');

try {
  const patterns = findPatterns(errorsDir);
  console.log(`Found ${patterns.length} patterns: ${patterns.map(p => p.name).join(', ')}`);
  
  const content = generatePatternFile(patterns);
  
  // Ensure output directory exists
  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  fs.writeFileSync(outputPath, content);
  console.log(`✓ Generated ${outputPath} with ${patterns.length} patterns`);
} catch (error) {
  console.error('✗ Failed to build patterns:', error.message);
  process.exit(1);
}