# mlld

A language for LLMs to speak with machines.

mlld (pronounced "meld") is **not a template language**. It's a scripting language embedded in Markdown documents that enhances them with dynamic content generation while preserving readability.

## Core Syntax Rules

### 1. Directives only at start of lines
mlld syntax is only interpreted in lines that start with a mlld directive:
- âœ… `/text @greeting = "Hello"`
- âŒ `Some text /text @greeting = "Hello"` (directive not at line start)

### 2. Slash for directives, @ for variables
- **Directives use `/`**: `/run`, `/var`, `/show`, `/exe`, etc.
- **Variables use `@`**: Create with `@name`, reference with `@name`
- âŒ `/run/` (trailing slash is invalid)

### 3. Variable creation requires @ prefix
- âœ… `/text @name = "value"` (creates variable `name`)
- âŒ `/text name = "value"` (missing @ on left side)

### 4. Commands use braces or quotes
- âœ… `/run {echo "hello"}` (braces for multi-line)
- âœ… `/run "echo hello @name"` (quotes for single-line)
- âŒ `/run echo "hello"` (missing braces/quotes)

### 5. Only /run, /add, and /output produce output
Other directives define or assign but don't output.
- `/run` - executes commands and shows their output
- `/add` - adds content to the document
- `/output` - controls where output goes (stdout, stderr, file)

### 6. Comments use >>
- Start-of-line: `>> This is a comment`
- End-of-line: `/text @name = "Alice" >> This is also a comment`
- Inside templates/strings: `[[Hello >> World]]` - >> is treated as literal text, not a comment

## Basic Examples

```mlld
# Simple variable assignment
/text @author = "Alice"
/text @greeting = "Hello, world!"

>> Comments go at start or end of lines only
# Output content
/add @greeting
/add "Welcome to mlld!"  >> Inline comments too!

# Run commands (quoted syntax for single lines)
/run "echo System info:"
/run "date"

# Or use braces for multi-line commands
/run {
  echo "Multiple commands"
  ls -la
}

# Data structures
/data @config = {
  "name": "my-app",
  "version": "1.0.0",
  "debug": true
}

# Access nested data
/add "App: {{config.name}} v{{config.version}}"
```

## Templates and Interpolation

### Backtick templates (primary - with @ interpolation)
```mlld
/text @message = `Hello @name, welcome to @place!`
/text @link = `[@title](@url)`
```

### Double-bracket templates (fallback - for @ heavy content)
```mlld
/text @tweet = [[Hey {{user}}, check out {{handle}}'s new post!]]
```

### @ interpolation in double quotes
```mlld
/text @greeting = "Hello @name!"    >> @ variables work in double quotes
/run "echo User: @username"         >> Works in quoted commands
/run {echo "Welcome @user.name"}    >> And in brace commands
```

## Exec - Defining Reusable Commands

```mlld
# Command executable
/exec @deploy(env) = "deploy.sh @env"      >> Single line with quotes
/exec @build(type) = {                      >> Multi-line with braces
  npm run build:@type
  npm test
}

# Code executable
/exec @calculate(x) = js {return @x * 2}

# Template executable
/exec @greet(name) = `Hello @name!`

# Section executable
/exec @getIntro(file) = [@file # Introduction]

# Environment declaration (shadow functions)
/exec @js = { formatDate, parseJSON }
```

## Conditional Logic (/when)

```mlld
# Simple condition
/when @isProduction => /deploy() trust always

# Multiple conditions
/when @env first: [
  "prod" => /add "âš ï¸ Production Environment"
  "dev" => /add "ðŸ”§ Development Environment"
  _ => /add "Unknown environment"
]
```

## Import System

```mlld
# File imports
/import { greeting, config } from "shared.mld"
/import { * } from "utils.mld"

# Module imports (no quotes)
/import { fetchData, parseJSON } from @corp/utils

# Environment variables (must be in mlld.lock.json)
/import { API_KEY, NODE_ENV } from @INPUT
```

## Paths

```mlld
# Simple paths (quoted strings)
/path @docs = "./documentation"
/path @output = "results/output.txt"

# Paths with interpolation (double quotes)
/path @userFile = "data/@username/profile.json"

# Literal paths (single quotes - no interpolation)
/path @template = 'templates/@var-template.html'  // @var is literal text

# Bare resolvers (no quotes)
/import { utils } from @corp/shared-lib

# URLs with caching
/path @api = https://api.example.com/data (5m)
```

## Output Directive

```mlld
# Output to files
/output @content to "output.txt"
/output @data to "config.json"
/output @html to "page.html" as html

# Output to stdout/stderr
/output @message to stdout
/output @error to stderr

# With format specification
/output @config to "settings.yaml" as yaml
```

## Common Patterns

### Running scripts with parameters
```mlld
/exec @test(suite) = {npm test -- @suite}
/run @test("integration")
```

### Template with many @ symbols
```mlld
# Use [[...]] when you have many @ symbols to escape
/text @twitterTemplate = [[
  Hey @{{handle}}, love your work!
  @{{otherHandle}} you should check this out.
  Reply to this tweet @{{originalAuthor}}
]]
```

### Field access
```mlld
/data @user = { "name": "Alice", "scores": [95, 87, 92] }
/add "Name: @user.name"
/add "First score: @user.scores.0"
```

## Common Mistakes

### âŒ Forgetting braces or quotes in commands
```mlld
/run echo "hello"     # WRONG - needs braces or quotes
/run {echo "hello"}   # CORRECT - braces
/run "echo hello"     # CORRECT - quotes for single line
```

### âŒ Missing @ when creating variables
```mlld
/text greeting = "Hello"  # WRONG - missing @
/text @greeting = "Hello"  # CORRECT
```

### âŒ Using @ for directives
```mlld
@text @greeting = "Hello"  # WRONG - directives use /
/text @greeting = "Hello"  # CORRECT
```

### âŒ Trying to interpolate everywhere
```mlld
Hello @name!  # WRONG - plain text, not interpreted
/add "Hello @name!"  # CORRECT - in directive
/text @msg = `Hello @name!`  # CORRECT - in template
```

## Module-First Philosophy

For complex operations, create modules instead of inline scripts:

### âŒ Overly complex inline mlld
```mlld
/data @results = foreach @processData(@items) | @validate @transform
/when @results.length > 0: [
  true => /data @filtered = foreach @filter(@results)
]
```

### âœ… Better: Use a module
```mlld
/import { processItems } from @myteam/data-utils
/data @results = @processItems(@items)
```

## Key Concepts

1. **mlld is NOT a template language** - It's a scripting language that only processes lines starting with directives
2. **Everything is explicit** - No magic, no hidden behavior
3. **Markdown-first** - The document should be readable without executing mlld
4. **Module-first for complexity** - Use modules for complex logic
5. **Clear visual distinction** - `/` for commands (directives), `@` for data (variables)
6. **Comments use >>** - Double angle brackets, visually distinct from directives