# Mlld Examples

This file contains all test case examples organized by category.
Generated by `tests/utils/ast-fixtures.js`

## Table of Contents

- [Exceptions](#exceptions)
  - [Import non module](#exceptions-import-non-module)
  - [Path module content](#exceptions-path-module-content)
  - [Var text parameterized run command](#exceptions-var-text-parameterized-run-command)
  - [When any with individual actions](#exceptions-when-any-with-individual-actions)
- [Valid](#valid)
  - [Alligator glob concat](#valid-alligator-glob-concat)
  - [Alligator glob rename](#valid-alligator-glob-rename)
  - [Bracket notation comprehensive](#valid-bracket-notation-comprehensive)
  - [Command substitution interactive](#valid-command-substitution-interactive)
  - [Command substitution sh](#valid-command-substitution-sh)
  - [Command substitution tty](#valid-command-substitution-tty)
  - [Examples](#valid-examples)
  - [Exe invocation module](#valid-exe-invocation-module)
  - [Exe param shadowing](#valid-exe-param-shadowing)
  - [Exe parameterized command](#valid-exe-parameterized-command)
  - [Exe sh module](#valid-exe-sh-module)
  - [Exe shadow env capture](#valid-exe-shadow-env-capture)
  - [Exe shadow env import](#valid-exe-shadow-env-import)
  - [Expressions operators](#valid-expressions-operators)
  - [Expressions operators parsing](#valid-expressions-operators-parsing)
  - [File reference glob](#valid-file-reference-glob)
  - [File reference interpolation](#valid-file-reference-interpolation)
  - [Import env test](#valid-import-env-test)
  - [Literals in function args](#valid-literals-in-function-args)
  - [Load content js edge cases](#valid-load-content-js-edge-cases)
  - [Load content js unwrap](#valid-load-content-js-unwrap)
  - [Load content node unwrap](#valid-load-content-node-unwrap)
  - [Now basic compat](#valid-now-basic-compat)
  - [Now enhanced formats](#valid-now-enhanced-formats)
  - [Now lowercase basic](#valid-now-lowercase-basic)
  - [Object property access in exec args](#valid-object-property-access-in-exec-args)
  - [Object property access in functions](#valid-object-property-access-in-functions)
  - [Optional slash comprehensive](#valid-optional-slash-comprehensive)
  - [Resolver contexts](#valid-resolver-contexts)
  - [Template syntax migration](#valid-template-syntax-migration)
  - [When literal condition](#valid-when-literal-condition)
- [Warnings](#warnings)
  - [Bare variable reference](#warnings-bare-variable-reference)
  - [Directive in text line](#warnings-directive-in-text-line)
  - [Template syntax in text](#warnings-template-syntax-in-text)

## Exceptions

### Exceptions Import non module

**Input:**
```mlld
# Test Import Non-Module Rejection

/import { content } from "./data.txt"
/show @content
```

### Exceptions Path module content

**Input:**
```mlld
# Test Path Module Rejection

/path @mod = "./module.mld"
/show @mod
```

### Exceptions Var text parameterized run command

**Input:**
```mlld
# Parameterized Text with Run Command (Invalid)

This example shows an invalid syntax where someone tries to create a parameterized text variable with a `@run` command.

/exe @codecat(dir) = run {find @dir -type f -exec sh -c 'echo "<$(realpath --relative-to=@dir {})>"; cat {}; echo "@dir {})>"' \;}

This should fail because:
1. Parameterized text templates should use `@exec` not `@text`
2. The complex shell escaping may not be properly handled
3. There's malformed syntax at the end
```

### Exceptions When any with individual actions

**Input:**
```mlld
/var @condition1 = "true"
/var @condition2 = "false"

# Invalid: any: modifier cannot have individual actions
/when @condition1 any: [
  @condition1 => show "Action 1"
  @condition2 => show "Action 2"
]
```

## Valid

### Valid Alligator glob concat

**Input:**
```mlld
# Alligator Glob Concatenation Test

This test verifies that glob patterns concatenate content by default, consistent with single file behavior.

## Single File Behavior

/var @single = <single-file.md>
/show @single
/show `Content: <single-file.md>`

## Glob Pattern Behavior

/var @files = <*.md>
/show @files
/show `All files: <*.md>`

## Field Access on Glob

/var @allFiles = <*.md>
/show @allFiles.content
/show @allFiles[0].fm.title
/show @allFiles[0].content

## Template Interpolation

/var @template = `Combined: @files`
/show @template

## Direct Interpolation

/show `Direct: @files`
```

**Expected Output:**
```markdown
# Alligator Glob Concatenation Test

This test verifies that glob patterns concatenate content by default, consistent with single file behavior.

## Single File Behavior

# Single File

This is the content of the single file.

Content: # Single File

This is the content of the single file.
## Glob Pattern Behavior

# File 1

Content of first file.

# File 2

Content of second file.

All files: # File 1

Content of first file.

# File 2

Content of second file.
## Field Access on Glob

# File 1

Content of first file.

# File 2

Content of second file.
File One
# File 1

Content of first file.
## Template Interpolation

Combined: # File 1

Content of first file.

# File 2

Content of second file.
## Direct Interpolation

Direct: # File 1

Content of first file.

# File 2

Content of second file.
```

### Valid Alligator glob rename

**Input:**
```mlld
# Alligator Glob with Section Rename

This test demonstrates the alligator glob pattern with section extraction and rename using the `as` syntax.

## Setup Test Files

/var @modules = [
  {"name": "ai", "desc": "AI integration for mlld scripts"},
  {"name": "array", "desc": "Array utilities and operations"},
  {"name": "time", "desc": "Time and date utilities"}
]

## Single File Section Rename

First, let's test renaming a section from a single file:

/var @single = <single-module.mld.md # tldr> as "### Module: <>.fm.name"
/show @single

## Glob Pattern with Section Rename

Now let's use a glob pattern to extract and rename sections from multiple files:

/var @allModules = <*.mld.md # tldr> as "### [<>.fm.name](<>.relative)"
/show @allModules

## With Backtick Templates

The rename syntax also supports backtick templates:

/var @backtickRename = <single-module.mld.md # tldr> as `## <>.fm.name v<>.fm.version`
/show @backtickRename

## Complex Field Access

You can access nested fields in frontmatter:

/var @withAuthor = <with-author.mld.md # summary> as "## <>.fm.name by <>.fm.author"
/show @withAuthor
```

**Expected Output:**
```markdown
# Alligator Glob with Section Rename

This test demonstrates the alligator glob pattern with section extraction and rename using the `as` syntax.

## Setup Test Files

## Single File Section Rename

First, let's test renaming a section from a single file:

### Module: test
This is a test module for demonstrating alligator syntax.

## Glob Pattern with Section Rename

Now let's use a glob pattern to extract and rename sections from multiple files:

### [ai](./ai.mld.md)
AI integration for mlld scripts.

### [array](./array.mld.md)
Array utilities and operations.

### [time](./time.mld.md)
Time and date utilities.

## With Backtick Templates

The rename syntax also supports backtick templates:

## test v1.0.0
This is a test module for demonstrating alligator syntax.

## Complex Field Access

You can access nested fields in frontmatter:

## test by Alice
This module demonstrates field access in rename templates.
```

### Valid Bracket notation comprehensive

**Input:**
```mlld
# Bracket Notation Comprehensive Test

<!-- TODO: Issue #306 - Bracket notation field access lost in grammar parsing pipeline -->
<!-- This test is currently skipped because bracket notation doesn't work in most contexts -->
<!-- Remove this comment and unskip when Issue #306 is fixed -->

Test bracket notation across all major contexts to ensure universal support.

## Test Data Setup

/var @data = {
  "simple-key": "simple-value",
  "nested": {"inner-key": "inner-value"},
  "special-chars": {"key with spaces": "spaced-value", "key-with-dashes": "dashed-value"},
  "numbers": {"123": "numeric-key-value"}
}

/var @dynamicKey = "simple-key"
/var @nestedKey = "inner-key"

## 1. Variable Assignment Context (/var)

<!-- TODO: Issue #306 - These should assign the field values, not literal bracket text -->

### Static String Keys
/var @result1 = @data["simple-key"]
/var @result2 = @data["nested"]["inner-key"] 
/var @result3 = @data["special-chars"]["key with spaces"]
/var @result4 = @data["numbers"]["123"]

### Dynamic Variable Keys  
/var @result5 = @data[@dynamicKey]
/var @result6 = @data["nested"][@nestedKey]

## 2. Show Directive Context (/show)

<!-- TODO: Issue #306 - These should show the field values, not the whole object + bracket text -->

### Static String Keys
/show @data["simple-key"]
/show @data["nested"]["inner-key"]
/show @data["special-chars"]["key with spaces"] 
/show @data["numbers"]["123"]

### Dynamic Variable Keys
/show @data[@dynamicKey]
/show @data["nested"][@nestedKey]

## 3. Backtick Template Context

<!-- TODO: Issue #306 - These should interpolate the field values, not show object + bracket text -->

### Static String Keys
/show `Simple: @data["simple-key"]`
/show `Nested: @data["nested"]["inner-key"]`
/show `Spaced: @data["special-chars"]["key with spaces"]`
/show `Numeric: @data["numbers"]["123"]`

### Dynamic Variable Keys  
/show `Dynamic: @data[@dynamicKey]`
/show `Nested Dynamic: @data["nested"][@nestedKey]`

## 4. Executable Arguments Context

<!-- TODO: Issue #306 - These should pass the field values as arguments, not undefined -->

/exe @testFunc(@value) = js {return `Received: ${value}`}

### Static String Keys
/show @testFunc(@data["simple-key"])
/show @testFunc(@data["nested"]["inner-key"])
/show @testFunc(@data["special-chars"]["key with spaces"])
/show @testFunc(@data["numbers"]["123"])

### Dynamic Variable Keys
/show @testFunc(@data[@dynamicKey])
/show @testFunc(@data["nested"][@nestedKey])

## 5. Mixed Notation (Dot + Bracket)

<!-- TODO: Issue #306 - These should work consistently, but bracket parts fail -->

/show @data.nested["inner-key"]
/show @data["nested"].inner-key

## 6. Results Verification

<!-- TODO: Issue #306 - All of the above should output the expected values when fixed -->

All of the above should output the expected values:
- simple-value (multiple times)
- inner-value (multiple times)  
- spaced-value
- dashed-value
- numeric-key-value
```

**Expected Output:**
```markdown
# Bracket Notation Comprehensive Test

Test bracket notation across all major contexts to ensure universal support.

## Test Data Setup

## 1. Variable Assignment Context (/var)

### Static String Keys

### Dynamic Variable Keys  

## 2. Show Directive Context (/show)

### Static String Keys
simple-value
inner-value
spaced-value
numeric-key-value

### Dynamic Variable Keys
simple-value
inner-value

## 3. Backtick Template Context

### Static String Keys
Simple: simple-value
Nested: inner-value
Spaced: spaced-value
Numeric: numeric-key-value

### Dynamic Variable Keys  
Dynamic: simple-value
Nested Dynamic: inner-value

## 4. Executable Arguments Context

### Static String Keys
Received: simple-value
Received: inner-value
Received: spaced-value
Received: numeric-key-value

### Dynamic Variable Keys
Received: simple-value
Received: inner-value

## 5. Mixed Notation (Dot + Bracket)

inner-value
inner-value

## 6. Results Verification

All of the above should output the expected values:
- simple-value (multiple times)
- inner-value (multiple times)  
- spaced-value
- dashed-value
- numeric-key-value
```

### Valid Command substitution interactive

**Input:**
```mlld
# Command Substitution with Interactive-like Commands

This test simulates the behavior we see with interactive CLI tools in command substitution.

## Test Direct Execution

/exe @test_direct() = sh {
  # Direct execution - simulate inline
  if [ -t 0 ] || [ -t 1 ]; then
    echo "Direct execution"
  else
    echo "Direct execution" >&2
  fi
}
/var @direct = @test_direct()
/show `Direct: [@direct]`

## Test Command Substitution

/exe @test_substitution() = sh {
  # This might capture differently
  result=$(
    if [ -t 0 ] || [ -t 1 ]; then
      echo "Via substitution"
    else
      echo "Via substitution" >&2
    fi
  )
  echo "Captured: $result"
}
/var @subst = @test_substitution()
/show `Substitution: [@subst]`

## Test with Stderr Capture

/exe @test_with_stderr() = sh {
  # Explicitly capture both stdout and stderr
  result=$(
    if [ -t 0 ] || [ -t 1 ]; then
      echo "With stderr"
    else
      echo "With stderr" >&2
    fi
    2>&1
  )
  echo "Both streams: $result"
}
/var @both = @test_with_stderr()
/show `With stderr: [@both]`

## Python Script Simulation

/exe @python_sim() = sh {
  # Simulate a Python script that might buffer differently
  python3 -c "import sys; sys.stdout.write('Python output'); sys.stdout.flush()" 2>/dev/null || echo "Python not available"
}
/var @py_direct = @python_sim()
/show `Python direct: [@py_direct]`

/exe @python_subst() = sh {
  result=$(python3 -c "import sys; sys.stdout.write('Python output'); sys.stdout.flush()" 2>/dev/null || echo "Python not available")
  echo "$result"
}
/var @py_subst = @python_subst()
/show `Python subst: [@py_subst]`
```

**Expected Output:**
```markdown
# Command Substitution with Interactive-like Commands

This test simulates the behavior we see with interactive CLI tools in command substitution.

## Test Direct Execution

Direct: [Direct execution]
## Test Command Substitution

Substitution: [Captured: Via substitution]
## Test with Stderr Capture

With stderr: [Both streams: With stderr]
## Python Script Simulation

Python direct: [Python output]

Python subst: [Python not available]
```

### Valid Command substitution sh

**Input:**
```mlld
# Command Substitution in sh Blocks

This test verifies that command substitution works correctly in sh blocks across different scenarios.

## Basic Command Substitution

/exe @simple_subst() = sh {
  result=$(echo "basic substitution works")
  echo "Result: $result"
}
/var @test1 = @simple_subst()
/show @test1

## Command Substitution with Multiple Lines

/exe @multiline_subst() = sh {
  result=$(echo "line 1" && echo "line 2")
  echo "Combined: $result"
}
/var @test2 = @multiline_subst()
/show @test2

## Nested Command Substitution

/exe @nested_subst() = sh {
  inner=$(echo "inner")
  result=$(echo "outer contains: $inner")
  echo "$result"
}
/var @test3 = @nested_subst()
/show @test3

## Command Substitution with Exit Codes

/exe @exit_code_subst() = sh {
  result=$(echo "success" && exit 0)
  code=$?
  echo "Output: $result (exit code: $code)"
}
/var @test4 = @exit_code_subst()
/show @test4

## Command Substitution with stderr

/exe @stderr_subst() = sh {
  # This simulates a command that might write to stderr
  result=$(sh -c 'echo "stdout text" && echo "stderr text" >&2' 2>&1)
  echo "Captured: $result"
}
/var @test5 = @stderr_subst()
/show @test5

## Complex Pattern (similar to AI module)

/exe @complex_pattern() = sh {
  # Test if echo exists (it always does)
  if ! command -v echo >/dev/null 2>&1; then
    echo "Error: echo not found"
    exit 1
  fi
  
  # Capture output with error handling
  result=$(echo "complex pattern test" 2>&1)
  exit_code=$?
  
  if [ $exit_code -eq 0 ]; then
    echo "Success: $result"
  else
    echo "Failed: $result"
  fi
}
/var @test6 = @complex_pattern()
/show @test6

## Direct Output (for comparison)

/exe @direct_output() = sh {
  echo "direct output works"
}
/var @test7 = @direct_output()
/show @test7
```

**Expected Output:**
```markdown
# Command Substitution in sh Blocks

This test verifies that command substitution works correctly in sh blocks across different scenarios.

## Basic Command Substitution

Result: basic substitution works
## Command Substitution with Multiple Lines

Combined: line 1 line 2
## Nested Command Substitution

outer contains: inner
## Command Substitution with Exit Codes

Output: success (exit code: 0)
## Command Substitution with stderr

Captured: stdout text stderr text
## Complex Pattern (similar to AI module)

Success: complex pattern test
## Direct Output (for comparison)

direct output works
```

### Valid Command substitution tty

**Input:**
```mlld
# Command Substitution with TTY-aware Commands

This test explores how command substitution affects commands that behave differently based on TTY detection.

## Test TTY Detection

/exe @check_tty() = sh {
  # Direct execution (might have TTY)
  if [ -t 1 ]; then
    echo "Direct: stdout is a TTY"
  else
    echo "Direct: stdout is NOT a TTY"
  fi
}
/var @tty1 = @check_tty()
/show @tty1

/exe @check_tty_subst() = sh {
  # Inside command substitution (no TTY)
  result=$(
    if [ -t 1 ]; then
      echo "Subst: stdout is a TTY"
    else
      echo "Subst: stdout is NOT a TTY"
    fi
  )
  echo "$result"
}
/var @tty2 = @check_tty_subst()
/show @tty2

## Test with Script Command (TTY-aware)

/exe @script_direct() = sh {
  # Some commands behave differently without TTY
  # Using 'cat' as a simple example that works everywhere
  echo "test input" | cat
}
/var @script1 = @script_direct()
/show @script1

/exe @script_subst() = sh {
  # Same command in substitution
  result=$(echo "test input" | cat)
  echo "Captured: $result"
}
/var @script2 = @script_subst()
/show @script2

## Test Process Substitution vs Command Substitution

/exe @proc_subst_test() = sh {
  # Note: Process substitution <(...) might not be available in all shells
  # Just using regular piping instead
  echo "data" | { read line; echo "Read: $line"; }
}
/var @proc1 = @proc_subst_test()
/show @proc1

## Test Buffering Behavior

/exe @buffer_test() = sh {
  # Test if buffering affects output capture
  result=$(printf "unbuffered" && printf " output")
  echo "Result: $result"
}
/var @buffer1 = @buffer_test()
/show @buffer1
```

**Expected Output:**
```markdown
# Command Substitution with TTY-aware Commands

This test explores how command substitution affects commands that behave differently based on TTY detection.

## Test TTY Detection

Direct: stdout is NOT a TTY

Subst: stdout is NOT a TTY
## Test with Script Command (TTY-aware)

test input

Captured: test input
## Test Process Substitution vs Command Substitution

Read: data
## Test Buffering Behavior

Result: unbuffered output
```

### Valid Examples

**Input:**
```mlld
>> This is a comment and should be ignored
>> I can write a couple lines of them if I want and no one will ever know.

/import { * } from "files/imports.mld"

/var @role = {
    "architect": "You are a senior architect skilled in assessing TypeScript codebases.",
    "ux": "You are a senior ux designer skilled in assessing user experience.",
    "security": "You are a senior security engineer skilled in assessing TypeScript codebases."
}

/var @task = {
    "code_review": "Carefully review the code and test results and advise on the quality of the code and areas of improvement.",
    "ux_review": "Carefully review the user experience and advise on the quality of the user experience and areas of improvement.",
    "security_review": "Carefully review the security of the code and advise on the quality of the security and areas of improvement."
}

## Your role
/show @role.architect

## Documentation
### Architecture
/show @path "./docs/dev/ARCHITECTURE.md" # TESTING INFRASTRUCTURE
### Mlld error handling
/show @path "./docs/dev/ERRORS.md"

## Test Results
/run npm test core/syntax

## Your task
/show @task.code_review

>> this doesn't work but should
>> run @text codecat("./examples")
```

### Valid Exe invocation module

**Input:**
```mlld
# Test exec invocation from module imports

/import { sayHello, greetUser, multiLine, withParams, greeting } from "./test-module.mld"

## Direct invocation
/run @sayHello()

## With parameter
/run @greetUser("Alice")

## Multi-line command
/run @multiLine()

## Multiple parameters
/run @withParams("foo", "bar")

## In data directive
/var @result = @sayHello()
/show @result

## In text template
/var @message = :::Output: {{greeting}}:::
/show @message

## Verify regular variable import works
/show @greeting
```

**Expected Output:**
```markdown
# Test exec invocation from module imports

## Direct invocation
Hello, World!

## With parameter
Hello, Alice!

## Multi-line command
Line 1
Line 2

## Multiple parameters
First: foo, Second: bar

## In data directive

Hello, World!
## In text template

Output: Hello from module
## Verify regular variable import works
Hello from module
```

### Valid Exe param shadowing

**Input:**
```mlld
# Parameter Shadowing Test

This test ensures that function parameters can shadow variables in the parent scope.

/exe @compareFunc(@date1, @date2) = js {
  return date1 < date2 ? date1 : date2;
}

>> Define local variables that have the same names as function parameters
/var @date1 = "2024-01-01"
/var @date2 = "2024-12-31"

>> Call the function with different values - parameters should shadow the local variables
/var @result = @compareFunc("2023-06-15", "2023-08-20")
/show `Earliest date: @result`

>> Local variables should still have their original values
/show `Local date1: @date1`
/show `Local date2: @date2`
```

**Expected Output:**
```markdown
# Parameter Shadowing Test

This test ensures that function parameters can shadow variables in the parent scope.

Earliest date: 2023-06-15
Local date1: 2024-01-01
Local date2: 2024-12-31
```

### Valid Exe parameterized command

**Input:**
```mlld
# Parameterized Exec Command (Valid)

This example shows the correct way to create a parameterized command using `@exec`.

/exe @greet(name) = {echo "Hello @name!"
echo "Welcome @name!"
echo "Greetings @name!"}

/run @greet("Alice")
```

**Expected Output:**
```markdown
# Parameterized Exec Command (Valid)

This example shows the correct way to create a parameterized command using `@exec`.

Hello Alice!
Welcome Alice!
Greetings Alice!
```

### Valid Exe sh module

**Input:**
```mlld
# Test sh executables from module imports

This tests importing and using sh executables from a module.

/import { simple_sh, multiline_sh, parameterized_sh, error_handling_sh } from "./test-sh-module.mld"

## Simple sh execution
/var @result1 = @simple_sh()
/show `Simple: @result1`

## Multi-line sh execution
/var @result2 = @multiline_sh()
/show `Multi-line: @result2`

## Parameterized sh execution
/var @result3 = @parameterized_sh("Alice")
/show `Parameterized: @result3`

## Error handling sh execution
/var @result4 = @error_handling_sh("echo")
/show `Command exists: @result4`

/var @result5 = @error_handling_sh("nonexistent")
/show `Command missing: @result5`
```

**Expected Output:**
```markdown
# Test sh executables from module imports

This tests importing and using sh executables from a module.

## Simple sh execution

Simple: Simple sh output
## Multi-line sh execution

Multi-line: Multi-line sh output
## Parameterized sh execution

Parameterized: Hello, Alice from sh!
## Error handling sh execution

Command exists: echo is available

Command missing: nonexistent is not found
```

### Valid Exe shadow env capture

**Input:**
```mlld
/exe @helper() = js { return "I am helper"; }
/exe @user() = js { return helper() + " and I work"; }
/exe @js = { helper, user }
/var @result = @user()
/show @result
```

**Expected Output:**
```markdown
I am helper and I work
```

### Valid Exe shadow env import

**Input:**
```mlld
/import { api } from "shadow-module.mld"
/var @result = @api.callUser()
/show @result
```

**Expected Output:**
```markdown
I am helper and I work
```

### Valid Expressions operators

**Input:**
```mlld
# Expression Operators Test

## Logical Operators in /var

/var @andResult = @a && @b
/show @andResult
/var @orResult = @x || @y
/show @orResult
/var @complexLogic = @a && @b || @c && @d
/show @complexLogic
/var @withParens = (@a || @b) && (@c || @d)
/show @withParens

## Comparison Operators in /var

/var @isEqual = @name == "Alice"
/show @isEqual
/var @notEqual = @status != "active"
/show @notEqual
/var @chainedComp = @a == @b && @c != @d
/show @chainedComp

## Ternary Operator in /var

/var @simpleChoice = @isDev ? "development" : "production"
/show @simpleChoice
/var @nestedTernary = @env == "prod" ? "live" : @env == "staging" ? "test" : "dev"
/show @nestedTernary
/var @ternaryWithLogic = @isAdmin && @isActive ? @adminDash : @userDash
/show @ternaryWithLogic

## Unary Operator in /var

/var @notActive = !@isActive
/show @notActive
/var @complexNegation = !(@a && @b) || @c
/show @complexNegation

## Expressions in /when

/when @isProduction && !@debugMode => /show "Production mode"
/when @user.role == "admin" || @user.role == "moderator" => /show "Has privileges"
/when @count > 0 && @count < 100 => /show "In range"
/when !@isLoggedIn => /show "Please log in"

## Complex Expressions

/var @result = (@a && @b) || (!@c && @d) ? @option1 : @option2
/show @result
/when (@status == "active" || @override) && !@suspended => /run @process()

## Expression Precedence Test

>> These should parse with correct precedence
/var @test1 = @a || @b && @c     << Should be: @a || (@b && @c)
/show @test1
/var @test2 = @a && @b || @c     << Should be: (@a && @b) || @c
/show @test2
/var @test3 = !@a && @b          << Should be: (!@a) && @b
/show @test3
/var @test4 = @a == @b && @c != @d  << Should be: (@a == @b) && (@c != @d)
/show @test4
```

**Expected Output:**
```markdown
# Expression Operators Test

## Logical Operators in /var

undefined

undefined

undefined

undefined
## Comparison Operators in /var

false

true

false
## Ternary Operator in /var

production

dev

undefined
## Unary Operator in /var

true

true
## Expressions in /when

Please log in

## Complex Expressions

undefined

## Expression Precedence Test

undefined
undefined
undefined
false
```

### Valid Expressions operators parsing

**Input:**
```mlld
# Expression Operators Parsing Test

Tests that expression operators parse correctly (not evaluation).

## Logical Operators in /var

/var @a = true
/var @b = false
/var @c = true
/var @d = false

/var @andResult = @a && @b
/var @orResult = @a || @b
/var @chainedAnd = @a && @b && @c
/var @chainedOr = @a || @b || @c
/var @mixedLogic = @a && @b || @c && @d

## Comparison Operators in /var

/var @name = "Alice"
/var @status = "active"

/var @isEqual = @name == "Alice"
/var @notEqual = @status != "inactive"
/var @chainedComp = @name == "Alice" && @status == "active"

## Ternary Operator in /var

/var @isDev = false
/var @simpleChoice = @isDev ? "development" : "production"
/var @nestedTernary = @status == "active" ? "online" : @status == "pending" ? "waiting" : "offline"

## Unary Operator in /var

/var @isActive = true
/var @notActive = !@isActive
/var @doubleNot = !!@isActive

## Show Results

/show "Tests completed - if this shows, parsing worked!"
```

**Expected Output:**
```markdown
# Expression Operators Parsing Test

Tests that expression operators parse correctly (not evaluation).

## Logical Operators in /var

## Comparison Operators in /var

## Ternary Operator in /var

## Unary Operator in /var

## Show Results

Tests completed - if this shows, parsing worked!
```

### Valid File reference glob

**Input:**
```mlld
# File Reference Glob Pattern Tests

This test verifies glob pattern support in file reference interpolation.

## Glob Patterns

/var @allMarkdown = `<*.md>`
/show `Markdown files: @allMarkdown`

/var @allInDir = `<files/*.txt>`
/show `Text files in dir: @allInDir`

## Glob with Field Access

/var @firstMd = `<*.md>[0]`
/show `First markdown file: @firstMd`

## Glob with Pipes

/var @mdAsJson = `<*.md>|@json`
/show `Markdown files as JSON: @mdAsJson`
```

**Expected Output:**
```markdown
# File Reference Glob Pattern Tests

This test verifies glob pattern support in file reference interpolation.

## Glob Patterns

Markdown files: # Markdown File 1

Content of first markdown file.

---

# Markdown File 2

Content of second markdown file.

Text files in dir: Content of file 1.
Content of file 2.

## Glob with Field Access

First markdown file: # Markdown File 1

Content of first markdown file.

## Glob with Pipes

Markdown files as JSON: ["# Markdown File 1\n\nContent of first markdown file.","# Markdown File 2\n\nContent of second markdown file."]
```

### Valid File reference interpolation

**Input:**
```mlld
# File Reference Interpolation Tests

This comprehensive test suite verifies all aspects of file reference interpolation functionality.

## Basic File References

### Simple file reference
/var @content = `<test-content.txt>`
/show @content

### JSON file with field access
/var @name = `<test-data.json>.name`
/show `Name from JSON: @name`

### Array access
/var @firstEmail = `<test-data.json>.users[0].email`
/show `First user email: @firstEmail`

### Nested field access
/var @city = `<test-data.json>.users[1].address.city`
/show `Second user city: @city`

## Variable Substitution in Paths

/var @extension = "txt"
/var @filename = "test-content"
>> Note: Variable interpolation in file paths not yet implemented
>> /var @dynamicContent = `<@filename.@extension>`
/var @dynamicContent = "placeholder for dynamic file loading"
/show `Dynamic file: @dynamicContent`

## Pipe Transformations

### Single pipe
/var @formatted = `<test-data.json>|@json`
/show `Formatted JSON: @formatted`

### Multiple pipes
/var @xmlData = `<test-data.json>|@json|@xml`
/show `JSON to XML: @xmlData`

### Pipes with field access
/var @userData = `<test-data.json>.users[0]|@json`
/show `User data formatted: @userData`

## Variable Pipes

/var @testData = {"message": "hello world"}
/var @dataXml = @testData|@xml
/show `Variable to XML: @dataXml`

/var @userData2 = {"name": "alice", "age": 30}
/var @userDataJson = @userData2|@json
/show `Object formatted: @userDataJson`

## Complex Scenarios

### Nested templates
/var @template = `User @name from <test-data.json>.name lives in <test-data.json>.users[0].address.city`
/show @template

### In double quotes
/var @quoted = "File content: <test-content.txt>"
/show @quoted

### In command braces
/run {echo "Content: <test-content.txt>"}

### Multiple references
/var @combined = `<file1.txt> and <file2.txt> combined`
/show @combined

## Error Cases

### Missing file
/var @missing = `<nonexistent.txt>`
/show `Missing file: @missing`

### Invalid field
/var @invalidField = `<test-data.json>.nonexistent.field`
/show `Invalid field: @invalidField`

## Special Characters

### File with spaces
/var @spaced = `<file with spaces.txt>`
/show `Spaced filename: @spaced`

### Special characters in path
/var @special = `<data/special-@chars!.txt>`
/show `Special chars: @special`

## Template Contexts

### Double colon templates
/var @dblColon = ::<test-content.txt> interpolated::
/show @dblColon

### Mixed with variables
/var @userName = "Bob"
/var @mixed = `Hello @userName, content: <test-content.txt>`
/show @mixed
```

**Expected Output:**
```markdown
# File Reference Interpolation Tests

This comprehensive test suite verifies all aspects of file reference interpolation functionality.

## Basic File References

### Simple file reference

Hello from test content file!
### JSON file with field access

Name from JSON: Test User
### Array access

First user email: alice@example.com
### Nested field access

Second user city: Boston
## Variable Substitution in Paths

Dynamic file: placeholder for dynamic file loading
## Pipe Transformations

### Single pipe

Formatted JSON: {
  "name": "Test User",
  "users": [
    {
      "email": "alice@example.com",
      "address": {
        "city": "New York",
        "state": "NY"
      }
    },
    {
      "email": "bob@example.com",
      "address": {
        "city": "Boston",
        "state": "MA"
      }
    }
  ]
}
### Multiple pipes

JSON to XML: <NAME>Test User</NAME>
<USERS>
  <ITEM>
    <EMAIL>alice@example.com</EMAIL>
    <ADDRESS>
      <CITY>New York</CITY>
      <STATE>NY</STATE>
    </ADDRESS>
  </ITEM>
  <ITEM>
    <EMAIL>bob@example.com</EMAIL>
    <ADDRESS>
      <CITY>Boston</CITY>
      <STATE>MA</STATE>
    </ADDRESS>
  </ITEM>
</USERS>
### Pipes with field access

User data formatted: {
  "email": "alice@example.com",
  "address": {
    "city": "New York",
    "state": "NY"
  }
}
## Variable Pipes

Variable to XML: <MESSAGE>hello world</MESSAGE>

Object formatted: {
  "name": "alice",
  "age": 30
}
## Complex Scenarios

### Nested templates

User Test User from Test User lives in New York
### In double quotes

File content: Hello from test content file!
### In command braces
Content: Hello from test content file!

### Multiple references

First file content. and Second file content. combined
## Error Cases

### Missing file

Missing file: 
### Invalid field

Invalid field: 
## Special Characters

### File with spaces

Spaced filename: Content with spaces.
### Special characters in path

Special chars: Special content!
## Template Contexts

### Double colon templates

Hello from test content file! interpolated
### Mixed with variables

Hello Bob, content: Hello from test content file!
```

### Valid Import env test

**Input:**
```mlld
/import { MLLD_TEST_ENV } from @input
/show @MLLD_TEST_ENV
```

**Expected Output:**
```markdown
yes-this-works
```

### Valid Literals in function args

**Input:**
```mlld
# Array and Object Literals in Function Arguments

This test verifies that array and object literals can be passed directly as function arguments.

>> Define test functions
/exe @deepEq(@a, @b) = js {return JSON.stringify(a) === JSON.stringify(b) ? "PASS" : "FAIL"}
/exe @grab(@path, @pattern, @options) = js {return `path: ${path}, pattern: ${pattern}, options: ${JSON.stringify(options)}`}
/exe @filter(@arr, @key, @val) = js {return `Filtering ${arr.length} items by ${key}=${val}`}

>> Test array literals in function calls
/var @array = ["a", "b", "c"]

>> This should work: array literal as argument
/var @result1 = @deepEq(@array, ["a", "b", "c"])
/show `Array literal test: @result1`

>> Test object literals in function calls
/var @result2 = @grab("/path", "*.md", {"includeContent": true})
/show `Object literal test: @result2`

>> Test empty arrays
/var @result3 = @filter([], "key", "value")
/show `Empty array test: @result3`

>> Test nested structures
/var @result4 = @deepEq([{"a": 1}, {"b": 2}], [{"a": 1}, {"b": 2}])
/show `Nested structure test: @result4`

>> Mixed literals
/var @result5 = @grab("/test", "*.js", {"depth": 2, "exclude": [".git", "node_modules"]})
/show `Mixed literals test: @result5`

/show `All literal tests completed!`
```

**Expected Output:**
```markdown
# Array and Object Literals in Function Arguments

This test verifies that array and object literals can be passed directly as function arguments.

Array literal test: PASS

Object literal test: path: /path, pattern: *.md, options: {"includeContent":true}

Empty array test: Filtering 0 items by key=value

Nested structure test: PASS

Mixed literals test: path: /test, pattern: *.js, options: {"depth":2,"exclude":[".git","node_modules"]}
All literal tests completed!
```

### Valid Load content js edge cases

**Input:**
```mlld
# Test LoadContentResult edge cases and error handling

## Setup test files
/var @content1 = `First file content`
/var @content2 = `Second file content`
/var @jsonContent = `{"name": "test", "value": 42}`

/output @content1 to file1.txt
/output @content2 to file2.txt  
/output @jsonContent to data.json

## Test 1: Array unwrapping
# Skip: Glob patterns not supported in tests
# /var @files = <file*.txt>

/exe @processArray(@arr) = js {
  if (!Array.isArray(arr)) return "FAIL: Not an array";
  if (arr.length !== 2) return "FAIL: Wrong length";
  if (typeof arr[0] !== 'string') return "FAIL: Not strings";
  return "PASS: " + arr.join(" | ");
}

# /run @processArray(@files)
/show "SKIP: Glob test"

## Test 2: JSON content handling
/var @jsonFile = <data.json>

/exe @parseJson(@content) = js {
  try {
    const data = JSON.parse(content);
    return `PASS: ${data.name} = ${data.value}`;
  } catch (e) {
    return "FAIL: Could not parse JSON";
  }
}

/run @parseJson(@jsonFile)

## Test 3: LoadContentResult metadata access
/var @file = <file1.txt>

/exe @checkMetadata(@content, @filename) = js {
  // When LoadContentResult is unwrapped, we lose metadata
  // This test shows parameters are unwrapped to content only
  return `Content length: ${content.length}, filename param: ${filename}`;
}

/run @checkMetadata(@file, @file.filename)

## Test 4: Multiple parameters
/exe @combine(@a, @b) = js {
  return `${a} + ${b}`;
}

/var @f1 = <file1.txt>
/var @f2 = <file2.txt>
/run @combine(@f1, @f2)

## Test 5: Shadow environment unwrapping
/exe @upper(@text) = js {
  return text.toUpperCase();
}

/exe js = { upper }

/exe @useShadow(@content) = js {
  return upper(content);
}

/var @testFile = <file1.txt>
/run @useShadow(@testFile)

## Cleanup
/run "rm -f file1.txt file2.txt data.json"
```

**Expected Output:**
```markdown
# Test LoadContentResult edge cases and error handling

## Setup test files

  

## Test 1: Array unwrapping
# Skip: Glob patterns not supported in tests
# /var @files = <file*.txt>

# /run @processArray(@files)
SKIP: Glob test
## Test 2: JSON content handling

PASS: test = 42

## Test 3: LoadContentResult metadata access

Content length: 18, filename param: file1.txt

## Test 4: Multiple parameters

First file content + Second file content

## Test 5: Shadow environment unwrapping

FIRST FILE CONTENT

## Cleanup
```

### Valid Load content js unwrap

**Input:**
```mlld
# Test LoadContentResult auto-unwrapping in JavaScript functions

## Setup test file
/var @testContent = `# Test Content

This is the content of the test file.
It has multiple lines.
`
/output @testContent to test-file.md

## Test: LoadContentResult passed to JS function
/var @file = <test-file.md>

/exe @checkUnwrap(@content) = js {
  // Should receive the string content, not the LoadContentResult object
  if (typeof content !== 'string') {
    return `FAIL: Expected string, got ${typeof content}`;
  }
  
  if (content === '[object Object]') {
    return "FAIL: Got [object Object] instead of content";
  }
  
  if (content.includes("Test Content") && content.includes("multiple lines")) {
    return "PASS: Content properly unwrapped";
  }
  
  return "FAIL: Unexpected content";
}

/run @checkUnwrap(@file)

## Cleanup
/run "rm -f test-file.md"
```

**Expected Output:**
```markdown
# Test LoadContentResult auto-unwrapping in JavaScript functions

## Setup test file

## Test: LoadContentResult passed to JS function

PASS: Content properly unwrapped

## Cleanup
```

### Valid Load content node unwrap

**Input:**
```mlld
# Test LoadContentResult unwrapping in Node.js

## Setup
/var @mdContent = `# Markdown Test

This is a **test** document.
- Item 1
- Item 2`

/var @csvContent = `name,age,city
Alice,30,NYC
Bob,25,LA`

/output @mdContent to test.md
/output @csvContent to data.csv

## Test 1: Node.js string processing
/var @file = <test.md>

/exe @processNode(@content) = node {
  const lines = content.split('\n');
  
  // Process markdown
  const hasHeading = content.includes('# Markdown');
  const hasBold = content.includes('**test**');
  
  return `Lines: ${lines.length}
Type: ${typeof content}`;
}

/run @processNode(@file)

## Test 2: CSV parsing in Node
/var @csvFile = <data.csv>

/exe @parseCSV(@data) = node {
  const rows = data.trim().split('\n');
  const headers = rows[0].split(',');
  const dataRows = rows.slice(1);
  
  return `Headers: ${headers.join(', ')}
Data rows: ${dataRows.length}`;
}

/run @parseCSV(@csvFile)

## Test 3: File array in Node
# Skip: Glob patterns not supported in tests
# /var @files = <*.md>

/exe @countChars(@fileArray) = node {
  const totalChars = fileArray.reduce((sum, content) => {
    return sum + content.length;
  }, 0);
  
  return `Total characters: ${totalChars}`;
}

# /run @countChars(@files)
/show "SKIP: Glob test"

## Test 4: Metadata access
/exe @getMeta(@content, @filename) = node {
  return `File ${filename} has ${content.length} characters`;
}

/var @doc = <test.md>
/run @getMeta(@doc, @doc.filename)

## Cleanup
/run "rm -f test.md data.csv"
```

**Expected Output:**
```markdown
# Test LoadContentResult unwrapping in Node.js

## Setup

## Test 1: Node.js string processing

Lines: 5
Type: string

## Test 2: CSV parsing in Node

Headers: name, age, city
Data rows: 2

## Test 3: File array in Node
# Skip: Glob patterns not supported in tests
# /var @files = <*.md>

# /run @countChars(@files)
SKIP: Glob test
## Test 4: Metadata access

File test.md has 63 characters

## Cleanup
```

### Valid Now basic compat

**Input:**
```mlld
# Basic NOW Compatibility Test

## now as variable (returns text)
/var @timestamp = @now
/show `Variable now: @timestamp`

## now as variable (same as lowercase)
/var @timestamp2 = @now
/show `Variable now (same): @timestamp2`
```

**Expected Output:**
```markdown
# Basic NOW Compatibility Test

## now as variable (returns text)

Variable now: 2024-01-15T10:30:00.000Z
## now as variable (same as lowercase)

Variable now (same): 2024-01-15T10:30:00.000Z
```

### Valid Now enhanced formats

**Input:**
```mlld
# Enhanced TIME Module - Format Tests

## Import various time formats using now.* syntax
/import { "YYYY-MM-DD" as todayCustom, "HH:mm:ss" as timeCustom } from @time
/import { iso, unix, date as dateFormat, time as timeFormat } from @time

## Show imported values
/show `Today (custom): @todayCustom`
/show `Time (custom): @timeCustom`
/show `ISO: @iso`
/show `Unix: @unix`
/show `Date: @dateFormat`
/show `Time: @timeFormat`
```

**Expected Output:**
```markdown
# Enhanced TIME Module - Format Tests

## Import various time formats using now.* syntax

## Show imported values
Today (custom): 2024-01-15
Time (custom): 10:30:00
ISO: 2024-01-15T10:30:00.000Z
Unix: 1705316400
Date: 2024-01-15
Time: 10:30:00
```

### Valid Now lowercase basic

**Input:**
```mlld
# Basic time module test (lowercase)

## time as variable (returns text)
/var @timestamp = @time
/show `Variable time: @timestamp`

## time as import with common formats
/import { iso, unix, date as dateStr } from @time
/show `ISO: @iso`
/show `Unix: @unix`
/show `Date: @dateStr`
```

**Expected Output:**
```markdown
# Basic time module test (lowercase)

## time as variable (returns text)
Variable time: 2024-01-15T10:30:00.000Z

## time as import with common formats
ISO: 2024-01-15T10:30:00.000Z
Unix: 1705316400
Date: 2024-01-15
```

### Valid Object property access in exec args

**Input:**
```mlld
# GitHub Issue: Object Property Access in Function Arguments

This test specifically verifies the scenarios described in the GitHub issue.

>> Module imports would fail here, so we'll define simple test functions
/exe @eq(@a, @b) = js {return a === b ? "PASS" : `FAIL: expected '${b}' but got '${a}'`}
/exe @ok(@val) = js {return val === true ? "PASS" : `FAIL: expected true but got '${val}'`}

>> Test object property access in different contexts
/var @user = {"name": "Alice", "age": 30, "active": true}

>> This works fine (already verified):
/show `User name: @user.name`
/show `User age: @user.age`
/show `User active: @user.active`

>> This previously failed with "Variable not found: user.name"
>> First let's verify property access works in simple assignment
/var @user_name = @user.name
/show `Extracted name: @user_name`

>> Now test in function argument
/var @test_name = @eq(@user.name, "Alice")
/show `Test name: @test_name`

/var @test_age = @eq(@user.age, 30)
/show `Test age: @test_age`

/var @test_active = @ok(@user.active)
/show `Test active: @test_active`

>> Also test nested objects
/var @company = {"name": "Acme", "address": {"street": "123 Main St", "city": "Boston"}}
/var @test_company = @eq(@company.address.city, "Boston")
/show `Test company city: @test_company`

>> Test numeric field access
/var @data = {"123": "numeric key", "456": {"nested": "value"}}
/var @test_numeric = @eq(@data.123, "numeric key")
/show `Test numeric field: @test_numeric`

>> Test array-like access (if supported)
/var @arr = ["first", "second", "third"]
/var @test_array = @eq(@arr[0], "first")
/show `Test array access: @test_array`

/show `All tests completed!`
```

**Expected Output:**
```markdown
# GitHub Issue: Object Property Access in Function Arguments

This test specifically verifies the scenarios described in the GitHub issue.

User name: Alice
User age: 30
User active: true

Extracted name: Alice

Test name: PASS

Test age: PASS

Test active: PASS

Test company city: PASS

Test numeric field: PASS

Test array access: PASS
All tests completed!
```

### Valid Object property access in functions

**Input:**
```mlld
# Object Property Access in Function Arguments

This test verifies that object property access works correctly when passing values to functions.

>> Test object property access in different contexts
/var @user = {"name": "Alice", "age": 30, "active": true}

>> This works fine (already verified):
/show `User name: @user.name`
/show `User age: @user.age`

>> Test nested objects
/var @company = {"name": "Acme", "address": {"street": "123 Main St", "city": "Boston"}}
/show `Company city: @company.address.city`

>> Test numeric field access
/var @data = {"123": "numeric key", "456": {"nested": "value"}}
/show `Numeric field: @data.123`

>> Test object property access in function arguments
/exe @identity(@val) = run {echo "@val"}

>> These should now work correctly with property access
/run @identity(@user.name)
/run @identity(@user.age)
/run @identity(@company.address.city)
/run @identity(@data.123)

>> Summary
/show `All property access tests completed!`
```

**Expected Output:**
```markdown
# Object Property Access in Function Arguments

This test verifies that object property access works correctly when passing values to functions.

User name: Alice
User age: 30

Company city: Boston

Numeric field: numeric key
Alice

30

Boston

numeric key
All property access tests completed!
```

### Valid Optional slash comprehensive

**Input:**
```mlld
# Comprehensive Test for Optional Slashes in RHS Contexts

This test verifies that slashes are optional in all RHS contexts while producing identical output.

## Setup
/var @env = "production"
/var @buildComplete = "true"

## Var Assignment with /run
/var @timestamp = /run {echo "2024-01-15"}
/var @version = /run {echo "v2.0.0"}

## Exe Definitions with /run
/exe @build() = /run {echo "Building application..."}
/exe @deploy() = /run {echo "Deploying to server..."}

## When Actions with Slashes
/when @buildComplete => /show `Build completed for @env`
/when @buildComplete => /run {echo "Starting deployment process..."}
/when @buildComplete => /output "Deployment initialized" to stdout

## Execution
/show `[@timestamp] Application version: @version`
/show `[INFO] Deployment to @env started`
```

**Expected Output:**
```markdown
# Comprehensive Test for Optional Slashes in RHS Contexts

This test verifies that slashes are optional in all RHS contexts while producing identical output.

## Setup

## Var Assignment with /run

## Exe Definitions with /run

## When Actions with Slashes
Build completed for production

Starting deployment process...

## Execution
[2024-01-15] Application version: v2.0.0
[INFO] Deployment to production started
```

### Valid Resolver contexts

**Input:**
```mlld
# Test Resolver Context-Dependent Behavior

## now as variable (returns text)
/var @timestamp = @now
/show :::Variable now: {{timestamp}}:::
```

**Expected Output:**
```markdown
# Test Resolver Context-Dependent Behavior

## now as variable (returns text)

Variable now: 2024-01-01T00:00:00.000Z
```

### Valid Template syntax migration

**Input:**
```mlld
/var @name = "Alice"
/var @language = "JavaScript"

>> Test backticks in double colon template
/var @docs = ::The `getData()` function returns @language data::
/show @docs

>> Test multiple variables
/var @message = ::Hello @name! Welcome to `mlld` documentation::
/show @message

>> Test inline code examples
/var @example = ::To use this feature, run `npm install` and then call `init(@name)`::
/show @example
```

**Expected Output:**
```markdown
The `getData()` function returns JavaScript data

Hello Alice! Welcome to `mlld` documentation

To use this feature, run `npm install` and then call `init(Alice)`
```

### Valid When literal condition

**Input:**
```mlld
# When Directive with Literal Condition

The @when directive can accept literal values for simple conditional checks.

## Using literal true
/when true => /show "This always executes"

## Using literal false  
/when false => /show "This never executes"

## Using literal null
/when null => /show "This never executes (null is falsy)"

## Using literal string
/when "value" => /show "Non-empty strings are truthy"

## Using a variable
/var @myCondition = "true"
/when @myCondition => /show "Variables work too"
```

**Expected Output:**
```markdown
# When Directive with Literal Condition

The @when directive can accept literal values for simple conditional checks.

## Using literal true
This always executes

## Using literal false  

## Using literal null

## Using literal string
Non-empty strings are truthy

## Using a variable

Variables work too
```

## Warnings

### Warnings Bare variable reference

**Input:**
```mlld
/var @myvar = "Hello world"

This line contains a bare variable reference: @myvar
```

### Warnings Directive in text line

**Input:**
```mlld
/var @myvar = "Hello world"

Some text @add @myvar in the middle of a line.
```

### Warnings Template syntax in text

**Input:**
```mlld
/var @myvar = "Hello world"

This line uses template syntax: {{myvar}}
```
