# Mlld Examples

This file contains all test case examples organized by category.
Generated by `tests/utils/ast-fixtures.js`

## Table of Contents

- [Exceptions](#exceptions)
  - [Import non module](#exceptions-import-non-module)
  - [Path module content](#exceptions-path-module-content)
  - [Text parameterized run command](#exceptions-text-parameterized-run-command)
  - [When any with individual actions](#exceptions-when-any-with-individual-actions)
  - [When literal condition](#exceptions-when-literal-condition)
- [Valid](#valid)
  - [Command substitution interactive](#valid-command-substitution-interactive)
  - [Command substitution sh](#valid-command-substitution-sh)
  - [Command substitution tty](#valid-command-substitution-tty)
  - [Examples](#valid-examples)
  - [Exec invocation module](#valid-exec-invocation-module)
  - [Exec parameterized command](#valid-exec-parameterized-command)
  - [Exec sh module](#valid-exec-sh-module)
  - [Literals in function args](#valid-literals-in-function-args)
  - [Object property access in exec args](#valid-object-property-access-in-exec-args)
  - [Object property access in functions](#valid-object-property-access-in-functions)
  - [Optional slash comprehensive](#valid-optional-slash-comprehensive)
  - [Resolver contexts](#valid-resolver-contexts)
- [Warnings](#warnings)
  - [Bare variable reference](#warnings-bare-variable-reference)
  - [Directive in text line](#warnings-directive-in-text-line)
  - [Template syntax in text](#warnings-template-syntax-in-text)

## Exceptions

### Exceptions Import non module

**Input:**
```mlld
# Test Import Non-Module Rejection

/import { content } from "./data.txt"
/show @content
```

### Exceptions Path module content

**Input:**
```mlld
# Test Path Module Rejection

/path @mod = "./module.mld"
/show @mod
```

### Exceptions Text parameterized run command

**Input:**
```mlld
# Parameterized Text with Run Command (Invalid)

This example shows an invalid syntax where someone tries to create a parameterized text variable with a `@run` command.

/exe @codecat(dir) = run {find @dir -type f -exec sh -c 'echo "<$(realpath --relative-to=@dir {})>"; cat {}; echo "@dir {})>"' \;}

This should fail because:
1. Parameterized text templates should use `@exec` not `@text`
2. The complex shell escaping may not be properly handled
3. There's malformed syntax at the end
```

### Exceptions When any with individual actions

**Input:**
```mlld
/var @condition1 = "true"
/var @condition2 = "false"

# Invalid: any: modifier cannot have individual actions
/when @condition1 any: [
  @condition1 => show "Action 1"
  @condition2 => show "Action 2"
]
```

### Exceptions When literal condition

**Input:**
```mlld
# When Directive with Literal Condition

The @when directive requires a variable to evaluate, not a literal value.

## Invalid: Using literal true
/when true => show "This is invalid syntax"

## Invalid: Using literal false  
/when false => show "This is also invalid"

## Invalid: Using literal null
/when null => show "This too is invalid"

## Invalid: Using literal string
/when "value" => show "String literals are not allowed"

## Valid: Using a variable
/var @myCondition = "true"
/when @myCondition => show "This is valid syntax"
```

## Valid

### Valid Command substitution interactive

**Input:**
```mlld
# Command Substitution with Interactive-like Commands

This test simulates the behavior we see with interactive CLI tools in command substitution.

## Test Direct Execution

/exe @test_direct() = sh {
  # Direct execution - simulate inline
  if [ -t 0 ] || [ -t 1 ]; then
    echo "Direct execution"
  else
    echo "Direct execution" >&2
  fi
}
/var @direct = @test_direct()
/show `Direct: [@direct]`

## Test Command Substitution

/exe @test_substitution() = sh {
  # This might capture differently
  result=$(
    if [ -t 0 ] || [ -t 1 ]; then
      echo "Via substitution"
    else
      echo "Via substitution" >&2
    fi
  )
  echo "Captured: $result"
}
/var @subst = @test_substitution()
/show `Substitution: [@subst]`

## Test with Stderr Capture

/exe @test_with_stderr() = sh {
  # Explicitly capture both stdout and stderr
  result=$(
    if [ -t 0 ] || [ -t 1 ]; then
      echo "With stderr"
    else
      echo "With stderr" >&2
    fi
    2>&1
  )
  echo "Both streams: $result"
}
/var @both = @test_with_stderr()
/show `With stderr: [@both]`

## Python Script Simulation

/exe @python_sim() = sh {
  # Simulate a Python script that might buffer differently
  python3 -c "import sys; sys.stdout.write('Python output'); sys.stdout.flush()" 2>/dev/null || echo "Python not available"
}
/var @py_direct = @python_sim()
/show `Python direct: [@py_direct]`

/exe @python_subst() = sh {
  result=$(python3 -c "import sys; sys.stdout.write('Python output'); sys.stdout.flush()" 2>/dev/null || echo "Python not available")
  echo "$result"
}
/var @py_subst = @python_subst()
/show `Python subst: [@py_subst]`
```

**Expected Output:**
```markdown
# Command Substitution with Interactive-like Commands

This test simulates the behavior we see with interactive CLI tools in command substitution.

## Test Direct Execution

Direct: [Direct execution]
## Test Command Substitution

Substitution: [Captured: Via substitution]
## Test with Stderr Capture

With stderr: [Both streams: With stderr]
## Python Script Simulation

Python direct: [Python output]

Python subst: [Python not available]
```

### Valid Command substitution sh

**Input:**
```mlld
# Command Substitution in sh Blocks

This test verifies that command substitution works correctly in sh blocks across different scenarios.

## Basic Command Substitution

/exe @simple_subst() = sh {
  result=$(echo "basic substitution works")
  echo "Result: $result"
}
/var @test1 = @simple_subst()
/show @test1

## Command Substitution with Multiple Lines

/exe @multiline_subst() = sh {
  result=$(echo "line 1" && echo "line 2")
  echo "Combined: $result"
}
/var @test2 = @multiline_subst()
/show @test2

## Nested Command Substitution

/exe @nested_subst() = sh {
  inner=$(echo "inner")
  result=$(echo "outer contains: $inner")
  echo "$result"
}
/var @test3 = @nested_subst()
/show @test3

## Command Substitution with Exit Codes

/exe @exit_code_subst() = sh {
  result=$(echo "success" && exit 0)
  code=$?
  echo "Output: $result (exit code: $code)"
}
/var @test4 = @exit_code_subst()
/show @test4

## Command Substitution with stderr

/exe @stderr_subst() = sh {
  # This simulates a command that might write to stderr
  result=$(sh -c 'echo "stdout text" && echo "stderr text" >&2' 2>&1)
  echo "Captured: $result"
}
/var @test5 = @stderr_subst()
/show @test5

## Complex Pattern (similar to AI module)

/exe @complex_pattern() = sh {
  # Test if echo exists (it always does)
  if ! command -v echo >/dev/null 2>&1; then
    echo "Error: echo not found"
    exit 1
  fi
  
  # Capture output with error handling
  result=$(echo "complex pattern test" 2>&1)
  exit_code=$?
  
  if [ $exit_code -eq 0 ]; then
    echo "Success: $result"
  else
    echo "Failed: $result"
  fi
}
/var @test6 = @complex_pattern()
/show @test6

## Direct Output (for comparison)

/exe @direct_output() = sh {
  echo "direct output works"
}
/var @test7 = @direct_output()
/show @test7
```

**Expected Output:**
```markdown
# Command Substitution in sh Blocks

This test verifies that command substitution works correctly in sh blocks across different scenarios.

## Basic Command Substitution

Result: basic substitution works
## Command Substitution with Multiple Lines

Combined: line 1 line 2
## Nested Command Substitution

outer contains: inner
## Command Substitution with Exit Codes

Output: success (exit code: 0)
## Command Substitution with stderr

Captured: stdout text stderr text
## Complex Pattern (similar to AI module)

Success: complex pattern test
## Direct Output (for comparison)

direct output works
```

### Valid Command substitution tty

**Input:**
```mlld
# Command Substitution with TTY-aware Commands

This test explores how command substitution affects commands that behave differently based on TTY detection.

## Test TTY Detection

/exe @check_tty() = sh {
  # Direct execution (might have TTY)
  if [ -t 1 ]; then
    echo "Direct: stdout is a TTY"
  else
    echo "Direct: stdout is NOT a TTY"
  fi
}
/var @tty1 = @check_tty()
/show @tty1

/exe @check_tty_subst() = sh {
  # Inside command substitution (no TTY)
  result=$(
    if [ -t 1 ]; then
      echo "Subst: stdout is a TTY"
    else
      echo "Subst: stdout is NOT a TTY"
    fi
  )
  echo "$result"
}
/var @tty2 = @check_tty_subst()
/show @tty2

## Test with Script Command (TTY-aware)

/exe @script_direct() = sh {
  # Some commands behave differently without TTY
  # Using 'cat' as a simple example that works everywhere
  echo "test input" | cat
}
/var @script1 = @script_direct()
/show @script1

/exe @script_subst() = sh {
  # Same command in substitution
  result=$(echo "test input" | cat)
  echo "Captured: $result"
}
/var @script2 = @script_subst()
/show @script2

## Test Process Substitution vs Command Substitution

/exe @proc_subst_test() = sh {
  # Note: Process substitution <(...) might not be available in all shells
  # Just using regular piping instead
  echo "data" | { read line; echo "Read: $line"; }
}
/var @proc1 = @proc_subst_test()
/show @proc1

## Test Buffering Behavior

/exe @buffer_test() = sh {
  # Test if buffering affects output capture
  result=$(printf "unbuffered" && printf " output")
  echo "Result: $result"
}
/var @buffer1 = @buffer_test()
/show @buffer1
```

**Expected Output:**
```markdown
# Command Substitution with TTY-aware Commands

This test explores how command substitution affects commands that behave differently based on TTY detection.

## Test TTY Detection

Direct: stdout is NOT a TTY

Subst: stdout is NOT a TTY
## Test with Script Command (TTY-aware)

test input

Captured: test input
## Test Process Substitution vs Command Substitution

Read: data
## Test Buffering Behavior

Result: unbuffered output
```

### Valid Examples

**Input:**
```mlld
>> This is a comment and should be ignored
>> I can write a couple lines of them if I want and no one will ever know.

/import { * } from "files/imports.mld"

/var @role = {
    "architect": "You are a senior architect skilled in assessing TypeScript codebases.",
    "ux": "You are a senior ux designer skilled in assessing user experience.",
    "security": "You are a senior security engineer skilled in assessing TypeScript codebases."
}

/var @task = {
    "code_review": "Carefully review the code and test results and advise on the quality of the code and areas of improvement.",
    "ux_review": "Carefully review the user experience and advise on the quality of the user experience and areas of improvement.",
    "security_review": "Carefully review the security of the code and advise on the quality of the security and areas of improvement."
}

## Your role
/show @role.architect

## Documentation
### Architecture
/show @path "./docs/dev/ARCHITECTURE.md" # TESTING INFRASTRUCTURE
### Mlld error handling
/show @path "./docs/dev/ERRORS.md"

## Test Results
/run npm test core/syntax

## Your task
/show @task.code_review

>> this doesn't work but should
>> run @text codecat("./examples")
```

### Valid Exec invocation module

**Input:**
```mlld
# Test exec invocation from module imports

/import { sayHello, greetUser, multiLine, withParams, greeting } from "./test-module.mld"

## Direct invocation
/run @sayHello()

## With parameter
/run @greetUser("Alice")

## Multi-line command
/run @multiLine()

## Multiple parameters
/run @withParams("foo", "bar")

## In data directive
/var @result = @sayHello()
/show @result

## In text template
/var @message = ::Output: {{greeting}}::
/show @message

## Verify regular variable import works
/show @greeting
```

**Expected Output:**
```markdown
# Test exec invocation from module imports

## Direct invocation
Hello, World!

## With parameter
Hello, Alice!

## Multi-line command
Line 1
Line 2

## Multiple parameters
First: foo, Second: bar

## In data directive

Hello, World!
## In text template

Output: Hello from module
## Verify regular variable import works
Hello from module
```

#### Example.o Variant

**Input:**
```mlld
# Test exec invocation from module imports

## Direct invocation
Hello, World!

## With parameter
Hello, Alice!

## Multi-line command
Line 1
Line 2

## Multiple parameters
First: foo, Second: bar

## In data directive

Hello, World!
## In text template

Output: Hello from module
## Verify regular variable import works
Hello from module
```

### Valid Exec parameterized command

**Input:**
```mlld
# Parameterized Exec Command (Valid)

This example shows the correct way to create a parameterized command using `@exec`.

/exe @greet(name) = {echo "Hello @name!"
echo "Welcome @name!"
echo "Greetings @name!"}

/run @greet("Alice")
```

**Expected Output:**
```markdown
# Parameterized Exec Command (Valid)

This example shows the correct way to create a parameterized command using `@exec`.

Hello Alice!
Welcome Alice!
Greetings Alice!
```

### Valid Exec sh module

**Input:**
```mlld
# Test sh executables from module imports

This tests importing and using sh executables from a module.

/import { simple_sh, multiline_sh, parameterized_sh, error_handling_sh } from "./test-sh-module.mld"

## Simple sh execution
/var @result1 = @simple_sh()
/show `Simple: @result1`

## Multi-line sh execution
/var @result2 = @multiline_sh()
/show `Multi-line: @result2`

## Parameterized sh execution
/var @result3 = @parameterized_sh("Alice")
/show `Parameterized: @result3`

## Error handling sh execution
/var @result4 = @error_handling_sh("echo")
/show `Command exists: @result4`

/var @result5 = @error_handling_sh("nonexistent")
/show `Command missing: @result5`
```

**Expected Output:**
```markdown
# Test sh executables from module imports

This tests importing and using sh executables from a module.

## Simple sh execution

Simple: Simple sh output
## Multi-line sh execution

Multi-line: Multi-line sh output
## Parameterized sh execution

Parameterized: Hello, Alice from sh!
## Error handling sh execution

Command exists: echo is available

Command missing: nonexistent is not found
```

### Valid Literals in function args

**Input:**
```mlld
# Array and Object Literals in Function Arguments

This test verifies that array and object literals can be passed directly as function arguments.

>> Define test functions
/exe @deepEq(@a, @b) = js {return JSON.stringify(a) === JSON.stringify(b) ? "PASS" : "FAIL"}
/exe @grab(@path, @pattern, @options) = js {return `path: ${path}, pattern: ${pattern}, options: ${JSON.stringify(options)}`}
/exe @filter(@arr, @key, @val) = js {return `Filtering ${arr.length} items by ${key}=${val}`}

>> Test array literals in function calls
/var @array = ["a", "b", "c"]

>> This should work: array literal as argument
/var @result1 = @deepEq(@array, ["a", "b", "c"])
/show `Array literal test: @result1`

>> Test object literals in function calls
/var @result2 = @grab("/path", "*.md", {"includeContent": true})
/show `Object literal test: @result2`

>> Test empty arrays
/var @result3 = @filter([], "key", "value")
/show `Empty array test: @result3`

>> Test nested structures
/var @result4 = @deepEq([{"a": 1}, {"b": 2}], [{"a": 1}, {"b": 2}])
/show `Nested structure test: @result4`

>> Mixed literals
/var @result5 = @grab("/test", "*.js", {"depth": 2, "exclude": [".git", "node_modules"]})
/show `Mixed literals test: @result5`

/show `All literal tests completed!`
```

**Expected Output:**
```markdown
# Array and Object Literals in Function Arguments

This test verifies that array and object literals can be passed directly as function arguments.

Array literal test: PASS

Object literal test: path: /path, pattern: *.md, options: {"includeContent":true}

Empty array test: Filtering 0 items by key=value

Nested structure test: PASS

Mixed literals test: path: /test, pattern: *.js, options: {"depth":2,"exclude":[".git","node_modules"]}
All literal tests completed!
```

#### Example.o Variant

**Input:**
```mlld
# Array and Object Literals in Function Arguments

This test verifies that array and object literals can be passed directly as function arguments.

Array literal test: PASS

Object literal test: path: /path, pattern: \*.md, options: {"includeContent":true}

Empty array test: Filtering 0 items by key=value

Nested structure test: PASS

Mixed literals test: path: /test, pattern: \*.js, options: {"depth":2,"exclude":[".git","node_modules"]}
All literal tests completed!
```

### Valid Object property access in exec args

**Input:**
```mlld
# GitHub Issue: Object Property Access in Function Arguments

This test specifically verifies the scenarios described in the GitHub issue.

>> Module imports would fail here, so we'll define simple test functions
/exe @eq(@a, @b) = js {return a === b ? "PASS" : `FAIL: expected '${b}' but got '${a}'`}
/exe @ok(@val) = js {return val === true ? "PASS" : `FAIL: expected true but got '${val}'`}

>> Test object property access in different contexts
/var @user = {"name": "Alice", "age": 30, "active": true}

>> This works fine (already verified):
/show `User name: @user.name`
/show `User age: @user.age`
/show `User active: @user.active`

>> This previously failed with "Variable not found: user.name"
>> First let's verify property access works in simple assignment
/var @user_name = @user.name
/show `Extracted name: @user_name`

>> Now test in function argument
/var @test_name = @eq(@user.name, "Alice")
/show `Test name: @test_name`

/var @test_age = @eq(@user.age, 30)
/show `Test age: @test_age`

/var @test_active = @ok(@user.active)
/show `Test active: @test_active`

>> Also test nested objects
/var @company = {"name": "Acme", "address": {"street": "123 Main St", "city": "Boston"}}
/var @test_company = @eq(@company.address.city, "Boston")
/show `Test company city: @test_company`

>> Test numeric field access
/var @data = {"123": "numeric key", "456": {"nested": "value"}}
/var @test_numeric = @eq(@data.123, "numeric key")
/show `Test numeric field: @test_numeric`

>> Test array-like access (if supported)
/var @arr = ["first", "second", "third"]
/var @test_array = @eq(@arr[0], "first")
/show `Test array access: @test_array`

/show `All tests completed!`
```

**Expected Output:**
```markdown
# GitHub Issue: Object Property Access in Function Arguments

This test specifically verifies the scenarios described in the GitHub issue.

User name: Alice
User age: 30
User active: true

Extracted name: Alice

Test name: PASS

Test age: PASS

Test active: PASS

Test company city: PASS

Test numeric field: PASS

Test array access: PASS
All tests completed!
```

#### Example.o Variant

**Input:**
```mlld
# GitHub Issue: Object Property Access in Function Arguments

This test specifically verifies the scenarios described in the GitHub issue.

User name: Alice
User age: 30
User active: true

Extracted name: Alice

Test name: PASS

Test age: PASS

Test active: PASS

Test company city: PASS

Test numeric field: PASS

Test array access: PASS
All tests completed!
```

### Valid Object property access in functions

**Input:**
```mlld
# Object Property Access in Function Arguments

This test verifies that object property access works correctly when passing values to functions.

>> Test object property access in different contexts
/var @user = {"name": "Alice", "age": 30, "active": true}

>> This works fine (already verified):
/show `User name: @user.name`
/show `User age: @user.age`

>> Test nested objects
/var @company = {"name": "Acme", "address": {"street": "123 Main St", "city": "Boston"}}
/show `Company city: @company.address.city`

>> Test numeric field access
/var @data = {"123": "numeric key", "456": {"nested": "value"}}
/show `Numeric field: @data.123`

>> Test object property access in function arguments
/exe @identity(@val) = run {echo "@val"}

>> These should now work correctly with property access
/run @identity(@user.name)
/run @identity(@user.age)
/run @identity(@company.address.city)
/run @identity(@data.123)

>> Summary
/show `All property access tests completed!`
```

**Expected Output:**
```markdown
# Object Property Access in Function Arguments

This test verifies that object property access works correctly when passing values to functions.

User name: Alice
User age: 30

Company city: Boston

Numeric field: numeric key
Alice

30

Boston

numeric key
All property access tests completed!
```

#### Example.o Variant

**Input:**
```mlld
# Object Property Access in Function Arguments

This test verifies that object property access works correctly when passing values to functions.

User name: Alice
User age: 30

Company city: Boston

Numeric field: numeric key
Alice

30

Boston

numeric key
All property access tests completed!
```

### Valid Optional slash comprehensive

**Input:**
```mlld
# Comprehensive Test for Optional Slashes in RHS Contexts

This test verifies that slashes are optional in all RHS contexts while producing identical output.

## Setup
/var @env = "production"
/var @buildComplete = "true"

## Var Assignment with /run
/var @timestamp = /run {echo "2024-01-15"}
/var @version = /run {echo "v2.0.0"}

## Exe Definitions with /run
/exe @build() = /run {echo "Building application..."}
/exe @deploy() = /run {echo "Deploying to server..."}

## When Actions with Slashes
/when @buildComplete => /show `Build completed for @env`
/when @buildComplete => /run {echo "Starting deployment process..."}
/when @buildComplete => /output "Deployment initialized" to stdout

## Execution
/show `[@timestamp] Application version: @version`
/show `[INFO] Deployment to @env started`
```

**Expected Output:**
```markdown
# Comprehensive Test for Optional Slashes in RHS Contexts

This test verifies that slashes are optional in all RHS contexts while producing identical output.

## Setup

## Var Assignment with /run

## Exe Definitions with /run

## When Actions with Slashes
Build completed for production

Starting deployment process...

## Execution
[2024-01-15] Application version: v2.0.0
[INFO] Deployment to production started
```

### Valid Resolver contexts

**Input:**
```mlld
# Test Resolver Context-Dependent Behavior

## TIME as variable (returns text)
/var @timestamp = @TIME
/show ::Variable TIME: {{timestamp}}::

## TIME as import (returns data with multiple formats)
/import { iso, unix, date } from @TIME
/show ::Import TIME - ISO: {{iso}}, Date: {{date}}::
```

**Expected Output:**
```markdown
# Test Resolver Context-Dependent Behavior

## TIME as variable (returns text)

Variable TIME: 2024-01-01T00:00:00.000Z
## TIME as import (returns data with multiple formats)

Import TIME - ISO: 2024-01-01T00:00:00.000Z, Date: 2024-01-01
```

## Warnings

### Warnings Bare variable reference

**Input:**
```mlld
/var @myvar = "Hello world"

This line contains a bare variable reference: @myvar
```

### Warnings Directive in text line

**Input:**
```mlld
/var @myvar = "Hello world"

Some text @add @myvar in the middle of a line.
```

### Warnings Template syntax in text

**Input:**
```mlld
/var @myvar = "Hello world"

This line uses template syntax: {{myvar}}
```
