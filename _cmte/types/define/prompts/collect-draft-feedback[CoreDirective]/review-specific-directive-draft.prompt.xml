<ReviewDraftDefineTypesProposalResponseToArchitect>
  <Context>
You are the lead developer for the **CoreDirective** service.
The System Architect has proposed draft TypeScript types for  based on input from you and other leads.
**CRITICAL NOTE:** &apos;define&apos; in Meld **exclusively** embeds *text content* or *variable values*.
Review the following:
1. **Overall Architecture:**
    <DocsDevDiArchitectureMd>
```javascript
# Meld Architecture

## INTRODUCTION

Meld is a specialized, directive-based scripting language designed for embedding small "@directives" inside an otherwise plain text (e.g., Markdown-like) document. The code in this repository implements:

• Meld grammar rules and token types (e.g., text directives, path directives, data directives).  
• The parsing layer that converts Meld content into an AST (Abstract Syntax Tree).  
• A directive interpretation layer that processes these AST nodes and manipulates internal "states" to store variables and more.  
• A resolution layer to handle variable references, path expansions, data manipulations, etc.  
• Testing utilities and an in-memory FS (memfs) to simulate filesystems for thorough testing.  

The main idea:  
1. Meld code is parsed to an AST.  
2. Each directive node is validated and interpreted, updating a shared "state" (variables, data structures, commands, etc.).  
3. Optional transformations (e.g., output formatting) generate final representations (Markdown, LLM-friendly XML, etc.).  

Below is an overview of the directory and service-level architecture, referencing code from this codebase.

## DEPENDENCY INJECTION ARCHITECTURE

Meld uses TSyringe for dependency injection, which brings the following benefits:

• Decoupled service creation from service usage
• Simplified testing with mock injections
• Clear dependencies between services
• Centralized service configuration

### DI Core Concepts

1. **Service Registration**: Services are registered with the DI container via the `@Service()` decorator, which handles automatic registration with the container.

2. **Dependency Injection**: Services declare their dependencies using constructor parameters with the `@inject()` decorator, allowing the container to provide the correct dependencies.

3. **Container Resolution**: The container automatically resolves dependencies when creating instances, managing the entire dependency tree.

4. **Interface-based Design**: Services follow an interface-first design pattern, where each service implements an interface (e.g., `IFileSystemService`) and dependencies are declared using interface tokens.

5. **Circular Dependency Handling**: Circular dependencies are managed through the Client Factory pattern, which creates focused client interfaces for specific service interactions.

### DI Configuration

The core DI configuration is managed in `core/di-config.ts`, which:

1. Configures the global container
2. Registers core services and client factories
3. Connects services via their respective client interfaces
4. Registers remaining services using class registrations

## DIRECTORY & FILE STRUCTURE

At a high level, the project is arranged as follows (select key entries included):

project-root/  
 ├─ api/                    ← High-level API and tests  
 │   ├─ api.test.ts  
 │   └─ index.ts  
 ├─ bin/                    ← CLI entry point  
 │   └─ meld.ts  
 ├─ cli/                    ← CLI implementation  
 │   ├─ cli.test.ts  
 │   └─ index.ts  
 ├─ core/                   ← Core utilities and types  
 │   ├─ config/            ← Configuration (logging, etc.)  
 │   ├─ errors/            ← Error class definitions  
 │   │   ├─ MeldError.ts
 │   │   ├─ ServiceInitializationError.ts   ← Service initialization errors
 │   │   └─ ... other errors
 │   ├─ types/             ← Core type definitions  
 │   │   ├─ dependencies.ts  ← Service dependency definitions
 │   │   └─ index.ts
 │   ├─ utils/             ← Logging and utility modules  
 │   │   ├─ logger.ts
 │   │   ├─ serviceValidation.ts  ← Service validation utilities
 │   │   └─ simpleLogger.ts
 │   └─ ServiceProvider.ts ← DI service provider & helpers
 ├─ services/              ← Core service implementations  
 │   ├─ pipeline/          ← Main transformation pipeline  
 │   │   ├─ ParserService/     ← Initial parsing  
 │   │   ├─ InterpreterService/← Pipeline orchestration  
 │   │   ├─ DirectiveService/  ← Directive handling  
 │   │   │   ├─ handlers/  
 │   │   │   │   ├─ definition/   ← Handlers for definition directives  
 │   │   │   │   └─ execution/    ← Handlers for execution directives  
 │   │   │   └─ errors/  
 │   │   └─ OutputService/    ← Final output generation  
 │   ├─ state/             ← State management  
 │   │   ├─ StateService/      ← Core state management  
 │   │   └─ StateEventService/ ← Core event system  
 │   ├─ resolution/        ← Resolution and validation  
 │   │   ├─ ResolutionService/ ← Variable/path resolution  
 │   │   ├─ ValidationService/ ← Directive validation  
 │   │   └─ CircularityService/← Circular dependency detection  
 │   ├─ fs/                ← File system operations  
 │   │   ├─ FileSystemService/ ← File operations  
 │   │   ├─ PathService/      ← Path handling  
 │   │   └─ PathOperationsService/ ← Path utilities  
 │   └─ cli/               ← Command line interface  
 │       └─ CLIService/    ← CLI entry point  
 ├─ tests/                  ← Test infrastructure   
 │   ├─ fixtures/          ← Test fixture data  
 │   ├─ mocks/             ← Test mock implementations  
 │   └─ utils/             ← Test utilities and helpers  
 │       ├─ debug/         ← Test debug utilities  
 │       │   ├─ StateDebuggerService/  
 │       │   ├─ StateVisualizationService/  
 │       │   ├─ StateHistoryService/  
 │       │   └─ StateTrackingService/  
 │       ├─ di/            ← DI test utilities
 │       │   ├─ TestContainerHelper.ts ← Container management for tests
 │       │   └─ TestContextDI.ts ← DI-enabled test context
 │       ├─ FixtureManager.ts  
 │       ├─ MemfsTestFileSystem.ts  
 │       ├─ ProjectBuilder.ts  
 │       ├─ TestContext.ts  
 │       └─ TestSnapshot.ts  
 ├─ docs/                   ← Documentation  
 ├─ package.json  
 ├─ tsconfig.json  
 ├─ tsup.config.ts  
 └─ vitest.config.ts  

Key subfolders:  
• services/pipeline/: Core transformation pipeline services (parsing, interpretation, directives, output)  
• services/state/: State management and event services  
• services/resolution/: Resolution, validation, and circularity detection services  
• services/fs/: File system, path handling, and operations services  
• services/cli/: Command line interface services  
• core/: Central types, errors, utilities, and DI service provider used throughout the codebase  
• tests/utils/: Test infrastructure including debug utilities, memfs implementation, fixture management, and test helpers  
• tests/utils/di/: DI-specific test utilities
• api/: High-level public API for using Meld programmatically  
• cli/: Command line interface for Meld  

## CORE LIBRARIES & THEIR ROLE

### meld-ast 
   • parse(content: string): MeldNode[]  
   • Basic parsing that identifies directives vs. text nodes.  
   • Produces an AST which other services manipulate.  

### llmxml 
   • Converts content to an LLM-friendly XML format or can parse partially.  
   • OutputService may call it if user requests "llm" format.  

### meld-spec
   • Contains interface definitions for MeldNode, DirectiveNode, TextNode, etc.  
   • Contains directive kind enumerations.  

### tsyringe
   • Provides the dependency injection container
   • Manages service creation and resolution
   • Handles dependencies between services

## HIGH-LEVEL FLOW

Below is a simplified flow of how Meld content is processed:

   ┌─────────────────────────────┐
   │   Meld Source Document      │
   └─────────────────────────────┘
                │
                ▼
   ┌─────────────────────────────┐
   │ ParserService.parse(...)    │
   │   → uses meld-ast to parse  │
   └─────────────────────────────┘
                │ AST (MeldNode[])
                ▼
   ┌─────────────────────────────────────────────────┐
   │ InterpreterService.interpret(nodes, options)    │
   │   → For each node, pass to DirectiveService     │
   │   → Handles node transformations                │
   └─────────────────────────────────────────────────┘
                │
                ▼
   ┌──────────────────────────────────────────┐
   │ DirectiveService                         │
   │   → Routes to correct directive handler  │
   │   → Handlers can provide replacements    │
   └──────────────────────────────────────────┘
                │
                ▼
   ┌───────────────────────────────────────────────┐
   │ StateService + ResolutionService + Others     │
   │   → Stores variables and transformed nodes    │
   │   → Path expansions, data lookups, etc.       │
   └───────────────────────────────────────────────┘
                │
                ▼
   ┌──────────────────────────────────────────┐
   │ OutputService                            │
   │   → Uses transformed nodes for output    │
   │   → Generates clean, directive-free      │
   │     markdown, LLM XML, or other formats  │
   └──────────────────────────────────────────┘

This flow is orchestrated through DI, where the container resolves all required services and their dependencies automatically. The DI container handles service creation, ensuring each service gets the dependencies it needs to function properly.

## MAJOR SERVICES (OVERVIEW)

Below are the key "services" in the codebase. Each follows the single responsibility principle and is registered with the DI container via the `@Service()` decorator:

### CLIService
   - Provides command-line interface for running Meld
   - Handles file watching and reprocessing
   - Manages format selection and output options
   - Routes to appropriate services based on CLI flags
   - Dependencies: ParserService, InterpreterService, OutputService, FileSystemService, PathService, StateService

### ParserService  
   - Wraps the meld-ast parse(content) function  
   - Adds location information with file paths (parseWithLocations)  
   - Produces an array of MeldNode objects  
   - Dependencies: ResolutionServiceClient (for resolving variables during parsing)

### DirectiveService  
   - Routes directives to the correct directive handler  
   - Validates directives using ValidationService  
   - Calls ResolutionService for variable resolution  
   - Updates StateService with directive execution results
   - Supports node transformation through DirectiveResult interface
   - Handlers can provide replacement nodes for transformed output
   - Dependencies: ValidationService, StateService, PathService, FileSystemService, ParserService, InterpreterService, CircularityService, ResolutionService

### InterpreterService  
   - Orchestrates the main interpret(nodes) pipeline  
   - For each AST node:
       a) If it's text, store it or pass it along  
       b) If it's a directive:
          - Calls DirectiveService for processing
          - Handles node transformations if provided
          - Updates state with transformed nodes
   - Maintains the top-level process flow
   - Supports transformation mode through feature flags
   - Dependencies: DirectiveService, StateService, ParserService, FileSystemService, PathService, CircularityService

### StateService  
   - Stores variables in maps:
       • textVars (for @text)  
       • dataVars (for @data)  
       • pathVars (for @path)  
       • commands (for @define)  
   - Tracks both original and transformed MeldNodes
   - Provides transformation capabilities for directive processing
   - Maintains transformation state during cloning
   - Provides child states for nested imports  
   - Supports immutability toggles  
   - Dependencies: StateFactory, StateEventService, StateTrackingService

### ResolutionService  
   - Handles all variable interpolation:
       • Variables ("{{var}}", "{{data.field}}")
       • Path expansions ("$HOMEPATH/path")  
       • Command references  
   - Context-aware resolution  
   - Circular reference detection  
   - Sub-fragment parsing support  
   - Dependencies: StateService, FileSystemService, ParserServiceClient, PathService

### CircularityService  
   - Prevents infinite import loops  
   - Detects circular variable references  
   - Maintains dependency graphs  
   - Dependencies: ResolutionService

### PathService  
   - Validates and normalizes paths  
   - Enforces path security constraints  
   - Handles path joining and manipulation  
   - Supports test mode for path operations  
   - Dependencies: FileSystemServiceClient (to check if paths exist)

### ValidationService  
   - Validates directive syntax and constraints  
   - Provides extensible validator registration  
   - Throws MeldDirectiveError on validation failures  
   - Tracks available directive kinds  
   - Dependencies: ResolutionService

### FileSystemService  
   - Abstracts file operations (read, write)  
   - Supports both real and test filesystems  
   - Handles path resolution and validation  
   - Dependencies: PathOperationsService, PathServiceClient, IFileSystem

### OutputService  
   - Converts final AST and state to desired format
   - Uses transformed nodes when available
   - Supports markdown and LLM XML output  
   - Integrates with llmxml for LLM-friendly formatting  
   - Handles format-specific transformations
   - Provides clean output without directive definitions
   - Dependencies: StateService, ResolutionService, VariableReferenceResolverClient

## TESTING INFRASTRUCTURE

All tests are heavily reliant on a memory-based filesystem (memfs) for isolation and speed. The major testing utilities include:

### TestContainerHelper
   - Manages DI containers for tests
   - Provides isolated container creation
   - Supports mock registration and service resolution
   - Handles container cleanup between tests
   - Detects container state leaks

### TestContextDI
   - Central test harness that extends TestContext with DI support
   - Creates a DI container for each test
   - Provides mock service registration
   - Supports child context creation
   - Ensures proper cleanup after tests
   - Resolves services from the container for testing

### MemfsTestFileSystem  
   - Thin wrapper around memfs  
   - Offers readFile, writeFile, mkdir, etc. with in-memory data  
   - Provides an ephemeral environment for all test IO  

### TestContext  
   - Base class for testing environment
   - Provides references to all major services
   - Allows writing files, snapshotting the FS, and comparing  

### TestSnapshot  
   - Takes "snapshots" of the current Memfs FS, storing a Map<filePath, content>  
   - Compares snapshots to detect added/removed/modified files  

### ProjectBuilder  
   - Creates mock "projects" in the in-memory FS from JSON structure  
   - Useful for complex, multi-file tests or large fixture-based testing  

### Node Factories  
   - Provides helper functions for creating AST nodes in tests  
   - Supports creating directive, text, and code fence nodes  
   - Includes location utilities for source mapping  

Testing Organization:
• tests/utils/: Core test infrastructure (MemFS, snapshots, contexts)  
• tests/utils/di/: DI-specific test utilities
• tests/mocks/: Minimal mocks and test doubles  
• tests/fixtures/: JSON-based test data  
• tests/services/: Service-specific integration tests  

Testing Approach:
• Each test uses TestContextDI to create a fresh container
• Direct service resolution from the container
• Mock registration for dependencies
• Isolated container state between tests
• Factory functions for creating test nodes and data
• Snapshots for tracking filesystem changes  

## DEBUGGING INFRASTRUCTURE

The codebase includes specialized debugging services located in `tests/utils/debug/` that help diagnose and troubleshoot state-related issues:

### StateDebuggerService
   - Provides debug session management and diagnostics
   - Tracks state operations and transformations
   - Offers operation tracing and analysis
   - Helps identify state manipulation issues

### StateVisualizationService
   - Generates visual representations of state
   - Creates Mermaid/DOT graphs of state relationships
   - Visualizes state metrics and transformations
   - Aids in understanding complex state changes

### StateHistoryService
   - Records chronological state changes
   - Maintains operation history
   - Tracks transformation chains
   - Enables state change replay and analysis

### StateTrackingService
   - Monitors state relationships and dependencies
   - Tracks state lineage and inheritance
   - Records metadata about state changes
   - Helps debug scope and inheritance issues

Debugging Approach:
• Services can be enabled selectively in tests
• Debug output includes detailed state snapshots
• Visual representations help understand complex states
• History tracking enables step-by-step analysis

These debugging services are particularly useful for:
• Troubleshooting complex state transformations
• Understanding directive processing chains
• Analyzing variable resolution paths
• Debugging scope inheritance issues
• Visualizing state relationships

## SERVICE RELATIONSHIPS AND DEPENDENCY INJECTION

Services in Meld follow a dependency graph managed through the DI container:

1. Base Services:
   - FileSystemService (depends on PathOperationsService, PathServiceClient)
   - PathService (depends on FileSystemServiceClient)

2. State Management:
   - StateEventService (no dependencies)
   - StateService (depends on StateFactory, StateEventService, StateTrackingService)

3. Core Pipeline:
   - ParserService (depends on ResolutionServiceClient)
   - ResolutionService (depends on StateService, FileSystemService, PathService, ParserServiceClient)
   - ValidationService (depends on ResolutionService)
   - CircularityService (depends on ResolutionService)

4. Pipeline Orchestration:
   - DirectiveService (depends on multiple services)
   - InterpreterService (orchestrates others)

5. Output Generation:
   - OutputService (depends on StateService, ResolutionService, VariableReferenceResolverClient)

6. Debug Support:
   - DebuggerService (optional, depends on all)

## Dependency Resolution Patterns

### Circular Dependency Challenges

Circular dependencies occur when two or more services depend on each other, creating a dependency cycle:

- **FileSystemService ↔ PathService**: FileSystemService needs PathService for path resolution, while PathService needs FileSystemService to check if paths exist
- **ParserService ↔ ResolutionService**: ParserService needs ResolutionService to resolve variables, while ResolutionService needs ParserService to parse content
- **StateService ↔ StateTrackingService**: Complex bidirectional relationship for state tracking and management

### Client Factory Pattern (Current Approach)

The primary approach for handling circular dependencies in Meld is the Client Factory pattern:

1. Create minimal client interfaces that expose only the methods needed by the dependent service
2. Implement factories to create these client interfaces
3. Inject the factories rather than the actual services
4. Use the clients to access only the functionality that's actually needed

This pattern follows the Interface Segregation Principle (the "I" in SOLID), ensuring that services depend only on the methods they actually use.

#### Example Implementation

For the FileSystemService ↔ PathService circular dependency:

```typescript
// Minimal interface for what FileSystemService needs from PathService
export interface IPathServiceClient {
  resolvePath(path: string): string;
  normalizePath(path: string): string;
}

// Factory to create a client for PathService functionality
@injectable()
@Service({
  description: 'Factory for creating path service clients'
})
export class PathServiceClientFactory {
  constructor(@inject('IPathService') private pathService: IPathService) {}
  
  createClient(): IPathServiceClient {
    return {
      resolvePath: (path) => this.pathService.resolvePath(path),
      normalizePath: (path) => this.pathService.normalizePath(path)
    };
  }
}

// Updated FileSystemService that depends on the factory
@injectable()
@Service({
  description: 'Service for file system operations'
})
export class FileSystemService implements IFileSystemService {
  private pathClient: IPathServiceClient;
  
  constructor(
    @inject('IPathOperationsService') private readonly pathOps: IPathOperationsService,
    @inject('PathServiceClientFactory') pathClientFactory: PathServiceClientFactory,
    @inject('IFileSystem') fileSystem: IFileSystem | null = null
  ) {
    this.fs = fileSystem || new NodeFileSystem();
    this.pathClient = pathClientFactory.createClient();
  }
  
  // Use the client interface directly
  private resolvePath(filePath: string): string {
    return this.pathClient.resolvePath(filePath);
  }
}
```
Similarly, implement the reverse direction with a  and .
    </DocsDevDiArchitectureMd>
    <DirectContainerResolutionAlternativeApproach>
For cases where the Client Factory pattern isn&apos;t feasible, direct container resolution with lazy loading can be used:
```typescript
import { resolveService } from '@core/ServiceProvider';

@injectable()
@Service({
  description: 'Service with lazy dependency resolution'
})
export class OutputService implements IOutputService {
  private resolverClient?: IVariableReferenceResolverClient;
  
  constructor(
    @inject('IStateService') private readonly stateService: IStateService,
    @inject('IResolutionService') private readonly resolutionService: IResolutionService
  ) {}
  
  /**
   * Get a resolver client using direct container resolution
   * This breaks circular dependencies by deferring resolution until needed
   */
  private getVariableResolver(): IVariableReferenceResolverClient | undefined {
    // Lazy-load the client only when needed
    if (!this.resolverClient) {
      try {
        // Get the factory from the container using ServiceProvider helper
        const factory = resolveService<VariableReferenceResolverClientFactory>(
          'VariableReferenceResolverClientFactory'
        );
        
        // Create the client
        this.resolverClient = factory.createClient();
        logger.debug('Successfully created VariableReferenceResolverClient');
      } catch (error) {
        logger.warn('Failed to create VariableReferenceResolverClient', { error });
      }
    }
    
    return this.resolverClient;
  }
  
  // Using the lazy-loaded client
  async convert(nodes: MeldNode[], state: IStateService, format: string = 'markdown'): Promise<string> {
    // Get the resolver only when needed
    const resolver = this.getVariableResolver();
    
    if (resolver && format === 'markdown') {
      // Process nodes using the resolver for field access
      return this.nodeToMarkdown(nodes, state, resolver);
    }
    
    // Fallback implementation if resolver isn't available
    return this.legacyConvert(nodes, state, format);
  }
}
```
This approach:
1. Avoids creating circular dependencies at initialization time
2. Loads dependencies only when they&apos;re actually needed
3. Provides fallback mechanisms when resolution fails
4. Uses the ServiceProvider helper  rather than direct container access
Key considerations when using direct container resolution:
1. Always include fallback mechanisms
2. Log resolution failures for debugging
3. Cache resolved instances for performance
4. Only resolve what you need, when you need it
      <BenefitsOfClientFactoryPattern>
1. **Clear Dependencies**: Services explicitly state what they need through focused interfaces
2. **Interface Segregation**: Services only get access to the specific methods they need
3. **No Null Checks**: Factory creates clients at initialization time, eliminating null checks
4. **Simpler Testing**: Small, focused interfaces are easier to mock
5. **Reduced Tight Coupling**: Services are coupled only to minimal interfaces
6. **Improved Code Readability**: Code intent becomes clearer when using direct method calls
7. **Better Maintainability**: Changes to service interfaces won&apos;t affect all dependent services
      </BenefitsOfClientFactoryPattern>
      <NamingConventions>
For consistency across the codebase, we follow these naming conventions:
- Client Interfaces:  (e.g., )
- Factory Classes:  (e.g., )
- Factory Methods:  for consistent API
      </NamingConventions>
      <TestingWithClientFactories>
Testing becomes more straightforward with the client factory pattern:
```typescript
describe('FileSystemService', () => {
  let context: TestContextDI;
  let service: IFileSystemService;
  
  beforeEach(() => {
    context = TestContextDI.create();
    
    // Create a mock client
    const mockPathClient = {
      resolvePath: vi.fn().mockReturnValue('/resolved/path'),
      normalizePath: vi.fn().mockReturnValue('normalized/path')
    };
    
    // Create a mock factory that returns our mock client
    const mockPathClientFactory = {
      createClient: vi.fn().mockReturnValue(mockPathClient)
    };
    
    // Register the mock factory
    context.registerMock('PathServiceClientFactory', mockPathClientFactory);
    
    // Resolve the service
    service = context.resolveSync('IFileSystemService');
  });
  
  afterEach(async () => {
    await context.cleanup();
  });
  
  it('should resolve paths using the path client', async () => {
    // Test that calling methods on the service uses the client correctly
    await service.readFile('some/path');
    
    // Verify the path client was used
    expect(mockPathClient.resolvePath).toHaveBeenCalledWith('some/path');
  });
});
```
For testing services that use direct container resolution, we register mocks directly with the container:
```typescript
describe('OutputService', () => {
  let context: TestContextDI;
  let service: IOutputService;
  
  beforeEach(() => {
    context = TestContextDI.create();
    
    // Create a mock resolver client
    const mockResolverClient = {
      accessFields: vi.fn().mockReturnValue('resolved value'),
      convertToString: vi.fn().mockReturnValue('formatted string')
    };
    
    // Create a mock factory that returns our mock client
    const mockFactory = {
      createClient: vi.fn().mockReturnValue(mockResolverClient)
    };
    
    // Register the mock factory with the container
    context.registerMock('VariableReferenceResolverClientFactory', mockFactory);
    
    // Resolve the service
    service = context.resolveSync('IOutputService');
  });
  
  afterEach(async () => {
    await context.cleanup();
  });
  
  it('should convert nodes to markdown with field access', async () => {
    const result = await service.convert(mockNodes, mockState, 'markdown');
    expect(result).toContain('formatted string');
  });
});
```
      </TestingWithClientFactories>
    </DirectContainerResolutionAlternativeApproach>
  </Context>
  <ExampleUsageScenario>
1. Input: A .meld file with lines like:@text greeting = "Hello"@data config = {
  "value": 123
}@import [ path = &quot;other.meld&quot; ]
2. We load the file from disk.
3. ParserService → parse the content → AST.
4. InterpreterService → interpret(AST).a) For each directive, DirectiveService → validation → resolution → update StateService.b) If an import is encountered, CircularityService ensures no infinite loops.
5. Once done, the final StateService has textVars.greeting = "Hello", dataVars.config = { value: 123 }, etc.
6. OutputService can generate the final text or an LLM-XML representation.
With DI, this flow is orchestrated through the container, which resolves all the required services and their dependencies automatically.
  </ExampleUsageScenario>
  <ErrorHandling>
• MeldDirectiveError thrown if a directive fails validation or interpretation.• MeldParseError if the parser cannot parse content.• PathValidationError for invalid paths.• ResolutionError for variable resolution issues.• MeldError as a base class for other specialized errors.• ServiceInitializationError for DI-related initialization failures.
These errors typically bubble up to the caller or test.
  </ErrorHandling>
  <Conclusion>
This codebase implements the entire Meld language pipeline:• Parsing Meld documents into an AST.• Validating &amp; interpreting directives.• Storing data in a hierarchical state.• Resolving references (text, data, paths, commands).• (Optionally) generating final formatted output.
The codebase uses TSyringe for dependency injection, which helps manage the complex relationships between services. The Client Factory pattern is used to handle circular dependencies between core services, with direct container resolution as an alternative for specific cases.
The test environment includes robust DI support with TestContextDI, allowing for isolated container testing, mock registration, and service resolution. The system adheres to SOLID design principles with interface-first design and clear separation of concerns.
  </Conclusion>
</ReviewDraftDefineTypesProposalResponseToArchitect>

<DependencyInjectionInMeld>
This document provides guidance on working with the dependency injection (DI) system in the Meld codebase.
  <Overview>
Meld uses [TSyringe](https://github.com/microsoft/tsyringe) for dependency injection. All services are registered and resolved through the DI container, which simplifies service initialization and testing.
  </Overview>
  <CoreConcepts>
    <1serviceRegistration>
Services are automatically registered with the DI container when they are decorated with the  decorator:
```typescript
import { Service } from '@core/ServiceProvider';

@Service({
  description: 'Service that provides file system operations'
})
export class FileSystemService implements IFileSystemService {
  // Implementation...
}
```
The  decorator registers the class with the container and adds some metadata for documentation purposes.
    </1serviceRegistration>
    <2dependencyInjection>
Services can inject their dependencies through constructor parameters:
```typescript
import { inject } from 'tsyringe';

@Service()
export class ResolutionService implements IResolutionService {
  constructor(
    @inject('IStateService') private stateService: IStateService,
    @inject('IFileSystemService') private filesystem: IFileSystemService,
    @inject('IParserService') private parser: IParserService,
    @inject('IPathService') private pathService: IPathService
  ) {}
  
  // Implementation...
}
```
    </2dependencyInjection>
    <3creatingServices>
Services should be created using the DI container, not with :
```typescript
// CORRECT: Let the DI container create the service
import { container } from 'tsyringe';
const service = container.resolve(ServiceClass);

// CORRECT: Use the ServiceProvider helper
import { createService } from '@core/ServiceProvider';
const service = createService(ServiceClass);

// INCORRECT: Don't use 'new' directly
const service = new ServiceClass(); // Avoid this
```
    </3creatingServices>
  </CoreConcepts>
  <BestPractices>
    <ServiceDesign>
1. **Interface-First Design**: Define an interface for your service before implementing it
2. **Explicit Dependencies**: Always specify dependencies in the constructor
3. **Private Injection**: Use  in constructor parameters to store the dependencies
4. **Explicit Return Types**: Always provide return types for methods
5. **Proper Initialization**: Services should be fully initialized after construction
    </ServiceDesign>
    <ExampleService>
```typescript
import { inject } from 'tsyringe';
import { Service } from '@core/ServiceProvider';

// 1. Define the interface
export interface IExampleService {
  process(data: string): Promise<string>;
  getStatus(): string;
}

// 2. Implement the service
@Service({
  description: 'Example service that demonstrates best practices'
})
export class ExampleService implements IExampleService {
  // 3. Constructor injection with explicit dependencies
  constructor(
    @inject('IDependencyService') private dependency: IDependencyService,
    @inject('ILoggerService') private logger: ILoggerService
  ) {}

  // 4. Explicit return type
  async process(data: string): Promise<string> {
    this.logger.log('Processing data...');
    return this.dependency.transform(data);
  }

  getStatus(): string {
    return 'Ready';
  }
}
```
    </ExampleService>
  </BestPractices>
  <TestingWithDi>
    <UsingTestcontextdi>
The  class provides utilities for testing with DI:
```typescript
import { TestContextDI } from '@tests/utils/di/TestContextDI';

describe('MyService', () => {
  let context: TestContextDI;
  
  beforeEach(() => {
    // Create a test context with DI
    context = TestContextDI.create();
  });
  
  afterEach(async () => {
    // Clean up resources
    await context.cleanup();
  });
  
  it('should process data correctly', async () => {
    // Register a mock dependency
    const mockDependency = { transform: vi.fn().mockReturnValue('transformed') };
    context.registerMock('IDependencyService', mockDependency);
    
    // Get the service from the container
    const service = context.container.resolve('IExampleService');
    
    // Test the service
    const result = await service.process('input');
    expect(result).toBe('transformed');
    expect(mockDependency.transform).toHaveBeenCalledWith('input');
  });
});
```
    </UsingTestcontextdi>
    <MockingServices>
To register mock implementations:
```typescript
// Register a mock instance
context.registerMock('IServiceName', mockImplementation);

// Register a mock class
context.container.registerMockClass('IServiceName', MockClass);
```
    </MockingServices>
  </TestingWithDi>
  <CommonPatterns>
    <DualModeConstructorPattern>
Meld services need to support both DI and non-DI modes. The recommended pattern is:
```typescript
/**
 * Constructor with DI annotations
 */
constructor(
  @inject(SomeFactory) factory?: SomeFactory,
  @inject('IService1') service1?: IService1,
  @inject('IService2') service2?: IService2
) {
  this.initializeFromParams(factory, service1, service2);
}

/**
 * Helper that chooses initialization path
 */
private initializeFromParams(
  factory?: SomeFactory,
  service1?: IService1,
  service2?: IService2
): void {
  if (factory) {
    this.initializeDIMode(factory, service1, service2);
  } else {
    this.initializeLegacyMode(service1, service2);
  }
}

/**
 * DI mode initialization
 */
private initializeDIMode(
  factory: SomeFactory,
  service1?: IService1,
  service2?: IService2
): void {
  this.factory = factory;
  this.service1 = service1;
  this.service2 = service2;
  // Additional initialization
}

/**
 * Legacy mode initialization
 */
private initializeLegacyMode(
  service1?: IService1,
  service2?: IService2
): void {
  // Create default dependencies
  this.factory = new SomeFactory();
  
  // Additional initialization
}
```
This pattern:
1. Keeps the constructor simple
2. Clearly separates DI and non-DI initialization logic
3. Makes maintenance easier
4. Preserves dual-mode functionality
5. Provides a clear path to eventually remove legacy mode
See  for more examples.
    </DualModeConstructorPattern>
    <FactoryPattern>
For services that need complex initialization or multiple instances:
```typescript
@Service()
export class ServiceFactory {
  constructor(
    @inject('IDependencyA') private depA: IDependencyA,
    @inject('IDependencyB') private depB: IDependencyB
  ) {}
  
  createService(config: ServiceConfig): IService {
    // Create a specialized instance with the given config
    // The factory can use its injected dependencies
    return new SpecializedService(this.depA, this.depB, config);
  }
}
```
    </FactoryPattern>
    <ServiceProviders>
For centralized service registration:
```typescript
// In a central di-config.ts file:
import { container } from 'tsyringe';

// Register core services
container.register('FileSystemService', { useClass: FileSystemService });
container.register('IFileSystemService', { useToken: 'FileSystemService' });
```
    </ServiceProviders>
  </CommonPatterns>
  <Troubleshooting>
    <CircularDependencies>
If you have circular dependencies, use  with a string token instead of a direct class reference:
```typescript
// Instead of this (can cause circular dependency issues):
constructor(@inject(DependentService) private dependent: DependentService)

// Do this:
constructor(@inject('IDependentService') private dependent: IDependentService)
```
    </CircularDependencies>
    <MissingDependencies>
If a service fails to resolve with &quot;unregistered dependency token&quot; errors:
1. Check that the service is decorated with 
2. Verify that the injected token is registered in the container
3. Check for typos in the injection token string
4. Make sure the services are imported and executed before use
    </MissingDependencies>
    <TestingIssues>
If tests fail with DI errors:
1. Use  to create a clean container for each test
2. Register all required mock dependencies before resolving the service
3. Clean up after tests with
```

#### ../../docs/dev/PIPELINE.md
```javascript
# Meld Pipeline Flow

## Overview

The Meld pipeline processes `.mld` files through several stages to produce either `.xml` or `.md` output. Here's a detailed look at how it works:

```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│  Service    │     │   Service   │     │   Pipeline   │     │  Variable    │     │    Final     │
│Initialization├────►│ Validation  ├────►│  Execution   ├────►│  Resolution  ├────►│   Output     │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
      │                    │                    │                    │                    │
      ▼                    ▼                    ▼                    ▼                    ▼
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│Dependencies │     │Validate All │     │Process Input │     │Resolve Vars & │     │Generate Clean│
│  Resolved   │     │ Services    │     │   Content    │     │  References   │     │   Output    │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
```
    </TestingIssues>
  </Troubleshooting>
  <ServiceOrganization>
The pipeline is organized into logical service groups, with strict initialization order and dependency validation:
    <PipelineServicesServicesPipeline>
```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐
│   Parser    │     │  Directive  │     │ Interpreter  │     │   Output     │
│   Service   ├────►│   Service   ├────►│   Service    ├────►│   Service    │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘
      │                    │                    │                    │
      ▼                    ▼                    ▼                    ▼
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐
│Initialize & │     │Validate &   │     │Transform &   │     │Format &     │
│  Validate   │     │Process Dirs │     │Update State  │     │Generate Out │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘
```
    </PipelineServicesServicesPipeline>
    <StateServicesServicesState>
```ascii
┌─────────────┐     ┌─────────────┐
│    State    │     │    State    │
│   Service   ├────►│    Event    │
└─────────────┘     │   Service   │
                    └─────────────┘
```
    </StateServicesServicesState>
    <ResolutionServicesServicesResolution>
```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐
│ Resolution  │     │ Validation  │     │ Circularity  │
│   Service   ├────►│   Service   ├────►│   Service    │
└─────────────┘     └─────────────┘     └──────────────┘
```
    </ResolutionServicesServicesResolution>
    <FileSystemServicesServicesFs>
```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐
│    File     │     │    Path     │     │     Path     │
│   System    ├────►│   Service   ├────►│  Operations  │
│   Service   │     │             │     │   Service    │
└─────────────┘     └─────────────┘     └──────────────┘
```
    </FileSystemServicesServicesFs>
  </ServiceOrganization>
  <DetailedFlow>
1. **Service Initialization** ()
- Resolves service dependencies
- Initializes in correct order
- Validates service configuration
- Enables transformation if requested
2. **Input Processing** ()
- User runs 
-  handles command line options
- Default output is  format
- Can specify  for  output
- Supports  for direct console output
3. **Parsing** ()
- Reads the input file content
- Parses into AST using 
- Identifies directives and text nodes
- Adds source location information
4. **Interpretation** ()
- Processes each AST node sequentially
- Routes directives to appropriate handlers
- Handlers can provide replacement nodes
- Maintains both original and transformed states
- Resolves variables and references
- Handles file imports and embedding
5. **Variable Resolution** ()
- Resolves variable references like 
- Handles field access with dot and bracket notation
- Supports nested object and array access
- Manages path variable resolution and prefixing
- Provides two architecture models:
- Traditional: OutputService handles resolution
- Delegated: ResolutionService handles resolution
6. **Output Generation** ()
- Takes transformed nodes and state
- Converts to requested format:
- : Uses  library for LLM-friendly XML
- : Clean markdown without directive definitions
- Writes output to file or stdout
  </DetailedFlow>
  <TransformationModeAndVariableResolution>
When transformation mode is enabled, the pipeline handles directives and variables in a special way. Understanding this flow is critical for debugging and enhancing directive handlers:
```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐
│  Directive  │     │Interpretation│     │   Variable   │     │   Output     │
│  Handlers   ├────►│  & Node     ├────►│  Resolution  ├────►│  Generation  │
│(with replace│     │Transformation│     │              │     │              │
│  nodes)     │     │              │     │              │     │              │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘
```
    <KeyTransformationPipelineConcepts>
1. **Directive Handler Replacement Nodes**
- Directive handlers can return replacement nodes when in transformation mode
- The InterpreterService must properly apply these replacements in the transformed nodes array
- For import directives, the replacement is typically an empty text node
- For embed directives, the replacement node contains the embedded content
2. **State Propagation Across Boundaries**
- Variables must be explicitly copied between parent and child states
- When importing files, variables must be copied from imported state to parent state
- The ImportDirectiveHandler must ensure all variable types (text, data, path, commands) are copied
3. **Variable Resolution Process**
- Variables can be resolved at multiple stages:
- During directive processing
- During node transformation
- During final output generation
- During post-processing in the main function
- Meld supports two distinct architectures for variable resolution:
- **Traditional Architecture**: OutputService resolves variables directly during final rendering
- **Delegated Architecture**: OutputService delegates to ResolutionService for variable resolution
- Architecture is controlled by the  feature flag or the  environment variable
4. **State Management for Transformation**
- The StateService maintains both original and transformed node arrays
- Transformed nodes must be explicitly initialized
- The transformNode method is used to replace directive nodes with their outputs
- State must keep track of transformation options to determine which directives to transform
    </KeyTransformationPipelineConcepts>
  </TransformationModeAndVariableResolution>
  <ServiceResponsibilities>
    <PipelineServices>
1. **ParserService** ()
- Wraps meld-ast parser
- Produces AST nodes
- Adds file location information
2. **InterpreterService** ()
- Orchestrates directive processing
- Handles node transformations
- Maintains interpretation state
- Handles imports and embedding
- **Critical for transformation:** Applies directive handler replacement nodes to transformed node array
- **State propagation:** Ensures proper variable inheritance between parent and child states
3. **DirectiveService** ()
- Routes directives to handlers
- Validates directive syntax
- Supports node transformation
- Updates state based on directive results
- **Directive handlers:** Can return replacement nodes in transformation mode
- **Handler context:** Includes parent state for proper variable propagation
4. **OutputService** ()
- Uses transformed nodes for clean output
- Supports markdown and LLM XML
- Generates directive-free output
- Handles formatting options
- **Variable resolution:** Resolves variable references in text nodes during output generation
- **Transformation handling:** Uses special processing for variable references in transformation mode
    </PipelineServices>
    <StateServices>
1. **StateService** ()
- Stores variables and commands
- Maintains original and transformed nodes
- Manages scope and inheritance
- Tracks file dependencies
- **Transformation support:** Keeps track of both original and transformed node arrays
- **Variable copying:** Must explicitly copy variables between parent and child states
- **Transformation options:** Supports selective transformation of different directive types
2. **StateEventService** ()
- Handles state change events
- Manages state updates
- Provides event hooks
- Supports state tracking
    </StateServices>
    <ResolutionServices>
1. **ResolutionService** ()
- Resolves variables and references
- Handles path expansions
- Manages circular dependencies
2. **ValidationService** ()
- Validates directive syntax and constraints
- Provides extensible validator registration
- Throws MeldDirectiveError on validation failures
- Tracks available directive kinds
3. **CircularityService** ()
- Prevents infinite import loops
- Detects circular variable references
- Maintains dependency graphs
    </ResolutionServices>
    <FileSystemServices>
1. **FileSystemService** ()
- Abstracts file operations (read, write)
- Supports both real and test filesystems
- Handles path resolution and validation
2. **PathService** ()
- Validates and normalizes paths
- Enforces path security constraints
- Handles path joining and manipulation
- Supports test mode for path operations
3. **PathOperationsService** ()
- Handles complex path operations
- Provides path utilities
- Manages path transformations
```




2.  **`@define` Documentation:** 



#### ../../_dev/DEFINE-CLARITY.md
```javascript
# @define Directive: Understanding and Implementation

## Core Concept: Creating Reusable Command Templates

The `@define` directive allows you to create named, reusable templates for runnable commands (both shell commands and language scripts). These templates can accept parameters, making them function like simple macros or functions within Meld.

Defined commands are invoked using the `@run $commandName(...)` syntax.

## Syntax

There are two primary forms:

**1. Defining Basic Commands (Shell Commands):**

```meld
@define commandName(param1, param2) = @run [command template with {{param1}} and {{param2}}]

// Or for multiline commands:
@define multiCmd(arg) = @run [[
  echo "Starting script with {{arg}}"
  ./run_script.sh {{arg}}
]]
```
- ****: The identifier (no @run $commandName(...)`.
- ****: An optional list of parameter names, acting as placeholders within the command template.
- ****: Separator.
- ** or **: The right-hand side **must** be a   directive. This defines the shell command template to be executed.
**2. Defining Language Commands (JS, Python, Bash):**
```meld
@define jsCommand(name, value) = @run js(name, value) [[
  // Raw JavaScript code using parameters name & value
  console.log(`Processing ${name}: ${value}`);
  // Note: {{variables}} are NOT interpolated here
]]

@define pyCommand(inputPath) = @run python(inputPath) [[
# Raw Python code
import sys
input_file = sys.argv[1]
print(f"Processing {input_file}")
# ...
]]
```
- ****: Identifier for the language command.
- ****: Parameters expected by the language script.
- ****: The right-hand side **must** be a   directive. This defines the language, the parameters it accepts, and the *raw code block* to be executed.
    </FileSystemServices>
  </ServiceResponsibilities>
  <CommandTemplateBodyForBasicCommands>
When defining a Basic Command template ( or ):
- **Shell Command**: It should be a valid shell command string.
- **Parameter Placeholders**: It can contain , , etc., corresponding to the parameters defined in the parentheses . These will be replaced by the arguments provided when the command is invoked via .
- **Other Variables**: It can also contain standard Meld variable references (, ). These are *not* resolved when  is processed; they are resolved *at the time the command is executed* via .
- **Multiline Syntax ()**: If using double brackets, the first newline immediately following  is ignored.
  </CommandTemplateBodyForBasicCommands>
  <LanguageCodeBlockForLanguageCommands>
When defining a Language Command template ():
- **Raw Code**: The content within  is treated as **raw source code** for the specified language (js, python, bash).
- **NO Interpolation**: Variables (, ) inside the  block are **NOT** interpolated. The code is passed directly to the language interpreter.
- **Parameters**: The parameters defined in  are passed to the script at runtime (e.g., as command-line arguments).
  </LanguageCodeBlockForLanguageCommands>
  <CoreImplementationDefinedirectivehandler>
The  handler primarily acts as a storage mechanism:
1. **Validate Syntax**: Checks the overall  structure.
2. **Extract Components**: Parses the directive to get the  (without parameters[
  "param1",
  "param2"
]@run` directive (its kind - basic or language, the command template string or code block, the language if applicable).
3. **Store Definition**: Creates a  object containing the  array and the necessary details from the  directive (e.g., the literal command template string for basic commands, or the language and raw code block for language commands).
4. **Update State**: Stores this  object in the current execution state using . Metadata can also be stored.
**Important**: The  handler does *not* execute anything or resolve variables within the template/code block. It simply stores the definition.
  </CoreImplementationDefinedirectivehandler>
  <InteractionWithRunCommandname>
The execution logic resides within the  and its  subtype:
1. **Invocation**: 
2. **Retrieve Definition**: Fetches the  for  from the state.
3. **Resolve Arguments**: Resolves the arguments (, ) provided in the  call.
4. **Execution based on Definition Type**:
- **If Basic Command Definition**: Substitutes the resolved arguments *positionally* into the stored command template string (replacing , , etc.). The resulting command string is then executed, resolving any other variables (, ) at that time.
- **If Language Command Definition**: Passes the resolved arguments to the stored language script (e.g., as command-line arguments  in Python,  in Node). The raw code block stored in the definition is executed by the appropriate language interpreter.
  </InteractionWithRunCommandname>
  <KeyImplementationAspectsConsiderations>
- **Positional Parameters**: Substitution/passing relies strictly on the order in the  parameter list and the  argument list.
- **Delayed Resolution (Basic Commands)**: Variables (, ) within a basic command template are resolved only when invoked via .
- **No Interpolation (Language Commands)**: The code block for language commands is executed raw; use the defined parameters to pass data into the script.
- **No Direct Output**:  only modifies state.
  </KeyImplementationAspectsConsiderations>
  <ValidationCriteria>
A correct  implementation ensures:
- Both basic and language command definitions are correctly parsed and stored.
- Invocation via  correctly retrieves the definition and identifies its type.
- Arguments passed to  are resolved correctly.
- For basic commands: Positional parameter substitution into the template works reliably, and the final command executes correctly.
- For language commands: Resolved arguments are passed correctly to the script, and the stored code block is executed by the correct interpreter.
```




3.  **Your Service Code (`CoreDirective`)**: 



#### ../../services/pipeline/DirectiveService/DirectiveService.ts
```javascript
import type { DirectiveNode, DirectiveKind, DirectiveData } from '@core/syntax/types/index.js';
import { directiveLogger } from '@core/utils/logger.js';
import { IDirectiveService, IDirectiveHandler, DirectiveContext } from '@services/pipeline/DirectiveService/IDirectiveService.js';
import type { 
  ValidationServiceLike, 
  StateServiceLike, 
  PathServiceLike, 
  FileSystemLike, 
  ParserServiceLike, 
  InterpreterServiceLike,
  CircularityServiceLike, 
  ResolutionServiceLike,
  DirectiveServiceLike
} from '@core/shared-service-types.js';
import { MeldDirectiveError } from '@core/errors/MeldDirectiveError.js';
import { DirectiveError, DirectiveErrorCode, DirectiveErrorSeverity } from '@services/pipeline/DirectiveService/errors/DirectiveError.js';
import { ErrorSeverity } from '@core/errors/MeldError.js';
import type { ILogger } from '@services/pipeline/DirectiveService/handlers/execution/EmbedDirectiveHandler.js';
import { Service } from '@core/ServiceProvider.js';
import { inject, delay, injectable } from 'tsyringe';
import { container } from 'tsyringe';
import type { IResolutionServiceClientForDirective } from '@services/pipeline/ResolutionService/interfaces/IResolutionServiceClientForDirective.js';
import { ResolutionServiceClientForDirectiveFactory } from '@services/pipeline/ResolutionService/factories/ResolutionServiceClientForDirectiveFactory.js';
import { InterpreterServiceClientFactory } from '@services/pipeline/InterpreterService/factories/InterpreterServiceClientFactory.js';
import type { IInterpreterServiceClient } from '@services/pipeline/InterpreterService/interfaces/IInterpreterServiceClient.js';
import { DirectiveResult } from './interfaces/DirectiveTypes.js';

// Import all handlers
import { TextDirectiveHandler } from '@services/pipeline/DirectiveService/handlers/definition/TextDirectiveHandler.js';
import { DataDirectiveHandler } from '@services/pipeline/DirectiveService/handlers/definition/DataDirectiveHandler.js';
import { PathDirectiveHandler } from '@services/pipeline/DirectiveService/handlers/definition/PathDirectiveHandler.js';
import { DefineDirectiveHandler } from '@services/pipeline/DirectiveService/handlers/definition/DefineDirectiveHandler.js';
import { RunDirectiveHandler } from '@services/pipeline/DirectiveService/handlers/execution/RunDirectiveHandler.js';
import { EmbedDirectiveHandler } from '@services/pipeline/DirectiveService/handlers/execution/EmbedDirectiveHandler.js';
import { ImportDirectiveHandler } from '@services/pipeline/DirectiveService/handlers/execution/ImportDirectiveHandler.js';

export class MeldLLMXMLError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly details?: any
  ) {
    super(message);
    this.name = 'MeldLLMXMLError';
    Object.setPrototypeOf(this, MeldLLMXMLError.prototype);
  }
}

/**
 * Service responsible for handling directives
 */
@injectable()
@Service({
  description: 'Service responsible for handling and processing directives',
  dependencies: [
    { token: 'IValidationService', name: 'validationService' },
    { token: 'IStateService', name: 'stateService' },
    { token: 'IPathService', name: 'pathService' },
    { token: 'IFileSystemService', name: 'fileSystemService' },
    { token: 'IParserService', name: 'parserService' },
    { token: 'InterpreterServiceClientFactory', name: 'interpreterServiceClientFactory' },
    { token: 'ICircularityService', name: 'circularityService' },
    { token: 'IResolutionService', name: 'resolutionService' }
  ]
})
export class DirectiveService implements IDirectiveService, DirectiveServiceLike {
  private validationService!: ValidationServiceLike;
  private stateService!: StateServiceLike;
  private pathService!: PathServiceLike;
  private fileSystemService!: FileSystemLike;
  private parserService!: ParserServiceLike;
  private interpreterService?: InterpreterServiceLike; // Legacy reference
  private interpreterClient?: IInterpreterServiceClient; // Client from factory pattern
  private interpreterClientFactory?: InterpreterServiceClientFactory;
  private circularityService!: CircularityServiceLike;
  private resolutionService!: ResolutionServiceLike;
  private resolutionClient?: IResolutionServiceClientForDirective;
  private resolutionClientFactory?: ResolutionServiceClientForDirectiveFactory;
  private factoryInitialized: boolean = false;
  private interpreterFactoryInitialized: boolean = false;
  private initialized = false;
  private logger: ILogger;

  private handlers: Map<string, IDirectiveHandler> = new Map();

  /**
   * Creates a new DirectiveService instance.
   * Uses dependency injection for service dependencies.
   * 
   * @param validationService Validation service for directives (injected)
   * @param stateService State service for managing variables (injected)
   * @param pathService Path service for handling file paths (injected)
   * @param fileSystemService File system service for file operations (injected)
   * @param parserService Parser service for parsing Meld files (injected)
   * @param interpreterServiceClientFactory Factory for creating interpreter clients (injected)
   * @param circularityService Circularity service for detecting circular imports (injected)
   * @param resolutionService Resolution service for variable resolution (injected)
   * @param logger Logger for directive operations (optional)
   */
  constructor(
    @inject('IValidationService') validationService?: ValidationServiceLike,
    @inject('IStateService') stateService?: StateServiceLike,
    @inject('IPathService') pathService?: PathServiceLike,
    @inject('IFileSystemService') fileSystemService?: FileSystemLike,
    @inject('IParserService') parserService?: ParserServiceLike,
    @inject('InterpreterServiceClientFactory') interpreterServiceClientFactory?: InterpreterServiceClientFactory,
    @inject('ICircularityService') circularityService?: CircularityServiceLike,
    @inject('IResolutionService') resolutionService?: ResolutionServiceLike,
    @inject('DirectiveLogger') logger?: ILogger
  ) {
    // Always ensure we have a logger (both in DI and non-DI modes)
    this.logger = logger || directiveLogger;
    
    // Skip initialization if we're in DI mode and not all required services are provided
    if (validationService && stateService && pathService && fileSystemService && 
        parserService && circularityService && resolutionService) {
      this.initializeFromParams(
        validationService,
        stateService,
        pathService,
        fileSystemService,
        parserService,
        undefined, // Replaced by interpreterServiceClientFactory
        circularityService,
        resolutionService
      );
    } else {
      // In non-DI mode or when not fully initialized, just set up the logger
      this.logger.debug('DirectiveService constructed but not fully initialized, call initialize() manually');
    }
    
    // Initialize interpreter client factory
    this.interpreterClientFactory = interpreterServiceClientFactory;
    if (this.interpreterClientFactory) {
      this.interpreterFactoryInitialized = true;
      this.initializeInterpreterClient();
    }
    
    // Set initialized to true before registering handlers
    this.initialized = true;
    
    // Register default handlers
    this.registerDefaultHandlers();
  }
  
  /**
   * Initialize this service with the given parameters.
   * Uses DI-only mode for initialization.
   */
  private initializeFromParams(
    validationService?: ValidationServiceLike,
    stateService?: StateServiceLike,
    pathService?: PathServiceLike,
    fileSystemService?: FileSystemLike,
    parserService?: ParserServiceLike,
    interpreterServiceClientFactory?: InterpreterServiceClientFactory,
    circularityService?: CircularityServiceLike,
    resolutionService?: ResolutionServiceLike
  ): void {
    // Verify that required services are provided
    if (!validationService || !stateService || !pathService || 
        !fileSystemService || !parserService || 
        !circularityService || !resolutionService) {
      this.logger.warn('DirectiveService initialized with missing dependencies');
      return;
    }
    
    // Initialize all services
    this.validationService = validationService;
    this.stateService = stateService;
    this.pathService = pathService;
    this.fileSystemService = fileSystemService;
    this.parserService = parserService;
    this.circularityService = circularityService;
    this.resolutionService = resolutionService;
    
    // Set initialized to true
    this.initialized = true;
    
    // Handle the circular dependency with InterpreterService
    // We'll set this later in updateInterpreterService()
    // but use the delay-injected service if available
    if (interpreterServiceClientFactory) {
      // Use setTimeout to ensure all services are fully initialized
      setTimeout(() => {
        this.registerDefaultHandlers();
        this.logger.debug('DirectiveService initialized via DI', {
          handlers: Array.from(this.handlers.keys())
        });
      }, 0);
    }
  }

  /**
   * Explicitly initialize the service with all required dependencies.
   * @deprecated This method is maintained for backward compatibility. 
   * The service is automatically initialized via dependency injection.
   */
  initialize(
    validationService: ValidationServiceLike,
    stateService: StateServiceLike,
    pathService: PathServiceLike,
    fileSystemService: FileSystemLike,
    parserService: ParserServiceLike,
    interpreterServiceClientFactory: InterpreterServiceClientFactory,
    circularityService: CircularityServiceLike,
    resolutionService: ResolutionServiceLike
  ): void {
    this.validationService = validationService;
    this.stateService = stateService;
    this.pathService = pathService;
    this.fileSystemService = fileSystemService;
    this.parserService = parserService;
    this.circularityService = circularityService;
    this.resolutionService = resolutionService;
    this.initialized = true;

    // Initialize interpreter client factory
    this.interpreterClientFactory = interpreterServiceClientFactory;
    if (this.interpreterClientFactory) {
      this.interpreterFactoryInitialized = true;
      this.initializeInterpreterClient();
    }

    // Register default handlers
    this.registerDefaultHandlers();

    this.logger.debug('DirectiveService initialized manually', {
      handlers: Array.from(this.handlers.keys())
    });
  }

  /**
   * Register all default directive handlers
   * This is public to allow tests to explicitly initialize handlers in both DI and non-DI modes
   */
  public registerDefaultHandlers(): void {
    // Add debug logging to help diagnose DI issues
    this.logger.debug('Registering default handlers', {
      hasValidationService: !!this.validationService,
      hasStateService: !!this.stateService,
      hasResolutionService: !!this.resolutionService,
      hasFileSystemService: !!this.fileSystemService,
      stateTransformationEnabled: this.stateService?.isTransformationEnabled?.(),
      state: this.stateService ? {
        hasTrackingService: !!(this.stateService as any).trackingService,
        hasEventService: !!(this.stateService as any).eventService
      } : 'undefined'
    });

    try {
      // Definition handlers
      const textHandler = new TextDirectiveHandler(
        this.validationService!,
        this.stateService!,
        this.resolutionService!
      );
      
      // Set FileSystemService if available
      if (this.fileSystemService) {
        textHandler.setFileSystemService(this.fileSystemService);
      }
      
      this.registerHandler(textHandler);

      this.registerHandler(
        new DataDirectiveHandler(
          this.validationService!,
          this.stateService!,
          this.resolutionService!
        )
      );
    } catch (error) {
      this.logger.error('Error registering directive handlers', { error });
      throw error;
    }

    this.registerHandler(
      new PathDirectiveHandler(
        this.validationService!,
        this.stateService!,
        this.resolutionService!
      )
    );

    this.registerHandler(
      new DefineDirectiveHandler(
        this.validationService!,
        this.stateService!,
        this.resolutionService!
      )
    );

    // Execution handlers
    try {
      // Try to get CommandExecutionService from the container
      let commandExecutionService: any;
      try {
        commandExecutionService = container.resolve('ICommandExecutionService');
        this.logger.debug('Resolved CommandExecutionService from container');
      } catch (resolveError) {
        this.logger.warn('CommandExecutionService not found in container, creating mock for testing');
        
        // Create RunFeedbackManager for the mock
        const mockFeedbackManager = {
          showRunningCommandFeedback: (command: string) => {
            this.logger.debug(`Running command: ${command}`);
          },
          clearCommandFeedback: () => {},
          startCommandAnimation: (message: string) => {
            this.logger.debug(message || 'Running command...');
            return () => {};
          }
        };

        // Create a mock CommandExecutionService
        commandExecutionService = {
          executeShellCommand: async (command: string, options?: any) => {
            this.logger.debug(`Mock executing shell command: ${command}`);
            return { stdout: `Mock output for: ${command}`, stderr: '', exitCode: 0 };
          },
          executeLanguageCode: async (code: string, language: string, options?: any) => {
            this.logger.debug(`Mock executing ${language} code`);
            return { stdout: `Mock output for ${language} code`, stderr: '', exitCode: 0 };
          }
        };
        
        // Register the mock for future resolution
        try {
          container.registerInstance('ICommandExecutionService', commandExecutionService);
          container.registerInstance('RunFeedbackManager', mockFeedbackManager);
          this.logger.debug('Registered mock CommandExecutionService in container');
        } catch (registerError) {
          this.logger.warn('Failed to register mock CommandExecutionService', { error: registerError });
        }
      }
      
      this.registerHandler(
        new RunDirectiveHandler(
          this.validationService!,
          this.resolutionService!,
          this.stateService!,
          this.fileSystemService!,
          commandExecutionService
        )
      );
    } catch (error) {
      this.logger.error('Failed to create RunDirectiveHandler', { error });
      throw error;
    }

    this.registerHandler(
      new EmbedDirectiveHandler(
        this.validationService!,
        this.resolutionService!,
        this.stateService!,
        this.circularityService!,
        this.fileSystemService!,
        this.parserService!,
        this.interpreterClientFactory!,
        this.logger
      )
    );

    this.registerHandler(
      new ImportDirectiveHandler(
        this.validationService!,
        this.resolutionService!,
        this.stateService!,
        this.fileSystemService!,
        this.parserService!,
        this.interpreterClientFactory!,
        this.circularityService!
      )
    );
  }

  /**
   * Register a new directive handler
   */
  registerHandler(handler: IDirectiveHandler): void {
    if (!this.initialized) {
      throw new Error('DirectiveService must be initialized before registering handlers');
    }

    if (!handler.kind) {
      throw new Error('Handler must have a kind property');
    }

    this.handlers.set(handler.kind, handler);
    this.logger.debug(`Registered handler for directive: ${handler.kind}`);
  }

  /**
   * Handle a directive node
   */
  public async handleDirective(node: DirectiveNode, context: DirectiveContext): Promise<StateServiceLike> {
    return this.processDirective(node, context);
  }

  /**
   * Process multiple directives in sequence
   */
  async processDirectives(nodes: DirectiveNode[], parentContext?: DirectiveContext): Promise<StateServiceLike> {
    let currentState = parentContext?.state?.clone() || this.stateService!.createChildState();
    
    // Inherit or create initial formatting context
    let currentFormattingContext = parentContext?.formattingContext ? { ...parentContext.formattingContext } : {
      isOutputLiteral: currentState.isTransformationEnabled(),
      contextType: 'block' as 'inline' | 'block',
      nodeType: 'Text'
    };

    for (const node of nodes) {
      // Create a new context with the current state as both parent and state
      // This ensures that subsequent directives can see variables defined by previous directives
      const nodeContext = {
        currentFilePath: parentContext?.currentFilePath || '',
        parentState: currentState,
        state: currentState.clone(),
        formattingContext: {
          ...currentFormattingContext,
          nodeType: node.type,
          parentContext: currentFormattingContext
        }
      } as DirectiveContext;

      // Process directive and get the updated state
      const result = await this.processDirective(node, nodeContext);
      
      // Update formatting context for the next directive
      // This ensures consistent newline handling between directives
      if (nodeContext.formattingContext) {
        currentFormattingContext = nodeContext.formattingContext;
      }
      
      // If transformation is enabled, we don't merge states since the directive
      // will be replaced with a text node and its state will be handled separately
      if (!currentState.isTransformationEnabled?.()) {
        // Update currentState directly with the result so next directives have access to it
        currentState = result;
      } else {
        // Even if transformation is enabled, we need to make sure variables defined in one directive
        // are available to subsequent directives
        if (result !== nodeContext.state) {
          // Only apply the new state if it actually changed (as a result of directive execution)
          currentState = result;
        }
      }
    }

    return currentState;
  }

  /**
   * Create execution context for a directive
   */
  private createContext(node: DirectiveNode, parentContext?: DirectiveContext): DirectiveContext {
    // Create a new state or clone parent state
    const state = parentContext?.state?.clone() || this.stateService!.createChildState();
    
    // Create a new resolution context or inherit from parent
    const resolutionContext = parentContext?.resolutionContext || {};
    
    // Set the default formatting context based on node type
    const formattingContext = {
      isOutputLiteral: state.isTransformationEnabled?.() || false,
      contextType: 'block' as 'inline' | 'block',
      nodeType: node.type,
      parentContext: parentContext?.formattingContext
    };
    
    // Determine working directory - use parent's or default to current directory
    const workingDirectory = parentContext?.workingDirectory || this.fileSystemService?.getCwd() || process.cwd();
    
    // Return the complete context
    return {
      state,
      parentState: parentContext?.state,
      currentFilePath: parentContext?.currentFilePath || this.stateService?.getCurrentFilePath() || '',
      workingDirectory,
      resolutionContext,
      formattingContext
    } as DirectiveContext;
  }

  /**
   * Update the interpreter service reference
   */
  updateInterpreterService(interpreterService: InterpreterServiceLike): void {
    this.interpreterService = interpreterService;
    this.logger.debug('Updated interpreter service reference');
  }

  /**
   * Check if a handler exists for a directive kind
   */
  hasHandler(kind: string): boolean {
    return this.handlers.has(kind);
  }

  /**
   * Validate a directive node
   */
  async validateDirective(node: DirectiveNode): Promise<void> {
    try {
      await this.validationService!.validate(node);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorForLog = error instanceof Error ? error : new Error(String(error));
      
      this.logger.error('Failed to validate directive', {
        kind: node.directive.kind,
        location: node.location,
        error: errorForLog
      });
      
      throw new DirectiveError(
        errorMessage,
        node.directive.kind,
        DirectiveErrorCode.VALIDATION_FAILED,
        {
          node
        }
      );
    }
  }

  /**
   * Create a child context for nested directives
   */
  public createChildContext(parentContext: DirectiveContext, filePath: string): DirectiveContext {
    // Create a child state that inherits from parent
    const childState = parentContext.state.createChildState();
    
    // Set the file path in the child state
    if (filePath) {
      childState.setCurrentFilePath(filePath);
    }
    
    // Create a new resolution context - inherit from parent with updated state
    const resolutionContext = {
      ...(parentContext.resolutionContext || {}),
      state: childState,
      currentFilePath: filePath
    };
    
    // Inherit or create formatting context
    const formattingContext = {
      isOutputLiteral: parentContext.formattingContext?.isOutputLiteral ?? childState.isTransformationEnabled(),
      parentContext: parentContext.formattingContext,
      contextType: (parentContext.formattingContext?.contextType || 'block') as 'inline' | 'block',
      nodeType: parentContext.formattingContext?.nodeType || 'Text',
      atLineStart: parentContext.formattingContext?.atLineStart,
      atLineEnd: parentContext.formattingContext?.atLineEnd
    };
    
    // Return the complete child context
    return {
      state: childState,
      parentState: parentContext.state,
      currentFilePath: filePath,
      workingDirectory: parentContext.workingDirectory,
      resolutionContext,
      formattingContext
    } as DirectiveContext;
  }

  supportsDirective(kind: string): boolean {
    return this.handlers.has(kind);
  }

  getSupportedDirectives(): string[] {
    return Array.from(this.handlers.keys());
  }

  private ensureInitialized(): void {
    if (!this.initialized) {
      throw new Error('DirectiveService must be initialized before use');
    }
  }

  private async handleTextDirective(node: DirectiveNode): Promise<void> {
    const directive = node.directive;
    
    this.logger.debug('Processing text directive', {
      identifier: directive.identifier,
      location: node.location
    });

    try {
      // Value is already interpolated by meld-ast
      await this.stateService!.setTextVar(directive.identifier, directive.value);
      
      this.logger.debug('Text directive processed successfully', {
        identifier: directive.identifier,
        location: node.location
      });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorForLog = error instanceof Error ? error : new Error(String(error));
      
      this.logger.error('Failed to process text directive', {
        identifier: directive.identifier,
        location: node.location,
        error: errorForLog
      });
      
      throw new MeldDirectiveError(
        errorMessage,
        'text',
        { location: node.location?.start }
      );
    }
  }

  private async handleDataDirective(node: DirectiveNode): Promise<void> {
    const directive = node.directive;
    
    this.logger.debug('Processing data directive', {
      identifier: directive.identifier,
      location: node.location
    });

    try {
      // Value is already interpolated by meld-ast
      let value = directive.value;
      if (typeof value === 'string') {
        value = JSON.parse(value);
      }

      await this.stateService!.setDataVar(directive.identifier, value);
      
      this.logger.debug('Data directive processed successfully', {
        identifier: directive.identifier,
        location: node.location
      });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorForLog = error instanceof Error ? error : new Error(String(error));
      
      this.logger.error('Failed to process data directive', {
        identifier: directive.identifier,
        location: node.location,
        error: errorForLog
      });
      
      throw new MeldDirectiveError(
        errorMessage,
        'data',
        { location: node.location?.start }
      );
    }
  }

  private async handleImportDirective(node: DirectiveNode): Promise<void> {
    const directive = node.directive;
    
    this.logger.debug('Processing import directive', {
      path: directive.path,
      section: directive.section,
      fuzzy: directive.fuzzy,
      location: node.location
    });

    try {
      // Path is already interpolated by meld-ast
      const fullPath = await this.pathService!.resolvePath(directive.path);
      
      // Check for circular imports
      this.circularityService!.beginImport(fullPath);

      try {
        // Check if file exists
        if (!await this.fileSystemService!.exists(fullPath)) {
          throw new Error(`Import file not found: ${fullPath}`);
        }

        // Create a child state for the import
        const childState = await this.stateService!.createChildState();

        // Read the file content
        const content = await this.fileSystemService!.readFile(fullPath);

        // If a section is specified, extract it (section name is already interpolated)
        let processedContent = content;
        if (directive.section) {
          processedContent = await this.extractSection(
            content, 
            directive.section, 
            directive.fuzzy || 0
          );
        }

        // Parse and interpret the content
        const parsedNodes = await this.parserService!.parse(processedContent);
        await this.callInterpreterInterpret(parsedNodes, {
          initialState: childState,
          filePath: fullPath,
          mergeState: true
        });

        this.logger.debug('Import content processed', {
          path: fullPath,
          section: directive.section,
          location: node.location
        });
      } finally {
        // Always end import tracking, even if there was an error
        this.circularityService!.endImport(fullPath);
      }
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorForLog = error instanceof Error ? error : new Error(String(error));
      
      this.logger.error('Failed to process import directive', {
        path: directive.path,
        section: directive.section,
        location: node.location,
        error: errorForLog
      });
      
      throw new MeldDirectiveError(
        errorMessage,
        'import',
        { location: node.location?.start }
      );
    }
  }

  private async extractSection(
    content: string,
    section: string,
    fuzzyMatch: number
  ): Promise<string> {
    try {
      // Split content into lines
      const lines = content.split('\n');
      const headings: { title: string; line: number; level: number }[] = [];
      
      // Find all headings and their levels
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const match = line.match(/^(#{1,6})\s+(.+)$/);
        if (match) {
          headings.push({
            title: match[2],
            line: i,
            level: match[1].length
          });
        }
      }

      // Find best matching heading
      let bestMatch: typeof headings[0] | undefined;
      let bestScore = 0;

      for (const heading of headings) {
        const score = this.calculateSimilarity(heading.title, section);
        if (score > fuzzyMatch && score > bestScore) {
          bestScore = score;
          bestMatch = heading;
        }
      }

      if (!bestMatch) {
        // Find closest match for error message
        let closestMatch = '';
        let closestScore = 0;
        for (const heading of headings) {
          const score = this.calculateSimilarity(heading.title, section);
          if (score > closestScore) {
            closestScore = score;
            closestMatch = heading.title;
          }
        }

        throw new MeldLLMXMLError(
          'Section not found',
          'SECTION_NOT_FOUND',
          { title: section, bestMatch: closestMatch }
        );
      }

      // Find the end of the section (next heading of same or higher level)
      let endLine = lines.length;
      for (let i = bestMatch.line + 1; i < lines.length; i++) {
        const line = lines[i];
        const match = line.match(/^(#{1,6})\s+/);
        if (match && match[1].length <= bestMatch.level) {
          endLine = i;
          break;
        }
      }

      // Extract the section content
      return lines.slice(bestMatch.line, endLine).join('\n');
    } catch (error) {
      if (error instanceof MeldLLMXMLError) {
        throw error;
      }
      throw new MeldLLMXMLError(
        error instanceof Error ? error.message : 'Unknown error during section extraction',
        'PARSE_ERROR',
        error
      );
    }
  }

  private calculateSimilarity(str1: string, str2: string): number {
    // Convert strings to lowercase for case-insensitive comparison
    const s1 = str1.toLowerCase();
    const s2 = str2.toLowerCase();

    if (s1 === s2) return 1.0;

    // Calculate Levenshtein distance
    const len1 = s1.length;
    const len2 = s2.length;
    const matrix: number[][] = [];

    for (let i = 0; i <= len1; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= len2; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= len1; i++) {
      for (let j = 1; j <= len2; j++) {
        const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j - 1] + cost
        );
      }
    }

    // Convert distance to similarity score between 0 and 1
    const maxLen = Math.max(len1, len2);
    return maxLen === 0 ? 1.0 : 1.0 - matrix[len1][len2] / maxLen;
  }

  private async handleEmbedDirective(node: DirectiveNode): Promise<void> {
    const directive = node.directive;
    
    this.logger.debug('Processing embed directive', {
      path: directive.path,
      section: directive.section,
      fuzzy: directive.fuzzy,
      names: directive.names,
      location: node.location
    });

    try {
      // Path is already interpolated by meld-ast
      const fullPath = await this.pathService!.resolvePath(directive.path);
      
      // Check for circular imports
      this.circularityService!.beginImport(fullPath);

      try {
        // Check if file exists
        if (!await this.fileSystemService!.exists(fullPath)) {
          throw new Error(`Embed file not found: ${fullPath}`);
        }

        // Create a child state for the import
        const childState = await this.stateService!.createChildState();

        // Read the file content
        const content = await this.fileSystemService!.readFile(fullPath);

        // If a section is specified, extract it (section name is already interpolated)
        let processedContent = content;
        if (directive.section) {
          processedContent = await this.extractSection(
            content, 
            directive.section, 
            directive.fuzzy || 0
          );
        }

        // Parse and interpret the content
        const parsedNodes = await this.parserService!.parse(processedContent);
        await this.callInterpreterInterpret(parsedNodes, {
          initialState: childState,
          filePath: fullPath,
          mergeState: true
        });

        this.logger.debug('Embed content processed', {
          path: fullPath,
          section: directive.section,
          location: node.location
        });
      } finally {
        // Always end import tracking, even if there was an error
        this.circularityService!.endImport(fullPath);
      }
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorForLog = error instanceof Error ? error : new Error(String(error));
      
      this.logger.error('Failed to process embed directive', {
        path: directive.path,
        section: directive.section,
        location: node.location,
        error: errorForLog
      });
      
      throw new MeldDirectiveError(
        errorMessage,
        'embed',
        { location: node.location?.start }
      );
    }
  }

  /**
   * Process a directive node, validating and executing it
   * Values in the directive will already be interpolated by meld-ast
   * @returns The updated state after directive execution
   * @throws {MeldDirectiveError} If directive processing fails
   */
  public async processDirective(node: DirectiveNode, context: DirectiveContext): Promise<StateServiceLike> {
    // Add initialization check before any other processing
    if (!this.initialized) {
      throw new MeldDirectiveError(
        'DirectiveService must be initialized before use',
        'initialization',
        { severity: ErrorSeverity.Fatal }
      );
    }

    try {
      // Get the handler for this directive kind
      const { kind } = node.directive;
      const handler = this.handlers.get(kind);

      if (!handler) {
        throw new DirectiveError(
          `No handler found for directive: ${kind}`,
          kind,
          DirectiveErrorCode.HANDLER_NOT_FOUND,
          { node }
        );
      }

      // Validate directive before handling
      await this.validateDirective(node);

      // Execute the directive and handle both possible return types
      const result = await handler.execute(node, context);
      
      // If result is a DirectiveResult with formatting context, update context for propagation
      if ('state' in result) {
        // If the directive returned a formatting context, update the context
        if ((result as DirectiveResult).formattingContext && context.formattingContext) {
          Object.assign(context.formattingContext, (result as DirectiveResult).formattingContext);
        }
        return result.state;
      }
      
      // Otherwise, result is already an IStateService
      return result;
    } catch (error) {
      // If it's already a DirectiveError or MeldDirectiveError, just rethrow
      if (error instanceof DirectiveError || error instanceof MeldDirectiveError) {
        throw error;
      }

      // Simplify error messages for common cases
      let message = error instanceof Error ? error.message : String(error);
      let code = DirectiveErrorCode.EXECUTION_FAILED;
      let severity = ErrorSeverity.Recoverable;
      
      if (message.includes('file not found') || message.includes('no such file')) {
        message = `Referenced file not found: ${node.directive.path || node.directive.value}`;
        code = DirectiveErrorCode.FILE_NOT_FOUND;
        severity = DirectiveErrorSeverity[code];
      } else if (message.includes('circular import') || message.includes('circular reference')) {
        message = 'Circular import detected';
        code = DirectiveErrorCode.CIRCULAR_REFERENCE;
        severity = DirectiveErrorSeverity[code];
      } else if (message.includes('parameter count') || message.includes('wrong number of parameters')) {
        message = 'Invalid parameter count';
        code = DirectiveErrorCode.VALIDATION_FAILED;
        severity = DirectiveErrorSeverity[code];
      } else if (message.includes('invalid path') || message.includes('path validation failed')) {
        message = 'Invalid path';
        code = DirectiveErrorCode.VALIDATION_FAILED;
        severity = DirectiveErrorSeverity[code];
      }

      throw new DirectiveError(
        message,
        node.directive?.kind || 'unknown',
        code,
        { 
          node, 
          context,
          cause: error instanceof Error ? error : undefined 
        }
      );
    }
  }

  /**
   * Lazily initialize the ResolutionServiceClientForDirective factory
   * This is called only when needed to avoid circular dependencies
   */
  private ensureFactoryInitialized(): void {
    if (this.factoryInitialized) {
      return;
    }
    
    this.factoryInitialized = true;
    
    try {
      this.resolutionClientFactory = container.resolve('ResolutionServiceClientForDirectiveFactory');
      this.initializeResolutionClient();
    } catch (error) {
      // Factory not available, will use direct reference
      this.logger.debug('ResolutionServiceClientForDirectiveFactory not available, using direct reference for resolution operations');
    }
  }
  
  /**
   * Initialize the ResolutionServiceClientForDirective using the factory
   */
  private initializeResolutionClient(): void {
    if (!this.resolutionClientFactory) {
      return;
    }
    
    try {
      this.resolutionClient = this.resolutionClientFactory.createClient();
      this.logger.debug('Successfully created ResolutionServiceClientForDirective using factory');
    } catch (error) {
      this.logger.warn('Failed to create ResolutionServiceClientForDirective, falling back to direct reference', { error });
      this.resolutionClient = undefined;
    }
  }

  /**
   * Resolve text using the resolution service
   * @private
   */
  private async resolveText(text: string, context: DirectiveContext): Promise<string> {
    this.ensureFactoryInitialized();
    
    if (this.resolutionClient) {
      try {
        return await this.resolutionClient.resolveText(text, context.resolutionContext || {
          currentFilePath: context.currentFilePath,
          workingDirectory: context.workingDirectory
        });
      } catch (error) {
        directiveLogger.warn('Error using resolutionClient.resolveText', { error });
      }
    }
    
    // Fallback to direct resolution service
    return this.resolutionService.resolveText(text, {
      currentFilePath: context.currentFilePath,
      workingDirectory: context.workingDirectory
    });
  }

  /**
   * Resolve data using the resolution service
   * @private
   */
  private async resolveData(ref: string, context: DirectiveContext): Promise<any> {
    this.ensureFactoryInitialized();
    
    if (this.resolutionClient) {
      try {
        return await this.resolutionClient.resolveData(ref, context.resolutionContext || {
          currentFilePath: context.currentFilePath,
          workingDirectory: context.workingDirectory
        });
      } catch (error) {
        directiveLogger.warn('Error using resolutionClient.resolveData', { error });
      }
    }
    
    // Fallback to direct resolution service
    return this.resolutionService.resolveData(ref, {
      currentFilePath: context.currentFilePath,
      workingDirectory: context.workingDirectory
    });
  }

  /**
   * Resolve path using the resolution service
   * @private
   */
  private async resolvePath(path: string, context: DirectiveContext): Promise<string> {
    this.ensureFactoryInitialized();
    
    if (this.resolutionClient) {
      try {
        return await this.resolutionClient.resolvePath(path, context.resolutionContext || {
          currentFilePath: context.currentFilePath,
          workingDirectory: context.workingDirectory
        });
      } catch (error) {
        directiveLogger.warn('Error using resolutionClient.resolvePath', { error });
      }
    }
    
    // Fallback to direct resolution service
    return this.resolutionService.resolvePath(path, {
      currentFilePath: context.currentFilePath,
      workingDirectory: context.workingDirectory
    });
  }

  /**
   * Initialize the interpreterClient using the factory
   */
  private initializeInterpreterClient(): void {
    if (!this.interpreterClientFactory) {
      return;
    }
    
    try {
      this.interpreterClient = this.interpreterClientFactory.createClient();
      this.logger.debug('Successfully created InterpreterServiceClient using factory');
    } catch (error) {
      this.logger.warn('Failed to create InterpreterServiceClient', { error });
      this.interpreterClient = undefined;
    }
  }
  
  /**
   * Lazily initialize the InterpreterServiceClient factory
   * This is called only when needed to avoid circular dependencies
   */
  private ensureInterpreterFactoryInitialized(): void {
    if (this.interpreterFactoryInitialized) {
      return;
    }
    
    this.interpreterFactoryInitialized = true;
    
    try {
      this.interpreterClientFactory = container.resolve('InterpreterServiceClientFactory');
      this.initializeInterpreterClient();
    } catch (error) {
      // Factory not available, will use direct service
      this.logger.debug('InterpreterServiceClientFactory not available, will use direct service if available');
    }
  }
  
  /**
   * Calls the interpret method on the interpreter service
   * Uses the client if available, falls back to direct service reference
   */
  private async callInterpreterInterpret(nodes: any[], options?: any): Promise<StateServiceLike> {
    // Ensure factory is initialized
    this.ensureInterpreterFactoryInitialized();
    
    // Try to use the client from factory first
    if (this.interpreterClient) {
      try {
        return await this.interpreterClient.interpret(nodes, options);
      } catch (error) {
        this.logger.warn('Error using interpreterClient.interpret, falling back to direct service', { error });
      }
    }
    
    // Fall back to direct service reference
    if (this.interpreterService) {
      return await this.interpreterService.interpret(nodes, options);
    }
    
    throw new Error('No interpreter service available');
  }
  
  /**
   * Calls the createChildContext method on the interpreter service
   * Uses the client if available, falls back to direct service reference
   */
  private async callInterpreterCreateChildContext(parentState: StateServiceLike, filePath?: string, options?: any): Promise<StateServiceLike> {
    // Ensure factory is initialized
    this.ensureInterpreterFactoryInitialized();
    
    // Try to use the client from factory first
    if (this.interpreterClient) {
      try {
        return await this.interpreterClient.createChildContext(parentState, filePath, options);
      } catch (error) {
        this.logger.warn('Error using interpreterClient.createChildContext, falling back to direct service', { error });
      }
    }
    
    // Fall back to direct service reference
    if (this.interpreterService) {
      return await this.interpreterService.createChildContext(parentState, filePath, options);
    }
    
    throw new Error('No interpreter service available');
  }
} 
```
    <ServicesPipelineDirectiveserviceIdirectiveserviceTs>
```javascript
import type { DirectiveNode } from '@core/syntax/types/index.js';
import type { DirectiveContextBase } from '@core/shared/types.js';
import type { 
  StateServiceLike, 
  ValidationServiceLike,
  PathServiceLike,
  FileSystemLike,
  ParserServiceLike,
  CircularityServiceLike,
  ResolutionServiceLike,
  DirectiveServiceLike
} from '@core/shared-service-types.js';
import type { DirectiveResult } from '@services/pipeline/DirectiveService/types.js';

/**
 * Context for directive execution
 * Extends the base context with state-specific fields
 */
export interface DirectiveContext extends DirectiveContextBase {
  /** Parent state for nested contexts */
  parentState?: StateServiceLike;
  /** Current state for this directive */
  state: StateServiceLike;
  /** Current file being processed */
  currentFilePath?: string;
  /** Working directory for command execution */
  workingDirectory?: string;
  /** Resolution context for variable resolution */
  resolutionContext?: any;
  /** Formatting context for output generation - propagates formatting preferences across service boundaries */
  formattingContext?: {
    /** Whether in output-literal mode (formerly transformation mode) */
    isOutputLiteral: boolean;
    /** Whether this is an inline or block context */
    contextType: 'inline' | 'block';
    /** Current node type being processed */
    nodeType: string;
    /** Whether at start of line */
    atLineStart?: boolean;
    /** Whether at end of line */
    atLineEnd?: boolean;
    /** Parent formatting context for inheritance */
    parentContext?: any;
  };
}

/**
 * Interface for directive handlers
 */
export interface IDirectiveHandler {
  /** The directive kind this handler processes */
  readonly kind: string;

  /**
   * Execute the directive
   * 
   * @param node - The directive node to execute
   * @param context - The execution context
   * @returns The updated state after directive execution, or a DirectiveResult containing both state and optional replacement node
   * @throws {MeldDirectiveError} If directive execution fails
   */
  execute(
    node: DirectiveNode,
    context: DirectiveContext
  ): Promise<DirectiveResult | StateServiceLike>;
}

/**
 * Service responsible for handling Meld directives in the processing pipeline.
 * Orchestrates directive validation, execution, and transformation.
 * 
 * @remarks
 * The DirectiveService acts as the core orchestrator for directive processing.
 * It maintains a registry of directive handlers, validates directive syntax and
 * semantics, and routes directives to the appropriate handler for execution.
 * 
 * This service is central to the Meld pipeline and interacts with nearly all
 * other services to process directives effectively.
 * 
 * Dependencies:
 * - ValidationServiceLike: For directive syntax and semantic validation
 * - StateServiceLike: For maintaining state during directive execution
 * - PathServiceLike: For path resolution in file-related directives
 * - FileSystemLike: For file operations in import and other directives
 * - ParserServiceLike: For parsing content in imports and fragments
 * - InterpreterServiceClientFactory: For nested interpretation in imports
 * - CircularityServiceLike: For detecting circular imports and references
 * - ResolutionServiceLike: For variable resolution in directive content
 */
export interface IDirectiveService extends DirectiveServiceLike {
  /**
   * Initialize the DirectiveService with required dependencies
   * 
   * @param validationService - Service for validating directive syntax and semantics
   * @param stateService - Service for maintaining state during execution
   * @param pathService - Service for path resolution
   * @param fileSystemService - Service for file operations
   * @param parserService - Service for parsing content
   * @param interpreterServiceClientFactory - Factory for creating interpreter service clients
   * @param circularityService - Service for detecting circular references
   * @param resolutionService - Service for variable resolution
   */
  initialize(
    validationService: ValidationServiceLike,
    stateService: StateServiceLike,
    pathService: PathServiceLike,
    fileSystemService: FileSystemLike,
    parserService: ParserServiceLike,
    interpreterServiceClientFactory: any, // Use 'any' to allow both IInterpreterService and InterpreterServiceClientFactory
    circularityService: CircularityServiceLike,
    resolutionService: ResolutionServiceLike
  ): void;

  /**
   * Update the interpreter service reference
   * This is needed to handle circular dependencies in initialization
   * 
   * @param interpreterService - The interpreter service to use
   * @deprecated Use interpreterServiceClientFactory instead
   */
  updateInterpreterService(interpreterService: any): void;

  /**
   * Handle a directive node
   * 
   * @param node - The directive node to handle
   * @param context - The execution context
   * @returns The updated state after directive execution
   * @throws {MeldDirectiveError} If directive handling fails
   */
  handleDirective(
    node: DirectiveNode,
    context: DirectiveContext
  ): Promise<StateServiceLike>;

  /**
   * Register a new directive handler
   * 
   * @param handler - The handler to register
   * @throws {MeldServiceError} If a handler for the directive kind already exists
   */
  registerHandler(handler: IDirectiveHandler): void;

  /**
   * Check if a handler exists for a directive kind
   * 
   * @param kind - The directive kind to check
   * @returns true if a handler exists, false otherwise
   */
  hasHandler(kind: string): boolean;

  /**
   * Validate a directive node
   * 
   * @param node - The directive node to validate
   * @throws {MeldDirectiveError} If validation fails
   */
  validateDirective(node: DirectiveNode): Promise<void>;

  /**
   * Create a child context for nested directives
   * 
   * @param parentContext - The parent execution context
   * @param filePath - The file path for the child context
   * @returns A new directive context with a child state
   */
  createChildContext(
    parentContext: DirectiveContext,
    filePath: string
  ): DirectiveContext;

  /**
   * Process a directive node, validating and executing it
   * Values in the directive will already be interpolated by meld-ast
   * 
   * @param node - The directive node to process
   * @param parentContext - Optional parent context for nested directives
   * @returns The updated state after directive execution
   * @throws {MeldDirectiveError} If directive processing fails
   * 
   * @example
   * ```ts
   * const node = {
   *   type: 'Directive',
   *   kind: 'text',
   *   name: 'greeting',
   *   value: 'Hello, world!',
   *   // ... other properties
   * };
   * const state = await directiveService.processDirective(node);
   * ```
   */
  processDirective(node: DirectiveNode, parentContext?: DirectiveContext): Promise<StateServiceLike>;

  /**
   * Process multiple directive nodes in sequence
   * 
   * @param nodes - The directive nodes to process
   * @param parentContext - Optional parent context for nested directives
   * @returns The final state after processing all directives
   * @throws {MeldDirectiveError} If any directive processing fails
   */
  processDirectives(nodes: DirectiveNode[], parentContext?: DirectiveContext): Promise<StateServiceLike>;

  /**
   * Check if a directive kind is supported
   * 
   * @param kind - The directive kind to check
   * @returns true if the directive kind is supported, false otherwise
   */
  supportsDirective(kind: string): boolean;

  /**
   * Get a list of all supported directive kinds
   * 
   * @returns An array of supported directive kinds
   */
  getSupportedDirectives(): string[];
} 
```
    </ServicesPipelineDirectiveserviceIdirectiveserviceTs>
    <ServicesPipelineDirectiveserviceInterfacesDirectivetypesTs>
```javascript
import { StateServiceLike } from '@core/shared-service-types.js';
import { MeldNode } from '@core/syntax/types/index.js';

/**
 * The result of executing a directive
 * Contains the updated state and optionally a replacement node to use in transformation mode
 */
export interface DirectiveResult {
  /**
   * The updated state after processing the directive
   */
  state: StateServiceLike;
  
  /**
   * In transformation mode, this is the replacement node that the directive's node should be transformed into
   */
  replacement?: MeldNode;
  
  /**
   * Optional formatting context that should be propagated to further processing.
   * This helps maintain consistent newline handling and formatting.
   */
  formattingContext?: {
    isOutputLiteral?: boolean;
    contextType?: 'inline' | 'block';
    nodeType?: string;
    [key: string]: any;
  };
} 
```
1. **Your Original Request &amp; Justification:**
    </ServicesPipelineDirectiveserviceInterfacesDirectivetypesTs>
  </ValidationCriteria>
</DependencyInjectionInMeld>

<FilesystemcoreServiceImprovementsForDefineTypes>
  <CurrentStateAnalysis>
After examining the FileSystemService code and the broader Meld architecture, I&apos;ve identified several areas where stronger typing for the  directive would significantly improve the service&apos;s reliability and maintainability.
The FileSystemService is responsible for file operations and command execution, making it a critical component when handling  directives and their execution via . Currently, the service has limited type support for command execution, which creates several challenges:
  </CurrentStateAnalysis>
  <KeyImprovementAreas>
    <1commandExecutionTypeSafety>
**Current Issue:**
The  method currently accepts any string as a command without validation or type checking:
```typescript
async executeCommand(command: string, options?: { cwd?: string }): Promise<{ stdout: string; stderr: string }>
```
This creates several problems:
- No distinction between regular shell commands and defined commands
- No parameter validation for defined commands
- No compile-time verification of command structure
**Proposed Solution:**
Create a discriminated union type for commands:
```typescript
// Define command types
type CommandType = 'shell' | 'defined' | 'language';

// Base command interface
interface BaseCommand {
  type: CommandType;
  options?: { cwd?: string };
}

// Shell command (direct execution)
interface ShellCommand extends BaseCommand {
  type: 'shell';
  command: string;
}

// Defined command (from @define directive)
interface DefinedCommand extends BaseCommand {
  type: 'defined';
  name: string;
  parameters: Record<string, string>;
  originalTemplate?: string;
}

// Language command (JavaScript, Python, etc.)
interface LanguageCommand extends BaseCommand {
  type: 'language';
  language: 'js' | 'python' | 'bash';
  code: string;
  parameters: string[];
}

// Union type for all commands
type Command = ShellCommand | DefinedCommand | LanguageCommand;
```
**Benefits:**
1. **Type Safety**: Prevents mixing of different command types
2. **Parameter Validation**: Ensures defined commands receive the correct parameters
3. **Better IDE Support**: Provides autocomplete and documentation for command properties
4. **Error Prevention**: Catches command structure errors at compile time
    </1commandExecutionTypeSafety>
    <2commandDefinitionType>
**Current Issue:**
The service lacks a clear type definition for command templates created via , making it difficult to validate and process them consistently.
**Proposed Solution:**
Create a dedicated type for command definitions:
```typescript
interface CommandParameter {
  name: string;
  defaultValue?: string;
  required: boolean;
}

interface CommandDefinition {
  name: string;
  parameters: CommandParameter[];
  template: string;
  isLanguageCommand: boolean;
  language?: 'js' | 'python' | 'bash';
  codeBlock?: string;
}
```
**Benefits:**
1. **Consistent Structure**: Ensures all command definitions follow the same structure
2. **Parameter Validation**: Makes it easier to validate parameters when executing commands
3. **Clear Documentation**: Provides a self-documenting type for command definitions
4. **Integration with State Service**: Simplifies storage and retrieval of command definitions
    </2commandDefinitionType>
    <3commandExecutionResultType>
**Current Issue:**
The current return type for  is simplistic and doesn&apos;t provide enough context about the execution:
```typescript
Promise<{ stdout: string; stderr: string }>
```
**Proposed Solution:**
Enhance the return type to include more execution context:
```typescript
interface CommandExecutionResult {
  stdout: string;
  stderr: string;
  exitCode: number;
  command: Command;
  executionTime: number;
  successful: boolean;
}
```
**Benefits:**
1. **Rich Context**: Provides more information about the command execution
2. **Error Handling**: Makes it easier to determine if a command succeeded
3. **Debugging**: Includes the original command for debugging purposes
4. **Performance Tracking**: Includes execution time for performance analysis
    </3commandExecutionResultType>
    <4commandValidationType>
**Current Issue:**
There&apos;s no structured way to validate commands before execution, leading to runtime errors.
**Proposed Solution:**
Create a validation result type:
```typescript
interface CommandValidationError {
  code: string;
  message: string;
  parameter?: string;
  suggestion?: string;
}

interface CommandValidationResult {
  valid: boolean;
  command: Command;
  errors: CommandValidationError[];
}
```
**Benefits:**
1. **Early Error Detection**: Catches command errors before execution
2. **Detailed Error Messages**: Provides specific information about validation failures
3. **Suggestions**: Can offer suggestions to fix invalid commands
4. **Consistent Validation**: Ensures all commands are validated consistently
    </4commandValidationType>
  </KeyImprovementAreas>
  <ImplementationExample>
Here&apos;s how these types could be integrated into the FileSystemService:
```typescript
// Updated executeCommand method with stronger typing
async executeCommand(command: Command): Promise<CommandExecutionResult> {
  const context = {
    operation: 'executeCommand',
    commandType: command.type,
    command: command.type === 'shell' ? command.command : command.name
  };

  try {
    logger.debug('Executing command', context);
    
    let result: { stdout: string; stderr: string; exitCode: number };
    const startTime = Date.now();
    
    switch (command.type) {
      case 'shell':
        result = await this.fs.executeCommand(command.command, command.options);
        break;
        
      case 'defined':
        // Get the command definition from state
        const definition = await this.getCommandDefinition(command.name);
        if (!definition) {
          throw new MeldFileSystemError(`Command not found: ${command.name}`, { command: command.name });
        }
        
        // Apply parameters to template
        const resolvedCommand = this.applyParametersToTemplate(definition, command.parameters);
        result = await this.fs.executeCommand(resolvedCommand, command.options);
        break;
        
      case 'language':
        // Execute language command
        result = await this.executeLanguageCommand(command);
        break;
    }
    
    const executionTime = Date.now() - startTime;
    
    logger.debug('Command executed successfully', { 
      ...context, 
      stdout: result.stdout, 
      stderr: result.stderr,
      exitCode: result.exitCode,
      executionTime
    });
    
    return {
      stdout: result.stdout,
      stderr: result.stderr,
      exitCode: result.exitCode,
      command,
      executionTime,
      successful: result.exitCode === 0
    };
  } catch (error) {
    const err = error as Error;
    logger.error('Failed to execute command', { ...context, error: err });
    throw new MeldFileSystemError(`Failed to execute command: ${
      command.type === 'shell' ? command.command : command.name
    }`, {
      cause: err,
      command: command.type === 'shell' ? command.command : command.name
    });
  }
}
```
  </ImplementationExample>
  <ValidationMethodExample>
```typescript
// Command validation method
validateCommand(command: Command): CommandValidationResult {
  const errors: CommandValidationError[] = [];
  
  switch (command.type) {
    case 'defined':
      // Get the command definition
      const definition = this.getCommandDefinition(command.name);
      
      // Check if command exists
      if (!definition) {
        errors.push({
          code: 'COMMAND_NOT_FOUND',
          message: `Command '${command.name}' not found`,
          suggestion: 'Check the command name or define it using @define'
        });
        break;
      }
      
      // Validate parameters
      for (const param of definition.parameters) {
        if (param.required && !command.parameters[param.name]) {
          errors.push({
            code: 'MISSING_PARAMETER',
            message: `Missing required parameter: ${param.name}`,
            parameter: param.name,
            suggestion: `Provide a value for '${param.name}'`
          });
        }
      }
      break;
      
    case 'language':
      // Validate language
      if (!['js', 'python', 'bash'].includes(command.language)) {
        errors.push({
          code: 'INVALID_LANGUAGE',
          message: `Invalid language: ${command.language}`,
          suggestion: 'Use one of: js, python, bash'
        });
      }
      break;
  }
  
  return {
    valid: errors.length === 0,
    command,
    errors
  };
}
```
  </ValidationMethodExample>
  <BenefitsForFilesystemcoreService>
1. **Reduced Error Handling**: The discriminated union pattern eliminates many runtime checks and error cases.
2. **Improved Developer Experience**: Strong types provide better autocomplete, documentation, and error messages.
3. **Consistency with Meld Architecture**: These types align with Meld&apos;s directive-based architecture and dependency injection pattern.
4. **Simplified Testing**: Well-defined types make it easier to create mock commands and test the service.
5. **Better Integration with State Service**: Clear types for command definitions improve how they&apos;re stored and retrieved from the state.
6. **Enhanced Security**: Stronger typing reduces the risk of command injection and other security issues.
7. **Future-Proofing**: The type structure allows for easy extension to support new command types or parameters.
  </BenefitsForFilesystemcoreService>
  <Conclusion>
Implementing stronger TypeScript types for the  directive would significantly improve the FileSystemCore service by making command execution more robust, reducing runtime errors, and providing better documentation and IDE support. These changes align with Meld&apos;s architecture and would make the service easier to maintain and extend in the future.
5.  **Architect&apos;s Draft Type Proposal:**
Reviewing your information about the Meld architecture and the  directive, I&apos;ll now create a TypeScript type definition proposal that aligns with the system&apos;s design patterns and requirements.
```typescript
/**
 * TypeScript type definitions for the @define directive
 */

/**
 * Parameter metadata for command definitions
 * 
 * @remarks Includes position information for positional parameter substitution
 * and optional metadata for future extensibility.
 */
export interface ICommandParameterMetadata {
  /** Parameter name used in substitution patterns like {{paramName}} */
  name: string;
  
  /** Zero-based position in the parameter list */
  position: number;
  
  /** Whether the parameter is required (defaults to true) */
  required?: boolean;
  
  /** Optional default value if not provided at invocation time */
  defaultValue?: string;
  
  // TODO: Runtime validation for parameter name format (must be valid identifier)
}

/**
 * Base interface for all command definitions
 * 
 * @remarks Using a discriminated union pattern with 'type' field for better type safety
 * and IDE support, following Meld's existing patterns.
 */
export interface ICommandDefinitionBase {
  /** Command name used in @run $commandName(...) */
  name: string;
  
  /** Discriminator field for the union type */
  type: 'basic' | 'language';
  
  /** Array of parameter metadata */
  parameters: ICommandParameterMetadata[];
  
  /** Optional source location for error reporting */
  sourceLocation?: {
    filePath: string;
    line: number;
    column: number;
  };
  
  /** Optional visibility metadata */
  visibility?: 'public' | 'private';
  
  /** Optional description for documentation */
  description?: string;
  
  // TODO: Runtime validation for command name (must be valid identifier)
}

/**
 * Definition for basic shell commands
 * 
 * @remarks Basic commands are shell commands with parameter substitution.
 * The template can contain {{paramName}} placeholders and {{varName}} variable references.
 */
export interface IBasicCommandDefinition extends ICommandDefinitionBase {
  /** Discriminator value */
  type: 'basic';
  
  /** The shell command template with parameter placeholders */
  commandTemplate: string;
  
  /** Whether this is a multiline command (using [[ ]]) */
  isMultiline: boolean;
  
  // TODO: Runtime validation that commandTemplate contains valid parameter references
}

/**
 * Definition for language-specific script commands
 * 
 * @remarks Language commands contain raw code blocks executed by specific interpreters.
 * Parameters are passed to the script as arguments rather than substituted in the code.
 */
export interface ILanguageCommandDefinition extends ICommandDefinitionBase {
  /** Discriminator value */
  type: 'language';
  
  /** The language identifier (js, python, bash, etc.) */
  language: string;
  
  /** The raw code block to execute */
  codeBlock: string;
  
  /** Optional language-specific parameters separate from the command parameters */
  languageParameters?: string[];
  
  // TODO: Runtime validation for supported languages
}

/**
 * Union type for all command definition types
 * 
 * @remarks Using discriminated union pattern for type safety
 */
export type ICommandDefinition = IBasicCommandDefinition | ILanguageCommandDefinition;

/**
 * Command registry interface for storing and retrieving command definitions
 * 
 * @remarks Designed to integrate with StateService for command storage
 */
export interface ICommandRegistry {
  /**
   * Register a command definition
   * 
   * @param definition The command definition to register
   * @returns boolean indicating success
   * @throws MeldDirectiveError if command name already exists or validation fails
   */
  registerCommand(definition: ICommandDefinition): boolean;
  
  /**
   * Get a command definition by name
   * 
   * @param name The name of the command to retrieve
   * @returns The command definition or undefined if not found
   */
  getCommand(name: string): ICommandDefinition | undefined;
  
  /**
   * Check if a command exists
   * 
   * @param name The name of the command to check
   * @returns boolean indicating if the command exists
   */
  hasCommand(name: string): boolean;
  
  /**
   * Get all registered commands
   * 
   * @returns Array of all command definitions
   */
  getAllCommands(): ICommandDefinition[];
}

/**
 * Type guard for checking if a command definition is a basic command
 * 
 * @param definition The command definition to check
 * @returns boolean indicating if it's a basic command
 */
export function isBasicCommand(definition: ICommandDefinition): definition is IBasicCommandDefinition {
  return definition.type === 'basic';
}

/**
 * Type guard for checking if a command definition is a language command
 * 
 * @param definition The command definition to check
 * @returns boolean indicating if it's a language command
 */
export function isLanguageCommand(definition: ICommandDefinition): definition is ILanguageCommandDefinition {
  return definition.type === 'language';
}

/**
 * Execution context for command invocation
 * 
 * @remarks Provides context for error reporting and environment control
 */
export interface ICommandExecutionContext {
  /** The original command name */
  commandName: string;
  
  /** The resolved arguments for the command */
  resolvedArguments: string[];
  
  /** The state service instance */
  state: IStateService;
  
  /** The resolution service for variable resolution */
  resolutionService: IResolutionService;
  
  /** The file system service for file operations */
  fileSystem: IFileSystemService;
  
  /** The path service for path operations */
  pathService: IPathService;
  
  /** Optional working directory for command execution */
  workingDirectory?: string;
  
  /** Optional environment variables for command execution */
  environmentVariables?: Record<string, string>;
}

/**
 * Options for command definition parsing
 * 
 * @remarks Configuration options for the @define directive handler
 */
export interface ICommandDefinitionOptions {
  /** Whether to allow overriding existing commands */
  allowOverride?: boolean;
  
  /** Whether to extract metadata from command name */
  extractMetadata?: boolean;
  
  /** Default visibility for commands without explicit metadata */
  defaultVisibility?: 'public' | 'private';
}
```
  </Conclusion>
  <TaskRespondToTheArchitect>
Review the Architect&apos;s Draft Type Proposal (@define` directive, I&apos;ll now create a TypeScript type definition proposal that aligns with the system&apos;s design patterns and requirements.
```typescript
/**
 * TypeScript type definitions for the @define directive
 */

/**
 * Parameter metadata for command definitions
 * 
 * @remarks Includes position information for positional parameter substitution
 * and optional metadata for future extensibility.
 */
export interface ICommandParameterMetadata {
  /** Parameter name used in substitution patterns like {{paramName}} */
  name: string;
  
  /** Zero-based position in the parameter list */
  position: number;
  
  /** Whether the parameter is required (defaults to true) */
  required?: boolean;
  
  /** Optional default value if not provided at invocation time */
  defaultValue?: string;
  
  // TODO: Runtime validation for parameter name format (must be valid identifier)
}

/**
 * Base interface for all command definitions
 * 
 * @remarks Using a discriminated union pattern with 'type' field for better type safety
 * and IDE support, following Meld's existing patterns.
 */
export interface ICommandDefinitionBase {
  /** Command name used in @run $commandName(...) */
  name: string;
  
  /** Discriminator field for the union type */
  type: 'basic' | 'language';
  
  /** Array of parameter metadata */
  parameters: ICommandParameterMetadata[];
  
  /** Optional source location for error reporting */
  sourceLocation?: {
    filePath: string;
    line: number;
    column: number;
  };
  
  /** Optional visibility metadata */
  visibility?: 'public' | 'private';
  
  /** Optional description for documentation */
  description?: string;
  
  // TODO: Runtime validation for command name (must be valid identifier)
}

/**
 * Definition for basic shell commands
 * 
 * @remarks Basic commands are shell commands with parameter substitution.
 * The template can contain {{paramName}} placeholders and {{varName}} variable references.
 */
export interface IBasicCommandDefinition extends ICommandDefinitionBase {
  /** Discriminator value */
  type: 'basic';
  
  /** The shell command template with parameter placeholders */
  commandTemplate: string;
  
  /** Whether this is a multiline command (using [[ ]]) */
  isMultiline: boolean;
  
  // TODO: Runtime validation that commandTemplate contains valid parameter references
}

/**
 * Definition for language-specific script commands
 * 
 * @remarks Language commands contain raw code blocks executed by specific interpreters.
 * Parameters are passed to the script as arguments rather than substituted in the code.
 */
export interface ILanguageCommandDefinition extends ICommandDefinitionBase {
  /** Discriminator value */
  type: 'language';
  
  /** The language identifier (js, python, bash, etc.) */
  language: string;
  
  /** The raw code block to execute */
  codeBlock: string;
  
  /** Optional language-specific parameters separate from the command parameters */
  languageParameters?: string[];
  
  // TODO: Runtime validation for supported languages
}

/**
 * Union type for all command definition types
 * 
 * @remarks Using discriminated union pattern for type safety
 */
export type ICommandDefinition = IBasicCommandDefinition | ILanguageCommandDefinition;

/**
 * Command registry interface for storing and retrieving command definitions
 * 
 * @remarks Designed to integrate with StateService for command storage
 */
export interface ICommandRegistry {
  /**
   * Register a command definition
   * 
   * @param definition The command definition to register
   * @returns boolean indicating success
   * @throws MeldDirectiveError if command name already exists or validation fails
   */
  registerCommand(definition: ICommandDefinition): boolean;
  
  /**
   * Get a command definition by name
   * 
   * @param name The name of the command to retrieve
   * @returns The command definition or undefined if not found
   */
  getCommand(name: string): ICommandDefinition | undefined;
  
  /**
   * Check if a command exists
   * 
   * @param name The name of the command to check
   * @returns boolean indicating if the command exists
   */
  hasCommand(name: string): boolean;
  
  /**
   * Get all registered commands
   * 
   * @returns Array of all command definitions
   */
  getAllCommands(): ICommandDefinition[];
}

/**
 * Type guard for checking if a command definition is a basic command
 * 
 * @param definition The command definition to check
 * @returns boolean indicating if it's a basic command
 */
export function isBasicCommand(definition: ICommandDefinition): definition is IBasicCommandDefinition {
  return definition.type === 'basic';
}

/**
 * Type guard for checking if a command definition is a language command
 * 
 * @param definition The command definition to check
 * @returns boolean indicating if it's a language command
 */
export function isLanguageCommand(definition: ICommandDefinition): definition is ILanguageCommandDefinition {
  return definition.type === 'language';
}

/**
 * Execution context for command invocation
 * 
 * @remarks Provides context for error reporting and environment control
 */
export interface ICommandExecutionContext {
  /** The original command name */
  commandName: string;
  
  /** The resolved arguments for the command */
  resolvedArguments: string[];
  
  /** The state service instance */
  state: IStateService;
  
  /** The resolution service for variable resolution */
  resolutionService: IResolutionService;
  
  /** The file system service for file operations */
  fileSystem: IFileSystemService;
  
  /** The path service for path operations */
  pathService: IPathService;
  
  /** Optional working directory for command execution */
  workingDirectory?: string;
  
  /** Optional environment variables for command execution */
  environmentVariables?: Record<string, string>;
}

/**
 * Options for command definition parsing
 * 
 * @remarks Configuration options for the @define directive handler
 */
export interface ICommandDefinitionOptions {
  /** Whether to allow overriding existing commands */
  allowOverride?: boolean;
  
  /** Whether to extract metadata from command name */
  extractMetadata?: boolean;
  
  /** Default visibility for commands without explicit metadata */
  defaultVisibility?: 'public' | 'private';
}
````). Does it adequately address your original request (`# FileSystemCore Service Improvements for @define Types

## Current State Analysis

After examining the FileSystemService code and the broader Meld architecture, I've identified several areas where stronger typing for the `@define` directive would significantly improve the service's reliability and maintainability.

The FileSystemService is responsible for file operations and command execution, making it a critical component when handling `@define` directives and their execution via `@run`. Currently, the service has limited type support for command execution, which creates several challenges:

## Key Improvement Areas

### 1. Command Execution Type Safety

**Current Issue:**
The `executeCommand` method currently accepts any string as a command without validation or type checking:

```typescript
async executeCommand(command: string, options?: { cwd?: string }): Promise<{ stdout: string; stderr: string }>
```
This creates several problems:
- No distinction between regular shell commands and defined commands
- No parameter validation for defined commands
- No compile-time verification of command structure
**Proposed Solution:**
Create a discriminated union type for commands:
```typescript
// Define command types
type CommandType = 'shell' | 'defined' | 'language';

// Base command interface
interface BaseCommand {
  type: CommandType;
  options?: { cwd?: string };
}

// Shell command (direct execution)
interface ShellCommand extends BaseCommand {
  type: 'shell';
  command: string;
}

// Defined command (from @define directive)
interface DefinedCommand extends BaseCommand {
  type: 'defined';
  name: string;
  parameters: Record<string, string>;
  originalTemplate?: string;
}

// Language command (JavaScript, Python, etc.)
interface LanguageCommand extends BaseCommand {
  type: 'language';
  language: 'js' | 'python' | 'bash';
  code: string;
  parameters: string[];
}

// Union type for all commands
type Command = ShellCommand | DefinedCommand | LanguageCommand;
```
**Benefits:**
1. **Type Safety**: Prevents mixing of different command types
2. **Parameter Validation**: Ensures defined commands receive the correct parameters
3. **Better IDE Support**: Provides autocomplete and documentation for command properties
4. **Error Prevention**: Catches command structure errors at compile time
    <2commandDefinitionType>
**Current Issue:**
The service lacks a clear type definition for command templates created via , making it difficult to validate and process them consistently.
**Proposed Solution:**
Create a dedicated type for command definitions:
```typescript
interface CommandParameter {
  name: string;
  defaultValue?: string;
  required: boolean;
}

interface CommandDefinition {
  name: string;
  parameters: CommandParameter[];
  template: string;
  isLanguageCommand: boolean;
  language?: 'js' | 'python' | 'bash';
  codeBlock?: string;
}
```
**Benefits:**
1. **Consistent Structure**: Ensures all command definitions follow the same structure
2. **Parameter Validation**: Makes it easier to validate parameters when executing commands
3. **Clear Documentation**: Provides a self-documenting type for command definitions
4. **Integration with State Service**: Simplifies storage and retrieval of command definitions
    </2commandDefinitionType>
    <3commandExecutionResultType>
**Current Issue:**
The current return type for  is simplistic and doesn&apos;t provide enough context about the execution:
```typescript
Promise<{ stdout: string; stderr: string }>
```
**Proposed Solution:**
Enhance the return type to include more execution context:
```typescript
interface CommandExecutionResult {
  stdout: string;
  stderr: string;
  exitCode: number;
  command: Command;
  executionTime: number;
  successful: boolean;
}
```
**Benefits:**
1. **Rich Context**: Provides more information about the command execution
2. **Error Handling**: Makes it easier to determine if a command succeeded
3. **Debugging**: Includes the original command for debugging purposes
4. **Performance Tracking**: Includes execution time for performance analysis
    </3commandExecutionResultType>
    <4commandValidationType>
**Current Issue:**
There&apos;s no structured way to validate commands before execution, leading to runtime errors.
**Proposed Solution:**
Create a validation result type:
```typescript
interface CommandValidationError {
  code: string;
  message: string;
  parameter?: string;
  suggestion?: string;
}

interface CommandValidationResult {
  valid: boolean;
  command: Command;
  errors: CommandValidationError[];
}
```
**Benefits:**
1. **Early Error Detection**: Catches command errors before execution
2. **Detailed Error Messages**: Provides specific information about validation failures
3. **Suggestions**: Can offer suggestions to fix invalid commands
4. **Consistent Validation**: Ensures all commands are validated consistently
    </4commandValidationType>
  </TaskRespondToTheArchitect>
  <ImplementationExample>
Here&apos;s how these types could be integrated into the FileSystemService:
```typescript
// Updated executeCommand method with stronger typing
async executeCommand(command: Command): Promise<CommandExecutionResult> {
  const context = {
    operation: 'executeCommand',
    commandType: command.type,
    command: command.type === 'shell' ? command.command : command.name
  };

  try {
    logger.debug('Executing command', context);
    
    let result: { stdout: string; stderr: string; exitCode: number };
    const startTime = Date.now();
    
    switch (command.type) {
      case 'shell':
        result = await this.fs.executeCommand(command.command, command.options);
        break;
        
      case 'defined':
        // Get the command definition from state
        const definition = await this.getCommandDefinition(command.name);
        if (!definition) {
          throw new MeldFileSystemError(`Command not found: ${command.name}`, { command: command.name });
        }
        
        // Apply parameters to template
        const resolvedCommand = this.applyParametersToTemplate(definition, command.parameters);
        result = await this.fs.executeCommand(resolvedCommand, command.options);
        break;
        
      case 'language':
        // Execute language command
        result = await this.executeLanguageCommand(command);
        break;
    }
    
    const executionTime = Date.now() - startTime;
    
    logger.debug('Command executed successfully', { 
      ...context, 
      stdout: result.stdout, 
      stderr: result.stderr,
      exitCode: result.exitCode,
      executionTime
    });
    
    return {
      stdout: result.stdout,
      stderr: result.stderr,
      exitCode: result.exitCode,
      command,
      executionTime,
      successful: result.exitCode === 0
    };
  } catch (error) {
    const err = error as Error;
    logger.error('Failed to execute command', { ...context, error: err });
    throw new MeldFileSystemError(`Failed to execute command: ${
      command.type === 'shell' ? command.command : command.name
    }`, {
      cause: err,
      command: command.type === 'shell' ? command.command : command.name
    });
  }
}
```
  </ImplementationExample>
  <ValidationMethodExample>
```typescript
// Command validation method
validateCommand(command: Command): CommandValidationResult {
  const errors: CommandValidationError[] = [];
  
  switch (command.type) {
    case 'defined':
      // Get the command definition
      const definition = this.getCommandDefinition(command.name);
      
      // Check if command exists
      if (!definition) {
        errors.push({
          code: 'COMMAND_NOT_FOUND',
          message: `Command '${command.name}' not found`,
          suggestion: 'Check the command name or define it using @define'
        });
        break;
      }
      
      // Validate parameters
      for (const param of definition.parameters) {
        if (param.required && !command.parameters[param.name]) {
          errors.push({
            code: 'MISSING_PARAMETER',
            message: `Missing required parameter: ${param.name}`,
            parameter: param.name,
            suggestion: `Provide a value for '${param.name}'`
          });
        }
      }
      break;
      
    case 'language':
      // Validate language
      if (!['js', 'python', 'bash'].includes(command.language)) {
        errors.push({
          code: 'INVALID_LANGUAGE',
          message: `Invalid language: ${command.language}`,
          suggestion: 'Use one of: js, python, bash'
        });
      }
      break;
  }
  
  return {
    valid: errors.length === 0,
    command,
    errors
  };
}
```
  </ValidationMethodExample>
  <BenefitsForFilesystemcoreService>
1. **Reduced Error Handling**: The discriminated union pattern eliminates many runtime checks and error cases.
2. **Improved Developer Experience**: Strong types provide better autocomplete, documentation, and error messages.
3. **Consistency with Meld Architecture**: These types align with Meld&apos;s directive-based architecture and dependency injection pattern.
4. **Simplified Testing**: Well-defined types make it easier to create mock commands and test the service.
5. **Better Integration with State Service**: Clear types for command definitions improve how they&apos;re stored and retrieved from the state.
6. **Enhanced Security**: Stronger typing reduces the risk of command injection and other security issues.
7. **Future-Proofing**: The type structure allows for easy extension to support new command types or parameters.
  </BenefitsForFilesystemcoreService>
  <Conclusion>
Implementing stronger TypeScript types for the  directive would significantly improve the FileSystemCore service by making command execution more robust, reducing runtime errors, and providing better documentation and IDE support. These changes align with Meld&apos;s architecture and would make the service easier to maintain and extend in the future.CoreDirective` service?
**Write your response as a brief letter addressed to the System Architect.**
- Acknowledge the proposal.
- State clearly whether the draft meets the core needs outlined in your original request, particularly regarding code simplification.
- If it falls short, explain *specifically* what changes are still required in the types to achieve the desired simplification in your service&apos;s code.
- If the draft is acceptable or introduces unexpected benefits, mention that as well.
- Keep the tone professional and constructive.
  </Conclusion>
</FilesystemcoreServiceImprovementsForDefineTypes>