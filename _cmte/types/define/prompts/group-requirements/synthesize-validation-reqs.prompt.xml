<SynthesizeValidationRequirementsForDefine>
  <Context>
You are the **System Architect**. You have received feedback from component leads regarding the validation rules needed for the  directive.
**CRITICAL NOTE:** Focus *only* on validation requirements (static and runtime) for  directive parameters, syntax, and definition storage.
    <FeedbackOnValidation></FeedbackOnValidation>
  </Context>
</SynthesizeValidationRequirementsForDefine>

<NoteInputsAdjustedForDefineContext>
**DefineHandler Feedback:**
</NoteInputsAdjustedForDefineContext>

<TypescriptTypeImprovementsForDefinedirectivehandler>
After analyzing the current implementation of the  and  functions, I&apos;ve identified several areas where stronger TypeScript types would significantly improve code safety, readability, and maintainability.
  <CurrentIssues>
1. **Loose Command Definition Structure**: The  interface doesn&apos;t explicitly distinguish between basic commands and language commands.
2. **Manual Validation**: There&apos;s excessive manual validation that could be handled by the type system.
3. **Unclear Parameter Requirements**: The relationship between parameters and their usage in commands isn&apos;t strongly typed.
4. **Metadata Handling**: The metadata parsing logic is error-prone with manual string splitting and validation.
5. **Command Type Ambiguity**: The code doesn&apos;t clearly distinguish between different types of commands (shell vs. language-specific).
  </CurrentIssues>
  <ProposedTypeImprovements>
    <1discriminatedUnionForCommandTypes>
```typescript
// Base command definition
interface BaseCommandDefinition {
  parameters: string[];
  metadata?: CommandMetadata;
}

// For shell commands
interface ShellCommandDefinition extends BaseCommandDefinition {
  type: 'shell';
  command: string;
}

// For language-specific commands
interface LanguageCommandDefinition extends BaseCommandDefinition {
  type: 'language';
  language: 'js' | 'python' | 'bash';
  code: string;
}

// Union type
type CommandDefinition = ShellCommandDefinition | LanguageCommandDefinition;
```
**Justification**: This discriminated union clearly distinguishes between shell commands and language-specific commands. It eliminates the need for runtime checks of command structure and makes the code&apos;s intent clearer. The handler can use type guards to safely process each command type appropriately.
    </1discriminatedUnionForCommandTypes>
    <2strongerMetadataTypes>
```typescript
interface CommandMetadata {
  risk?: 'high' | 'med' | 'low';
  about?: string;
  meta?: Record<string, unknown>;
}

// For parsing from dot notation
type MetadataKey = 'risk' | 'about';
type RiskLevel = 'high' | 'med' | 'low';
```
**Justification**: Creating explicit types for metadata keys and risk levels eliminates string literal checks and improves autocomplete support. This reduces the chance of errors in metadata handling and makes the code more maintainable.
    </2strongerMetadataTypes>
    <3defineDirectiveDataType>
```typescript
interface BaseDefineDirectiveData {
  name: string;
  parameters?: string[];
}

interface ShellDefineData extends BaseDefineDirectiveData {
  commandType: 'shell';
  command: {
    kind: 'run';
    command: string;
  };
}

interface LanguageDefineData extends BaseDefineDirectiveData {
  commandType: 'language';
  command: {
    kind: 'run';
    language: 'js' | 'python' | 'bash';
    args?: string[];
    code: string;
  };
}

type DefineDirectiveData = ShellDefineData | LanguageDefineData;
```
**Justification**: This improved type definition for the directive data makes it clear what properties are expected and enforces the relationship between command types. It would eliminate many of the manual validation checks currently needed.
    </3defineDirectiveDataType>
    <4commandNameParserType>
```typescript
interface ParsedIdentifier {
  name: string;
  metadata?: CommandMetadata;
}

// For parsing command.name.risk.high format
interface NameWithMetadata {
  baseName: string;
  metadataKey?: MetadataKey;
  metadataValue?: string;
}
```
**Justification**: Creating a structured type for parsed identifiers makes the parsing logic more explicit and less error-prone. It eliminates the need for manual string splitting and validation in the  method.
    </4commandNameParserType>
    <5parameterReferenceType>
```typescript
interface ParameterReference {
  name: string;
  position: number;
}
```
**Justification**: This type would improve the parameter extraction logic by providing a clear structure for parameter references, including their position in the command string. This would make parameter substitution more reliable.
    </5parameterReferenceType>
  </ProposedTypeImprovements>
  <ImplementationExample>
Here&apos;s how the improved  would look with these type improvements:
```typescript
@injectable()
@Service({
  description: 'Handler for @define directives'
})
export class DefineDirectiveHandler implements IDirectiveHandler {
  public readonly kind = 'define';

  constructor(
    @inject('IValidationService') private validationService: IValidationService,
    @inject('IStateService') private stateService: IStateService,
    @inject('IResolutionService') private resolutionService: IResolutionService
  ) {}

  async execute(node: DirectiveNode, context: DirectiveContext): Promise<IStateService> {
    try {
      // 1. Validate directive structure
      await this.validationService.validate(node);

      // 2. Extract name, parameters, and command from directive
      const directive = node.directive as DefineDirectiveData;
      
      // Parse any metadata from the name
      const parsedIdentifier = this.parseIdentifier(directive.name);
      
      // 3. Create command definition based on the type
      let commandDef: CommandDefinition;
      
      if (directive.commandType === 'shell') {
        commandDef = {
          type: 'shell',
          parameters: directive.parameters || [],
          command: directive.command.command,
          ...(parsedIdentifier.metadata && { metadata: parsedIdentifier.metadata })
        };
      } else {
        // Language command
        commandDef = {
          type: 'language',
          parameters: directive.parameters || [],
          language: directive.command.language,
          code: directive.command.code,
          ...(parsedIdentifier.metadata && { metadata: parsedIdentifier.metadata })
        };
      }

      // 4. Create new state for modifications
      const newState = context.state.clone();

      // 5. Store command with metadata
      newState.setCommand(parsedIdentifier.name, commandDef);

      return newState;
    } catch (error) {
      // Error handling (unchanged)
      // ...
    }
  }

  private parseIdentifier(identifier: string): ParsedIdentifier {
    // Check for metadata fields
    const parts = identifier.split('.');
    const name = parts[0];

    if (!name) {
      throw new DirectiveError(
        'Define directive requires a valid identifier',
        this.kind,
        DirectiveErrorCode.VALIDATION_FAILED,
        {
          severity: DirectiveErrorSeverity[DirectiveErrorCode.VALIDATION_FAILED]
        }
      );
    }

    // Handle metadata if present
    if (parts.length > 1) {
      const metadataKey = parts[1] as MetadataKey;
      const metadataValue = parts[2];

      // Validate metadata key
      if (metadataKey !== 'risk' && metadataKey !== 'about') {
        throw new DirectiveError(
          'Invalid metadata field. Only risk and about are supported',
          this.kind,
          DirectiveErrorCode.VALIDATION_FAILED,
          {
            severity: DirectiveErrorSeverity[DirectiveErrorCode.VALIDATION_FAILED]
          }
        );
      }

      // Handle risk metadata
      if (metadataKey === 'risk') {
        const riskLevel = metadataValue as RiskLevel;
        
        // Validate risk level
        if (!['high', 'med', 'low'].includes(riskLevel)) {
          throw new DirectiveError(
            'Invalid risk level. Must be high, med, or low',
            this.kind,
            DirectiveErrorCode.VALIDATION_FAILED,
            {
              severity: DirectiveErrorSeverity[DirectiveErrorCode.VALIDATION_FAILED]
            }
          );
        }
        
        return { 
          name, 
          metadata: { risk: riskLevel } 
        };
      }

      // Handle about metadata
      if (metadataKey === 'about') {
        return { 
          name, 
          metadata: { about: metadataValue || 'This is a description' } 
        };
      }
    }

    return { name };
  }
}
```
  </ImplementationExample>
  <BenefitsOfTheseChanges>
1. **Type Safety**: The discriminated unions ensure that we&apos;re handling the correct command types at compile time.
2. **Reduced Runtime Validation**: Many of the manual validation checks can be eliminated because the type system enforces correct structure.
3. **Better IDE Support**: Developers get better autocompletion and inline documentation when working with these types.
4. **Clearer Intent**: The code clearly distinguishes between shell commands and language commands.
5. **More Maintainable**: When changes are needed to the command structure, the type system will highlight all places that need updates.
6. **Improved Error Messages**: TypeScript will provide more specific error messages during development.
7. **Self-Documenting Code**: The types themselves serve as documentation for the expected structure of define directives.
These improvements would significantly enhance the robustness and maintainability of the DefineDirectiveHandler while reducing the likelihood of bugs related to command structure and processing.
**ParserCore Feedback (Syntax Validation):**
  </BenefitsOfTheseChanges>
</TypescriptTypeImprovementsForDefinedirectivehandler>

<ParsercoreImprovementsForDefineDirectiveTypeHandling>
  <CurrentLimitationsAndChallenges>
After analyzing the ParserCore service, I&apos;ve identified several areas where we can enhance TypeScript type support for the  directive. The current implementation has these limitations:
1. **No Specialized Type for @define Directives**: The code uses generic  types, requiring manual validation and type assertion.
2. **Inadequate Parameter Type Handling**: Parameters in  directives need stronger type validation to prevent runtime errors.
3. **Lack of Discrimination Between Command Types**: Basic shell commands vs. language commands (JS, Python, etc.) aren&apos;t clearly distinguished at the type level.
4. **Missing Structure for Command Templates**: The right-hand side  directive structure isn&apos;t enforced by the type system.
  </CurrentLimitationsAndChallenges>
  <ProposedTypeImprovements>
    <1defineSpecificDirectiveType>
```typescript
interface DefineDirectiveNode extends DirectiveNode {
  directive: {
    kind: 'define';
    commandName: string;
    parameters: string[];
    body: RunDirectiveNode; // Must be a @run directive
    // Metadata for better error reporting
    location?: SourceLocation;
  }
}
```
**Justification**: This specialized type would:
- Eliminate the need for manual type checking and casting in the  method
- Provide compile-time validation that all required properties exist
- Make the code more self-documenting by clearly showing the expected structure
- Enable better IDE autocompletion and error detection
    </1defineSpecificDirectiveType>
    <2parameterTypeEnhancement>
```typescript
interface DefineParameter {
  name: string;
  defaultValue?: string | null;
  location?: SourceLocation;
}

// Updated directive to use the enhanced parameter type
interface DefineDirectiveNode extends DirectiveNode {
  directive: {
    kind: 'define';
    commandName: string;
    parameters: DefineParameter[]; // Using the stronger type
    body: RunDirectiveNode;
    location?: SourceLocation;
  }
}
```
**Justification**: This improvement would:
- Support future parameter validation (e.g., default values, required vs. optional)
- Enable better error messages that point to the specific parameter causing an issue
- Provide location information for highlighting the problematic parameter in error messages
- Simplify parameter handling by providing a consistent structure
    </2parameterTypeEnhancement>
    <3commandTypeDiscrimination>
```typescript
type RunDirectiveKind = 'basic' | 'language';

interface BaseRunDirectiveNode extends DirectiveNode {
  directive: {
    kind: 'run';
    runKind: RunDirectiveKind;
    location?: SourceLocation;
  }
}

interface BasicRunDirectiveNode extends BaseRunDirectiveNode {
  directive: {
    kind: 'run';
    runKind: 'basic';
    command: string;
    isMultiline: boolean;
    location?: SourceLocation;
  }
}

interface LanguageRunDirectiveNode extends BaseRunDirectiveNode {
  directive: {
    kind: 'run';
    runKind: 'language';
    language: string;
    parameters: string[];
    code: string;
    location?: SourceLocation;
  }
}

type RunDirectiveNode = BasicRunDirectiveNode | LanguageRunDirectiveNode;
```
**Justification**: This discrimination would:
- Enforce correct handling of different command types through TypeScript&apos;s discriminated unions
- Prevent errors from trying to access properties that don&apos;t exist on a particular command type
- Make code more maintainable by clearly indicating the expected structure for each command type
- Simplify conditional logic with type guards instead of manual property checking
    </3commandTypeDiscrimination>
    <4commandDefinitionType>
```typescript
interface CommandDefinition {
  commandName: string;
  parameters: DefineParameter[];
  runDirective: RunDirectiveNode;
  sourceLocation?: SourceLocation;
}
```
**Justification**: This type would:
- Provide a clean structure for storing command definitions in the state
- Ensure all necessary information is captured for later execution
- Make the relationship between define directives and their execution clearer
- Enable better error reporting by preserving source locations
    </4commandDefinitionType>
  </ProposedTypeImprovements>
  <ImplementationBenefits>
Implementing these type improvements would bring several benefits to the ParserCore service:
    <1simplifiedVariableNodeTransformation>
Current code in  uses type assertions and manual property checking:
```typescript
if (anyNode.type === 'Directive' && anyNode.directive) {
  // Clone the directive data and recursively transform any variables it contains
  const transformedDirective = { ...anyNode.directive };
  
  // Check for specific properties that might contain variable references
  if (transformedDirective.value && typeof transformedDirective.value === 'object') {
    transformedDirective.value = this.transformVariableNode(transformedDirective.value);
  }
  
  return {
    ...anyNode,
    directive: transformedDirective
  };
}
```
With improved types, we could have clearer, type-safe handling:
```typescript
if (isDefineDirective(anyNode)) {
  // Handle define directive specifically
  return {
    ...anyNode,
    directive: {
      ...anyNode.directive,
      body: this.transformVariableNode(anyNode.directive.body) as RunDirectiveNode
    }
  };
}
```
    </1simplifiedVariableNodeTransformation>
    <2enhancedErrorReporting>
Our current error handling in  could be extended to validate define directives:
```typescript
private validateDefineDirective(node: DefineDirectiveNode): void {
  const { commandName, parameters, body } = node.directive;
  
  // Validate command name
  if (!commandName || commandName.trim() === '') {
    throw new MeldParseError(
      'Invalid @define directive: missing command name',
      node.location
    );
  }
  
  // Validate that body is a run directive
  if (body.directive.kind !== 'run') {
    throw new MeldParseError(
      'Invalid @define directive: body must be a @run directive',
      body.location || node.location
    );
  }
  
  // Additional validations based on run directive kind
  if (body.directive.runKind === 'language') {
    // Validate language-specific requirements
  }
}
```
    </2enhancedErrorReporting>
    <3saferParameterHandling>
With the enhanced parameter type, we can perform better validation:
```typescript
private validateParameters(parameters: DefineParameter[]): void {
  // Check for duplicate parameter names
  const paramNames = new Set<string>();
  for (const param of parameters) {
    if (paramNames.has(param.name)) {
      throw new MeldParseError(
        `Duplicate parameter name: ${param.name}`,
        param.location
      );
    }
    paramNames.add(param.name);
  }
}
```
    </3saferParameterHandling>
  </ImplementationBenefits>
  <MigrationPath>
To implement these improvements with minimal disruption:
1. **Define the new types** in a dedicated file (e.g., )
2. **Add type guards** to safely check and convert between types:
```typescript
function isDefineDirective(node: MeldNode): node is DefineDirectiveNode {
  return (
    node.type === 'Directive' &&
    node.directive?.kind === 'define' &&
    typeof node.directive.commandName === 'string'
  );
}
```
1. **Update the parser transformation logic** to use these specialized types
2. **Add validation functions** that leverage the type information
  </MigrationPath>
  <Conclusion>
By enhancing the TypeScript types for the  directive, we can make the ParserCore service more robust, maintainable, and self-documenting. These improvements would:
- Provide stronger compile-time validation
- Reduce the need for manual type checking and assertions
- Enable better error messages with precise location information
- Make the code more maintainable by clearly expressing the expected structure
- Improve IDE support with better autocompletion and error detection
These benefits directly address the complexity and manual validation currently required for handling  directives, resulting in code that is both safer and easier to understand.
  </Conclusion>
</ParsercoreImprovementsForDefineDirectiveTypeHandling>

<RemovedRunvalidationfeedbackRunhandlercorefeedback>
  <TaskSynthesizeValidationRequirements>
Review the provided feedback. Consolidate the requirements related *specifically* to the validation of  directives.
- Identify necessary static checks (e.g., command name syntax, parameter syntax, RHS must be ).
- Note required runtime checks (e.g., potential name collisions?).
- Consolidate rules for parameter definition validation.
**Output Format:** Produce concise notes outlining the synthesized validation requirements for the  directive.
    <SynthesizedRequirementsDefineValidation>
- Requirement 1: (e.g., Validate command name doesn&apos;t start with $, no spaces)
- Requirement 2: (e.g., Validate parameter names are valid identifiers)
- Requirement 3: (e.g., Validate RHS is a valid @run directive)
- Requirement 4: (e.g., Check for duplicate command definitions?)
- (List other key validation requirements)
    </SynthesizedRequirementsDefineValidation>
  </TaskSynthesizeValidationRequirements>
</RemovedRunvalidationfeedbackRunhandlercorefeedback>