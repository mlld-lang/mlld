<SimplifyResolutioncoreCodeWithStrongerDefineTypes>
  <Context>
You are the lead developer for the **ResolutionCore** service.
The Meld language is improving its TypeScript type system for the  directive.
**CRITICAL NOTE:** The &apos;define&apos; directive in Meld **exclusively** embeds *text content* from files or *string values* from variables. It does **not** handle multimedia or web content. Base your analysis ONLY on this Meld-specific definition.
Review the following:
1. **Overall Architecture:**
    <DocsDevDiArchitectureMd>
```javascript
# Meld Architecture

## INTRODUCTION

Meld is a specialized, directive-based scripting language designed for embedding small "@directives" inside an otherwise plain text (e.g., Markdown-like) document. The code in this repository implements:

• Meld grammar rules and token types (e.g., text directives, path directives, data directives).  
• The parsing layer that converts Meld content into an AST (Abstract Syntax Tree).  
• A directive interpretation layer that processes these AST nodes and manipulates internal "states" to store variables and more.  
• A resolution layer to handle variable references, path expansions, data manipulations, etc.  
• Testing utilities and an in-memory FS (memfs) to simulate filesystems for thorough testing.  

The main idea:  
1. Meld code is parsed to an AST.  
2. Each directive node is validated and interpreted, updating a shared "state" (variables, data structures, commands, etc.).  
3. Optional transformations (e.g., output formatting) generate final representations (Markdown, LLM-friendly XML, etc.).  

Below is an overview of the directory and service-level architecture, referencing code from this codebase.

## DEPENDENCY INJECTION ARCHITECTURE

Meld uses TSyringe for dependency injection, which brings the following benefits:

• Decoupled service creation from service usage
• Simplified testing with mock injections
• Clear dependencies between services
• Centralized service configuration

### DI Core Concepts

1. **Service Registration**: Services are registered with the DI container via the `@Service()` decorator, which handles automatic registration with the container.

2. **Dependency Injection**: Services declare their dependencies using constructor parameters with the `@inject()` decorator, allowing the container to provide the correct dependencies.

3. **Container Resolution**: The container automatically resolves dependencies when creating instances, managing the entire dependency tree.

4. **Interface-based Design**: Services follow an interface-first design pattern, where each service implements an interface (e.g., `IFileSystemService`) and dependencies are declared using interface tokens.

5. **Circular Dependency Handling**: Circular dependencies are managed through the Client Factory pattern, which creates focused client interfaces for specific service interactions.

### DI Configuration

The core DI configuration is managed in `core/di-config.ts`, which:

1. Configures the global container
2. Registers core services and client factories
3. Connects services via their respective client interfaces
4. Registers remaining services using class registrations

## DIRECTORY & FILE STRUCTURE

At a high level, the project is arranged as follows (select key entries included):

project-root/  
 ├─ api/                    ← High-level API and tests  
 │   ├─ api.test.ts  
 │   └─ index.ts  
 ├─ bin/                    ← CLI entry point  
 │   └─ meld.ts  
 ├─ cli/                    ← CLI implementation  
 │   ├─ cli.test.ts  
 │   └─ index.ts  
 ├─ core/                   ← Core utilities and types  
 │   ├─ config/            ← Configuration (logging, etc.)  
 │   ├─ errors/            ← Error class definitions  
 │   │   ├─ MeldError.ts
 │   │   ├─ ServiceInitializationError.ts   ← Service initialization errors
 │   │   └─ ... other errors
 │   ├─ types/             ← Core type definitions  
 │   │   ├─ dependencies.ts  ← Service dependency definitions
 │   │   └─ index.ts
 │   ├─ utils/             ← Logging and utility modules  
 │   │   ├─ logger.ts
 │   │   ├─ serviceValidation.ts  ← Service validation utilities
 │   │   └─ simpleLogger.ts
 │   └─ ServiceProvider.ts ← DI service provider & helpers
 ├─ services/              ← Core service implementations  
 │   ├─ pipeline/          ← Main transformation pipeline  
 │   │   ├─ ParserService/     ← Initial parsing  
 │   │   ├─ InterpreterService/← Pipeline orchestration  
 │   │   ├─ DirectiveService/  ← Directive handling  
 │   │   │   ├─ handlers/  
 │   │   │   │   ├─ definition/   ← Handlers for definition directives  
 │   │   │   │   └─ execution/    ← Handlers for execution directives  
 │   │   │   └─ errors/  
 │   │   └─ OutputService/    ← Final output generation  
 │   ├─ state/             ← State management  
 │   │   ├─ StateService/      ← Core state management  
 │   │   └─ StateEventService/ ← Core event system  
 │   ├─ resolution/        ← Resolution and validation  
 │   │   ├─ ResolutionService/ ← Variable/path resolution  
 │   │   ├─ ValidationService/ ← Directive validation  
 │   │   └─ CircularityService/← Circular dependency detection  
 │   ├─ fs/                ← File system operations  
 │   │   ├─ FileSystemService/ ← File operations  
 │   │   ├─ PathService/      ← Path handling  
 │   │   └─ PathOperationsService/ ← Path utilities  
 │   └─ cli/               ← Command line interface  
 │       └─ CLIService/    ← CLI entry point  
 ├─ tests/                  ← Test infrastructure   
 │   ├─ fixtures/          ← Test fixture data  
 │   ├─ mocks/             ← Test mock implementations  
 │   └─ utils/             ← Test utilities and helpers  
 │       ├─ debug/         ← Test debug utilities  
 │       │   ├─ StateDebuggerService/  
 │       │   ├─ StateVisualizationService/  
 │       │   ├─ StateHistoryService/  
 │       │   └─ StateTrackingService/  
 │       ├─ di/            ← DI test utilities
 │       │   ├─ TestContainerHelper.ts ← Container management for tests
 │       │   └─ TestContextDI.ts ← DI-enabled test context
 │       ├─ FixtureManager.ts  
 │       ├─ MemfsTestFileSystem.ts  
 │       ├─ ProjectBuilder.ts  
 │       ├─ TestContext.ts  
 │       └─ TestSnapshot.ts  
 ├─ docs/                   ← Documentation  
 ├─ package.json  
 ├─ tsconfig.json  
 ├─ tsup.config.ts  
 └─ vitest.config.ts  

Key subfolders:  
• services/pipeline/: Core transformation pipeline services (parsing, interpretation, directives, output)  
• services/state/: State management and event services  
• services/resolution/: Resolution, validation, and circularity detection services  
• services/fs/: File system, path handling, and operations services  
• services/cli/: Command line interface services  
• core/: Central types, errors, utilities, and DI service provider used throughout the codebase  
• tests/utils/: Test infrastructure including debug utilities, memfs implementation, fixture management, and test helpers  
• tests/utils/di/: DI-specific test utilities
• api/: High-level public API for using Meld programmatically  
• cli/: Command line interface for Meld  

## CORE LIBRARIES & THEIR ROLE

### meld-ast 
   • parse(content: string): MeldNode[]  
   • Basic parsing that identifies directives vs. text nodes.  
   • Produces an AST which other services manipulate.  

### llmxml 
   • Converts content to an LLM-friendly XML format or can parse partially.  
   • OutputService may call it if user requests "llm" format.  

### meld-spec
   • Contains interface definitions for MeldNode, DirectiveNode, TextNode, etc.  
   • Contains directive kind enumerations.  

### tsyringe
   • Provides the dependency injection container
   • Manages service creation and resolution
   • Handles dependencies between services

## HIGH-LEVEL FLOW

Below is a simplified flow of how Meld content is processed:

   ┌─────────────────────────────┐
   │   Meld Source Document      │
   └─────────────────────────────┘
                │
                ▼
   ┌─────────────────────────────┐
   │ ParserService.parse(...)    │
   │   → uses meld-ast to parse  │
   └─────────────────────────────┘
                │ AST (MeldNode[])
                ▼
   ┌─────────────────────────────────────────────────┐
   │ InterpreterService.interpret(nodes, options)    │
   │   → For each node, pass to DirectiveService     │
   │   → Handles node transformations                │
   └─────────────────────────────────────────────────┘
                │
                ▼
   ┌──────────────────────────────────────────┐
   │ DirectiveService                         │
   │   → Routes to correct directive handler  │
   │   → Handlers can provide replacements    │
   └──────────────────────────────────────────┘
                │
                ▼
   ┌───────────────────────────────────────────────┐
   │ StateService + ResolutionService + Others     │
   │   → Stores variables and transformed nodes    │
   │   → Path expansions, data lookups, etc.       │
   └───────────────────────────────────────────────┘
                │
                ▼
   ┌──────────────────────────────────────────┐
   │ OutputService                            │
   │   → Uses transformed nodes for output    │
   │   → Generates clean, directive-free      │
   │     markdown, LLM XML, or other formats  │
   └──────────────────────────────────────────┘

This flow is orchestrated through DI, where the container resolves all required services and their dependencies automatically. The DI container handles service creation, ensuring each service gets the dependencies it needs to function properly.

## MAJOR SERVICES (OVERVIEW)

Below are the key "services" in the codebase. Each follows the single responsibility principle and is registered with the DI container via the `@Service()` decorator:

### CLIService
   - Provides command-line interface for running Meld
   - Handles file watching and reprocessing
   - Manages format selection and output options
   - Routes to appropriate services based on CLI flags
   - Dependencies: ParserService, InterpreterService, OutputService, FileSystemService, PathService, StateService

### ParserService  
   - Wraps the meld-ast parse(content) function  
   - Adds location information with file paths (parseWithLocations)  
   - Produces an array of MeldNode objects  
   - Dependencies: ResolutionServiceClient (for resolving variables during parsing)

### DirectiveService  
   - Routes directives to the correct directive handler  
   - Validates directives using ValidationService  
   - Calls ResolutionService for variable resolution  
   - Updates StateService with directive execution results
   - Supports node transformation through DirectiveResult interface
   - Handlers can provide replacement nodes for transformed output
   - Dependencies: ValidationService, StateService, PathService, FileSystemService, ParserService, InterpreterService, CircularityService, ResolutionService

### InterpreterService  
   - Orchestrates the main interpret(nodes) pipeline  
   - For each AST node:
       a) If it's text, store it or pass it along  
       b) If it's a directive:
          - Calls DirectiveService for processing
          - Handles node transformations if provided
          - Updates state with transformed nodes
   - Maintains the top-level process flow
   - Supports transformation mode through feature flags
   - Dependencies: DirectiveService, StateService, ParserService, FileSystemService, PathService, CircularityService

### StateService  
   - Stores variables in maps:
       • textVars (for @text)  
       • dataVars (for @data)  
       • pathVars (for @path)  
       • commands (for @define)  
   - Tracks both original and transformed MeldNodes
   - Provides transformation capabilities for directive processing
   - Maintains transformation state during cloning
   - Provides child states for nested imports  
   - Supports immutability toggles  
   - Dependencies: StateFactory, StateEventService, StateTrackingService

### ResolutionService  
   - Handles all variable interpolation:
       • Variables ("{{var}}", "{{data.field}}")
       • Path expansions ("$HOMEPATH/path")  
       • Command references  
   - Context-aware resolution  
   - Circular reference detection  
   - Sub-fragment parsing support  
   - Dependencies: StateService, FileSystemService, ParserServiceClient, PathService

### CircularityService  
   - Prevents infinite import loops  
   - Detects circular variable references  
   - Maintains dependency graphs  
   - Dependencies: ResolutionService

### PathService  
   - Validates and normalizes paths  
   - Enforces path security constraints  
   - Handles path joining and manipulation  
   - Supports test mode for path operations  
   - Dependencies: FileSystemServiceClient (to check if paths exist)

### ValidationService  
   - Validates directive syntax and constraints  
   - Provides extensible validator registration  
   - Throws MeldDirectiveError on validation failures  
   - Tracks available directive kinds  
   - Dependencies: ResolutionService

### FileSystemService  
   - Abstracts file operations (read, write)  
   - Supports both real and test filesystems  
   - Handles path resolution and validation  
   - Dependencies: PathOperationsService, PathServiceClient, IFileSystem

### OutputService  
   - Converts final AST and state to desired format
   - Uses transformed nodes when available
   - Supports markdown and LLM XML output  
   - Integrates with llmxml for LLM-friendly formatting  
   - Handles format-specific transformations
   - Provides clean output without directive definitions
   - Dependencies: StateService, ResolutionService, VariableReferenceResolverClient

## TESTING INFRASTRUCTURE

All tests are heavily reliant on a memory-based filesystem (memfs) for isolation and speed. The major testing utilities include:

### TestContainerHelper
   - Manages DI containers for tests
   - Provides isolated container creation
   - Supports mock registration and service resolution
   - Handles container cleanup between tests
   - Detects container state leaks

### TestContextDI
   - Central test harness that extends TestContext with DI support
   - Creates a DI container for each test
   - Provides mock service registration
   - Supports child context creation
   - Ensures proper cleanup after tests
   - Resolves services from the container for testing

### MemfsTestFileSystem  
   - Thin wrapper around memfs  
   - Offers readFile, writeFile, mkdir, etc. with in-memory data  
   - Provides an ephemeral environment for all test IO  

### TestContext  
   - Base class for testing environment
   - Provides references to all major services
   - Allows writing files, snapshotting the FS, and comparing  

### TestSnapshot  
   - Takes "snapshots" of the current Memfs FS, storing a Map<filePath, content>  
   - Compares snapshots to detect added/removed/modified files  

### ProjectBuilder  
   - Creates mock "projects" in the in-memory FS from JSON structure  
   - Useful for complex, multi-file tests or large fixture-based testing  

### Node Factories  
   - Provides helper functions for creating AST nodes in tests  
   - Supports creating directive, text, and code fence nodes  
   - Includes location utilities for source mapping  

Testing Organization:
• tests/utils/: Core test infrastructure (MemFS, snapshots, contexts)  
• tests/utils/di/: DI-specific test utilities
• tests/mocks/: Minimal mocks and test doubles  
• tests/fixtures/: JSON-based test data  
• tests/services/: Service-specific integration tests  

Testing Approach:
• Each test uses TestContextDI to create a fresh container
• Direct service resolution from the container
• Mock registration for dependencies
• Isolated container state between tests
• Factory functions for creating test nodes and data
• Snapshots for tracking filesystem changes  

## DEBUGGING INFRASTRUCTURE

The codebase includes specialized debugging services located in `tests/utils/debug/` that help diagnose and troubleshoot state-related issues:

### StateDebuggerService
   - Provides debug session management and diagnostics
   - Tracks state operations and transformations
   - Offers operation tracing and analysis
   - Helps identify state manipulation issues

### StateVisualizationService
   - Generates visual representations of state
   - Creates Mermaid/DOT graphs of state relationships
   - Visualizes state metrics and transformations
   - Aids in understanding complex state changes

### StateHistoryService
   - Records chronological state changes
   - Maintains operation history
   - Tracks transformation chains
   - Enables state change replay and analysis

### StateTrackingService
   - Monitors state relationships and dependencies
   - Tracks state lineage and inheritance
   - Records metadata about state changes
   - Helps debug scope and inheritance issues

Debugging Approach:
• Services can be enabled selectively in tests
• Debug output includes detailed state snapshots
• Visual representations help understand complex states
• History tracking enables step-by-step analysis

These debugging services are particularly useful for:
• Troubleshooting complex state transformations
• Understanding directive processing chains
• Analyzing variable resolution paths
• Debugging scope inheritance issues
• Visualizing state relationships

## SERVICE RELATIONSHIPS AND DEPENDENCY INJECTION

Services in Meld follow a dependency graph managed through the DI container:

1. Base Services:
   - FileSystemService (depends on PathOperationsService, PathServiceClient)
   - PathService (depends on FileSystemServiceClient)

2. State Management:
   - StateEventService (no dependencies)
   - StateService (depends on StateFactory, StateEventService, StateTrackingService)

3. Core Pipeline:
   - ParserService (depends on ResolutionServiceClient)
   - ResolutionService (depends on StateService, FileSystemService, PathService, ParserServiceClient)
   - ValidationService (depends on ResolutionService)
   - CircularityService (depends on ResolutionService)

4. Pipeline Orchestration:
   - DirectiveService (depends on multiple services)
   - InterpreterService (orchestrates others)

5. Output Generation:
   - OutputService (depends on StateService, ResolutionService, VariableReferenceResolverClient)

6. Debug Support:
   - DebuggerService (optional, depends on all)

## Dependency Resolution Patterns

### Circular Dependency Challenges

Circular dependencies occur when two or more services depend on each other, creating a dependency cycle:

- **FileSystemService ↔ PathService**: FileSystemService needs PathService for path resolution, while PathService needs FileSystemService to check if paths exist
- **ParserService ↔ ResolutionService**: ParserService needs ResolutionService to resolve variables, while ResolutionService needs ParserService to parse content
- **StateService ↔ StateTrackingService**: Complex bidirectional relationship for state tracking and management

### Client Factory Pattern (Current Approach)

The primary approach for handling circular dependencies in Meld is the Client Factory pattern:

1. Create minimal client interfaces that expose only the methods needed by the dependent service
2. Implement factories to create these client interfaces
3. Inject the factories rather than the actual services
4. Use the clients to access only the functionality that's actually needed

This pattern follows the Interface Segregation Principle (the "I" in SOLID), ensuring that services depend only on the methods they actually use.

#### Example Implementation

For the FileSystemService ↔ PathService circular dependency:

```typescript
// Minimal interface for what FileSystemService needs from PathService
export interface IPathServiceClient {
  resolvePath(path: string): string;
  normalizePath(path: string): string;
}

// Factory to create a client for PathService functionality
@injectable()
@Service({
  description: 'Factory for creating path service clients'
})
export class PathServiceClientFactory {
  constructor(@inject('IPathService') private pathService: IPathService) {}
  
  createClient(): IPathServiceClient {
    return {
      resolvePath: (path) => this.pathService.resolvePath(path),
      normalizePath: (path) => this.pathService.normalizePath(path)
    };
  }
}

// Updated FileSystemService that depends on the factory
@injectable()
@Service({
  description: 'Service for file system operations'
})
export class FileSystemService implements IFileSystemService {
  private pathClient: IPathServiceClient;
  
  constructor(
    @inject('IPathOperationsService') private readonly pathOps: IPathOperationsService,
    @inject('PathServiceClientFactory') pathClientFactory: PathServiceClientFactory,
    @inject('IFileSystem') fileSystem: IFileSystem | null = null
  ) {
    this.fs = fileSystem || new NodeFileSystem();
    this.pathClient = pathClientFactory.createClient();
  }
  
  // Use the client interface directly
  private resolvePath(filePath: string): string {
    return this.pathClient.resolvePath(filePath);
  }
}
```
Similarly, implement the reverse direction with a  and .
    </DocsDevDiArchitectureMd>
    <DirectContainerResolutionAlternativeApproach>
For cases where the Client Factory pattern isn&apos;t feasible, direct container resolution with lazy loading can be used:
```typescript
import { resolveService } from '@core/ServiceProvider';

@injectable()
@Service({
  description: 'Service with lazy dependency resolution'
})
export class OutputService implements IOutputService {
  private resolverClient?: IVariableReferenceResolverClient;
  
  constructor(
    @inject('IStateService') private readonly stateService: IStateService,
    @inject('IResolutionService') private readonly resolutionService: IResolutionService
  ) {}
  
  /**
   * Get a resolver client using direct container resolution
   * This breaks circular dependencies by deferring resolution until needed
   */
  private getVariableResolver(): IVariableReferenceResolverClient | undefined {
    // Lazy-load the client only when needed
    if (!this.resolverClient) {
      try {
        // Get the factory from the container using ServiceProvider helper
        const factory = resolveService<VariableReferenceResolverClientFactory>(
          'VariableReferenceResolverClientFactory'
        );
        
        // Create the client
        this.resolverClient = factory.createClient();
        logger.debug('Successfully created VariableReferenceResolverClient');
      } catch (error) {
        logger.warn('Failed to create VariableReferenceResolverClient', { error });
      }
    }
    
    return this.resolverClient;
  }
  
  // Using the lazy-loaded client
  async convert(nodes: MeldNode[], state: IStateService, format: string = 'markdown'): Promise<string> {
    // Get the resolver only when needed
    const resolver = this.getVariableResolver();
    
    if (resolver && format === 'markdown') {
      // Process nodes using the resolver for field access
      return this.nodeToMarkdown(nodes, state, resolver);
    }
    
    // Fallback implementation if resolver isn't available
    return this.legacyConvert(nodes, state, format);
  }
}
```
This approach:
1. Avoids creating circular dependencies at initialization time
2. Loads dependencies only when they&apos;re actually needed
3. Provides fallback mechanisms when resolution fails
4. Uses the ServiceProvider helper  rather than direct container access
Key considerations when using direct container resolution:
1. Always include fallback mechanisms
2. Log resolution failures for debugging
3. Cache resolved instances for performance
4. Only resolve what you need, when you need it
      <BenefitsOfClientFactoryPattern>
1. **Clear Dependencies**: Services explicitly state what they need through focused interfaces
2. **Interface Segregation**: Services only get access to the specific methods they need
3. **No Null Checks**: Factory creates clients at initialization time, eliminating null checks
4. **Simpler Testing**: Small, focused interfaces are easier to mock
5. **Reduced Tight Coupling**: Services are coupled only to minimal interfaces
6. **Improved Code Readability**: Code intent becomes clearer when using direct method calls
7. **Better Maintainability**: Changes to service interfaces won&apos;t affect all dependent services
      </BenefitsOfClientFactoryPattern>
      <NamingConventions>
For consistency across the codebase, we follow these naming conventions:
- Client Interfaces:  (e.g., )
- Factory Classes:  (e.g., )
- Factory Methods:  for consistent API
      </NamingConventions>
      <TestingWithClientFactories>
Testing becomes more straightforward with the client factory pattern:
```typescript
describe('FileSystemService', () => {
  let context: TestContextDI;
  let service: IFileSystemService;
  
  beforeEach(() => {
    context = TestContextDI.create();
    
    // Create a mock client
    const mockPathClient = {
      resolvePath: vi.fn().mockReturnValue('/resolved/path'),
      normalizePath: vi.fn().mockReturnValue('normalized/path')
    };
    
    // Create a mock factory that returns our mock client
    const mockPathClientFactory = {
      createClient: vi.fn().mockReturnValue(mockPathClient)
    };
    
    // Register the mock factory
    context.registerMock('PathServiceClientFactory', mockPathClientFactory);
    
    // Resolve the service
    service = context.resolveSync('IFileSystemService');
  });
  
  afterEach(async () => {
    await context.cleanup();
  });
  
  it('should resolve paths using the path client', async () => {
    // Test that calling methods on the service uses the client correctly
    await service.readFile('some/path');
    
    // Verify the path client was used
    expect(mockPathClient.resolvePath).toHaveBeenCalledWith('some/path');
  });
});
```
For testing services that use direct container resolution, we register mocks directly with the container:
```typescript
describe('OutputService', () => {
  let context: TestContextDI;
  let service: IOutputService;
  
  beforeEach(() => {
    context = TestContextDI.create();
    
    // Create a mock resolver client
    const mockResolverClient = {
      accessFields: vi.fn().mockReturnValue('resolved value'),
      convertToString: vi.fn().mockReturnValue('formatted string')
    };
    
    // Create a mock factory that returns our mock client
    const mockFactory = {
      createClient: vi.fn().mockReturnValue(mockResolverClient)
    };
    
    // Register the mock factory with the container
    context.registerMock('VariableReferenceResolverClientFactory', mockFactory);
    
    // Resolve the service
    service = context.resolveSync('IOutputService');
  });
  
  afterEach(async () => {
    await context.cleanup();
  });
  
  it('should convert nodes to markdown with field access', async () => {
    const result = await service.convert(mockNodes, mockState, 'markdown');
    expect(result).toContain('formatted string');
  });
});
```
      </TestingWithClientFactories>
    </DirectContainerResolutionAlternativeApproach>
  </Context>
  <ExampleUsageScenario>
1. Input: A .meld file with lines like:@text greeting = "Hello"@data config = {
  "value": 123
}@import [ path = &quot;other.meld&quot; ]
2. We load the file from disk.
3. ParserService → parse the content → AST.
4. InterpreterService → interpret(AST).a) For each directive, DirectiveService → validation → resolution → update StateService.b) If an import is encountered, CircularityService ensures no infinite loops.
5. Once done, the final StateService has textVars.greeting = "Hello", dataVars.config = { value: 123 }, etc.
6. OutputService can generate the final text or an LLM-XML representation.
With DI, this flow is orchestrated through the container, which resolves all the required services and their dependencies automatically.
  </ExampleUsageScenario>
  <ErrorHandling>
• MeldDirectiveError thrown if a directive fails validation or interpretation.• MeldParseError if the parser cannot parse content.• PathValidationError for invalid paths.• ResolutionError for variable resolution issues.• MeldError as a base class for other specialized errors.• ServiceInitializationError for DI-related initialization failures.
These errors typically bubble up to the caller or test.
  </ErrorHandling>
  <Conclusion>
This codebase implements the entire Meld language pipeline:• Parsing Meld documents into an AST.• Validating &amp; interpreting directives.• Storing data in a hierarchical state.• Resolving references (text, data, paths, commands).• (Optionally) generating final formatted output.
The codebase uses TSyringe for dependency injection, which helps manage the complex relationships between services. The Client Factory pattern is used to handle circular dependencies between core services, with direct container resolution as an alternative for specific cases.
The test environment includes robust DI support with TestContextDI, allowing for isolated container testing, mock registration, and service resolution. The system adheres to SOLID design principles with interface-first design and clear separation of concerns.
  </Conclusion>
</SimplifyResolutioncoreCodeWithStrongerDefineTypes>

<DependencyInjectionInMeld>
This document provides guidance on working with the dependency injection (DI) system in the Meld codebase.
  <Overview>
Meld uses [TSyringe](https://github.com/microsoft/tsyringe) for dependency injection. All services are registered and resolved through the DI container, which simplifies service initialization and testing.
  </Overview>
  <CoreConcepts>
    <1serviceRegistration>
Services are automatically registered with the DI container when they are decorated with the  decorator:
```typescript
import { Service } from '@core/ServiceProvider';

@Service({
  description: 'Service that provides file system operations'
})
export class FileSystemService implements IFileSystemService {
  // Implementation...
}
```
The  decorator registers the class with the container and adds some metadata for documentation purposes.
    </1serviceRegistration>
    <2dependencyInjection>
Services can inject their dependencies through constructor parameters:
```typescript
import { inject } from 'tsyringe';

@Service()
export class ResolutionService implements IResolutionService {
  constructor(
    @inject('IStateService') private stateService: IStateService,
    @inject('IFileSystemService') private filesystem: IFileSystemService,
    @inject('IParserService') private parser: IParserService,
    @inject('IPathService') private pathService: IPathService
  ) {}
  
  // Implementation...
}
```
    </2dependencyInjection>
    <3creatingServices>
Services should be created using the DI container, not with :
```typescript
// CORRECT: Let the DI container create the service
import { container } from 'tsyringe';
const service = container.resolve(ServiceClass);

// CORRECT: Use the ServiceProvider helper
import { createService } from '@core/ServiceProvider';
const service = createService(ServiceClass);

// INCORRECT: Don't use 'new' directly
const service = new ServiceClass(); // Avoid this
```
    </3creatingServices>
  </CoreConcepts>
  <BestPractices>
    <ServiceDesign>
1. **Interface-First Design**: Define an interface for your service before implementing it
2. **Explicit Dependencies**: Always specify dependencies in the constructor
3. **Private Injection**: Use  in constructor parameters to store the dependencies
4. **Explicit Return Types**: Always provide return types for methods
5. **Proper Initialization**: Services should be fully initialized after construction
    </ServiceDesign>
    <ExampleService>
```typescript
import { inject } from 'tsyringe';
import { Service } from '@core/ServiceProvider';

// 1. Define the interface
export interface IExampleService {
  process(data: string): Promise<string>;
  getStatus(): string;
}

// 2. Implement the service
@Service({
  description: 'Example service that demonstrates best practices'
})
export class ExampleService implements IExampleService {
  // 3. Constructor injection with explicit dependencies
  constructor(
    @inject('IDependencyService') private dependency: IDependencyService,
    @inject('ILoggerService') private logger: ILoggerService
  ) {}

  // 4. Explicit return type
  async process(data: string): Promise<string> {
    this.logger.log('Processing data...');
    return this.dependency.transform(data);
  }

  getStatus(): string {
    return 'Ready';
  }
}
```
    </ExampleService>
  </BestPractices>
  <TestingWithDi>
    <UsingTestcontextdi>
The  class provides utilities for testing with DI:
```typescript
import { TestContextDI } from '@tests/utils/di/TestContextDI';

describe('MyService', () => {
  let context: TestContextDI;
  
  beforeEach(() => {
    // Create a test context with DI
    context = TestContextDI.create();
  });
  
  afterEach(async () => {
    // Clean up resources
    await context.cleanup();
  });
  
  it('should process data correctly', async () => {
    // Register a mock dependency
    const mockDependency = { transform: vi.fn().mockReturnValue('transformed') };
    context.registerMock('IDependencyService', mockDependency);
    
    // Get the service from the container
    const service = context.container.resolve('IExampleService');
    
    // Test the service
    const result = await service.process('input');
    expect(result).toBe('transformed');
    expect(mockDependency.transform).toHaveBeenCalledWith('input');
  });
});
```
    </UsingTestcontextdi>
    <MockingServices>
To register mock implementations:
```typescript
// Register a mock instance
context.registerMock('IServiceName', mockImplementation);

// Register a mock class
context.container.registerMockClass('IServiceName', MockClass);
```
    </MockingServices>
  </TestingWithDi>
  <CommonPatterns>
    <DualModeConstructorPattern>
Meld services need to support both DI and non-DI modes. The recommended pattern is:
```typescript
/**
 * Constructor with DI annotations
 */
constructor(
  @inject(SomeFactory) factory?: SomeFactory,
  @inject('IService1') service1?: IService1,
  @inject('IService2') service2?: IService2
) {
  this.initializeFromParams(factory, service1, service2);
}

/**
 * Helper that chooses initialization path
 */
private initializeFromParams(
  factory?: SomeFactory,
  service1?: IService1,
  service2?: IService2
): void {
  if (factory) {
    this.initializeDIMode(factory, service1, service2);
  } else {
    this.initializeLegacyMode(service1, service2);
  }
}

/**
 * DI mode initialization
 */
private initializeDIMode(
  factory: SomeFactory,
  service1?: IService1,
  service2?: IService2
): void {
  this.factory = factory;
  this.service1 = service1;
  this.service2 = service2;
  // Additional initialization
}

/**
 * Legacy mode initialization
 */
private initializeLegacyMode(
  service1?: IService1,
  service2?: IService2
): void {
  // Create default dependencies
  this.factory = new SomeFactory();
  
  // Additional initialization
}
```
This pattern:
1. Keeps the constructor simple
2. Clearly separates DI and non-DI initialization logic
3. Makes maintenance easier
4. Preserves dual-mode functionality
5. Provides a clear path to eventually remove legacy mode
See  for more examples.
    </DualModeConstructorPattern>
    <FactoryPattern>
For services that need complex initialization or multiple instances:
```typescript
@Service()
export class ServiceFactory {
  constructor(
    @inject('IDependencyA') private depA: IDependencyA,
    @inject('IDependencyB') private depB: IDependencyB
  ) {}
  
  createService(config: ServiceConfig): IService {
    // Create a specialized instance with the given config
    // The factory can use its injected dependencies
    return new SpecializedService(this.depA, this.depB, config);
  }
}
```
    </FactoryPattern>
    <ServiceProviders>
For centralized service registration:
```typescript
// In a central di-config.ts file:
import { container } from 'tsyringe';

// Register core services
container.register('FileSystemService', { useClass: FileSystemService });
container.register('IFileSystemService', { useToken: 'FileSystemService' });
```
    </ServiceProviders>
  </CommonPatterns>
  <Troubleshooting>
    <CircularDependencies>
If you have circular dependencies, use  with a string token instead of a direct class reference:
```typescript
// Instead of this (can cause circular dependency issues):
constructor(@inject(DependentService) private dependent: DependentService)

// Do this:
constructor(@inject('IDependentService') private dependent: IDependentService)
```
    </CircularDependencies>
    <MissingDependencies>
If a service fails to resolve with &quot;unregistered dependency token&quot; errors:
1. Check that the service is decorated with 
2. Verify that the injected token is registered in the container
3. Check for typos in the injection token string
4. Make sure the services are imported and executed before use
    </MissingDependencies>
    <TestingIssues>
If tests fail with DI errors:
1. Use  to create a clean container for each test
2. Register all required mock dependencies before resolving the service
3. Clean up after tests with
```

#### ../../docs/dev/PIPELINE.md
```javascript
# Meld Pipeline Flow

## Overview

The Meld pipeline processes `.mld` files through several stages to produce either `.xml` or `.md` output. Here's a detailed look at how it works:

```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│  Service    │     │   Service   │     │   Pipeline   │     │  Variable    │     │    Final     │
│Initialization├────►│ Validation  ├────►│  Execution   ├────►│  Resolution  ├────►│   Output     │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
      │                    │                    │                    │                    │
      ▼                    ▼                    ▼                    ▼                    ▼
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│Dependencies │     │Validate All │     │Process Input │     │Resolve Vars & │     │Generate Clean│
│  Resolved   │     │ Services    │     │   Content    │     │  References   │     │   Output    │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
```
    </TestingIssues>
  </Troubleshooting>
  <ServiceOrganization>
The pipeline is organized into logical service groups, with strict initialization order and dependency validation:
    <PipelineServicesServicesPipeline>
```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐
│   Parser    │     │  Directive  │     │ Interpreter  │     │   Output     │
│   Service   ├────►│   Service   ├────►│   Service    ├────►│   Service    │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘
      │                    │                    │                    │
      ▼                    ▼                    ▼                    ▼
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐
│Initialize & │     │Validate &   │     │Transform &   │     │Format &     │
│  Validate   │     │Process Dirs │     │Update State  │     │Generate Out │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘
```
    </PipelineServicesServicesPipeline>
    <StateServicesServicesState>
```ascii
┌─────────────┐     ┌─────────────┐
│    State    │     │    State    │
│   Service   ├────►│    Event    │
└─────────────┘     │   Service   │
                    └─────────────┘
```
    </StateServicesServicesState>
    <ResolutionServicesServicesResolution>
```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐
│ Resolution  │     │ Validation  │     │ Circularity  │
│   Service   ├────►│   Service   ├────►│   Service    │
└─────────────┘     └─────────────┘     └──────────────┘
```
    </ResolutionServicesServicesResolution>
    <FileSystemServicesServicesFs>
```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐
│    File     │     │    Path     │     │     Path     │
│   System    ├────►│   Service   ├────►│  Operations  │
│   Service   │     │             │     │   Service    │
└─────────────┘     └─────────────┘     └──────────────┘
```
    </FileSystemServicesServicesFs>
  </ServiceOrganization>
  <DetailedFlow>
1. **Service Initialization** ()
- Resolves service dependencies
- Initializes in correct order
- Validates service configuration
- Enables transformation if requested
2. **Input Processing** ()
- User runs 
-  handles command line options
- Default output is  format
- Can specify  for  output
- Supports  for direct console output
3. **Parsing** ()
- Reads the input file content
- Parses into AST using 
- Identifies directives and text nodes
- Adds source location information
4. **Interpretation** ()
- Processes each AST node sequentially
- Routes directives to appropriate handlers
- Handlers can provide replacement nodes
- Maintains both original and transformed states
- Resolves variables and references
- Handles file imports and embedding
5. **Variable Resolution** ()
- Resolves variable references like 
- Handles field access with dot and bracket notation
- Supports nested object and array access
- Manages path variable resolution and prefixing
- Provides two architecture models:
- Traditional: OutputService handles resolution
- Delegated: ResolutionService handles resolution
6. **Output Generation** ()
- Takes transformed nodes and state
- Converts to requested format:
- : Uses  library for LLM-friendly XML
- : Clean markdown without directive definitions
- Writes output to file or stdout
  </DetailedFlow>
  <TransformationModeAndVariableResolution>
When transformation mode is enabled, the pipeline handles directives and variables in a special way. Understanding this flow is critical for debugging and enhancing directive handlers:
```ascii
┌─────────────┐     ┌─────────────┐     ┌──────────────┐     ┌──────────────┐
│  Directive  │     │Interpretation│     │   Variable   │     │   Output     │
│  Handlers   ├────►│  & Node     ├────►│  Resolution  ├────►│  Generation  │
│(with replace│     │Transformation│     │              │     │              │
│  nodes)     │     │              │     │              │     │              │
└─────────────┘     └─────────────┘     └──────────────┘     └──────────────┘
```
    <KeyTransformationPipelineConcepts>
1. **Directive Handler Replacement Nodes**
- Directive handlers can return replacement nodes when in transformation mode
- The InterpreterService must properly apply these replacements in the transformed nodes array
- For import directives, the replacement is typically an empty text node
- For embed directives, the replacement node contains the embedded content
2. **State Propagation Across Boundaries**
- Variables must be explicitly copied between parent and child states
- When importing files, variables must be copied from imported state to parent state
- The ImportDirectiveHandler must ensure all variable types (text, data, path, commands) are copied
3. **Variable Resolution Process**
- Variables can be resolved at multiple stages:
- During directive processing
- During node transformation
- During final output generation
- During post-processing in the main function
- Meld supports two distinct architectures for variable resolution:
- **Traditional Architecture**: OutputService resolves variables directly during final rendering
- **Delegated Architecture**: OutputService delegates to ResolutionService for variable resolution
- Architecture is controlled by the  feature flag or the  environment variable
4. **State Management for Transformation**
- The StateService maintains both original and transformed node arrays
- Transformed nodes must be explicitly initialized
- The transformNode method is used to replace directive nodes with their outputs
- State must keep track of transformation options to determine which directives to transform
    </KeyTransformationPipelineConcepts>
  </TransformationModeAndVariableResolution>
  <ServiceResponsibilities>
    <PipelineServices>
1. **ParserService** ()
- Wraps meld-ast parser
- Produces AST nodes
- Adds file location information
2. **InterpreterService** ()
- Orchestrates directive processing
- Handles node transformations
- Maintains interpretation state
- Handles imports and embedding
- **Critical for transformation:** Applies directive handler replacement nodes to transformed node array
- **State propagation:** Ensures proper variable inheritance between parent and child states
3. **DirectiveService** ()
- Routes directives to handlers
- Validates directive syntax
- Supports node transformation
- Updates state based on directive results
- **Directive handlers:** Can return replacement nodes in transformation mode
- **Handler context:** Includes parent state for proper variable propagation
4. **OutputService** ()
- Uses transformed nodes for clean output
- Supports markdown and LLM XML
- Generates directive-free output
- Handles formatting options
- **Variable resolution:** Resolves variable references in text nodes during output generation
- **Transformation handling:** Uses special processing for variable references in transformation mode
    </PipelineServices>
    <StateServices>
1. **StateService** ()
- Stores variables and commands
- Maintains original and transformed nodes
- Manages scope and inheritance
- Tracks file dependencies
- **Transformation support:** Keeps track of both original and transformed node arrays
- **Variable copying:** Must explicitly copy variables between parent and child states
- **Transformation options:** Supports selective transformation of different directive types
2. **StateEventService** ()
- Handles state change events
- Manages state updates
- Provides event hooks
- Supports state tracking
    </StateServices>
    <ResolutionServices>
1. **ResolutionService** ()
- Resolves variables and references
- Handles path expansions
- Manages circular dependencies
2. **ValidationService** ()
- Validates directive syntax and constraints
- Provides extensible validator registration
- Throws MeldDirectiveError on validation failures
- Tracks available directive kinds
3. **CircularityService** ()
- Prevents infinite import loops
- Detects circular variable references
- Maintains dependency graphs
    </ResolutionServices>
    <FileSystemServices>
1. **FileSystemService** ()
- Abstracts file operations (read, write)
- Supports both real and test filesystems
- Handles path resolution and validation
2. **PathService** ()
- Validates and normalizes paths
- Enforces path security constraints
- Handles path joining and manipulation
- Supports test mode for path operations
3. **PathOperationsService** ()
- Handles complex path operations
- Provides path utilities
- Manages path transformations
```




2.  **`@define` Documentation:** 



#### ../../_dev/DEFINE-CLARITY.md
```javascript
# @define Directive: Understanding and Implementation

## Core Concept: Creating Reusable Command Templates

The `@define` directive allows you to create named, reusable templates for runnable commands (both shell commands and language scripts). These templates can accept parameters, making them function like simple macros or functions within Meld.

Defined commands are invoked using the `@run $commandName(...)` syntax.

## Syntax

There are two primary forms:

**1. Defining Basic Commands (Shell Commands):**

```meld
@define commandName(param1, param2) = @run [command template with {{param1}} and {{param2}}]

// Or for multiline commands:
@define multiCmd(arg) = @run [[
  echo "Starting script with {{arg}}"
  ./run_script.sh {{arg}}
]]
```
- ****: The identifier (no @run $commandName(...)`.
- ****: An optional list of parameter names, acting as placeholders within the command template.
- ****: Separator.
- ** or **: The right-hand side **must** be a   directive. This defines the shell command template to be executed.
**2. Defining Language Commands (JS, Python, Bash):**
```meld
@define jsCommand(name, value) = @run js(name, value) [[
  // Raw JavaScript code using parameters name & value
  console.log(`Processing ${name}: ${value}`);
  // Note: {{variables}} are NOT interpolated here
]]

@define pyCommand(inputPath) = @run python(inputPath) [[
# Raw Python code
import sys
input_file = sys.argv[1]
print(f"Processing {input_file}")
# ...
]]
```
- ****: Identifier for the language command.
- ****: Parameters expected by the language script.
- ****: The right-hand side **must** be a   directive. This defines the language, the parameters it accepts, and the *raw code block* to be executed.
    </FileSystemServices>
  </ServiceResponsibilities>
  <CommandTemplateBodyForBasicCommands>
When defining a Basic Command template ( or ):
- **Shell Command**: It should be a valid shell command string.
- **Parameter Placeholders**: It can contain , , etc., corresponding to the parameters defined in the parentheses . These will be replaced by the arguments provided when the command is invoked via .
- **Other Variables**: It can also contain standard Meld variable references (, ). These are *not* resolved when  is processed; they are resolved *at the time the command is executed* via .
- **Multiline Syntax ()**: If using double brackets, the first newline immediately following  is ignored.
  </CommandTemplateBodyForBasicCommands>
  <LanguageCodeBlockForLanguageCommands>
When defining a Language Command template ():
- **Raw Code**: The content within  is treated as **raw source code** for the specified language (js, python, bash).
- **NO Interpolation**: Variables (, ) inside the  block are **NOT** interpolated. The code is passed directly to the language interpreter.
- **Parameters**: The parameters defined in  are passed to the script at runtime (e.g., as command-line arguments).
  </LanguageCodeBlockForLanguageCommands>
  <CoreImplementationDefinedirectivehandler>
The  handler primarily acts as a storage mechanism:
1. **Validate Syntax**: Checks the overall  structure.
2. **Extract Components**: Parses the directive to get the  (without parameters[
  "param1",
  "param2"
]@run` directive (its kind - basic or language, the command template string or code block, the language if applicable).
3. **Store Definition**: Creates a  object containing the  array and the necessary details from the  directive (e.g., the literal command template string for basic commands, or the language and raw code block for language commands).
4. **Update State**: Stores this  object in the current execution state using . Metadata can also be stored.
**Important**: The  handler does *not* execute anything or resolve variables within the template/code block. It simply stores the definition.
  </CoreImplementationDefinedirectivehandler>
  <InteractionWithRunCommandname>
The execution logic resides within the  and its  subtype:
1. **Invocation**: 
2. **Retrieve Definition**: Fetches the  for  from the state.
3. **Resolve Arguments**: Resolves the arguments (, ) provided in the  call.
4. **Execution based on Definition Type**:
- **If Basic Command Definition**: Substitutes the resolved arguments *positionally* into the stored command template string (replacing , , etc.). The resulting command string is then executed, resolving any other variables (, ) at that time.
- **If Language Command Definition**: Passes the resolved arguments to the stored language script (e.g., as command-line arguments  in Python,  in Node). The raw code block stored in the definition is executed by the appropriate language interpreter.
  </InteractionWithRunCommandname>
  <KeyImplementationAspectsConsiderations>
- **Positional Parameters**: Substitution/passing relies strictly on the order in the  parameter list and the  argument list.
- **Delayed Resolution (Basic Commands)**: Variables (, ) within a basic command template are resolved only when invoked via .
- **No Interpolation (Language Commands)**: The code block for language commands is executed raw; use the defined parameters to pass data into the script.
- **No Direct Output**:  only modifies state.
  </KeyImplementationAspectsConsiderations>
  <ValidationCriteria>
A correct  implementation ensures:
- Both basic and language command definitions are correctly parsed and stored.
- Invocation via  correctly retrieves the definition and identifies its type.
- Arguments passed to  are resolved correctly.
- For basic commands: Positional parameter substitution into the template works reliably, and the final command executes correctly.
- For language commands: Resolved arguments are passed correctly to the script, and the stored code block is executed by the correct interpreter.
```




3.  **Your Service Code (`ResolutionCore`)**: 



#### ../../services/pipeline/ResolutionService/ResolutionService.ts
```javascript
import * as path from 'path';
import type { IStateService } from '@services/state/StateService/IStateService.js';
import type { IResolutionService, ResolutionContext } from '@services/pipeline/ResolutionService/IResolutionService.js';
import { ResolutionErrorCode } from '@services/pipeline/ResolutionService/IResolutionService.js';
import { TextResolver } from '@services/pipeline/ResolutionService/resolvers/TextResolver.js';
import { DataResolver } from '@services/pipeline/ResolutionService/resolvers/DataResolver.js';
import { PathResolver } from '@services/pipeline/ResolutionService/resolvers/PathResolver.js';
import { CommandResolver } from '@services/pipeline/ResolutionService/resolvers/CommandResolver.js';
import { ContentResolver } from '@services/pipeline/ResolutionService/resolvers/ContentResolver.js';
import { VariableReferenceResolver } from '@services/pipeline/ResolutionService/resolvers/VariableReferenceResolver.js';
import { FieldAccessUtility } from '@services/resolution/utilities/index.js';
import { resolutionLogger as logger } from '@core/utils/logger.js';
import type { IFileSystemService } from '@services/fs/FileSystemService/IFileSystemService.js';
import type { MeldNode, DirectiveNode, TextNode, DirectiveKind, CodeFenceNode } from '@core/syntax/types/index.js';
import { MeldFileNotFoundError } from '@core/errors/MeldFileNotFoundError.js';
import { MeldResolutionError } from '@core/errors/MeldResolutionError.js';
import { ErrorSeverity } from '@core/errors/MeldError.js';
import { inject, singleton, container } from 'tsyringe';
import type { IPathService } from '@services/fs/PathService/IPathService.js';
import { VariableResolutionTracker, ResolutionTrackingConfig } from '@tests/utils/debug/VariableResolutionTracker/index.js';
import { Service } from '@core/ServiceProvider.js';
import type { IParserServiceClient } from '@services/pipeline/ParserService/interfaces/IParserServiceClient.js';
import { ParserServiceClientFactory } from '@services/pipeline/ParserService/factories/ParserServiceClientFactory.js';
import { IVariableReferenceResolverClient } from '@services/pipeline/ResolutionService/interfaces/IVariableReferenceResolverClient.js';
import { VariableReferenceResolverClientFactory } from '@services/pipeline/ResolutionService/factories/VariableReferenceResolverClientFactory.js';
import { IDirectiveServiceClient } from '@services/pipeline/DirectiveService/interfaces/IDirectiveServiceClient.js';
import { DirectiveServiceClientFactory } from '@services/pipeline/DirectiveService/factories/DirectiveServiceClientFactory.js';
import type { IFileSystemServiceClient } from '@services/fs/FileSystemService/interfaces/IFileSystemServiceClient.js';
import { FileSystemServiceClientFactory } from '@services/fs/FileSystemService/factories/FileSystemServiceClientFactory.js';
import type { IParserService } from '@services/pipeline/ParserService/IParserService.js';
import { VariableResolutionErrorFactory } from '@services/pipeline/ResolutionService/resolvers/error-factory.js';

/**
 * Interface matching the StructuredPath expected from meld-spec
 */
interface StructuredPath {
  raw: string;
  structured: {
    segments: string[];
    variables?: {
      special?: string[];
      path?: string[];
    };
    cwd?: boolean;
  };
  normalized?: string;
}

/**
 * Internal type for heading nodes in the ResolutionService
 * This is converted from TextNode when we detect a heading pattern
 */
interface InternalHeadingNode {
  content: string;
  level: number;
}

/**
 * Convert a TextNode to an InternalHeadingNode if it matches heading pattern
 * Returns null if the node is not a heading
 */
function parseHeadingNode(node: TextNode): InternalHeadingNode | null {
  // Instead of using regex, check the AST properties
  if (!node.content.startsWith('#')) {
    return null;
  }
  
  // Count the number of # characters at the start
  let level = 0;
  for (let i = 0; i < node.content.length && i < 6; i++) {
    if (node.content[i] === '#') {
      level++;
    } else {
      break;
    }
  }
  
  // Validate level and check for space after #s
  if (level === 0 || level > 6 || node.content[level] !== ' ') {
    return null;
  }
  
  // Extract the content after the # characters
  const content = node.content.substring(level + 1).trim();
  
  if (!content) {
    return null;
  }
  
  return {
    level,
    content
  };
}

/**
 * Check if a node is a text node that represents a heading
 */
function isHeadingTextNode(node: MeldNode): node is TextNode {
  if (node.type !== 'Text') {
    return false;
  }
  
  const textNode = node as TextNode;
  
  // Must start with at least one # and at most 6
  if (!textNode.content.startsWith('#')) {
    return false;
  }
  
  // Count the number of # characters
  let hashCount = 0;
  for (let i = 0; i < textNode.content.length && i < 6; i++) {
    if (textNode.content[i] === '#') {
      hashCount++;
    } else {
      break;
    }
  }
  
  // Valid heading must have:
  // 1. Between 1-6 hash characters
  // 2. A space after the hash characters
  // 3. Content after the space
  return (
    hashCount >= 1 && 
    hashCount <= 6 && 
    textNode.content.length > hashCount &&
    textNode.content[hashCount] === ' ' &&
    textNode.content.substring(hashCount + 1).trim().length > 0
  );
}

/**
 * Service responsible for resolving variables, commands, and paths in different contexts
 */
@singleton()
@Service({
  description: 'Service responsible for resolving variable references and other dynamic content'
})
export class ResolutionService implements IResolutionService {
  private textResolver: TextResolver = null!;
  private dataResolver: DataResolver = null!;
  private pathResolver: PathResolver = null!;
  private commandResolver: CommandResolver = null!;
  private contentResolver: ContentResolver = null!;
  private variableReferenceResolver: VariableReferenceResolver = null!;
  private resolutionTracker?: VariableResolutionTracker;
  
  private stateService: IStateService = null!;
  private fileSystemService: IFileSystemService = null!;
  private pathService: IPathService = null!;
  private parserService?: IParserService;
  
  private parserClient?: IParserServiceClient;
  private parserClientFactory?: ParserServiceClientFactory;
  
  private variableResolverClient?: IVariableReferenceResolverClient;
  private variableResolverClientFactory?: VariableReferenceResolverClientFactory;
  
  private directiveClient?: IDirectiveServiceClient;
  private directiveClientFactory?: DirectiveServiceClientFactory;
  
  private fsClient?: IFileSystemServiceClient;
  private fsClientFactory?: FileSystemServiceClientFactory;
  
  private factoryInitialized: boolean = false;

  /**
   * Creates a new instance of the ResolutionService
   * @param stateService - State service for variable management
   * @param fileSystemService - File system service for file operations
   * @param pathService - Path service for path operations
   * @param parserService - Parser service for parsing strings
   */
  constructor(
    @inject('IStateService') stateService?: IStateService,
    @inject('IFileSystemService') fileSystemService?: IFileSystemService, 
    @inject('IPathService') pathService?: IPathService,
    @inject('IParserService') parserService?: IParserService
  ) {
    this.initializeFromParams(stateService, fileSystemService, pathService, parserService);
    
    // We'll initialize the factory lazily to avoid circular dependencies
    if (process.env.DEBUG === 'true') {
      console.log('ResolutionService: Initialized with', {
        hasStateService: !!this.stateService,
        hasFileSystemService: !!this.fileSystemService,
        hasPathService: !!this.pathService,
        hasParserService: !!this.parserService
      });
    }
  }
  
  /**
   * Lazily initialize all factories
   * This is called only when needed to avoid circular dependencies
   */
  private ensureFactoryInitialized(): void {
    if (this.factoryInitialized) {
      return;
    }
    
    this.factoryInitialized = true;
    
    // Initialize parser client factory
    try {
      this.parserClientFactory = container.resolve('ParserServiceClientFactory');
      this.initializeParserClient();
    } catch (error) {
      // In test environment, we need to work even without factories
      logger.debug(`ParserServiceClientFactory not available: ${(error as Error).message}`);
    }
    
    // Initialize variable resolver client factory
    try {
      this.variableResolverClientFactory = container.resolve('VariableReferenceResolverClientFactory');
      this.initializeVariableResolverClient();
    } catch (error) {
      // In test environment, we need to work even without factories
      logger.debug(`VariableReferenceResolverClientFactory not available: ${(error as Error).message}`);
    }
    
    // Initialize directive client factory
    try {
      this.directiveClientFactory = container.resolve('DirectiveServiceClientFactory');
      this.initializeDirectiveClient();
    } catch (error) {
      // In test environment, we need to work even without factories
      logger.debug(`DirectiveServiceClientFactory not available: ${(error as Error).message}`);
    }
    
    // Initialize file system client factory
    try {
      this.fsClientFactory = container.resolve('FileSystemServiceClientFactory');
      this.initializeFsClient();
    } catch (error) {
      // In test environment, we need to work even without factories
      logger.debug(`FileSystemServiceClientFactory not available: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize the ParserServiceClient using the factory
   */
  private initializeParserClient(): void {
    if (!this.parserClientFactory) {
      throw new Error('ParserServiceClientFactory is not initialized');
    }
    
    try {
      this.parserClient = this.parserClientFactory.createClient();
      logger.debug('Successfully created ParserServiceClient using factory');
    } catch (error) {
      throw new Error(`Failed to create ParserServiceClient: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize the VariableResolverClient using the factory
   */
  private initializeVariableResolverClient(): void {
    if (!this.variableResolverClientFactory) {
      throw new Error('VariableReferenceResolverClientFactory is not initialized');
    }
    
    try {
      this.variableResolverClient = this.variableResolverClientFactory.createClient();
      logger.debug('Successfully created VariableReferenceResolverClient using factory');
    } catch (error) {
      throw new Error(`Failed to create VariableReferenceResolverClient: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize the DirectiveServiceClient using the factory
   */
  private initializeDirectiveClient(): void {
    if (!this.directiveClientFactory) {
      throw new Error('DirectiveServiceClientFactory is not initialized');
    }
    
    try {
      this.directiveClient = this.directiveClientFactory.createClient();
      logger.debug('Successfully created DirectiveServiceClient using factory');
    } catch (error) {
      throw new Error(`Failed to create DirectiveServiceClient: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize the FileSystemServiceClient using the factory
   */
  private initializeFsClient(): void {
    if (!this.fsClientFactory) {
      throw new Error('FileSystemServiceClientFactory is not initialized');
    }
    
    try {
      this.fsClient = this.fsClientFactory.createClient();
      logger.debug('Successfully created FileSystemServiceClient using factory');
    } catch (error) {
      throw new Error(`Failed to create FileSystemServiceClient: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize this service with the given parameters
   * Using DI-only mode
   */
  private initializeFromParams(
    stateService?: IStateService,
    fileSystemService?: IFileSystemService,
    pathService?: IPathService,
    parserService?: IParserService
  ): void {
    // Verify required dependencies
    if (!stateService) {
      throw new Error('StateService is required for ResolutionService');
    }
    
    // Initialize services
    this.stateService = stateService;
    this.fileSystemService = fileSystemService || this.createDefaultFileSystemService();
    this.pathService = pathService || this.createDefaultPathService();
    this.parserService = parserService;
    
    // Initialize resolvers
    this.initializeResolvers();
  }

  /**
   * Create a default file system service if not provided
   * Used as fallback in case dependency injection fails
   */
  private createDefaultFileSystemService(): IFileSystemService {
    logger.warn('Using default FileSystemService - this should only happen in tests');
    // Use unknown as an intermediate cast to avoid strict type checking
    return {
      readFile: async (): Promise<string> => '',
      exists: async (): Promise<boolean> => false,
      writeFile: async (): Promise<void> => {},
      stat: async (): Promise<any> => ({ isDirectory: () => false }),
      isFile: async (): Promise<boolean> => false,
      readDir: async (): Promise<string[]> => [],
      ensureDir: async (): Promise<void> => {},
      isDirectory: async (): Promise<boolean> => false,
      getCwd: (): string => '',
      dirname: (filePath: string): string => '',
      watch: (): any => ({ [Symbol.asyncIterator]: () => ({ next: async () => ({ done: true, value: undefined }) }) }),
      executeCommand: async (): Promise<any> => ({ stdout: '', stderr: '' }),
      mkdir: async (): Promise<void> => {},
    } as unknown as IFileSystemService;
  }
  
  /**
   * Create a default path service if not provided
   * Used as fallback in case dependency injection fails
   */
  private createDefaultPathService(): IPathService {
    logger.warn('Using default PathService - this should only happen in tests');
    // Use unknown as an intermediate cast to avoid strict type checking
    return {
      validatePath: async (path: string | StructuredPath): Promise<string | StructuredPath> => path,
      resolvePath: (path: string | StructuredPath): string | StructuredPath => path,
      normalizePath: (path: string): string => path,
      initialize: (): void => {},
      enableTestMode: (): void => {},
      disableTestMode: (): void => {},
      isTestMode: (): boolean => false,
      setTestMode: (): void => {},
      getHomePath: (): string => '',
      getProjectPath: (): string => '',
      setProjectPath: (): void => {},
      dirname: (): string => '',
      isAbsolute: (): boolean => false,
      // Minimal implementation for fallback
    } as unknown as IPathService;
  }
  
  /**
   * Initialize the resolver components used by this service
   */
  private initializeResolvers(): void {
    this.textResolver = new TextResolver(this.stateService);
    this.dataResolver = new DataResolver(this.stateService);
    this.pathResolver = new PathResolver(this.stateService);
    this.commandResolver = new CommandResolver(this.stateService);
    this.contentResolver = new ContentResolver(this.stateService);
    this.variableReferenceResolver = new VariableReferenceResolver(
      this.stateService,
      this
    );
  }

  /**
   * Parse a string into AST nodes for resolution
   */
  private async parseForResolution(value: string): Promise<MeldNode[]> {
    try {
      // Ensure factory is initialized before trying to use it
      this.ensureFactoryInitialized();
      
      // Use the parser client if available
      if (this.parserClient) {
        try {
          const nodes = await this.parserClient.parseString(value);
          return nodes || [];
        } catch (error) {
          logger.error('Error using parserClient.parseString', { 
            error, 
            valueLength: value.length 
          });
        }
      }
      
      // Last resort fallback to direct parsing in tests
      logger.warn('No parser client available - falling back to direct import or mock parser');
      
      // Try using directly injected parser service if available (for tests)
      if (this.parserService) {
        try {
          const nodes = await this.parserService.parse(value);
          return nodes || [];
        } catch (error) {
          logger.warn('Error using injected parser service', { error });
        }
      }
      
      // Finally, try using require
      try {
        // Use require for better build compatibility
        const coreAst = require('@core/ast');
        const result = await coreAst.parse(value, { trackLocations: true });
        return result.ast || [];
      } catch (error) {
        // In a test environment, create a fallback text node
        logger.warn('Last resort - creating fallback text node', { value });
        return [{ type: 'Text', content: value } as TextNode];
      }
    } catch (error) {
      logger.error('Error parsing content for resolution', { error });
      return [];
    }
  }

  /**
   * Resolve text variables in a string
   */
  async resolveText(text: string, context: ResolutionContext): Promise<string> {
    const nodes = await this.parseForResolution(text);
    return this.textResolver.resolve(nodes[0] as DirectiveNode, context);
  }

  /**
   * Resolve data variables and fields
   */
  async resolveData(ref: string, context: ResolutionContext): Promise<any> {
    const nodes = await this.parseForResolution(ref);
    return this.dataResolver.resolve(nodes[0] as DirectiveNode, context);
  }

  /**
   * Resolve path variables
   */
  async resolvePath(path: string, context: ResolutionContext): Promise<string> {
    const nodes = await this.parseForResolution(path);
    return this.pathResolver.resolve(nodes[0] as DirectiveNode, context);
  }

  /**
   * Resolve command references
   */
  async resolveCommand(cmd: string, args: string[], context: ResolutionContext): Promise<string> {
    const node: DirectiveNode = {
      type: 'Directive',
      directive: {
        kind: 'run',
        name: cmd,
        identifier: cmd,
        args
      }
    };
    return this.commandResolver.resolve(node, context);
  }

  /**
   * Resolve content from a file path
   */
  async resolveFile(path: string): Promise<string> {
    try {
      // Ensure factory is initialized
      this.ensureFactoryInitialized();
      
      // Try to use the file system client if available
      if (this.fsClient) {
        try {
          // The IFileSystemServiceClient interface doesn't include readFile
          // so we need to directly use the fileSystemService instead
          return await this.fileSystemService.readFile(path);
        } catch (error) {
          logger.warn('Error reading file with fileSystemService', { 
            error: error instanceof Error ? error.message : 'Unknown error', 
            path 
          });
        }
      }
      
      // Fall back to direct file system service
      return await this.fileSystemService.readFile(path);
    } catch (error) {
      throw new MeldFileNotFoundError(`Failed to read file: ${path}`, { 
        cause: error instanceof Error ? error : new Error(String(error)) 
      });
    }
  }

  /**
   * Resolve raw content nodes, preserving formatting but skipping comments
   */
  async resolveContent(nodes: MeldNode[], context: ResolutionContext): Promise<string> {
    if (!Array.isArray(nodes)) {
      // If a string path is provided, read the file
      const path = String(nodes);
      if (!await this.fileSystemService.exists(path)) {
        throw new MeldResolutionError(
          `File not found: ${path}`,
          {
            code: ResolutionErrorCode.INVALID_PATH,
            details: { value: path },
            severity: ErrorSeverity.Fatal
          }
        );
      }
      return this.fileSystemService.readFile(path);
    }

    // Otherwise, process the nodes
    return this.contentResolver.resolve(nodes, context);
  }

  /**
   * Resolve any value based on the provided context rules
   */
  async resolveInContext(value: string | StructuredPath, context?: ResolutionContext): Promise<string> {
    // If no context is provided, create a default one
    const resolveContext = context || {
      allowedVariableTypes: {
        text: true,
        data: true,
        path: true,
        command: true
      },
      pathValidation: {
        requireAbsolute: false,
        allowedRoots: []
      },
      currentFilePath: undefined,
      state: this.stateService
    };
    
    // Add debug logging for debugging path handling issues
    logger.debug('ResolutionService.resolveInContext', {
      value: typeof value === 'string' ? value : value.raw,
      allowedVariableTypes: resolveContext.allowedVariableTypes,
      pathValidation: resolveContext.pathValidation,
      stateExists: !!resolveContext.state,
      specialPathVars: resolveContext.state ? {
        PROJECTPATH: resolveContext.state.getPathVar('PROJECTPATH'),
        HOMEPATH: resolveContext.state.getPathVar('HOMEPATH')
      } : 'state not available'
    });

    // Handle structured path objects by delegating to the dedicated method
    if (typeof value === 'object' && value !== null && 'raw' in value) {
      return this.resolveStructuredPath(value, resolveContext);
    }

    // Handle string values
    if (typeof value === 'string') {
      // Check for special direct path variable references
      if (value === '$HOMEPATH' || value === '$~') {
        const homePath = resolveContext.state?.getPathVar('HOMEPATH') || this.stateService.getPathVar('HOMEPATH');
        return homePath || '';
      }
      
      if (value === '$PROJECTPATH' || value === '$.') {
        const projectPath = resolveContext.state?.getPathVar('PROJECTPATH') || this.stateService.getPathVar('PROJECTPATH');
        return projectPath || '';
      }
      
      // Check for command references in the format $command(args)
      const commandRegex = /^\$(\w+)\(([^)]*)\)$/;
      const commandMatch = value.match(commandRegex);
      
      if (commandMatch) {
        const [, cmdName, argsStr] = commandMatch;
        // Parse args, splitting by comma but respecting quoted strings
        const args = argsStr.split(',').map(arg => arg.trim());
        
        try {
          logger.debug('Resolving command reference', { cmdName, args });
          const result = await this.resolveCommand(cmdName, args, resolveContext);
          return result;
        } catch (error) {
          logger.warn('Command execution failed', { cmdName, args, error });
          // Fall back to the command name and args, joining with spaces
          return `${cmdName} ${args.join(' ')}`;
        }
      }
      
      // Try to parse the string as a path using the parser service
      try {
        // Only attempt parsing if the string contains path variable indicators
        if (value.includes('$.') || value.includes('$~') || value.includes('$/') || value.includes(')) {
          const nodes = await this.parseForResolution(value);
          const pathNode = nodes.find(node => 
            (node as any).type === 'PathVar' || 
            (node.type === 'Directive' && (node as any).directive?.kind === 'path')
          );
          
          if (pathNode) {
            // Extract the structured path from the node
            let structPath: StructuredPath;
            
            if ((pathNode as any).type === 'PathVar' && (pathNode as any).value) {
              structPath = (pathNode as any).value as StructuredPath;
              // Recursive call with the structured path
              return this.resolveStructuredPath(structPath, resolveContext);
            } else if (pathNode.type === 'Directive') {
              const directiveNode = pathNode as any;
              if (directiveNode.directive.value && 
                  typeof directiveNode.directive.value === 'object' && 
                  'raw' in directiveNode.directive.value) {
                structPath = directiveNode.directive.value as StructuredPath;
                // Recursive call with the structured path
                return this.resolveStructuredPath(structPath, resolveContext);
              }
            }
          }
        }
      } catch (error) {
        // If parsing fails, fall back to variable resolution
        logger.debug('Path parsing failed, falling back to variable resolution', { 
          error: (error as Error).message
        });
      }
    }

    // Handle string values
    return this.resolveVariables(value as string, resolveContext);
  }
  
  /**
   * Resolve variables within a string value
   * @internal Used by resolveInContext
   */
  private async resolveVariables(value: string, context: ResolutionContext): Promise<string> {
    // Check if the string contains variable references
    if (value.includes('{{') || value.includes('${') || value.includes(')) {
      logger.debug('Resolving variables in string:', { value });
      
      // Special handling for path variables with $ prefix (like $temp)
      // Uncomment when adding path variable support
      // value = await this.resolvePathVariablesInText(value, context);
      
      // Ensure factory is initialized before trying to use it
      this.ensureFactoryInitialized();
      
      // Try new approach first (factory pattern)
      if (this.variableResolverClient) {
        try {
          return await this.variableResolverClient.resolve(value, context);
        } catch (error) {
          logger.warn('Error using variableResolverClient.resolve, falling back to direct reference', { 
            error, 
            value 
          });
        }
      }
      
      // Fall back to direct reference
      return this.variableReferenceResolver.resolve(value, context);
    }
    
    return value;
  }

  /**
   * Validate that resolution is allowed in the given context
   */
  async validateResolution(value: string | StructuredPath, context?: ResolutionContext): Promise<void> {
    // If no context is provided, create a default one
    const resolveContext = context || {
      allowedVariableTypes: {
        text: true,
        data: true,
        path: true,
        command: true
      },
      pathValidation: {
        requireAbsolute: false,
        allowedRoots: []
      },
      currentFilePath: undefined,
      state: this.stateService
    };
    
    // Convert StructuredPath to string if needed
    const stringValue = typeof value === 'string' ? value : value.raw;
    
    // Parse the value to check for variable types
    const nodes = await this.parseForResolution(stringValue);

    for (const node of nodes) {
      if (node.type !== 'Directive') continue;

      const directiveNode = node as DirectiveNode;
      
      // Check if the directive type is allowed
      switch (directiveNode.directive.kind) {
        case 'text':
          if (!resolveContext.allowedVariableTypes.text) {
            const errorMessage = 'Text variables are not allowed in this context';
            const errorDetails = { 
              value: typeof value === 'string' ? value : value.raw, 
              context: JSON.stringify(context)
            };
            const error = new MeldResolutionError(
              errorMessage,
              {
                code: ResolutionErrorCode.INVALID_CONTEXT,
                details: errorDetails,
                severity: ErrorSeverity.Fatal
              }
            );
            logger.error('Validation error in ResolutionService', { error });
            throw error;
          }
          break;

        case 'data':
          if (!resolveContext.allowedVariableTypes.data) {
            const errorMessage = 'Data variables are not allowed in this context';
            const errorDetails = { 
              value: typeof value === 'string' ? value : value.raw, 
              context: JSON.stringify(context)
            };
            const error = new MeldResolutionError(
              errorMessage,
              {
                code: ResolutionErrorCode.INVALID_CONTEXT,
                details: errorDetails,
                severity: ErrorSeverity.Fatal
              }
            );
            logger.error('Validation error in ResolutionService', { error });
            throw error;
          }
          break;

        case 'path':
          if (!resolveContext.allowedVariableTypes.path) {
            const errorMessage = 'Path variables are not allowed in this context';
            const errorDetails = { 
              value: typeof value === 'string' ? value : value.raw, 
              context: JSON.stringify(context)
            };
            const error = new MeldResolutionError(
              errorMessage,
              {
                code: ResolutionErrorCode.INVALID_CONTEXT,
                details: errorDetails,
                severity: ErrorSeverity.Fatal
              }
            );
            logger.error('Validation error in ResolutionService', { error });
            throw error;
          }
          break;

        case 'run':
          if (!resolveContext.allowedVariableTypes.command) {
            const errorMessage = 'Command references are not allowed in this context';
            const errorDetails = { 
              value: typeof value === 'string' ? value : value.raw, 
              context: JSON.stringify(context)
            };
            const error = new MeldResolutionError(
              errorMessage,
              {
                code: ResolutionErrorCode.INVALID_CONTEXT,
                details: errorDetails,
                severity: ErrorSeverity.Fatal
              }
            );
            logger.error('Validation error in ResolutionService', { error });
            throw error;
          }
          break;
      }
    }
  }

  /**
   * Check for circular variable references
   */
  async detectCircularReferences(value: string): Promise<void> {
    const visited = new Set<string>();
    const stack: string[] = [];

    const checkReferences = async (text: string, currentRef?: string) => {
      // Parse the text to get variable references
      const nodes = await this.parseForResolution(text);
      if (!nodes || !Array.isArray(nodes)) {
        throw new MeldResolutionError(
          'Invalid parse result',
          {
            code: ResolutionErrorCode.SYNTAX_ERROR,
            details: { value: text },
            severity: ErrorSeverity.Fatal
          }
        );
      }

      for (const node of nodes) {
        if (node.type !== 'Directive') continue;

        const directiveNode = node as DirectiveNode;
        const ref = directiveNode.directive.identifier;
        if (!ref) continue;

        // Skip if this is a direct reference to the current variable
        if (ref === currentRef) continue;

        if (stack.includes(ref)) {
          // Create the circular reference path
          const path = [...stack, ref].join(' -> ');
          throw new MeldResolutionError(
            `Circular reference detected: ${path}`,
            {
              code: ResolutionErrorCode.CIRCULAR_REFERENCE,
              details: { 
                value: text,
                variableName: ref
              },
              severity: ErrorSeverity.Fatal
            }
          );
        }

        if (!visited.has(ref)) {
          visited.add(ref);
          stack.push(ref);

          let refValue: string | undefined;

          switch (directiveNode.directive.kind) {
            case 'text':
              refValue = this.stateService.getTextVar(ref);
              break;
            case 'data':
              const dataValue = this.stateService.getDataVar(ref);
              if (dataValue && typeof dataValue === 'string') {
                refValue = dataValue;
              }
              break;
            case 'path':
              refValue = this.stateService.getPathVar(ref);
              break;
            case 'run':
              const cmdValue = this.stateService.getCommand(ref);
              if (cmdValue) {
                refValue = cmdValue.command;
              }
              break;
          }

          if (refValue) {
            await checkReferences(refValue, ref);
          }

          // Remove from stack after checking
          stack.pop();
        }
      }
    };

    await checkReferences(value);
  }

  /**
   * Extract a section from content by its heading
   * @param content The content to extract the section from
   * @param heading The heading text to search for
   * @param fuzzy Optional fuzzy matching threshold (0-1, where 1 is exact match, defaults to 0.7)
   */
  async extractSection(content: string, heading: string, fuzzy?: number): Promise<string> {
    logger.debug('Extracting section from content', {
      headingToFind: heading,
      contentLength: content.length,
      fuzzyThreshold: fuzzy
    });
    
    try {
      // Use llmxml for section extraction with new improved API
      const { createLLMXML } = await import('llmxml');
      const llmxml = createLLMXML({
        warningLevel: 'none'
      });
      
      // Extract the section directly from markdown using per-call configuration
      const section = await llmxml.getSection(content, heading, {
        includeNested: true,
        fuzzyThreshold: fuzzy !== undefined ? fuzzy : 0.7
      });
      
      logger.debug('Found section using llmxml', {
        heading,
        sectionLength: section.length
      });
      
      return section;
    } catch (error) {
      if (error instanceof MeldResolutionError) {
        throw error;
      }
      
      // Handle error from llmxml, which now provides detailed diagnostic information
      if (error && typeof error === 'object' && 'code' in error) {
        const llmError = error as any;
        
        if (llmError.code === 'SECTION_NOT_FOUND') {
          // Get available headings and closest matches from the error details
          const availableHeadings = llmError.details?.availableHeadings?.map((h: any) => h.title) || [];
          const closestMatches = llmError.details?.closestMatches?.map((m: any) => 
            `${m.title} (${Math.round(m.similarity * 100)}%)`
          ) || [];
          
          logger.warn('Section not found', {
            heading,
            availableHeadings,
            closestMatches
          });
          
          throw new MeldResolutionError(
            'Section not found: ' + heading,
            {
              code: ResolutionErrorCode.SECTION_NOT_FOUND,
              details: { 
                value: heading,
                contentPreview: content.substring(0, 100) + '...',
                availableHeadings: availableHeadings.join(', '),
                suggestions: closestMatches.join(', ')
              },
              severity: ErrorSeverity.Recoverable
            }
          );
        }
      }
      
      // For other errors, log and rethrow with additional context
      logger.error('Error extracting section', {
        heading,
        error: error instanceof Error ? error.message : String(error)
      });
      
      throw new MeldResolutionError(
        `Failed to extract section: ${error instanceof Error ? error.message : String(error)}`,
        {
          code: ResolutionErrorCode.SECTION_EXTRACTION_FAILED,
          details: { 
            value: heading
          },
          severity: ErrorSeverity.Recoverable
        }
      );
    }
  }
  
  /**
   * Extract all headings from content using regex
   * Since llmxml API compatibility issues, we'll use a simple regex approach
   * @private
   */
  private async extractHeadingsFromContent(content: string): Promise<{ title: string; level: number; path: string[] }[]> {
    try {
      // Simple regex to extract markdown headings
      const headingRegex = /^(#{1,6})\s+(.+?)(?:\s+#+)?$/gm;
      const matches = [...content.matchAll(headingRegex)];
      
      // Transform regex matches into structured heading objects
      const headings: { title: string; level: number; path: string[] }[] = [];
      const pathMap: Map<number, string[]> = new Map(); // Level -> current path at that level
      
      for (const match of matches) {
        const level = match[1].length; // Number of # characters
        const title = match[2].trim();
        
        // Create a path array by inheriting from parent levels
        const path: string[] = [];
        for (let i = 1; i < level; i++) {
          const parentPath = pathMap.get(i);
          if (parentPath && parentPath.length > 0) {
            path.push(...parentPath);
          }
        }
        path.push(title);
        
        // Update the path map for this level
        pathMap.set(level, [title]);
        
        // Add to headings array
        headings.push({
          title,
          level,
          path
        });
      }
      
      return headings;
    } catch (error) {
      logger.warn('Error extracting headings', {
        error: error instanceof Error ? error.message : String(error)
      });
      return [];
    }
  }

  private nodesToString(nodes: MeldNode[]): string {
    return nodes.map(node => {
      switch (node.type) {
        case 'Text':
          return (node as TextNode).content;
        case 'CodeFence':
          const codeFence = node as CodeFenceNode;
          return '```' + (codeFence.language || '') + '\n' + codeFence.content + '\n```';
        case 'Directive':
          const directive = node as DirectiveNode;
          return `@${directive.directive.kind} ${directive.directive.value || ''}`;
        default:
          return '';
      }
    }).join('\n');
  }

  /**
   * Resolve a structured path to an absolute path
   * @private
   */
  private async resolveStructuredPath(path: StructuredPath, context?: ResolutionContext): Promise<string> {
    // If no context is provided, create a default one
    const resolveContext = context || {
      allowedVariableTypes: {
        text: true,
        data: true,
        path: true,
        command: true
      },
      pathValidation: {
        requireAbsolute: false,
        allowedRoots: []
      },
      currentFilePath: undefined,
      state: this.stateService
    };
    
    // IMPORTANT FIX: Check for special flags that indicate we should skip path resolution
    // This prevents directory paths from being added to variable content in embeds
    if ((resolveContext as any).isVariableEmbed === true || 
        (resolveContext as any).disablePathPrefixing === true) {
      logger.debug('Path prefixing disabled for this context (variable embed)', {
        raw: path.raw,
        isVariableEmbed: (resolveContext as any).isVariableEmbed,
        disablePathPrefixing: (resolveContext as any).disablePathPrefixing
      });
      
      // For variable embeds, return the raw value without path resolution
      if (typeof path === 'string') {
        return path;
      }
      return path.raw;
    }
    
    const { structured, raw } = path;
    
    // Get base directory from context if available (use currentFilePath if available)
    const baseDir = resolveContext.currentFilePath ? this.pathService.dirname(resolveContext.currentFilePath) : process.cwd();
    
    // Add detailed debug logging for path resolution
    logger.debug('Resolving structured path', {
      raw: path.raw,
      structured: path.structured,
      baseDir,
      currentFilePath: resolveContext.currentFilePath,
      home: process.env.HOME,
      cwd: process.cwd()
    });
    
    // Add specific logging for home path resolution
    if (structured.variables?.special?.includes('HOMEPATH')) {
      const homePath = this.pathService.getHomePath();
      if (process.env.DEBUG === 'true') {
        console.log('Resolving home path in structured path:', {
          raw,
          homePath,
          segments: structured.segments,
          baseDir
        });
      }
    }
    
    try {
      // Use the PathService to resolve the structured path
      // This handles all special variables and path normalization
      const resolvedPath = this.pathService.resolvePath(path, baseDir);
      
      // Log the final resolved path for debugging
      if (process.env.DEBUG === 'true') {
        console.log('Path resolved successfully:', {
          raw,
          resolvedPath,
          exists: await this.fileSystemService.exists(resolvedPath)
        });
      }
      
      return resolvedPath;
    } catch (error) {
      // Log detailed error information
      if (process.env.DEBUG === 'true') {
        console.error('Path resolution failed:', {
          raw,
          structured,
          baseDir,
          error: (error as Error).message
        });
      }
      
      // Handle error based on severity
      throw new MeldResolutionError(
        `Failed to resolve path: ${(error as Error).message}`,
        {
          code: ResolutionErrorCode.INVALID_PATH,
          details: { value: raw },
          severity: ErrorSeverity.Recoverable
        }
      );
    }
  }

  /**
   * Get the variable reference resolver
   */
  getVariableResolver(): VariableReferenceResolver {
    return this.variableReferenceResolver;
  }

  /**
   * Enable tracking of variable resolution attempts
   * @param config Configuration for the resolution tracker
   */
  enableResolutionTracking(config: Partial<ResolutionTrackingConfig>): void {
    // Import and create the tracker if it doesn't exist
    if (!this.resolutionTracker) {
      this.resolutionTracker = new VariableResolutionTracker();
    }
    
    // Configure the tracker
    this.resolutionTracker.configure({
      enabled: true,
      ...config
    });
    
    // Set it on the variable reference resolver
    this.variableReferenceResolver.setResolutionTracker(this.resolutionTracker);
  }

  /**
   * Get the resolution tracker for debugging
   * @returns The current resolution tracker or undefined if not enabled
   */
  getResolutionTracker(): VariableResolutionTracker | undefined {
    return this.resolutionTracker;
  }

  /**
   * Validate a path for security and existence
   * 
   * @param path - The path to validate
   * @param context - The resolution context with state and allowed variable types
   * @returns A promise that resolves to true if the path is valid, false otherwise
   */
  async validatePath(path: string, context: ResolutionContext): Promise<boolean> {
    try {
      // First resolve the path to handle any variables
      const resolvedPath = await this.resolvePath(path, context);
      
      // Then validate the resolved path using the PathService
      await this.pathService.validatePath(resolvedPath, {
        mustExist: true
      });
      
      return true;
    } catch (error) {
      logger.debug('Path validation failed', { 
        path, 
        error: (error as Error).message 
      });
      return false;
    }
  }

  /**
   * Resolves a field access on a variable (e.g., variable.field.subfield)
   * 
   * @param variableName - The base variable name
   * @param fieldPath - The path to the specific field
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved field value
   * @throws {MeldResolutionError} If field access fails
   */
  async resolveFieldAccess(variableName: string, fieldPath: string, context?: ResolutionContext): Promise<any> {
    logger.debug(`Resolving field access: ${variableName}.${fieldPath}`);
    
    if (!context || !context.state) {
      throw new MeldResolutionError(
        `Cannot resolve field access without state context`,
        {
          code: ResolutionErrorCode.INVALID_CONTEXT,
          severity: ErrorSeverity.Fatal
        }
      );
    }
    
    // Get the base variable value
    const baseValue = context.state.getDataVar(variableName);
    
    if (baseValue === undefined) {
      throw VariableResolutionErrorFactory.variableNotFound(variableName);
    }
    
    try {
      // Extract field access options from the context if available
      const fieldAccessOptions = (context as any).fieldAccessOptions || {};
      
      // Use the shared FieldAccessUtility for consistent field access across the codebase
      const result = FieldAccessUtility.accessFieldsByPath(
        baseValue,
        fieldPath,
        {
          // Always enable both notation types for maximum compatibility
          arrayNotation: true,
          numericIndexing: true,
          // Preserve types by default, unless explicitly turned off
          preserveType: fieldAccessOptions.preserveType !== false,
          // Pass through formatting context if available
          formattingContext: fieldAccessOptions.formattingContext
        },
        variableName,
        context.strict !== false // Use strict mode unless explicitly disabled
      );
      
      logger.debug(`Successfully resolved field access ${variableName}.${fieldPath}`, {
        resultType: typeof result,
        isArray: Array.isArray(result)
      });
      
      return result;
    } catch (error) {
      logger.error(`Error resolving field access ${variableName}.${fieldPath}`, { error });
      throw VariableResolutionErrorFactory.fieldAccessError(
        `Error accessing field "${fieldPath}" of variable "${variableName}": ${error instanceof Error ? error.message : String(error)}`,
        variableName
      );
    }
  }

  /**
   * Convert a value to a formatted string based on the provided formatting context.
   * Delegates to the VariableReferenceResolverClient when available.
   * 
   * @param value - The value to convert to a string
   * @param options - Formatting options including context information
   * @returns The formatted string representation of the value
   */
  async convertToFormattedString(value: any, options?: any): Promise<string> {
    // First try to use the client for proper formatting
    if (!this.variableResolverClient) {
      this.initializeVariableResolverClient();
    }
    
    if (this.variableResolverClient) {
      try {
        return this.variableResolverClient.convertToString(value, options);
      } catch (error) {
        logger.warn('Error using variableResolverClient.convertToString, falling back to basic formatting', { 
          error: error instanceof Error ? error.message : String(error) 
        });
      }
    }
    
    // Fall back to basic formatting
    if (value === undefined || value === null) {
      return '';
    } else if (typeof value === 'string') {
      return value;
    } else if (typeof value === 'object') {
      try {
        // Check if this is a block context from options
        const isBlock = options?.formattingContext?.isBlock === true;
        const isTransformation = options?.formattingContext?.isTransformation === true;
        
        // For objects in block context or transformation mode, use pretty printing
        if ((isBlock || isTransformation) && (Array.isArray(value) || Object.keys(value).length > 0)) {
          return JSON.stringify(value, null, 2);
        }
        
        // For inline contexts, use compact representation
        return JSON.stringify(value);
      } catch (error) {
        logger.warn('Error formatting object to string', { 
          error: error instanceof Error ? error.message : String(error) 
        });
        return String(value);
      }
    } else {
      // For primitive values, just use String()
      return String(value);
    }
  }
} 
```
    <ServicesPipelineResolutionserviceIresolutionserviceTs>
```javascript
import type { MeldNode } from '@core/syntax/types/index.js';
import type { StateServiceLike, StructuredPath } from '@core/shared-service-types.js';
import { VariableResolutionTracker, ResolutionTrackingConfig } from '@tests/utils/debug/VariableResolutionTracker/index.js';

/**
 * Context for variable resolution, specifying what types of variables and operations are allowed.
 * Controls the behavior of resolution operations for security and validation.
 */
interface ResolutionContext {
  /** Current file being processed, for error reporting */
  currentFilePath?: string;
  
  /** What types of variables are allowed in this context */
  allowedVariableTypes: {
    /** Allow text variables {{var}} (formerly ${var}) */
    text: boolean;    
    /** Allow data variables {{data}} (formerly #{data}) */
    data: boolean;    
    /** Allow path variables $path */
    path: boolean;    
    /** Allow command interpolation $command */
    command: boolean; 
  };
  
  /** Path validation rules when resolving paths */
  pathValidation?: {
    /** Whether paths must be absolute */
    requireAbsolute: boolean;
    /** List of allowed path roots e.g. [$HOMEPATH, $PROJECTPATH] */
    allowedRoots: string[]; 
  };

  /** Whether field access is allowed for data variables (e.g., data.field) */
  allowDataFields?: boolean;

  /** Whether to throw errors on resolution failures (true) or attempt to recover (false) */
  strict?: boolean;

  /** Whether nested variable references are allowed */
  allowNested?: boolean;

  /** The state service to use for variable resolution */
  state: StateServiceLike;
  
  /** Flag indicating this is a variable embed context for special handling */
  isVariableEmbed?: boolean;
  
  /** Flag to disable path prefixing */
  disablePathPrefixing?: boolean;
  
  /** Flag to actively prevent path prefixing from occurring */
  preventPathPrefixing?: boolean;
  
  /** Field access options for enhanced field resolution */
  fieldAccessOptions?: {
    preserveType?: boolean;
    formattingContext?: any;
    arrayNotation?: boolean;
    numericIndexing?: boolean;
    variableName?: string;
  };
}

/**
 * Error codes for resolution failures to enable precise error handling
 */
enum ResolutionErrorCode {
  /** Variable is undefined in the current context */
  UNDEFINED_VARIABLE = 'UNDEFINED_VARIABLE',
  /** Circular reference detected in variable resolution */
  CIRCULAR_REFERENCE = 'CIRCULAR_REFERENCE',
  /** Resolution context is invalid or missing required properties */
  INVALID_CONTEXT = 'INVALID_CONTEXT',
  /** Variable type is not allowed in the current context */
  INVALID_VARIABLE_TYPE = 'INVALID_VARIABLE_TYPE',
  /** Path format is invalid or violates path security rules */
  INVALID_PATH = 'INVALID_PATH',
  /** Maximum iteration count exceeded during resolution */
  MAX_ITERATIONS_EXCEEDED = 'MAX_ITERATIONS_EXCEEDED',
  /** Variable reference has invalid syntax */
  SYNTAX_ERROR = 'SYNTAX_ERROR',
  /** Error accessing fields in a data variable */
  FIELD_ACCESS_ERROR = 'FIELD_ACCESS_ERROR',
  /** Maximum recursion depth exceeded during resolution */
  MAX_DEPTH_EXCEEDED = 'MAX_DEPTH_EXCEEDED',
  /** General resolution failure */
  RESOLUTION_FAILED = 'RESOLUTION_FAILED',
  /** Node type is invalid for the requested operation */
  INVALID_NODE_TYPE = 'INVALID_NODE_TYPE',
  /** Command reference is invalid */
  INVALID_COMMAND = 'INVALID_COMMAND',
  /** Variable not found in the current state */
  VARIABLE_NOT_FOUND = 'VARIABLE_NOT_FOUND',
  /** Field does not exist in the data variable */
  INVALID_FIELD = 'INVALID_FIELD',
  /** Command not found in the current state */
  COMMAND_NOT_FOUND = 'COMMAND_NOT_FOUND',
  /** Section not found in the content */
  SECTION_NOT_FOUND = 'SECTION_NOT_FOUND',
  /** Section extraction failed */
  SECTION_EXTRACTION_FAILED = 'SECTION_EXTRACTION_FAILED',
  /** Specific field not found in variable */
  FIELD_NOT_FOUND = 'FIELD_NOT_FOUND',
  /** Invalid access pattern (e.g., array access on non-array) */
  INVALID_ACCESS = 'INVALID_ACCESS'
}

/**
 * Service responsible for resolving variables, commands, and paths in Meld content.
 * Handles all interpolation and reference resolution while enforcing security constraints.
 * 
 * @remarks
 * The ResolutionService is a core service that handles all variable interpolation and
 * reference resolution in Meld. It's responsible for replacing variables like {{var}},
 * resolving paths with special variables ($HOMEPATH, $PROJECTPATH), executing commands
 * via $command references, and extracting sections from content.
 * 
 * This service implements safety checks to prevent security issues like circular references
 * and unauthorized path access, while providing rich error information for debugging.
 * 
 * Dependencies:
 * - IStateService: For retrieving variable values
 * - IPathService: For path validation and resolution
 * - IFileSystemService: For file access
 * - ICircularityService: For detecting circular references
 */
interface IResolutionService {
  /**
   * Resolve text variables ({{var}}) in a string.
   * 
   * @param text - The string containing text variables to resolve
   * @param context - The resolution context with state and allowed variable types
   * @returns The string with all variables resolved
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   * 
   * @example
   * ```ts
   * const resolved = await resolutionService.resolveText(
   *   "Hello, {{name}}! Welcome to {{company}}.",
   *   { allowedVariableTypes: { text: true, data: false, path: false, command: false }, state }
   * );
   * ```
   */
  resolveText(text: string, context: ResolutionContext): Promise<string>;

  /**
   * Resolve data variables and fields ({{data.field}}) to their values.
   * 
   * @param ref - The data variable reference to resolve
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved data value
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   * 
   * @example
   * ```ts
   * const data = await resolutionService.resolveData(
   *   "user.profile.name",
   *   { allowedVariableTypes: { text: false, data: true, path: false, command: false }, 
   *     allowDataFields: true, state }
   * );
   * ```
   */
  resolveData(ref: string, context: ResolutionContext): Promise<any>;

  /**
   * Resolve path variables ($path) to absolute paths.
   * Handles $HOMEPATH/$~ and $PROJECTPATH/$. resolution.
   * 
   * @param path - The path with variables to resolve
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved absolute path
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   * @throws {PathValidationError} If the path violates path security rules
   * 
   * @example
   * ```ts
   * const absPath = await resolutionService.resolvePath(
   *   "$./src/config/$environment.json",
   *   { allowedVariableTypes: { text: true, data: false, path: true, command: false }, state }
   * );
   * ```
   */
  resolvePath(path: string, context: ResolutionContext): Promise<string>;

  /**
   * Resolve command references ($command(args)) to their results.
   * 
   * @param cmd - The command name to resolve
   * @param args - The arguments to pass to the command
   * @param context - The resolution context with state and allowed variable types
   * @returns The command execution result
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   * 
   * @example
   * ```ts
   * const result = await resolutionService.resolveCommand(
   *   "listFiles",
   *   ["*.js", "--recursive"],
   *   { allowedVariableTypes: { text: true, data: true, path: true, command: true }, state }
   * );
   * ```
   */
  resolveCommand(cmd: string, args: string[], context: ResolutionContext): Promise<string>;

  /**
   * Resolve content from a file path.
   * 
   * @param path - The path to the file to read
   * @returns The file content as a string
   * @throws {MeldFileSystemError} If the file cannot be read
   */
  resolveFile(path: string): Promise<string>;

  /**
   * Resolve raw content nodes, preserving formatting but skipping comments.
   * 
   * @param nodes - The AST nodes to convert to text
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved content as a string
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   */
  resolveContent(nodes: MeldNode[], context: ResolutionContext): Promise<string>;

  /**
   * Resolve any value based on the provided context rules.
   * This is a general-purpose resolution method that handles different types of values.
   * 
   * @param value - The string or structured path to resolve
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved value as a string
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   */
  resolveInContext(value: string | StructuredPath, context?: ResolutionContext): Promise<string>;

  /**
   * Resolves a field access on a variable (e.g., variable.field.subfield)
   * 
   * @param variableName - The base variable name
   * @param fieldPath - The path to the specific field
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved field value
   * @throws {MeldResolutionError} If field access fails
   */
  resolveFieldAccess(variableName: string, fieldPath: string, context?: ResolutionContext): Promise<any>;

  /**
   * Validate that a value can be resolved with the given context
   * @throws {MeldResolutionError} If validation fails
   */
  validateResolution(value: string | StructuredPath, context?: ResolutionContext): Promise<void>;

  /**
   * Extract a section from content by its heading.
   * Useful for retrieving specific parts of markdown or other structured text.
   * 
   * @param content - The content to extract the section from
   * @param section - The heading text to search for
   * @param fuzzy - Optional fuzzy matching threshold (0-1, where 1 is exact match, defaults to 0.7)
   * @returns The extracted section content
   * @throws {MeldResolutionError} With code SECTION_NOT_FOUND if the section cannot be found
   * 
   * @example
   * ```ts
   * const apiDocs = await resolutionService.extractSection(
   *   readme,
   *   "API Documentation",
   *   0.8 // 80% match threshold
   * );
   * ```
   */
  extractSection(content: string, section: string, fuzzy?: number): Promise<string>;

  /**
   * Check for circular variable references.
   * 
   * @param value - The string to check for circular references
   * @throws {MeldResolutionError} With code CIRCULAR_REFERENCE if circular references are detected
   */
  detectCircularReferences(value: string): Promise<void>;
  
  /**
   * Convert a value to a formatted string based on the provided formatting context.
   * This is particularly useful for handling data variables in different output contexts.
   * 
   * @param value - The value to convert to a string
   * @param options - Formatting options including context information
   * @returns The formatted string representation of the value
   * 
   * @example
   * ```ts
   * const formatted = await resolutionService.convertToFormattedString(
   *   dataValue,
   *   { 
   *     formattingContext: { 
   *       isBlock: true, 
   *       nodeType: 'embed',
   *       isTransformation: true 
   *     }
   *   }
   * );
   * ```
   */
  convertToFormattedString(value: any, options?: any): Promise<string>;
  
  /**
   * Enable tracking of variable resolution attempts.
   * This is primarily used for debugging and visualization.
   * 
   * @param config - Configuration for the resolution tracker
   */
  enableResolutionTracking(config: Partial<ResolutionTrackingConfig>): void;
  
  /**
   * Get the resolution tracker for debugging.
   * 
   * @returns The current resolution tracker or undefined if not enabled
   */
  getResolutionTracker(): VariableResolutionTracker | undefined;
}

export type { ResolutionContext, IResolutionService };
export { ResolutionErrorCode }; 
```
    </ServicesPipelineResolutionserviceIresolutionserviceTs>
  </ValidationCriteria>
  <TaskProposeJustifyDefineTypeImprovementsForYourCode>
Examine your service&apos;s code (`
    <ServicesPipelineResolutionserviceResolutionserviceTs>
```javascript
import * as path from 'path';
import type { IStateService } from '@services/state/StateService/IStateService.js';
import type { IResolutionService, ResolutionContext } from '@services/pipeline/ResolutionService/IResolutionService.js';
import { ResolutionErrorCode } from '@services/pipeline/ResolutionService/IResolutionService.js';
import { TextResolver } from '@services/pipeline/ResolutionService/resolvers/TextResolver.js';
import { DataResolver } from '@services/pipeline/ResolutionService/resolvers/DataResolver.js';
import { PathResolver } from '@services/pipeline/ResolutionService/resolvers/PathResolver.js';
import { CommandResolver } from '@services/pipeline/ResolutionService/resolvers/CommandResolver.js';
import { ContentResolver } from '@services/pipeline/ResolutionService/resolvers/ContentResolver.js';
import { VariableReferenceResolver } from '@services/pipeline/ResolutionService/resolvers/VariableReferenceResolver.js';
import { FieldAccessUtility } from '@services/resolution/utilities/index.js';
import { resolutionLogger as logger } from '@core/utils/logger.js';
import type { IFileSystemService } from '@services/fs/FileSystemService/IFileSystemService.js';
import type { MeldNode, DirectiveNode, TextNode, DirectiveKind, CodeFenceNode } from '@core/syntax/types/index.js';
import { MeldFileNotFoundError } from '@core/errors/MeldFileNotFoundError.js';
import { MeldResolutionError } from '@core/errors/MeldResolutionError.js';
import { ErrorSeverity } from '@core/errors/MeldError.js';
import { inject, singleton, container } from 'tsyringe';
import type { IPathService } from '@services/fs/PathService/IPathService.js';
import { VariableResolutionTracker, ResolutionTrackingConfig } from '@tests/utils/debug/VariableResolutionTracker/index.js';
import { Service } from '@core/ServiceProvider.js';
import type { IParserServiceClient } from '@services/pipeline/ParserService/interfaces/IParserServiceClient.js';
import { ParserServiceClientFactory } from '@services/pipeline/ParserService/factories/ParserServiceClientFactory.js';
import { IVariableReferenceResolverClient } from '@services/pipeline/ResolutionService/interfaces/IVariableReferenceResolverClient.js';
import { VariableReferenceResolverClientFactory } from '@services/pipeline/ResolutionService/factories/VariableReferenceResolverClientFactory.js';
import { IDirectiveServiceClient } from '@services/pipeline/DirectiveService/interfaces/IDirectiveServiceClient.js';
import { DirectiveServiceClientFactory } from '@services/pipeline/DirectiveService/factories/DirectiveServiceClientFactory.js';
import type { IFileSystemServiceClient } from '@services/fs/FileSystemService/interfaces/IFileSystemServiceClient.js';
import { FileSystemServiceClientFactory } from '@services/fs/FileSystemService/factories/FileSystemServiceClientFactory.js';
import type { IParserService } from '@services/pipeline/ParserService/IParserService.js';
import { VariableResolutionErrorFactory } from '@services/pipeline/ResolutionService/resolvers/error-factory.js';

/**
 * Interface matching the StructuredPath expected from meld-spec
 */
interface StructuredPath {
  raw: string;
  structured: {
    segments: string[];
    variables?: {
      special?: string[];
      path?: string[];
    };
    cwd?: boolean;
  };
  normalized?: string;
}

/**
 * Internal type for heading nodes in the ResolutionService
 * This is converted from TextNode when we detect a heading pattern
 */
interface InternalHeadingNode {
  content: string;
  level: number;
}

/**
 * Convert a TextNode to an InternalHeadingNode if it matches heading pattern
 * Returns null if the node is not a heading
 */
function parseHeadingNode(node: TextNode): InternalHeadingNode | null {
  // Instead of using regex, check the AST properties
  if (!node.content.startsWith('#')) {
    return null;
  }
  
  // Count the number of # characters at the start
  let level = 0;
  for (let i = 0; i < node.content.length && i < 6; i++) {
    if (node.content[i] === '#') {
      level++;
    } else {
      break;
    }
  }
  
  // Validate level and check for space after #s
  if (level === 0 || level > 6 || node.content[level] !== ' ') {
    return null;
  }
  
  // Extract the content after the # characters
  const content = node.content.substring(level + 1).trim();
  
  if (!content) {
    return null;
  }
  
  return {
    level,
    content
  };
}

/**
 * Check if a node is a text node that represents a heading
 */
function isHeadingTextNode(node: MeldNode): node is TextNode {
  if (node.type !== 'Text') {
    return false;
  }
  
  const textNode = node as TextNode;
  
  // Must start with at least one # and at most 6
  if (!textNode.content.startsWith('#')) {
    return false;
  }
  
  // Count the number of # characters
  let hashCount = 0;
  for (let i = 0; i < textNode.content.length && i < 6; i++) {
    if (textNode.content[i] === '#') {
      hashCount++;
    } else {
      break;
    }
  }
  
  // Valid heading must have:
  // 1. Between 1-6 hash characters
  // 2. A space after the hash characters
  // 3. Content after the space
  return (
    hashCount >= 1 && 
    hashCount <= 6 && 
    textNode.content.length > hashCount &&
    textNode.content[hashCount] === ' ' &&
    textNode.content.substring(hashCount + 1).trim().length > 0
  );
}

/**
 * Service responsible for resolving variables, commands, and paths in different contexts
 */
@singleton()
@Service({
  description: 'Service responsible for resolving variable references and other dynamic content'
})
export class ResolutionService implements IResolutionService {
  private textResolver: TextResolver = null!;
  private dataResolver: DataResolver = null!;
  private pathResolver: PathResolver = null!;
  private commandResolver: CommandResolver = null!;
  private contentResolver: ContentResolver = null!;
  private variableReferenceResolver: VariableReferenceResolver = null!;
  private resolutionTracker?: VariableResolutionTracker;
  
  private stateService: IStateService = null!;
  private fileSystemService: IFileSystemService = null!;
  private pathService: IPathService = null!;
  private parserService?: IParserService;
  
  private parserClient?: IParserServiceClient;
  private parserClientFactory?: ParserServiceClientFactory;
  
  private variableResolverClient?: IVariableReferenceResolverClient;
  private variableResolverClientFactory?: VariableReferenceResolverClientFactory;
  
  private directiveClient?: IDirectiveServiceClient;
  private directiveClientFactory?: DirectiveServiceClientFactory;
  
  private fsClient?: IFileSystemServiceClient;
  private fsClientFactory?: FileSystemServiceClientFactory;
  
  private factoryInitialized: boolean = false;

  /**
   * Creates a new instance of the ResolutionService
   * @param stateService - State service for variable management
   * @param fileSystemService - File system service for file operations
   * @param pathService - Path service for path operations
   * @param parserService - Parser service for parsing strings
   */
  constructor(
    @inject('IStateService') stateService?: IStateService,
    @inject('IFileSystemService') fileSystemService?: IFileSystemService, 
    @inject('IPathService') pathService?: IPathService,
    @inject('IParserService') parserService?: IParserService
  ) {
    this.initializeFromParams(stateService, fileSystemService, pathService, parserService);
    
    // We'll initialize the factory lazily to avoid circular dependencies
    if (process.env.DEBUG === 'true') {
      console.log('ResolutionService: Initialized with', {
        hasStateService: !!this.stateService,
        hasFileSystemService: !!this.fileSystemService,
        hasPathService: !!this.pathService,
        hasParserService: !!this.parserService
      });
    }
  }
  
  /**
   * Lazily initialize all factories
   * This is called only when needed to avoid circular dependencies
   */
  private ensureFactoryInitialized(): void {
    if (this.factoryInitialized) {
      return;
    }
    
    this.factoryInitialized = true;
    
    // Initialize parser client factory
    try {
      this.parserClientFactory = container.resolve('ParserServiceClientFactory');
      this.initializeParserClient();
    } catch (error) {
      // In test environment, we need to work even without factories
      logger.debug(`ParserServiceClientFactory not available: ${(error as Error).message}`);
    }
    
    // Initialize variable resolver client factory
    try {
      this.variableResolverClientFactory = container.resolve('VariableReferenceResolverClientFactory');
      this.initializeVariableResolverClient();
    } catch (error) {
      // In test environment, we need to work even without factories
      logger.debug(`VariableReferenceResolverClientFactory not available: ${(error as Error).message}`);
    }
    
    // Initialize directive client factory
    try {
      this.directiveClientFactory = container.resolve('DirectiveServiceClientFactory');
      this.initializeDirectiveClient();
    } catch (error) {
      // In test environment, we need to work even without factories
      logger.debug(`DirectiveServiceClientFactory not available: ${(error as Error).message}`);
    }
    
    // Initialize file system client factory
    try {
      this.fsClientFactory = container.resolve('FileSystemServiceClientFactory');
      this.initializeFsClient();
    } catch (error) {
      // In test environment, we need to work even without factories
      logger.debug(`FileSystemServiceClientFactory not available: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize the ParserServiceClient using the factory
   */
  private initializeParserClient(): void {
    if (!this.parserClientFactory) {
      throw new Error('ParserServiceClientFactory is not initialized');
    }
    
    try {
      this.parserClient = this.parserClientFactory.createClient();
      logger.debug('Successfully created ParserServiceClient using factory');
    } catch (error) {
      throw new Error(`Failed to create ParserServiceClient: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize the VariableResolverClient using the factory
   */
  private initializeVariableResolverClient(): void {
    if (!this.variableResolverClientFactory) {
      throw new Error('VariableReferenceResolverClientFactory is not initialized');
    }
    
    try {
      this.variableResolverClient = this.variableResolverClientFactory.createClient();
      logger.debug('Successfully created VariableReferenceResolverClient using factory');
    } catch (error) {
      throw new Error(`Failed to create VariableReferenceResolverClient: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize the DirectiveServiceClient using the factory
   */
  private initializeDirectiveClient(): void {
    if (!this.directiveClientFactory) {
      throw new Error('DirectiveServiceClientFactory is not initialized');
    }
    
    try {
      this.directiveClient = this.directiveClientFactory.createClient();
      logger.debug('Successfully created DirectiveServiceClient using factory');
    } catch (error) {
      throw new Error(`Failed to create DirectiveServiceClient: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize the FileSystemServiceClient using the factory
   */
  private initializeFsClient(): void {
    if (!this.fsClientFactory) {
      throw new Error('FileSystemServiceClientFactory is not initialized');
    }
    
    try {
      this.fsClient = this.fsClientFactory.createClient();
      logger.debug('Successfully created FileSystemServiceClient using factory');
    } catch (error) {
      throw new Error(`Failed to create FileSystemServiceClient: ${(error as Error).message}`);
    }
  }
  
  /**
   * Initialize this service with the given parameters
   * Using DI-only mode
   */
  private initializeFromParams(
    stateService?: IStateService,
    fileSystemService?: IFileSystemService,
    pathService?: IPathService,
    parserService?: IParserService
  ): void {
    // Verify required dependencies
    if (!stateService) {
      throw new Error('StateService is required for ResolutionService');
    }
    
    // Initialize services
    this.stateService = stateService;
    this.fileSystemService = fileSystemService || this.createDefaultFileSystemService();
    this.pathService = pathService || this.createDefaultPathService();
    this.parserService = parserService;
    
    // Initialize resolvers
    this.initializeResolvers();
  }

  /**
   * Create a default file system service if not provided
   * Used as fallback in case dependency injection fails
   */
  private createDefaultFileSystemService(): IFileSystemService {
    logger.warn('Using default FileSystemService - this should only happen in tests');
    // Use unknown as an intermediate cast to avoid strict type checking
    return {
      readFile: async (): Promise<string> => '',
      exists: async (): Promise<boolean> => false,
      writeFile: async (): Promise<void> => {},
      stat: async (): Promise<any> => ({ isDirectory: () => false }),
      isFile: async (): Promise<boolean> => false,
      readDir: async (): Promise<string[]> => [],
      ensureDir: async (): Promise<void> => {},
      isDirectory: async (): Promise<boolean> => false,
      getCwd: (): string => '',
      dirname: (filePath: string): string => '',
      watch: (): any => ({ [Symbol.asyncIterator]: () => ({ next: async () => ({ done: true, value: undefined }) }) }),
      executeCommand: async (): Promise<any> => ({ stdout: '', stderr: '' }),
      mkdir: async (): Promise<void> => {},
    } as unknown as IFileSystemService;
  }
  
  /**
   * Create a default path service if not provided
   * Used as fallback in case dependency injection fails
   */
  private createDefaultPathService(): IPathService {
    logger.warn('Using default PathService - this should only happen in tests');
    // Use unknown as an intermediate cast to avoid strict type checking
    return {
      validatePath: async (path: string | StructuredPath): Promise<string | StructuredPath> => path,
      resolvePath: (path: string | StructuredPath): string | StructuredPath => path,
      normalizePath: (path: string): string => path,
      initialize: (): void => {},
      enableTestMode: (): void => {},
      disableTestMode: (): void => {},
      isTestMode: (): boolean => false,
      setTestMode: (): void => {},
      getHomePath: (): string => '',
      getProjectPath: (): string => '',
      setProjectPath: (): void => {},
      dirname: (): string => '',
      isAbsolute: (): boolean => false,
      // Minimal implementation for fallback
    } as unknown as IPathService;
  }
  
  /**
   * Initialize the resolver components used by this service
   */
  private initializeResolvers(): void {
    this.textResolver = new TextResolver(this.stateService);
    this.dataResolver = new DataResolver(this.stateService);
    this.pathResolver = new PathResolver(this.stateService);
    this.commandResolver = new CommandResolver(this.stateService);
    this.contentResolver = new ContentResolver(this.stateService);
    this.variableReferenceResolver = new VariableReferenceResolver(
      this.stateService,
      this
    );
  }

  /**
   * Parse a string into AST nodes for resolution
   */
  private async parseForResolution(value: string): Promise<MeldNode[]> {
    try {
      // Ensure factory is initialized before trying to use it
      this.ensureFactoryInitialized();
      
      // Use the parser client if available
      if (this.parserClient) {
        try {
          const nodes = await this.parserClient.parseString(value);
          return nodes || [];
        } catch (error) {
          logger.error('Error using parserClient.parseString', { 
            error, 
            valueLength: value.length 
          });
        }
      }
      
      // Last resort fallback to direct parsing in tests
      logger.warn('No parser client available - falling back to direct import or mock parser');
      
      // Try using directly injected parser service if available (for tests)
      if (this.parserService) {
        try {
          const nodes = await this.parserService.parse(value);
          return nodes || [];
        } catch (error) {
          logger.warn('Error using injected parser service', { error });
        }
      }
      
      // Finally, try using require
      try {
        // Use require for better build compatibility
        const coreAst = require('@core/ast');
        const result = await coreAst.parse(value, { trackLocations: true });
        return result.ast || [];
      } catch (error) {
        // In a test environment, create a fallback text node
        logger.warn('Last resort - creating fallback text node', { value });
        return [{ type: 'Text', content: value } as TextNode];
      }
    } catch (error) {
      logger.error('Error parsing content for resolution', { error });
      return [];
    }
  }

  /**
   * Resolve text variables in a string
   */
  async resolveText(text: string, context: ResolutionContext): Promise<string> {
    const nodes = await this.parseForResolution(text);
    return this.textResolver.resolve(nodes[0] as DirectiveNode, context);
  }

  /**
   * Resolve data variables and fields
   */
  async resolveData(ref: string, context: ResolutionContext): Promise<any> {
    const nodes = await this.parseForResolution(ref);
    return this.dataResolver.resolve(nodes[0] as DirectiveNode, context);
  }

  /**
   * Resolve path variables
   */
  async resolvePath(path: string, context: ResolutionContext): Promise<string> {
    const nodes = await this.parseForResolution(path);
    return this.pathResolver.resolve(nodes[0] as DirectiveNode, context);
  }

  /**
   * Resolve command references
   */
  async resolveCommand(cmd: string, args: string[], context: ResolutionContext): Promise<string> {
    const node: DirectiveNode = {
      type: 'Directive',
      directive: {
        kind: 'run',
        name: cmd,
        identifier: cmd,
        args
      }
    };
    return this.commandResolver.resolve(node, context);
  }

  /**
   * Resolve content from a file path
   */
  async resolveFile(path: string): Promise<string> {
    try {
      // Ensure factory is initialized
      this.ensureFactoryInitialized();
      
      // Try to use the file system client if available
      if (this.fsClient) {
        try {
          // The IFileSystemServiceClient interface doesn't include readFile
          // so we need to directly use the fileSystemService instead
          return await this.fileSystemService.readFile(path);
        } catch (error) {
          logger.warn('Error reading file with fileSystemService', { 
            error: error instanceof Error ? error.message : 'Unknown error', 
            path 
          });
        }
      }
      
      // Fall back to direct file system service
      return await this.fileSystemService.readFile(path);
    } catch (error) {
      throw new MeldFileNotFoundError(`Failed to read file: ${path}`, { 
        cause: error instanceof Error ? error : new Error(String(error)) 
      });
    }
  }

  /**
   * Resolve raw content nodes, preserving formatting but skipping comments
   */
  async resolveContent(nodes: MeldNode[], context: ResolutionContext): Promise<string> {
    if (!Array.isArray(nodes)) {
      // If a string path is provided, read the file
      const path = String(nodes);
      if (!await this.fileSystemService.exists(path)) {
        throw new MeldResolutionError(
          `File not found: ${path}`,
          {
            code: ResolutionErrorCode.INVALID_PATH,
            details: { value: path },
            severity: ErrorSeverity.Fatal
          }
        );
      }
      return this.fileSystemService.readFile(path);
    }

    // Otherwise, process the nodes
    return this.contentResolver.resolve(nodes, context);
  }

  /**
   * Resolve any value based on the provided context rules
   */
  async resolveInContext(value: string | StructuredPath, context?: ResolutionContext): Promise<string> {
    // If no context is provided, create a default one
    const resolveContext = context || {
      allowedVariableTypes: {
        text: true,
        data: true,
        path: true,
        command: true
      },
      pathValidation: {
        requireAbsolute: false,
        allowedRoots: []
      },
      currentFilePath: undefined,
      state: this.stateService
    };
    
    // Add debug logging for debugging path handling issues
    logger.debug('ResolutionService.resolveInContext', {
      value: typeof value === 'string' ? value : value.raw,
      allowedVariableTypes: resolveContext.allowedVariableTypes,
      pathValidation: resolveContext.pathValidation,
      stateExists: !!resolveContext.state,
      specialPathVars: resolveContext.state ? {
        PROJECTPATH: resolveContext.state.getPathVar('PROJECTPATH'),
        HOMEPATH: resolveContext.state.getPathVar('HOMEPATH')
      } : 'state not available'
    });

    // Handle structured path objects by delegating to the dedicated method
    if (typeof value === 'object' && value !== null && 'raw' in value) {
      return this.resolveStructuredPath(value, resolveContext);
    }

    // Handle string values
    if (typeof value === 'string') {
      // Check for special direct path variable references
      if (value === '$HOMEPATH' || value === '$~') {
        const homePath = resolveContext.state?.getPathVar('HOMEPATH') || this.stateService.getPathVar('HOMEPATH');
        return homePath || '';
      }
      
      if (value === '$PROJECTPATH' || value === '$.') {
        const projectPath = resolveContext.state?.getPathVar('PROJECTPATH') || this.stateService.getPathVar('PROJECTPATH');
        return projectPath || '';
      }
      
      // Check for command references in the format $command(args)
      const commandRegex = /^\$(\w+)\(([^)]*)\)$/;
      const commandMatch = value.match(commandRegex);
      
      if (commandMatch) {
        const [, cmdName, argsStr] = commandMatch;
        // Parse args, splitting by comma but respecting quoted strings
        const args = argsStr.split(',').map(arg => arg.trim());
        
        try {
          logger.debug('Resolving command reference', { cmdName, args });
          const result = await this.resolveCommand(cmdName, args, resolveContext);
          return result;
        } catch (error) {
          logger.warn('Command execution failed', { cmdName, args, error });
          // Fall back to the command name and args, joining with spaces
          return `${cmdName} ${args.join(' ')}`;
        }
      }
      
      // Try to parse the string as a path using the parser service
      try {
        // Only attempt parsing if the string contains path variable indicators
        if (value.includes('$.') || value.includes('$~') || value.includes('$/') || value.includes(')) {
          const nodes = await this.parseForResolution(value);
          const pathNode = nodes.find(node => 
            (node as any).type === 'PathVar' || 
            (node.type === 'Directive' && (node as any).directive?.kind === 'path')
          );
          
          if (pathNode) {
            // Extract the structured path from the node
            let structPath: StructuredPath;
            
            if ((pathNode as any).type === 'PathVar' && (pathNode as any).value) {
              structPath = (pathNode as any).value as StructuredPath;
              // Recursive call with the structured path
              return this.resolveStructuredPath(structPath, resolveContext);
            } else if (pathNode.type === 'Directive') {
              const directiveNode = pathNode as any;
              if (directiveNode.directive.value && 
                  typeof directiveNode.directive.value === 'object' && 
                  'raw' in directiveNode.directive.value) {
                structPath = directiveNode.directive.value as StructuredPath;
                // Recursive call with the structured path
                return this.resolveStructuredPath(structPath, resolveContext);
              }
            }
          }
        }
      } catch (error) {
        // If parsing fails, fall back to variable resolution
        logger.debug('Path parsing failed, falling back to variable resolution', { 
          error: (error as Error).message
        });
      }
    }

    // Handle string values
    return this.resolveVariables(value as string, resolveContext);
  }
  
  /**
   * Resolve variables within a string value
   * @internal Used by resolveInContext
   */
  private async resolveVariables(value: string, context: ResolutionContext): Promise<string> {
    // Check if the string contains variable references
    if (value.includes('{{') || value.includes('${') || value.includes(')) {
      logger.debug('Resolving variables in string:', { value });
      
      // Special handling for path variables with $ prefix (like $temp)
      // Uncomment when adding path variable support
      // value = await this.resolvePathVariablesInText(value, context);
      
      // Ensure factory is initialized before trying to use it
      this.ensureFactoryInitialized();
      
      // Try new approach first (factory pattern)
      if (this.variableResolverClient) {
        try {
          return await this.variableResolverClient.resolve(value, context);
        } catch (error) {
          logger.warn('Error using variableResolverClient.resolve, falling back to direct reference', { 
            error, 
            value 
          });
        }
      }
      
      // Fall back to direct reference
      return this.variableReferenceResolver.resolve(value, context);
    }
    
    return value;
  }

  /**
   * Validate that resolution is allowed in the given context
   */
  async validateResolution(value: string | StructuredPath, context?: ResolutionContext): Promise<void> {
    // If no context is provided, create a default one
    const resolveContext = context || {
      allowedVariableTypes: {
        text: true,
        data: true,
        path: true,
        command: true
      },
      pathValidation: {
        requireAbsolute: false,
        allowedRoots: []
      },
      currentFilePath: undefined,
      state: this.stateService
    };
    
    // Convert StructuredPath to string if needed
    const stringValue = typeof value === 'string' ? value : value.raw;
    
    // Parse the value to check for variable types
    const nodes = await this.parseForResolution(stringValue);

    for (const node of nodes) {
      if (node.type !== 'Directive') continue;

      const directiveNode = node as DirectiveNode;
      
      // Check if the directive type is allowed
      switch (directiveNode.directive.kind) {
        case 'text':
          if (!resolveContext.allowedVariableTypes.text) {
            const errorMessage = 'Text variables are not allowed in this context';
            const errorDetails = { 
              value: typeof value === 'string' ? value : value.raw, 
              context: JSON.stringify(context)
            };
            const error = new MeldResolutionError(
              errorMessage,
              {
                code: ResolutionErrorCode.INVALID_CONTEXT,
                details: errorDetails,
                severity: ErrorSeverity.Fatal
              }
            );
            logger.error('Validation error in ResolutionService', { error });
            throw error;
          }
          break;

        case 'data':
          if (!resolveContext.allowedVariableTypes.data) {
            const errorMessage = 'Data variables are not allowed in this context';
            const errorDetails = { 
              value: typeof value === 'string' ? value : value.raw, 
              context: JSON.stringify(context)
            };
            const error = new MeldResolutionError(
              errorMessage,
              {
                code: ResolutionErrorCode.INVALID_CONTEXT,
                details: errorDetails,
                severity: ErrorSeverity.Fatal
              }
            );
            logger.error('Validation error in ResolutionService', { error });
            throw error;
          }
          break;

        case 'path':
          if (!resolveContext.allowedVariableTypes.path) {
            const errorMessage = 'Path variables are not allowed in this context';
            const errorDetails = { 
              value: typeof value === 'string' ? value : value.raw, 
              context: JSON.stringify(context)
            };
            const error = new MeldResolutionError(
              errorMessage,
              {
                code: ResolutionErrorCode.INVALID_CONTEXT,
                details: errorDetails,
                severity: ErrorSeverity.Fatal
              }
            );
            logger.error('Validation error in ResolutionService', { error });
            throw error;
          }
          break;

        case 'run':
          if (!resolveContext.allowedVariableTypes.command) {
            const errorMessage = 'Command references are not allowed in this context';
            const errorDetails = { 
              value: typeof value === 'string' ? value : value.raw, 
              context: JSON.stringify(context)
            };
            const error = new MeldResolutionError(
              errorMessage,
              {
                code: ResolutionErrorCode.INVALID_CONTEXT,
                details: errorDetails,
                severity: ErrorSeverity.Fatal
              }
            );
            logger.error('Validation error in ResolutionService', { error });
            throw error;
          }
          break;
      }
    }
  }

  /**
   * Check for circular variable references
   */
  async detectCircularReferences(value: string): Promise<void> {
    const visited = new Set<string>();
    const stack: string[] = [];

    const checkReferences = async (text: string, currentRef?: string) => {
      // Parse the text to get variable references
      const nodes = await this.parseForResolution(text);
      if (!nodes || !Array.isArray(nodes)) {
        throw new MeldResolutionError(
          'Invalid parse result',
          {
            code: ResolutionErrorCode.SYNTAX_ERROR,
            details: { value: text },
            severity: ErrorSeverity.Fatal
          }
        );
      }

      for (const node of nodes) {
        if (node.type !== 'Directive') continue;

        const directiveNode = node as DirectiveNode;
        const ref = directiveNode.directive.identifier;
        if (!ref) continue;

        // Skip if this is a direct reference to the current variable
        if (ref === currentRef) continue;

        if (stack.includes(ref)) {
          // Create the circular reference path
          const path = [...stack, ref].join(' -> ');
          throw new MeldResolutionError(
            `Circular reference detected: ${path}`,
            {
              code: ResolutionErrorCode.CIRCULAR_REFERENCE,
              details: { 
                value: text,
                variableName: ref
              },
              severity: ErrorSeverity.Fatal
            }
          );
        }

        if (!visited.has(ref)) {
          visited.add(ref);
          stack.push(ref);

          let refValue: string | undefined;

          switch (directiveNode.directive.kind) {
            case 'text':
              refValue = this.stateService.getTextVar(ref);
              break;
            case 'data':
              const dataValue = this.stateService.getDataVar(ref);
              if (dataValue && typeof dataValue === 'string') {
                refValue = dataValue;
              }
              break;
            case 'path':
              refValue = this.stateService.getPathVar(ref);
              break;
            case 'run':
              const cmdValue = this.stateService.getCommand(ref);
              if (cmdValue) {
                refValue = cmdValue.command;
              }
              break;
          }

          if (refValue) {
            await checkReferences(refValue, ref);
          }

          // Remove from stack after checking
          stack.pop();
        }
      }
    };

    await checkReferences(value);
  }

  /**
   * Extract a section from content by its heading
   * @param content The content to extract the section from
   * @param heading The heading text to search for
   * @param fuzzy Optional fuzzy matching threshold (0-1, where 1 is exact match, defaults to 0.7)
   */
  async extractSection(content: string, heading: string, fuzzy?: number): Promise<string> {
    logger.debug('Extracting section from content', {
      headingToFind: heading,
      contentLength: content.length,
      fuzzyThreshold: fuzzy
    });
    
    try {
      // Use llmxml for section extraction with new improved API
      const { createLLMXML } = await import('llmxml');
      const llmxml = createLLMXML({
        warningLevel: 'none'
      });
      
      // Extract the section directly from markdown using per-call configuration
      const section = await llmxml.getSection(content, heading, {
        includeNested: true,
        fuzzyThreshold: fuzzy !== undefined ? fuzzy : 0.7
      });
      
      logger.debug('Found section using llmxml', {
        heading,
        sectionLength: section.length
      });
      
      return section;
    } catch (error) {
      if (error instanceof MeldResolutionError) {
        throw error;
      }
      
      // Handle error from llmxml, which now provides detailed diagnostic information
      if (error && typeof error === 'object' && 'code' in error) {
        const llmError = error as any;
        
        if (llmError.code === 'SECTION_NOT_FOUND') {
          // Get available headings and closest matches from the error details
          const availableHeadings = llmError.details?.availableHeadings?.map((h: any) => h.title) || [];
          const closestMatches = llmError.details?.closestMatches?.map((m: any) => 
            `${m.title} (${Math.round(m.similarity * 100)}%)`
          ) || [];
          
          logger.warn('Section not found', {
            heading,
            availableHeadings,
            closestMatches
          });
          
          throw new MeldResolutionError(
            'Section not found: ' + heading,
            {
              code: ResolutionErrorCode.SECTION_NOT_FOUND,
              details: { 
                value: heading,
                contentPreview: content.substring(0, 100) + '...',
                availableHeadings: availableHeadings.join(', '),
                suggestions: closestMatches.join(', ')
              },
              severity: ErrorSeverity.Recoverable
            }
          );
        }
      }
      
      // For other errors, log and rethrow with additional context
      logger.error('Error extracting section', {
        heading,
        error: error instanceof Error ? error.message : String(error)
      });
      
      throw new MeldResolutionError(
        `Failed to extract section: ${error instanceof Error ? error.message : String(error)}`,
        {
          code: ResolutionErrorCode.SECTION_EXTRACTION_FAILED,
          details: { 
            value: heading
          },
          severity: ErrorSeverity.Recoverable
        }
      );
    }
  }
  
  /**
   * Extract all headings from content using regex
   * Since llmxml API compatibility issues, we'll use a simple regex approach
   * @private
   */
  private async extractHeadingsFromContent(content: string): Promise<{ title: string; level: number; path: string[] }[]> {
    try {
      // Simple regex to extract markdown headings
      const headingRegex = /^(#{1,6})\s+(.+?)(?:\s+#+)?$/gm;
      const matches = [...content.matchAll(headingRegex)];
      
      // Transform regex matches into structured heading objects
      const headings: { title: string; level: number; path: string[] }[] = [];
      const pathMap: Map<number, string[]> = new Map(); // Level -> current path at that level
      
      for (const match of matches) {
        const level = match[1].length; // Number of # characters
        const title = match[2].trim();
        
        // Create a path array by inheriting from parent levels
        const path: string[] = [];
        for (let i = 1; i < level; i++) {
          const parentPath = pathMap.get(i);
          if (parentPath && parentPath.length > 0) {
            path.push(...parentPath);
          }
        }
        path.push(title);
        
        // Update the path map for this level
        pathMap.set(level, [title]);
        
        // Add to headings array
        headings.push({
          title,
          level,
          path
        });
      }
      
      return headings;
    } catch (error) {
      logger.warn('Error extracting headings', {
        error: error instanceof Error ? error.message : String(error)
      });
      return [];
    }
  }

  private nodesToString(nodes: MeldNode[]): string {
    return nodes.map(node => {
      switch (node.type) {
        case 'Text':
          return (node as TextNode).content;
        case 'CodeFence':
          const codeFence = node as CodeFenceNode;
          return '```' + (codeFence.language || '') + '\n' + codeFence.content + '\n```';
        case 'Directive':
          const directive = node as DirectiveNode;
          return `@${directive.directive.kind} ${directive.directive.value || ''}`;
        default:
          return '';
      }
    }).join('\n');
  }

  /**
   * Resolve a structured path to an absolute path
   * @private
   */
  private async resolveStructuredPath(path: StructuredPath, context?: ResolutionContext): Promise<string> {
    // If no context is provided, create a default one
    const resolveContext = context || {
      allowedVariableTypes: {
        text: true,
        data: true,
        path: true,
        command: true
      },
      pathValidation: {
        requireAbsolute: false,
        allowedRoots: []
      },
      currentFilePath: undefined,
      state: this.stateService
    };
    
    // IMPORTANT FIX: Check for special flags that indicate we should skip path resolution
    // This prevents directory paths from being added to variable content in embeds
    if ((resolveContext as any).isVariableEmbed === true || 
        (resolveContext as any).disablePathPrefixing === true) {
      logger.debug('Path prefixing disabled for this context (variable embed)', {
        raw: path.raw,
        isVariableEmbed: (resolveContext as any).isVariableEmbed,
        disablePathPrefixing: (resolveContext as any).disablePathPrefixing
      });
      
      // For variable embeds, return the raw value without path resolution
      if (typeof path === 'string') {
        return path;
      }
      return path.raw;
    }
    
    const { structured, raw } = path;
    
    // Get base directory from context if available (use currentFilePath if available)
    const baseDir = resolveContext.currentFilePath ? this.pathService.dirname(resolveContext.currentFilePath) : process.cwd();
    
    // Add detailed debug logging for path resolution
    logger.debug('Resolving structured path', {
      raw: path.raw,
      structured: path.structured,
      baseDir,
      currentFilePath: resolveContext.currentFilePath,
      home: process.env.HOME,
      cwd: process.cwd()
    });
    
    // Add specific logging for home path resolution
    if (structured.variables?.special?.includes('HOMEPATH')) {
      const homePath = this.pathService.getHomePath();
      if (process.env.DEBUG === 'true') {
        console.log('Resolving home path in structured path:', {
          raw,
          homePath,
          segments: structured.segments,
          baseDir
        });
      }
    }
    
    try {
      // Use the PathService to resolve the structured path
      // This handles all special variables and path normalization
      const resolvedPath = this.pathService.resolvePath(path, baseDir);
      
      // Log the final resolved path for debugging
      if (process.env.DEBUG === 'true') {
        console.log('Path resolved successfully:', {
          raw,
          resolvedPath,
          exists: await this.fileSystemService.exists(resolvedPath)
        });
      }
      
      return resolvedPath;
    } catch (error) {
      // Log detailed error information
      if (process.env.DEBUG === 'true') {
        console.error('Path resolution failed:', {
          raw,
          structured,
          baseDir,
          error: (error as Error).message
        });
      }
      
      // Handle error based on severity
      throw new MeldResolutionError(
        `Failed to resolve path: ${(error as Error).message}`,
        {
          code: ResolutionErrorCode.INVALID_PATH,
          details: { value: raw },
          severity: ErrorSeverity.Recoverable
        }
      );
    }
  }

  /**
   * Get the variable reference resolver
   */
  getVariableResolver(): VariableReferenceResolver {
    return this.variableReferenceResolver;
  }

  /**
   * Enable tracking of variable resolution attempts
   * @param config Configuration for the resolution tracker
   */
  enableResolutionTracking(config: Partial<ResolutionTrackingConfig>): void {
    // Import and create the tracker if it doesn't exist
    if (!this.resolutionTracker) {
      this.resolutionTracker = new VariableResolutionTracker();
    }
    
    // Configure the tracker
    this.resolutionTracker.configure({
      enabled: true,
      ...config
    });
    
    // Set it on the variable reference resolver
    this.variableReferenceResolver.setResolutionTracker(this.resolutionTracker);
  }

  /**
   * Get the resolution tracker for debugging
   * @returns The current resolution tracker or undefined if not enabled
   */
  getResolutionTracker(): VariableResolutionTracker | undefined {
    return this.resolutionTracker;
  }

  /**
   * Validate a path for security and existence
   * 
   * @param path - The path to validate
   * @param context - The resolution context with state and allowed variable types
   * @returns A promise that resolves to true if the path is valid, false otherwise
   */
  async validatePath(path: string, context: ResolutionContext): Promise<boolean> {
    try {
      // First resolve the path to handle any variables
      const resolvedPath = await this.resolvePath(path, context);
      
      // Then validate the resolved path using the PathService
      await this.pathService.validatePath(resolvedPath, {
        mustExist: true
      });
      
      return true;
    } catch (error) {
      logger.debug('Path validation failed', { 
        path, 
        error: (error as Error).message 
      });
      return false;
    }
  }

  /**
   * Resolves a field access on a variable (e.g., variable.field.subfield)
   * 
   * @param variableName - The base variable name
   * @param fieldPath - The path to the specific field
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved field value
   * @throws {MeldResolutionError} If field access fails
   */
  async resolveFieldAccess(variableName: string, fieldPath: string, context?: ResolutionContext): Promise<any> {
    logger.debug(`Resolving field access: ${variableName}.${fieldPath}`);
    
    if (!context || !context.state) {
      throw new MeldResolutionError(
        `Cannot resolve field access without state context`,
        {
          code: ResolutionErrorCode.INVALID_CONTEXT,
          severity: ErrorSeverity.Fatal
        }
      );
    }
    
    // Get the base variable value
    const baseValue = context.state.getDataVar(variableName);
    
    if (baseValue === undefined) {
      throw VariableResolutionErrorFactory.variableNotFound(variableName);
    }
    
    try {
      // Extract field access options from the context if available
      const fieldAccessOptions = (context as any).fieldAccessOptions || {};
      
      // Use the shared FieldAccessUtility for consistent field access across the codebase
      const result = FieldAccessUtility.accessFieldsByPath(
        baseValue,
        fieldPath,
        {
          // Always enable both notation types for maximum compatibility
          arrayNotation: true,
          numericIndexing: true,
          // Preserve types by default, unless explicitly turned off
          preserveType: fieldAccessOptions.preserveType !== false,
          // Pass through formatting context if available
          formattingContext: fieldAccessOptions.formattingContext
        },
        variableName,
        context.strict !== false // Use strict mode unless explicitly disabled
      );
      
      logger.debug(`Successfully resolved field access ${variableName}.${fieldPath}`, {
        resultType: typeof result,
        isArray: Array.isArray(result)
      });
      
      return result;
    } catch (error) {
      logger.error(`Error resolving field access ${variableName}.${fieldPath}`, { error });
      throw VariableResolutionErrorFactory.fieldAccessError(
        `Error accessing field "${fieldPath}" of variable "${variableName}": ${error instanceof Error ? error.message : String(error)}`,
        variableName
      );
    }
  }

  /**
   * Convert a value to a formatted string based on the provided formatting context.
   * Delegates to the VariableReferenceResolverClient when available.
   * 
   * @param value - The value to convert to a string
   * @param options - Formatting options including context information
   * @returns The formatted string representation of the value
   */
  async convertToFormattedString(value: any, options?: any): Promise<string> {
    // First try to use the client for proper formatting
    if (!this.variableResolverClient) {
      this.initializeVariableResolverClient();
    }
    
    if (this.variableResolverClient) {
      try {
        return this.variableResolverClient.convertToString(value, options);
      } catch (error) {
        logger.warn('Error using variableResolverClient.convertToString, falling back to basic formatting', { 
          error: error instanceof Error ? error.message : String(error) 
        });
      }
    }
    
    // Fall back to basic formatting
    if (value === undefined || value === null) {
      return '';
    } else if (typeof value === 'string') {
      return value;
    } else if (typeof value === 'object') {
      try {
        // Check if this is a block context from options
        const isBlock = options?.formattingContext?.isBlock === true;
        const isTransformation = options?.formattingContext?.isTransformation === true;
        
        // For objects in block context or transformation mode, use pretty printing
        if ((isBlock || isTransformation) && (Array.isArray(value) || Object.keys(value).length > 0)) {
          return JSON.stringify(value, null, 2);
        }
        
        // For inline contexts, use compact representation
        return JSON.stringify(value);
      } catch (error) {
        logger.warn('Error formatting object to string', { 
          error: error instanceof Error ? error.message : String(error) 
        });
        return String(value);
      }
    } else {
      // For primitive values, just use String()
      return String(value);
    }
  }
} 
```
    </ServicesPipelineResolutionserviceResolutionserviceTs>
    <ServicesPipelineResolutionserviceIresolutionserviceTs>
```javascript
import type { MeldNode } from '@core/syntax/types/index.js';
import type { StateServiceLike, StructuredPath } from '@core/shared-service-types.js';
import { VariableResolutionTracker, ResolutionTrackingConfig } from '@tests/utils/debug/VariableResolutionTracker/index.js';

/**
 * Context for variable resolution, specifying what types of variables and operations are allowed.
 * Controls the behavior of resolution operations for security and validation.
 */
interface ResolutionContext {
  /** Current file being processed, for error reporting */
  currentFilePath?: string;
  
  /** What types of variables are allowed in this context */
  allowedVariableTypes: {
    /** Allow text variables {{var}} (formerly ${var}) */
    text: boolean;    
    /** Allow data variables {{data}} (formerly #{data}) */
    data: boolean;    
    /** Allow path variables $path */
    path: boolean;    
    /** Allow command interpolation $command */
    command: boolean; 
  };
  
  /** Path validation rules when resolving paths */
  pathValidation?: {
    /** Whether paths must be absolute */
    requireAbsolute: boolean;
    /** List of allowed path roots e.g. [$HOMEPATH, $PROJECTPATH] */
    allowedRoots: string[]; 
  };

  /** Whether field access is allowed for data variables (e.g., data.field) */
  allowDataFields?: boolean;

  /** Whether to throw errors on resolution failures (true) or attempt to recover (false) */
  strict?: boolean;

  /** Whether nested variable references are allowed */
  allowNested?: boolean;

  /** The state service to use for variable resolution */
  state: StateServiceLike;
  
  /** Flag indicating this is a variable embed context for special handling */
  isVariableEmbed?: boolean;
  
  /** Flag to disable path prefixing */
  disablePathPrefixing?: boolean;
  
  /** Flag to actively prevent path prefixing from occurring */
  preventPathPrefixing?: boolean;
  
  /** Field access options for enhanced field resolution */
  fieldAccessOptions?: {
    preserveType?: boolean;
    formattingContext?: any;
    arrayNotation?: boolean;
    numericIndexing?: boolean;
    variableName?: string;
  };
}

/**
 * Error codes for resolution failures to enable precise error handling
 */
enum ResolutionErrorCode {
  /** Variable is undefined in the current context */
  UNDEFINED_VARIABLE = 'UNDEFINED_VARIABLE',
  /** Circular reference detected in variable resolution */
  CIRCULAR_REFERENCE = 'CIRCULAR_REFERENCE',
  /** Resolution context is invalid or missing required properties */
  INVALID_CONTEXT = 'INVALID_CONTEXT',
  /** Variable type is not allowed in the current context */
  INVALID_VARIABLE_TYPE = 'INVALID_VARIABLE_TYPE',
  /** Path format is invalid or violates path security rules */
  INVALID_PATH = 'INVALID_PATH',
  /** Maximum iteration count exceeded during resolution */
  MAX_ITERATIONS_EXCEEDED = 'MAX_ITERATIONS_EXCEEDED',
  /** Variable reference has invalid syntax */
  SYNTAX_ERROR = 'SYNTAX_ERROR',
  /** Error accessing fields in a data variable */
  FIELD_ACCESS_ERROR = 'FIELD_ACCESS_ERROR',
  /** Maximum recursion depth exceeded during resolution */
  MAX_DEPTH_EXCEEDED = 'MAX_DEPTH_EXCEEDED',
  /** General resolution failure */
  RESOLUTION_FAILED = 'RESOLUTION_FAILED',
  /** Node type is invalid for the requested operation */
  INVALID_NODE_TYPE = 'INVALID_NODE_TYPE',
  /** Command reference is invalid */
  INVALID_COMMAND = 'INVALID_COMMAND',
  /** Variable not found in the current state */
  VARIABLE_NOT_FOUND = 'VARIABLE_NOT_FOUND',
  /** Field does not exist in the data variable */
  INVALID_FIELD = 'INVALID_FIELD',
  /** Command not found in the current state */
  COMMAND_NOT_FOUND = 'COMMAND_NOT_FOUND',
  /** Section not found in the content */
  SECTION_NOT_FOUND = 'SECTION_NOT_FOUND',
  /** Section extraction failed */
  SECTION_EXTRACTION_FAILED = 'SECTION_EXTRACTION_FAILED',
  /** Specific field not found in variable */
  FIELD_NOT_FOUND = 'FIELD_NOT_FOUND',
  /** Invalid access pattern (e.g., array access on non-array) */
  INVALID_ACCESS = 'INVALID_ACCESS'
}

/**
 * Service responsible for resolving variables, commands, and paths in Meld content.
 * Handles all interpolation and reference resolution while enforcing security constraints.
 * 
 * @remarks
 * The ResolutionService is a core service that handles all variable interpolation and
 * reference resolution in Meld. It's responsible for replacing variables like {{var}},
 * resolving paths with special variables ($HOMEPATH, $PROJECTPATH), executing commands
 * via $command references, and extracting sections from content.
 * 
 * This service implements safety checks to prevent security issues like circular references
 * and unauthorized path access, while providing rich error information for debugging.
 * 
 * Dependencies:
 * - IStateService: For retrieving variable values
 * - IPathService: For path validation and resolution
 * - IFileSystemService: For file access
 * - ICircularityService: For detecting circular references
 */
interface IResolutionService {
  /**
   * Resolve text variables ({{var}}) in a string.
   * 
   * @param text - The string containing text variables to resolve
   * @param context - The resolution context with state and allowed variable types
   * @returns The string with all variables resolved
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   * 
   * @example
   * ```ts
   * const resolved = await resolutionService.resolveText(
   *   "Hello, {{name}}! Welcome to {{company}}.",
   *   { allowedVariableTypes: { text: true, data: false, path: false, command: false }, state }
   * );
   * ```
   */
  resolveText(text: string, context: ResolutionContext): Promise<string>;

  /**
   * Resolve data variables and fields ({{data.field}}) to their values.
   * 
   * @param ref - The data variable reference to resolve
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved data value
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   * 
   * @example
   * ```ts
   * const data = await resolutionService.resolveData(
   *   "user.profile.name",
   *   { allowedVariableTypes: { text: false, data: true, path: false, command: false }, 
   *     allowDataFields: true, state }
   * );
   * ```
   */
  resolveData(ref: string, context: ResolutionContext): Promise<any>;

  /**
   * Resolve path variables ($path) to absolute paths.
   * Handles $HOMEPATH/$~ and $PROJECTPATH/$. resolution.
   * 
   * @param path - The path with variables to resolve
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved absolute path
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   * @throws {PathValidationError} If the path violates path security rules
   * 
   * @example
   * ```ts
   * const absPath = await resolutionService.resolvePath(
   *   "$./src/config/$environment.json",
   *   { allowedVariableTypes: { text: true, data: false, path: true, command: false }, state }
   * );
   * ```
   */
  resolvePath(path: string, context: ResolutionContext): Promise<string>;

  /**
   * Resolve command references ($command(args)) to their results.
   * 
   * @param cmd - The command name to resolve
   * @param args - The arguments to pass to the command
   * @param context - The resolution context with state and allowed variable types
   * @returns The command execution result
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   * 
   * @example
   * ```ts
   * const result = await resolutionService.resolveCommand(
   *   "listFiles",
   *   ["*.js", "--recursive"],
   *   { allowedVariableTypes: { text: true, data: true, path: true, command: true }, state }
   * );
   * ```
   */
  resolveCommand(cmd: string, args: string[], context: ResolutionContext): Promise<string>;

  /**
   * Resolve content from a file path.
   * 
   * @param path - The path to the file to read
   * @returns The file content as a string
   * @throws {MeldFileSystemError} If the file cannot be read
   */
  resolveFile(path: string): Promise<string>;

  /**
   * Resolve raw content nodes, preserving formatting but skipping comments.
   * 
   * @param nodes - The AST nodes to convert to text
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved content as a string
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   */
  resolveContent(nodes: MeldNode[], context: ResolutionContext): Promise<string>;

  /**
   * Resolve any value based on the provided context rules.
   * This is a general-purpose resolution method that handles different types of values.
   * 
   * @param value - The string or structured path to resolve
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved value as a string
   * @throws {MeldResolutionError} If resolution fails and strict mode is enabled
   */
  resolveInContext(value: string | StructuredPath, context?: ResolutionContext): Promise<string>;

  /**
   * Resolves a field access on a variable (e.g., variable.field.subfield)
   * 
   * @param variableName - The base variable name
   * @param fieldPath - The path to the specific field
   * @param context - The resolution context with state and allowed variable types
   * @returns The resolved field value
   * @throws {MeldResolutionError} If field access fails
   */
  resolveFieldAccess(variableName: string, fieldPath: string, context?: ResolutionContext): Promise<any>;

  /**
   * Validate that a value can be resolved with the given context
   * @throws {MeldResolutionError} If validation fails
   */
  validateResolution(value: string | StructuredPath, context?: ResolutionContext): Promise<void>;

  /**
   * Extract a section from content by its heading.
   * Useful for retrieving specific parts of markdown or other structured text.
   * 
   * @param content - The content to extract the section from
   * @param section - The heading text to search for
   * @param fuzzy - Optional fuzzy matching threshold (0-1, where 1 is exact match, defaults to 0.7)
   * @returns The extracted section content
   * @throws {MeldResolutionError} With code SECTION_NOT_FOUND if the section cannot be found
   * 
   * @example
   * ```ts
   * const apiDocs = await resolutionService.extractSection(
   *   readme,
   *   "API Documentation",
   *   0.8 // 80% match threshold
   * );
   * ```
   */
  extractSection(content: string, section: string, fuzzy?: number): Promise<string>;

  /**
   * Check for circular variable references.
   * 
   * @param value - The string to check for circular references
   * @throws {MeldResolutionError} With code CIRCULAR_REFERENCE if circular references are detected
   */
  detectCircularReferences(value: string): Promise<void>;
  
  /**
   * Convert a value to a formatted string based on the provided formatting context.
   * This is particularly useful for handling data variables in different output contexts.
   * 
   * @param value - The value to convert to a string
   * @param options - Formatting options including context information
   * @returns The formatted string representation of the value
   * 
   * @example
   * ```ts
   * const formatted = await resolutionService.convertToFormattedString(
   *   dataValue,
   *   { 
   *     formattingContext: { 
   *       isBlock: true, 
   *       nodeType: 'embed',
   *       isTransformation: true 
   *     }
   *   }
   * );
   * ```
   */
  convertToFormattedString(value: any, options?: any): Promise<string>;
  
  /**
   * Enable tracking of variable resolution attempts.
   * This is primarily used for debugging and visualization.
   * 
   * @param config - Configuration for the resolution tracker
   */
  enableResolutionTracking(config: Partial<ResolutionTrackingConfig>): void;
  
  /**
   * Get the resolution tracker for debugging.
   * 
   * @returns The current resolution tracker or undefined if not enabled
   */
  getResolutionTracker(): VariableResolutionTracker | undefined;
}

export type { ResolutionContext, IResolutionService };
export { ResolutionErrorCode }; 
```
@define` directives, command execution, parameter handling, or state related to command definitions.
1. **Identify areas of complexity, manual validation, or edge-case handling in your code related to this directive.**
2. **Propose specific TypeScript type features** (e.g., required properties, discriminated unions, literal types) for  that would simplify or eliminate these complexities.
3. **Crucially, make a clear case for *why* each proposed feature is needed.** Explain how it would tangibly benefit the ResolutionCore service by making the code simpler, safer, or easier to maintain.
**IMPORTANT NOTE:** Structure your response clearly. When including code examples, use inline backticks () or standard Markdown indented code blocks (4 spaces). **Do not use nested triple-backtick () code fences within your response.**
    </ServicesPipelineResolutionserviceIresolutionserviceTs>
  </TaskProposeJustifyDefineTypeImprovementsForYourCode>
</DependencyInjectionInMeld>