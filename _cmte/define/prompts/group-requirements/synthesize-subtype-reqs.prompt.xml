<SynthesizeSubtypeParameterRequirementsForDefine>
  <Context>
You are the **System Architect**. You have received feedback from component leads regarding the structure and parameters of the  directive, which defines reusable commands.
**CRITICAL NOTE:** Focus *only* on the structure, parameters (name, type?), and template body needed to *define* a command. Ignore execution/invocation details for now.
    <FeedbackOnDefinitionStructure>
**CoreDirective Feedback:**
    </FeedbackOnDefinitionStructure>
  </Context>
</SynthesizeSubtypeParameterRequirementsForDefine>

<ProposedTypeImprovementsForDefineDirectiveInCoredirectiveService>
After analyzing the current implementation of the CoreDirective service and the  directive handling, I&apos;ve identified several opportunities to improve type safety, code clarity, and maintainability through stronger TypeScript types.
  <1commandDefinitionTypeStructure>
    <CurrentIssues>
- The  directive stores command definitions in a generic way without clear type distinctions between basic commands and language commands
- There&apos;s no type-level validation for command parameters or structure
- Command execution relies on runtime checks that could be caught at compile time
    </CurrentIssues>
    <ProposedSolutionDiscriminatedUnionForCommandTypes>
```typescript
// Base interface for all command definitions
interface BaseCommandDefinition {
  // Common properties for all commands
  identifier: string;
  parameters: string[];
  sourceLocation?: SourceLocation;
}

// For basic shell commands (@run [command])
interface BasicCommandDefinition extends BaseCommandDefinition {
  type: 'basic';
  commandTemplate: string;
  isMultiline: boolean;
}

// For language commands (@run js|python|bash)
interface LanguageCommandDefinition extends BaseCommandDefinition {
  type: 'language';
  language: 'js' | 'python' | 'bash' | string;
  codeBlock: string;
  languageParameters?: string[];
}

// Combined type using discriminated union
type CommandDefinition = BasicCommandDefinition | LanguageCommandDefinition;
```
    </ProposedSolutionDiscriminatedUnionForCommandTypes>
    <Benefits>
1. **Type Safety**: The discriminated union pattern with the  field ensures we can safely distinguish between command types
2. **Exhaustive Checking**: TypeScript will enforce handling of all command types when using switch statements
3. **Clear Intent**: Makes the difference between command types explicit in the code
4. **Self-Documenting**: The type structure itself documents the expected structure of commands
    </Benefits>
  </1commandDefinitionTypeStructure>
  <2commandParameterValidation>
    <CurrentIssues>
- Parameter validation is done at runtime with manual checks
- No compile-time guarantees about parameter counts or names
- Error messages about parameter mismatches are generic
    </CurrentIssues>
    <ProposedSolutionParameterMetadataType>
```typescript
interface ParameterMetadata {
  name: string;
  position: number;
  // Optional validation metadata
  required?: boolean;
  defaultValue?: string;
}

// Enhanced command definition
interface EnhancedCommandDefinition extends BaseCommandDefinition {
  // Replace string[] with structured metadata
  parameters: ParameterMetadata[];
  // Track parameter count for quick validation
  parameterCount: number;
}
```
    </ProposedSolutionParameterMetadataType>
    <Benefits>
1. **Validation at Definition Time**: We can validate parameter structure when the command is defined
2. **Rich Error Messages**: Generate specific error messages about which parameter is invalid
3. **Default Values**: Support for optional parameters with default values
4. **Position Tracking**: Explicit tracking of parameter positions for substitution
    </Benefits>
  </2commandParameterValidation>
  <3commandExecutionContextType>
    <CurrentIssues>
- Command execution context is loosely typed
- Arguments passed to commands are validated at runtime
- No clear connection between command definition and execution
    </CurrentIssues>
    <ProposedSolutionExecutionContextType>
```typescript
interface CommandExecutionContext {
  // The command being executed
  commandDefinition: CommandDefinition;
  // Arguments provided to the command
  arguments: string[];
  // Resolved values after parameter substitution
  resolvedArguments?: Record<string, string>;
  // Execution environment
  workingDirectory: string;
  environmentVariables?: Record<string, string>;
  // Parent context for nested commands
  parentContext?: CommandExecutionContext;
}
```
    </ProposedSolutionExecutionContextType>
    <Benefits>
1. **Contextual Execution**: Captures all information needed for command execution in one place
2. **Argument Validation**: Can validate argument count against parameter count at compile time
3. **Traceability**: Maintains connection between definition and execution for debugging
4. **Environment Control**: Explicit control over execution environment
    </Benefits>
  </3commandExecutionContextType>
  <4commandRegistryType>
    <CurrentIssues>
- Command definitions are stored in a generic state without type-specific validation
- Retrieval of commands requires type casting and runtime checks
- No compile-time guarantees about command existence
    </CurrentIssues>
    <ProposedSolutionTypedCommandRegistry>
```typescript
interface CommandRegistry {
  // Store commands by identifier
  commands: Map<string, CommandDefinition>;
  
  // Type-safe registration methods
  registerBasicCommand(definition: BasicCommandDefinition): void;
  registerLanguageCommand(definition: LanguageCommandDefinition): void;
  
  // Type-safe retrieval with optional chaining support
  getCommand(identifier: string): CommandDefinition | undefined;
  getBasicCommand(identifier: string): BasicCommandDefinition | undefined;
  getLanguageCommand(identifier: string): LanguageCommandDefinition | undefined;
  
  // Validation methods
  hasCommand(identifier: string): boolean;
  validateCommand(identifier: string): boolean;
}
```
    </ProposedSolutionTypedCommandRegistry>
    <Benefits>
1. **Type-Safe Access**: Retrieve commands with correct types without manual casting
2. **Centralized Validation**: Validate commands in one place with consistent rules
3. **Command Management**: Explicit API for adding, retrieving, and validating commands
4. **Encapsulation**: Hides implementation details of command storage
    </Benefits>
  </4commandRegistryType>
  <5defineDirectiveParserType>
    <CurrentIssues>
- Parsing of the  directive is complex with many edge cases
- Pattern matching for different command forms is done with regex and string manipulation
- Error handling is scattered throughout the parsing logic
    </CurrentIssues>
    <ProposedSolutionStructuredParserWithResultType>
```typescript
interface DefineDirectiveParseResult {
  // Success or failure
  success: boolean;
  // The parsed command definition if successful
  commandDefinition?: CommandDefinition;
  // Error information if parsing failed
  error?: {
    message: string;
    code: string;
    location?: SourceLocation;
  };
}

interface DefineDirectiveParser {
  // Parse a define directive node
  parse(node: DirectiveNode): DefineDirectiveParseResult;
  
  // Specialized parsers for different command types
  parseBasicCommand(node: DirectiveNode): DefineDirectiveParseResult;
  parseLanguageCommand(node: DirectiveNode): DefineDirectiveParseResult;
  
  // Helper methods for parameter extraction
  extractParameters(parameterString: string): string[];
  validateParameters(parameters: string[]): boolean;
}
```
    </ProposedSolutionStructuredParserWithResultType>
    <Benefits>
1. **Structured Error Handling**: Clear pattern for handling and reporting parse errors
2. **Separation of Concerns**: Split parsing logic by command type for better maintainability
3. **Result Pattern**: Consistent return type that includes both success and error states
4. **Testability**: Easier to test individual parsing functions in isolation
    </Benefits>
  </5defineDirectiveParserType>
  <6commandSubstitutionType>
    <CurrentIssues>
- Parameter substitution in command templates is done with string manipulation
- No type safety around substitution patterns
- Difficult to track which parameters have been substituted
    </CurrentIssues>
    <ProposedSolutionSubstitutionContextType>
```typescript
interface SubstitutionPattern {
  // The full pattern to replace (e.g., "{{param}}")
  pattern: string;
  // The parameter name (e.g., "param")
  parameterName: string;
  // The position in the parameter list
  position: number;
  // Whether this is a required parameter
  required: boolean;
}

interface SubstitutionContext {
  // The command template with patterns
  template: string;
  // Detected substitution patterns
  patterns: SubstitutionPattern[];
  // Arguments to substitute
  arguments: string[];
  // Result after substitution
  result?: string;
  // Tracking of which patterns were substituted
  substituted: Set<string>;
}
```
    </ProposedSolutionSubstitutionContextType>
    <Benefits>
1. **Pattern Tracking**: Explicit tracking of substitution patterns in the template
2. **Validation**: Can validate that all required parameters are substituted
3. **Debugging**: Clear context for debugging substitution issues
4. **Consistency**: Ensures consistent handling of parameter substitution
    </Benefits>
  </6commandSubstitutionType>
  <ImplementationExampleEnhancedDefinedirectivehandler>
Here&apos;s how these types could be used to enhance the DefineDirectiveHandler:
```typescript
class DefineDirectiveHandler implements IDirectiveHandler {
  readonly kind = 'define';
  
  private commandRegistry: CommandRegistry;
  private parser: DefineDirectiveParser;
  
  constructor(
    @inject('IValidationService') private validationService: ValidationServiceLike,
    @inject('IStateService') private stateService: StateServiceLike,
    @inject('IResolutionService') private resolutionService: ResolutionServiceLike
  ) {
    this.commandRegistry = new CommandRegistryImpl();
    this.parser = new DefineDirectiveParserImpl();
  }
  
  async execute(node: DirectiveNode, context: DirectiveContext): Promise<DirectiveResult | StateServiceLike> {
    try {
      // Parse the define directive
      const parseResult = this.parser.parse(node);
      
      if (!parseResult.success) {
        throw new MeldDirectiveError(
          parseResult.error!.message,
          'define',
          { location: parseResult.error!.location }
        );
      }
      
      // Register the command in the registry
      if (parseResult.commandDefinition!.type === 'basic') {
        this.commandRegistry.registerBasicCommand(parseResult.commandDefinition as BasicCommandDefinition);
      } else {
        this.commandRegistry.registerLanguageCommand(parseResult.commandDefinition as LanguageCommandDefinition);
      }
      
      // Store the command in state
      await this.stateService.setCommand(
        parseResult.commandDefinition!.identifier,
        parseResult.commandDefinition!
      );
      
      return {
        state: context.state,
        formattingContext: {
          contextType: 'block'
        }
      };
    } catch (error) {
      // Enhanced error handling with specific error types
      if (error instanceof CommandDefinitionError) {
        throw new MeldDirectiveError(
          error.message,
          'define',
          { location: node.location?.start, details: error.details }
        );
      }
      
      throw error;
    }
  }
}
```
  </ImplementationExampleEnhancedDefinedirectivehandler>
  <WhyTheseImprovementsMatter>
1. **Reduced Runtime Errors**: By catching more issues at compile time, we reduce the potential for runtime errors that are harder to debug
2. **Self-Documenting Code**: The type structure itself documents the expected structure and relationships between different parts of the command system
3. **Maintainability**: Clear type boundaries make it easier to refactor and extend the code without breaking existing functionality
4. **Developer Experience**: Improved autocompletion and type checking make it easier for developers to work with the code
5. **Testing**: More explicit types make it easier to write comprehensive tests with proper mocking
6. **Error Messages**: Structured error types allow for more specific and helpful error messages
These improvements would significantly enhance the CoreDirective service&apos;s handling of the  directive, making it more robust, maintainable, and developer-friendly.
**DefineHandler Feedback:**
  </WhyTheseImprovementsMatter>
</ProposedTypeImprovementsForDefineDirectiveInCoredirectiveService>

<TypescriptTypeImprovementsForDefinedirectivehandler>
After analyzing the current implementation of the  and  functions, I&apos;ve identified several areas where stronger TypeScript types would significantly improve code safety, readability, and maintainability.
  <CurrentIssues>
1. **Loose Command Definition Structure**: The  interface doesn&apos;t explicitly distinguish between basic commands and language commands.
2. **Manual Validation**: There&apos;s excessive manual validation that could be handled by the type system.
3. **Unclear Parameter Requirements**: The relationship between parameters and their usage in commands isn&apos;t strongly typed.
4. **Metadata Handling**: The metadata parsing logic is error-prone with manual string splitting and validation.
5. **Command Type Ambiguity**: The code doesn&apos;t clearly distinguish between different types of commands (shell vs. language-specific).
  </CurrentIssues>
  <ProposedTypeImprovements>
    <1discriminatedUnionForCommandTypes>
```typescript
// Base command definition
interface BaseCommandDefinition {
  parameters: string[];
  metadata?: CommandMetadata;
}

// For shell commands
interface ShellCommandDefinition extends BaseCommandDefinition {
  type: 'shell';
  command: string;
}

// For language-specific commands
interface LanguageCommandDefinition extends BaseCommandDefinition {
  type: 'language';
  language: 'js' | 'python' | 'bash';
  code: string;
}

// Union type
type CommandDefinition = ShellCommandDefinition | LanguageCommandDefinition;
```
**Justification**: This discriminated union clearly distinguishes between shell commands and language-specific commands. It eliminates the need for runtime checks of command structure and makes the code&apos;s intent clearer. The handler can use type guards to safely process each command type appropriately.
    </1discriminatedUnionForCommandTypes>
    <2strongerMetadataTypes>
```typescript
interface CommandMetadata {
  risk?: 'high' | 'med' | 'low';
  about?: string;
  meta?: Record<string, unknown>;
}

// For parsing from dot notation
type MetadataKey = 'risk' | 'about';
type RiskLevel = 'high' | 'med' | 'low';
```
**Justification**: Creating explicit types for metadata keys and risk levels eliminates string literal checks and improves autocomplete support. This reduces the chance of errors in metadata handling and makes the code more maintainable.
    </2strongerMetadataTypes>
    <3defineDirectiveDataType>
```typescript
interface BaseDefineDirectiveData {
  name: string;
  parameters?: string[];
}

interface ShellDefineData extends BaseDefineDirectiveData {
  commandType: 'shell';
  command: {
    kind: 'run';
    command: string;
  };
}

interface LanguageDefineData extends BaseDefineDirectiveData {
  commandType: 'language';
  command: {
    kind: 'run';
    language: 'js' | 'python' | 'bash';
    args?: string[];
    code: string;
  };
}

type DefineDirectiveData = ShellDefineData | LanguageDefineData;
```
**Justification**: This improved type definition for the directive data makes it clear what properties are expected and enforces the relationship between command types. It would eliminate many of the manual validation checks currently needed.
    </3defineDirectiveDataType>
    <4commandNameParserType>
```typescript
interface ParsedIdentifier {
  name: string;
  metadata?: CommandMetadata;
}

// For parsing command.name.risk.high format
interface NameWithMetadata {
  baseName: string;
  metadataKey?: MetadataKey;
  metadataValue?: string;
}
```
**Justification**: Creating a structured type for parsed identifiers makes the parsing logic more explicit and less error-prone. It eliminates the need for manual string splitting and validation in the  method.
    </4commandNameParserType>
    <5parameterReferenceType>
```typescript
interface ParameterReference {
  name: string;
  position: number;
}
```
**Justification**: This type would improve the parameter extraction logic by providing a clear structure for parameter references, including their position in the command string. This would make parameter substitution more reliable.
    </5parameterReferenceType>
  </ProposedTypeImprovements>
  <ImplementationExample>
Here&apos;s how the improved  would look with these type improvements:
```typescript
@injectable()
@Service({
  description: 'Handler for @define directives'
})
export class DefineDirectiveHandler implements IDirectiveHandler {
  public readonly kind = 'define';

  constructor(
    @inject('IValidationService') private validationService: IValidationService,
    @inject('IStateService') private stateService: IStateService,
    @inject('IResolutionService') private resolutionService: IResolutionService
  ) {}

  async execute(node: DirectiveNode, context: DirectiveContext): Promise<IStateService> {
    try {
      // 1. Validate directive structure
      await this.validationService.validate(node);

      // 2. Extract name, parameters, and command from directive
      const directive = node.directive as DefineDirectiveData;
      
      // Parse any metadata from the name
      const parsedIdentifier = this.parseIdentifier(directive.name);
      
      // 3. Create command definition based on the type
      let commandDef: CommandDefinition;
      
      if (directive.commandType === 'shell') {
        commandDef = {
          type: 'shell',
          parameters: directive.parameters || [],
          command: directive.command.command,
          ...(parsedIdentifier.metadata && { metadata: parsedIdentifier.metadata })
        };
      } else {
        // Language command
        commandDef = {
          type: 'language',
          parameters: directive.parameters || [],
          language: directive.command.language,
          code: directive.command.code,
          ...(parsedIdentifier.metadata && { metadata: parsedIdentifier.metadata })
        };
      }

      // 4. Create new state for modifications
      const newState = context.state.clone();

      // 5. Store command with metadata
      newState.setCommand(parsedIdentifier.name, commandDef);

      return newState;
    } catch (error) {
      // Error handling (unchanged)
      // ...
    }
  }

  private parseIdentifier(identifier: string): ParsedIdentifier {
    // Check for metadata fields
    const parts = identifier.split('.');
    const name = parts[0];

    if (!name) {
      throw new DirectiveError(
        'Define directive requires a valid identifier',
        this.kind,
        DirectiveErrorCode.VALIDATION_FAILED,
        {
          severity: DirectiveErrorSeverity[DirectiveErrorCode.VALIDATION_FAILED]
        }
      );
    }

    // Handle metadata if present
    if (parts.length > 1) {
      const metadataKey = parts[1] as MetadataKey;
      const metadataValue = parts[2];

      // Validate metadata key
      if (metadataKey !== 'risk' && metadataKey !== 'about') {
        throw new DirectiveError(
          'Invalid metadata field. Only risk and about are supported',
          this.kind,
          DirectiveErrorCode.VALIDATION_FAILED,
          {
            severity: DirectiveErrorSeverity[DirectiveErrorCode.VALIDATION_FAILED]
          }
        );
      }

      // Handle risk metadata
      if (metadataKey === 'risk') {
        const riskLevel = metadataValue as RiskLevel;
        
        // Validate risk level
        if (!['high', 'med', 'low'].includes(riskLevel)) {
          throw new DirectiveError(
            'Invalid risk level. Must be high, med, or low',
            this.kind,
            DirectiveErrorCode.VALIDATION_FAILED,
            {
              severity: DirectiveErrorSeverity[DirectiveErrorCode.VALIDATION_FAILED]
            }
          );
        }
        
        return { 
          name, 
          metadata: { risk: riskLevel } 
        };
      }

      // Handle about metadata
      if (metadataKey === 'about') {
        return { 
          name, 
          metadata: { about: metadataValue || 'This is a description' } 
        };
      }
    }

    return { name };
  }
}
```
  </ImplementationExample>
  <BenefitsOfTheseChanges>
1. **Type Safety**: The discriminated unions ensure that we&apos;re handling the correct command types at compile time.
2. **Reduced Runtime Validation**: Many of the manual validation checks can be eliminated because the type system enforces correct structure.
3. **Better IDE Support**: Developers get better autocompletion and inline documentation when working with these types.
4. **Clearer Intent**: The code clearly distinguishes between shell commands and language commands.
5. **More Maintainable**: When changes are needed to the command structure, the type system will highlight all places that need updates.
6. **Improved Error Messages**: TypeScript will provide more specific error messages during development.
7. **Self-Documenting Code**: The types themselves serve as documentation for the expected structure of define directives.
These improvements would significantly enhance the robustness and maintainability of the DefineDirectiveHandler while reducing the likelihood of bugs related to command structure and processing.
**ParserCore Feedback (Syntax Aspects):**
  </BenefitsOfTheseChanges>
</TypescriptTypeImprovementsForDefinedirectivehandler>

<ParsercoreImprovementsForDefineDirectiveTypeHandling>
  <CurrentLimitationsAndChallenges>
After analyzing the ParserCore service, I&apos;ve identified several areas where we can enhance TypeScript type support for the  directive. The current implementation has these limitations:
1. **No Specialized Type for @define Directives**: The code uses generic  types, requiring manual validation and type assertion.
2. **Inadequate Parameter Type Handling**: Parameters in  directives need stronger type validation to prevent runtime errors.
3. **Lack of Discrimination Between Command Types**: Basic shell commands vs. language commands (JS, Python, etc.) aren&apos;t clearly distinguished at the type level.
4. **Missing Structure for Command Templates**: The right-hand side  directive structure isn&apos;t enforced by the type system.
  </CurrentLimitationsAndChallenges>
  <ProposedTypeImprovements>
    <1defineSpecificDirectiveType>
```typescript
interface DefineDirectiveNode extends DirectiveNode {
  directive: {
    kind: 'define';
    commandName: string;
    parameters: string[];
    body: RunDirectiveNode; // Must be a @run directive
    // Metadata for better error reporting
    location?: SourceLocation;
  }
}
```
**Justification**: This specialized type would:
- Eliminate the need for manual type checking and casting in the  method
- Provide compile-time validation that all required properties exist
- Make the code more self-documenting by clearly showing the expected structure
- Enable better IDE autocompletion and error detection
    </1defineSpecificDirectiveType>
    <2parameterTypeEnhancement>
```typescript
interface DefineParameter {
  name: string;
  defaultValue?: string | null;
  location?: SourceLocation;
}

// Updated directive to use the enhanced parameter type
interface DefineDirectiveNode extends DirectiveNode {
  directive: {
    kind: 'define';
    commandName: string;
    parameters: DefineParameter[]; // Using the stronger type
    body: RunDirectiveNode;
    location?: SourceLocation;
  }
}
```
**Justification**: This improvement would:
- Support future parameter validation (e.g., default values, required vs. optional)
- Enable better error messages that point to the specific parameter causing an issue
- Provide location information for highlighting the problematic parameter in error messages
- Simplify parameter handling by providing a consistent structure
    </2parameterTypeEnhancement>
    <3commandTypeDiscrimination>
```typescript
type RunDirectiveKind = 'basic' | 'language';

interface BaseRunDirectiveNode extends DirectiveNode {
  directive: {
    kind: 'run';
    runKind: RunDirectiveKind;
    location?: SourceLocation;
  }
}

interface BasicRunDirectiveNode extends BaseRunDirectiveNode {
  directive: {
    kind: 'run';
    runKind: 'basic';
    command: string;
    isMultiline: boolean;
    location?: SourceLocation;
  }
}

interface LanguageRunDirectiveNode extends BaseRunDirectiveNode {
  directive: {
    kind: 'run';
    runKind: 'language';
    language: string;
    parameters: string[];
    code: string;
    location?: SourceLocation;
  }
}

type RunDirectiveNode = BasicRunDirectiveNode | LanguageRunDirectiveNode;
```
**Justification**: This discrimination would:
- Enforce correct handling of different command types through TypeScript&apos;s discriminated unions
- Prevent errors from trying to access properties that don&apos;t exist on a particular command type
- Make code more maintainable by clearly indicating the expected structure for each command type
- Simplify conditional logic with type guards instead of manual property checking
    </3commandTypeDiscrimination>
    <4commandDefinitionType>
```typescript
interface CommandDefinition {
  commandName: string;
  parameters: DefineParameter[];
  runDirective: RunDirectiveNode;
  sourceLocation?: SourceLocation;
}
```
**Justification**: This type would:
- Provide a clean structure for storing command definitions in the state
- Ensure all necessary information is captured for later execution
- Make the relationship between define directives and their execution clearer
- Enable better error reporting by preserving source locations
    </4commandDefinitionType>
  </ProposedTypeImprovements>
  <ImplementationBenefits>
Implementing these type improvements would bring several benefits to the ParserCore service:
    <1simplifiedVariableNodeTransformation>
Current code in  uses type assertions and manual property checking:
```typescript
if (anyNode.type === 'Directive' && anyNode.directive) {
  // Clone the directive data and recursively transform any variables it contains
  const transformedDirective = { ...anyNode.directive };
  
  // Check for specific properties that might contain variable references
  if (transformedDirective.value && typeof transformedDirective.value === 'object') {
    transformedDirective.value = this.transformVariableNode(transformedDirective.value);
  }
  
  return {
    ...anyNode,
    directive: transformedDirective
  };
}
```
With improved types, we could have clearer, type-safe handling:
```typescript
if (isDefineDirective(anyNode)) {
  // Handle define directive specifically
  return {
    ...anyNode,
    directive: {
      ...anyNode.directive,
      body: this.transformVariableNode(anyNode.directive.body) as RunDirectiveNode
    }
  };
}
```
    </1simplifiedVariableNodeTransformation>
    <2enhancedErrorReporting>
Our current error handling in  could be extended to validate define directives:
```typescript
private validateDefineDirective(node: DefineDirectiveNode): void {
  const { commandName, parameters, body } = node.directive;
  
  // Validate command name
  if (!commandName || commandName.trim() === '') {
    throw new MeldParseError(
      'Invalid @define directive: missing command name',
      node.location
    );
  }
  
  // Validate that body is a run directive
  if (body.directive.kind !== 'run') {
    throw new MeldParseError(
      'Invalid @define directive: body must be a @run directive',
      body.location || node.location
    );
  }
  
  // Additional validations based on run directive kind
  if (body.directive.runKind === 'language') {
    // Validate language-specific requirements
  }
}
```
    </2enhancedErrorReporting>
    <3saferParameterHandling>
With the enhanced parameter type, we can perform better validation:
```typescript
private validateParameters(parameters: DefineParameter[]): void {
  // Check for duplicate parameter names
  const paramNames = new Set<string>();
  for (const param of parameters) {
    if (paramNames.has(param.name)) {
      throw new MeldParseError(
        `Duplicate parameter name: ${param.name}`,
        param.location
      );
    }
    paramNames.add(param.name);
  }
}
```
    </3saferParameterHandling>
  </ImplementationBenefits>
  <MigrationPath>
To implement these improvements with minimal disruption:
1. **Define the new types** in a dedicated file (e.g., )
2. **Add type guards** to safely check and convert between types:
```typescript
function isDefineDirective(node: MeldNode): node is DefineDirectiveNode {
  return (
    node.type === 'Directive' &&
    node.directive?.kind === 'define' &&
    typeof node.directive.commandName === 'string'
  );
}
```
1. **Update the parser transformation logic** to use these specialized types
2. **Add validation functions** that leverage the type information
  </MigrationPath>
  <Conclusion>
By enhancing the TypeScript types for the  directive, we can make the ParserCore service more robust, maintainable, and self-documenting. These improvements would:
- Provide stronger compile-time validation
- Reduce the need for manual type checking and assertions
- Enable better error messages with precise location information
- Make the code more maintainable by clearly expressing the expected structure
- Improve IDE support with better autocompletion and error detection
These benefits directly address the complexity and manual validation currently required for handling  directives, resulting in code that is both safer and easier to understand.
**StateCore Feedback (Storage Aspects):**
  </Conclusion>
</ParsercoreImprovementsForDefineDirectiveTypeHandling>

<ImprovingDefineDirectiveTypeSafetyInStatecoreService>
After analyzing the StateCore service code, I&apos;ve identified several areas where enhanced TypeScript types for the  directive would significantly improve code safety, maintainability, and developer experience. The current implementation uses a generic  type that doesn&apos;t fully capture the structure and constraints of command definitions.
  <CurrentIssuesWithCommandDefinitionTypes>
    <1inadequateTypeDifferentiationForCommandTypes>
Currently, the  appears to be a simple object with a string  property and optional :
```typescript
// Current implicit type
type CommandDefinition = {
  command: string;
  options?: Record<string, unknown>;
};
```
**Problem:** This doesn&apos;t distinguish between basic shell commands and language-specific commands (JS, Python, Bash), which have different structures and validation requirements.
    </1inadequateTypeDifferentiationForCommandTypes>
    <2lackOfParameterTypeSafety>
Parameters for commands are not strongly typed, making it difficult to validate parameter counts and names when executing commands.
**Problem:** This can lead to runtime errors when parameter counts mismatch or when required parameters are missing.
    </2lackOfParameterTypeSafety>
    <3noDistinctionBetweenCommandTemplateAndRawCodeBlock>
The current type doesn&apos;t differentiate between command templates (for shell commands) and raw code blocks (for language commands).
**Problem:** This makes validation complex and error-prone, especially when processing different command types.
    </3noDistinctionBetweenCommandTemplateAndRawCodeBlock>
  </CurrentIssuesWithCommandDefinitionTypes>
  <ProposedTypeImprovements>
    <1discriminatedUnionForCommandTypes>
```typescript
// Base interface for all command definitions
interface BaseCommandDefinition {
  type: 'basic' | 'language';
  name: string;
  parameters: string[];
}

// For shell commands (@run)
interface BasicCommandDefinition extends BaseCommandDefinition {
  type: 'basic';
  commandTemplate: string;
  isMultiline: boolean;
}

// For language commands (@run js/python/bash)
interface LanguageCommandDefinition extends BaseCommandDefinition {
  type: 'language';
  language: 'js' | 'python' | 'bash' | string;
  codeBlock: string;
  languageParameters?: string[];
}

// Combined type using discriminated union
type CommandDefinition = BasicCommandDefinition | LanguageCommandDefinition;
```
**Benefits:**
1. **Type Safety:** The discriminated union pattern allows TypeScript to narrow types based on the  property.
2. **Validation:** Makes validation simpler with clear expectations for each command type.
3. **IDE Support:** Provides better autocomplete and documentation in IDEs.
    </1discriminatedUnionForCommandTypes>
    <2parameterHandlingImprovements>
```typescript
// Type for parameter validation
interface ParameterValidation {
  required: boolean;
  defaultValue?: string;
}

// Enhanced command definition with parameter validation
interface EnhancedBaseCommandDefinition extends BaseCommandDefinition {
  parameterValidation?: Record<string, ParameterValidation>;
}
```
**Benefits:**
1. **Parameter Validation:** Enables validation of required parameters and default values.
2. **Error Prevention:** Catches parameter mismatches at compile time rather than runtime.
3. **Documentation:** Self-documents the expected parameters for commands.
    </2parameterHandlingImprovements>
    <3commandStorageTypeEnhancements>
```typescript
// Enhanced state command storage
interface CommandStore {
  getCommand(name: string): CommandDefinition | undefined;
  setCommand(name: string, definition: CommandDefinition): void;
  hasCommand(name: string): boolean;
  validateParameters(name: string, providedParams: string[]): boolean;
  getAllCommands(): Map<string, CommandDefinition>;
}
```
**Benefits:**
1. **API Clarity:** Makes the command API more explicit and self-documenting.
2. **Validation:** Adds parameter validation as a first-class concern.
3. **Type Safety:** Ensures consistency in command storage and retrieval.
    </3commandStorageTypeEnhancements>
  </ProposedTypeImprovements>
  <ImplementationExamples>
    <CommandDefinitionStorage>
```typescript
// In StateService.ts
setCommand(name: string, command: string | CommandDefinition): void {
  this.checkMutable();
  const commands = new Map(this.currentState.commands);
  
  // If string is provided, convert to BasicCommandDefinition
  let commandDef: CommandDefinition;
  if (typeof command === 'string') {
    commandDef = {
      type: 'basic',
      name,
      parameters: [],
      commandTemplate: command,
      isMultiline: false
    };
  } else if ('command' in command) {
    // Legacy format conversion
    const isLanguageCommand = command.command.startsWith('@run js') || 
                             command.command.startsWith('@run python') ||
                             command.command.startsWith('@run bash');
    
    if (isLanguageCommand) {
      // Extract language and code block
      const match = /^@run\s+(\w+)(?:\(([^)]*)\))?\s+\[\[([\s\S]*)\]\]$/m.exec(command.command);
      if (match) {
        const [_, language, params, codeBlock] = match;
        commandDef = {
          type: 'language',
          name,
          parameters: [], // Would be filled from define directive params
          language,
          codeBlock: codeBlock.trim(),
          languageParameters: params ? params.split(',').map(p => p.trim()) : []
        };
      } else {
        // Fallback for malformed language command
        commandDef = {
          type: 'basic',
          name,
          parameters: [],
          commandTemplate: command.command,
          isMultiline: command.command.includes('[[')
        };
      }
    } else {
      // Basic command
      commandDef = {
        type: 'basic',
        name,
        parameters: [], // Would be filled from define directive params
        commandTemplate: command.command,
        isMultiline: command.command.includes('[[')
      };
    }
  } else {
    // Already in new format
    commandDef = command as CommandDefinition;
  }
  
  commands.set(name, commandDef);
  this.updateState({ commands }, `setCommand:${name}`);
}
```
    </CommandDefinitionStorage>
    <ParameterValidation>
```typescript
// New method in StateService
validateCommandParameters(commandName: string, providedParams: string[]): boolean {
  const command = this.getCommand(commandName);
  if (!command) return false;
  
  // For basic validation, just check parameter count
  if (command.parameters.length !== providedParams.length) {
    logger.warn(`Parameter count mismatch for command ${commandName}: expected ${command.parameters.length}, got ${providedParams.length}`);
    return false;
  }
  
  return true;
}
```
    </ParameterValidation>
    <TypeGuardsForCommandTypes>
```typescript
// Type guards for working with command definitions
function isBasicCommand(command: CommandDefinition): command is BasicCommandDefinition {
  return command.type === 'basic';
}

function isLanguageCommand(command: CommandDefinition): command is LanguageCommandDefinition {
  return command.type === 'language';
}

// Example usage in command execution
getCommandForExecution(name: string, args: string[]): string | undefined {
  const command = this.getCommand(name);
  if (!command) return undefined;
  
  if (isBasicCommand(command)) {
    // Process basic command
    let result = command.commandTemplate;
    command.parameters.forEach((param, index) => {
      result = result.replace(new RegExp(`{{${param}}}`, 'g'), args[index] || '');
    });
    return result;
  } else if (isLanguageCommand(command)) {
    // Process language command differently
    // ...
  }
  
  return undefined;
}
```
    </TypeGuardsForCommandTypes>
  </ImplementationExamples>
  <BenefitsToTheStatecoreService>
    <1improvedErrorDetection>
The enhanced types would catch many common errors at compile time:
- Mismatched parameter counts between definition and usage
- Incorrect command structure for different command types
- Missing required fields for specific command types
    </1improvedErrorDetection>
    <2selfDocumentingCode>
The discriminated union pattern makes the code self-documenting:
- Clear separation between basic and language commands
- Explicit parameter lists and validation
- Type-driven development for command handling
    </2selfDocumentingCode>
    <3simplifiedCommandProcessing>
Command processing becomes more straightforward with type narrowing:
```typescript
// Before
if (typeof command === 'string' || !command.options) {
  // Handle basic command
} else if (command.options.language) {
  // Handle language command
}

// After
if (isBasicCommand(command)) {
  // TypeScript knows this is a BasicCommandDefinition
  processBasicCommand(command.commandTemplate, command.parameters);
} else {
  // TypeScript knows this is a LanguageCommandDefinition
  processLanguageCommand(command.language, command.codeBlock, command.languageParameters);
}
```
    </3simplifiedCommandProcessing>
    <4enhancedDebuggingAndTesting>
With more specific types:
- Error messages become more precise
- Test cases can target specific command types
- Edge cases are more clearly defined and testable
    </4enhancedDebuggingAndTesting>
    <5futureExtensibility>
The proposed type system allows for future enhancements:
- Adding new command types with their own specific properties
- Extending parameter validation with more sophisticated rules
- Supporting additional metadata for commands without breaking changes
    </5futureExtensibility>
  </BenefitsToTheStatecoreService>
  <Conclusion>
Implementing these type improvements for the  directive would significantly enhance the StateCore service by:
1. Making command definitions more explicit and type-safe
2. Reducing runtime errors through compile-time validation
3. Simplifying command processing with type narrowing
4. Improving code readability and maintainability
5. Providing better developer experience through IDE support
These changes align with TypeScript best practices and would make the  directive implementation more robust while reducing the cognitive load on developers working with the codebase.
  </Conclusion>
  <TaskSynthesizeDefinitionStructureRequirements>
Review the provided feedback. Consolidate the requirements related *specifically* to defining the TypeScript types for the  directive itself and the structure used to store the definition in state.
- Identify common needs (e.g., interface for ).
- Note requirements for parameter representation (e.g., list of strings? Typed parameters?).
- Consolidate needs for storing the command template (string? structured?).
**Output Format:** Produce concise notes outlining the synthesized requirements for the  definition structure.
    <SynthesizedRequirementsDefineDefinitionStructure>
- Requirement 1: (e.g., Define  interface with , , )
- Requirement 2: (e.g., Consider adding optional parameter types if feasible?)
- Requirement 3: (e.g., Metadata storage requirements?)
- (List other key structural/parameter requirements for the definition)
    </SynthesizedRequirementsDefineDefinitionStructure>
  </TaskSynthesizeDefinitionStructureRequirements>
</ImprovingDefineDirectiveTypeSafetyInStatecoreService>