THIS IS BADLY OUTDATED AND SHOULD PROBABLY BE DELETED

# Module System Architecture

This document explains the module system used in the Mlld project, including how we handle ES modules (ESM) and CommonJS (CJS) compatibility, as well as the Mlld module export pattern.

## Overview

Mlld uses a **dual module system** to support both modern ESM and legacy CJS consumers:

- **Package Type**: ESM-first (`"type": "module"` in package.json)
- **Build Output**: Both `.mjs` (ESM) and `.cjs` (CommonJS) via tsup
- **Development**: TypeScript with ESM imports
- **Distribution**: Dual-format package with proper exports

## Key Decisions

### 1. ESM-First Approach
We use `"type": "module"` in package.json, which means:
- All `.js` files are treated as ES modules by default
- CommonJS files must use `.cjs` extension
- Scripts and tools use ESM imports

### 2. Parser Generation
The Peggy parser is special because:
- Build scripts need direct access to the generated parser
- The parser is generated in BOTH formats during build:
  - `grammar/parser/parser.js` - ES module version
  - `grammar/parser/parser.ts` - TypeScript version with type definitions
- Both versions are generated by `grammar/build-grammar.mjs`

### 3. Module Resolution

#### TypeScript Code
```typescript
import { parse } from '@grammar/parser';  // Resolves to grammar/parser/index.ts
```

#### Build Scripts
```javascript
import { parse } from '../grammar/parser/parser.js';  // Direct import of generated parser
```

## File Structure

```
grammar/
├── build-grammar.mjs       # ESM script that generates the parser
├── tsconfig.grammar.json   # Grammar-specific TS config
├── parser/
│   ├── index.ts           # TypeScript entry point (re-exports parser)
│   ├── parser.js          # Generated ES module parser
│   ├── parser.ts          # Generated TypeScript parser
│   └── deps/              # Parser dependencies (dual format)
└── deps/                  # Source dependencies for parser
```

## Build Process

1. **Grammar Build** (`npm run build:grammar`):
   - Runs `build-grammar.mjs` (ES module)
   - Generates both `parser.js` and `parser.ts`
   - Copies dependencies in both formats

2. **TypeScript Build** (tsup):
   - Compiles TypeScript to JavaScript
   - Creates dual outputs:
     - `dist/index.mjs` - ES module
     - `dist/index.cjs` - CommonJS
   - Bundles internal dependencies

3. **CLI Build**:
   - Builds to CommonJS only (`dist/cli.cjs`)
   - Uses wrapper script (`bin/mlld-wrapper.cjs`)

## Module Consumption

### For Package Consumers
```json
{
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  }
}
```

### For Internal Development
- TypeScript imports use path aliases (`@grammar/*`, `@core/*`, etc.)
- Build scripts use relative imports to generated files
- Tests run in Node with ESM support via Vite

## Common Issues and Solutions

### Issue: "Cannot use import statement outside a module"
**Cause**: File has `.js` extension but contains CommonJS code  
**Solution**: Rename to `.cjs` or convert to ESM

### Issue: Parser not found during development
**Cause**: Parser hasn't been generated yet  
**Solution**: Run `npm run build:grammar` first

### Issue: Dynamic import in CommonJS
**Cause**: Trying to use `import()` in a `.cjs` file  
**Solution**: Use `require()` or convert to ESM

## Best Practices

1. **Use ESM for new code** - All new files should use ES module syntax
2. **Explicit extensions** - Always include file extensions in imports
3. **Path aliases** - Use TypeScript path aliases for cleaner imports
4. **Build order** - Grammar must be built before TypeScript compilation

## Script Requirements

Scripts that need the parser directly:
- `scripts/ast-output.js` - AST visualization tool
- `scripts/build-fixtures.mjs` - Test fixture generation

These import the generated parser directly and require it to exist.

## Migration Notes

The project was migrated from CommonJS to ESM. Key changes:
- Changed `"type": "commonjs"` to `"type": "module"`
- Renamed CLI wrapper from `.js` to `.cjs`
- Updated build scripts to use ESM imports
- Removed unnecessary CommonJS compatibility layers

## Mlld Module Export Pattern

### Overview

Mlld modules use a dual export pattern that provides both flat access to individual exports and optional structured access through a module object. This design maximizes flexibility while preserving type information.

### How Module Exports Work

#### 1. Automatic Flat Export (Always Active)

**All top-level variables are automatically exported individually**, preserving their types:

```mlld
# In module.mld
@text greeting = "Hello"
@text sayHello(name) = @add :::Hello, {{name}}!:::
@exec build() = run [npm run build]

# These are ALL automatically available for import:
# - greeting (type: text)
# - sayHello (type: textTemplate) 
# - build (type: command)
```

#### 2. Optional Structured Export

The `@data module` pattern creates an **additional** structured export (not a replacement):

```mlld
# In module.mld
@text greeting = "Hello"
@text sayHello(name) = @add :::Hello, {{name}}!:::
@exec build() = run [npm run build]

# Optional: Create a structured interface
@data module = {
  greeting: @greeting,
  sayHello: @sayHello,
  build: @build
}
```

This enables **both** import styles:
```mlld
# Direct imports (from flat export)
@import { greeting, sayHello } from @user/module

# Structured import (if @data module is defined)
@import { module } from @user/module
# Then use: @module.greeting, @module.sayHello()
```

### Export Pattern Behaviors

#### Named Export Object Pattern

When a module defines a named data object (not called `module`), it creates a hybrid export:

```mlld
@exec get(url) = run [curl "@url"]
@exec post(url, data) = run [curl -X POST "@url"]

@data http = {
  get: @get,
  post: @post
}
```

**Auto-generated export includes:**
```javascript
{
  // Individual functions
  get: @get,
  post: @post,
  
  // The named object
  http: {
    get: @get,
    post: @post
  },
  
  // Metadata
  __meta__: { ... }
}
```

This allows importers to choose their preferred style:
- `@import { http } from @user/http-client` → `http.get()`
- `@import { get } from @user/http-client` → `get()`
- `@import { * as client } from @user/http-client` → `client.http.get()` or `client.get()`

### Module Structure

When imported, modules have this structure:

```javascript
{
  // Exported functions/variables
  functionName: ...,
  variableName: ...,
  
  // Nested exports (if defined)
  subModule: {
    function: ...
  },
  
  // Metadata from frontmatter
  __meta__: {
    author: "username",
    description: "...",
    version: "1.0.0",
    // ... other frontmatter fields
  }
}
```

### Import Behavior

1. **All top-level variables** are always accessible for import
2. **With `@data module`**: An additional `module` export is available for structured access
3. **Without `@data module`**: Only the flat exports are available
4. **Frontmatter metadata**: Always accessible via `__meta__` property

### Type Preservation

The module system preserves variable types through the export/import process:

```mlld
# In module.mld
@text greeting = "Hello"                    # Type: text
@text greet(name) = @add :::Hi {{name}}!:::  # Type: textTemplate (invokable)
@exec build() = run [make]                # Type: command (invokable)
@data config = { port: 3000 }              # Type: data
@path srcDir = "./src"                     # Type: path

# When imported, all types are preserved
# textTemplate and command types remain invokable
```

### Best Practices

1. **Use `@data module`** to provide a clean, structured API alongside flat exports
2. **Use underscore prefix** for internal helpers (e.g., `@text _internal`) - but note they're still exported
3. **Organize with named objects** for logical grouping without hiding flat exports
4. **Include frontmatter** with author, description, and version
5. **Document exports** with comments explaining usage

### Implementation Details

The module import system:
1. Fetches and parses the module content
2. **Always exports all top-level variables** with type preservation
3. If a `@data module` variable exists, adds it as an additional structured export
4. Adds `__meta__` property with frontmatter data
5. Makes the resulting object available to importers

#### Technical Implementation

The `processModuleExports` function in `interpreter/eval/import.ts`:

1. **Always export all top-level variables with type info:**
   ```typescript
   const moduleObject: Record<string, any> = {};
   
   // First, add all top-level variables with type preservation
   for (const [name, variable] of childVars) {
     if (name !== 'module') {
       moduleObject[name] = {
         __variableType: variable.type,
         __value: variable.value,
         // For textTemplate, preserve params and content
         ...(variable.type === 'textTemplate' ? {
           __params: variable.params,
           __content: variable.content
         } : {})
       };
     }
   }
   ```

2. **Add structured export if defined:**
   ```typescript
   const moduleVar = childVars.get('module');
   if (moduleVar && moduleVar.type === 'data') {
     // Add the module as an additional structured export
     moduleObject.module = {
       __variableType: 'data',
       __value: moduleValue
     };
   }
   ```

3. **Import side reconstructs proper variable types:**
   ```typescript
   // Extract the actual variable type from the module export
   if (value && typeof value === 'object' && '__variableType' in value) {
     varType = value.__variableType;
     varValue = value.__value;
     
     // For textTemplate, restore additional fields
     if (varType === 'textTemplate') {
       importedVariable.params = value.__params;
       importedVariable.content = value.__content;
     }
   }
   ```

This design enables:
- **Universal access** to all top-level exports
- **Type preservation** including invokable types (textTemplate, command)
- **Optional structure** with `@data module` for organization
- **Backward compatibility** with existing modules
- **Always available metadata** via `__meta__`
