# Module System Architecture

This document explains the module system used in the Mlld project, including how we handle ES modules (ESM) and CommonJS (CJS) compatibility.

## Overview

Mlld uses a **dual module system** to support both modern ESM and legacy CJS consumers:

- **Package Type**: ESM-first (`"type": "module"` in package.json)
- **Build Output**: Both `.mjs` (ESM) and `.cjs` (CommonJS) via tsup
- **Development**: TypeScript with ESM imports
- **Distribution**: Dual-format package with proper exports

## Key Decisions

### 1. ESM-First Approach
We use `"type": "module"` in package.json, which means:
- All `.js` files are treated as ES modules by default
- CommonJS files must use `.cjs` extension
- Scripts and tools use ESM imports

### 2. Parser Generation
The Peggy parser is special because:
- Build scripts need direct access to the generated parser
- The parser is generated in BOTH formats during build:
  - `grammar/parser/parser.js` - ES module version
  - `grammar/parser/parser.ts` - TypeScript version with type definitions
- Both versions are generated by `grammar/build-grammar.mjs`

### 3. Module Resolution

#### TypeScript Code
```typescript
import { parse } from '@grammar/parser';  // Resolves to grammar/parser/index.ts
```

#### Build Scripts
```javascript
import { parse } from '../grammar/parser/parser.js';  // Direct import of generated parser
```

## File Structure

```
grammar/
├── build-grammar.mjs       # ESM script that generates the parser
├── tsconfig.grammar.json   # Grammar-specific TS config
├── parser/
│   ├── index.ts           # TypeScript entry point (re-exports parser)
│   ├── parser.js          # Generated ES module parser
│   ├── parser.ts          # Generated TypeScript parser
│   └── deps/              # Parser dependencies (dual format)
└── deps/                  # Source dependencies for parser
```

## Build Process

1. **Grammar Build** (`npm run build:grammar`):
   - Runs `build-grammar.mjs` (ES module)
   - Generates both `parser.js` and `parser.ts`
   - Copies dependencies in both formats

2. **TypeScript Build** (tsup):
   - Compiles TypeScript to JavaScript
   - Creates dual outputs:
     - `dist/index.mjs` - ES module
     - `dist/index.cjs` - CommonJS
   - Bundles internal dependencies

3. **CLI Build**:
   - Builds to CommonJS only (`dist/cli.cjs`)
   - Uses wrapper script (`bin/mlld-wrapper.cjs`)

## Module Consumption

### For Package Consumers
```json
{
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    }
  }
}
```

### For Internal Development
- TypeScript imports use path aliases (`@grammar/*`, `@core/*`, etc.)
- Build scripts use relative imports to generated files
- Tests run in Node with ESM support via Vite

## Common Issues and Solutions

### Issue: "Cannot use import statement outside a module"
**Cause**: File has `.js` extension but contains CommonJS code  
**Solution**: Rename to `.cjs` or convert to ESM

### Issue: Parser not found during development
**Cause**: Parser hasn't been generated yet  
**Solution**: Run `npm run build:grammar` first

### Issue: Dynamic import in CommonJS
**Cause**: Trying to use `import()` in a `.cjs` file  
**Solution**: Use `require()` or convert to ESM

## Best Practices

1. **Use ESM for new code** - All new files should use ES module syntax
2. **Explicit extensions** - Always include file extensions in imports
3. **Path aliases** - Use TypeScript path aliases for cleaner imports
4. **Build order** - Grammar must be built before TypeScript compilation

## Script Requirements

Scripts that need the parser directly:
- `scripts/ast-output.js` - AST visualization tool
- `scripts/build-fixtures.mjs` - Test fixture generation

These import the generated parser directly and require it to exist.

## Migration Notes

The project was migrated from CommonJS to ESM. Key changes:
- Changed `"type": "commonjs"` to `"type": "module"`
- Renamed CLI wrapper from `.js` to `.cjs`
- Updated build scripts to use ESM imports
- Removed unnecessary CommonJS compatibility layers