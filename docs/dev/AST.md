# Meld Abstract Syntax Tree (AST) Documentation

This document describes the structure of the Abstract Syntax Tree (AST) generated by the Meld parser (`core/ast/grammar/meld.pegjs`). The parser processes Meld source text and outputs an array of AST nodes.

## Base Node Structure

All nodes generated by the parser share a common base structure:

```typescript
interface BaseNode {
  type: string; // The type of the node (e.g., 'Text', 'Comment', 'Directive')
  location: {
    start: { line: number; column: number };
    end: { line: number; column: number };
  };
  // ... other properties specific to the node type
}
```

## Core Node Types

These represent fundamental elements within a Meld document.

### Text

Represents plain text content between directives or other Meld constructs.

```typescript
interface TextNode extends BaseNode {
  type: 'Text';
  content: string; // The raw text content
}
```
*Grammar Rule:* `TextBlock`

### Comment

Represents a Meld comment (`>> ...`).

```typescript
interface CommentNode extends BaseNode {
  type: 'Comment';
  content: string; // The comment text (excluding '>>' and leading/trailing whitespace)
}
```
*Grammar Rules:* `LineStartComment`, `Comment`

### CodeFence

Represents a fenced code block (e.g., ```python ... ```).

```typescript
interface CodeFenceNode extends BaseNode {
  type: 'CodeFence';
  language?: string; // Optional language identifier (e.g., 'python')
  content: string;   // The raw content of the code block, including fences and language tag
}
```
*Grammar Rule:* `CodeFence`

### VariableReference

Represents a reference to a Meld variable. This is a unified node type resulting from the `PLAN-1.md` refactor, replacing the older `TextVar`, `DataVar`, `PathVar` specific nodes.

```typescript
interface VariableReferenceNode extends BaseNode {
  type: 'VariableReference';
  identifier: string;       // Base name of the variable (e.g., 'myVar', 'HOMEPATH')
  valueType: 'text' | 'data' | 'path'; // Indicates the type of variable being referenced
  isVariableReference: true; // Static flag for easy identification
  
  // Specific to valueType = 'data'
  fields?: Array<{ type: 'field', value: string } | { type: 'index', value: number | string }>; 
  
  // Specific to valueType = 'path'
  isSpecial?: boolean;      // True for special paths like $HOMEPATH, $PROJECTPATH, $, ~
  
  // Optional
  format?: string;          // Formatting hint (e.g., 'json' from {{var >> json}})
}
```
*Grammar Rules:* `TextVar`, `DataVar`, `PathVar` (via `createVariableReferenceNode` helper)
*Note:* The `valueType` field is crucial for downstream processing to understand how to resolve the variable.

## Directive Nodes

Directives are the core functional elements in Meld (`@directive [...]`). They share a common structure:

```typescript
interface BaseDirectiveNode extends BaseNode {
  type: 'Directive';
  directive: {
    kind: string; // The directive name (e.g., 'run', 'embed', 'import')
    // ... other properties specific to the directive kind and subtype
  };
}
```

The specific properties within the `directive` object depend on the `kind` and often a `subtype` field, which was introduced/standardized in the `PLAN-1.md` and `PLAN-RHS.md` refactors for improved clarity.

### `@import` Directive

Imports variables or content from other Meld files or sources.

**Node Structure:**

```typescript
interface ImportDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'import';
    subtype: 'importAll' | 'importStandard' | 'importNamed'; // Determined by syntax
    path: PathValueObject; // Object describing the path to import from (see PathValueObject below)
    imports: Array<{ name: string; alias: string | null }>; // List of named imports or [{ name: '*', alias: null }] for importAll
  };
}

interface PathValueObject {
  raw: string; // The original path string
  structured: {
    base: string; // Base path component (e.g., '.', '$HOMEPATH', '$PROJECTPATH')
    segments: string[]; // Path segments relative to the base
    variables?: { // Variables detected within the path
      text?: string[];    // e.g., {{var}}
      special?: string[]; // e.g., $HOMEPATH
      path?: string[];    // e.g., $pathVar
    };
    cwd?: boolean; // True if the path is relative to the current working directory (no slashes, not starting with $)
    url?: boolean; // True if the path is a URL (starts with http/https)
  };
  normalized?: string; // A normalized representation of the path
  isPathVariable?: boolean; // True if the path itself is a path variable (e.g., $myPath)
  variable_warning?: boolean; // True if text variables were found (often requires resolution)
}
```

*Grammar Rule:* `ImportDirective`
*Subtypes:*
    *   `importAll`: `*` or `[{name: '*', alias: null}]` was used (e.g., `@import [path]`, `@import [*] from [path]`).
    *   `importStandard`: Imports without aliases (e.g., `@import [var1, var2] from [path]`).
    *   `importNamed`: At least one import uses an alias (e.g., `@import [var1 as v1] from [path]`).

### `@embed` Directive

Embeds content from files, variables, or inline templates.

**Node Structure:**

```typescript
interface EmbedDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'embed';
    subtype: 'embedPath' | 'embedVariable' | 'embedTemplate'; // Determined by syntax
    
    // subtype = 'embedPath' specific fields
    path?: PathValueObject; // Path to the file to embed from
    section?: string;       // Optional section identifier (e.g., #sectionName)
    names?: string[];       // Optional list of specific names to embed (from syntax @embed {n1,n2} from [...])

    // subtype = 'embedTemplate' specific fields
    content?: string;          // The raw inline template content (from [[...]])
    isTemplateContent?: true;  // Flag indicating inline template content

    // subtype = 'embedVariable' specific fields
    // 'path' field is used, but its structure differs slightly:
    // path?: PathValueObject (for $pathVar) OR 
    //        { raw: string, isVariableReference: true, variable: VariableReferenceNode, structured: { variables: {...} } } (for {{textVar}} or {{dataVar}})

    // Optional fields applicable to multiple subtypes
    options?: { [key: string]: string }; // Key-value options (e.g., key="value")
    headerLevel?: number;               // Header level adjustment (e.g., as ##)
    underHeader?: string;               // Target header for embedding (e.g., under "Header")
  };
}
```

*Grammar Rule:* `EmbedDirective` (uses `_EmbedRHS` helper)
*Subtypes:*
    *   `embedPath`: Embeds content from a file path (e.g., `@embed [./file.md]`, `@embed [./file.md#section]`, `@embed {$projectpath}/file.md`)
    *   `embedVariable`: Embeds the resolved value of a variable (e.g., `@embed {{textVar}}`, `@embed {{data.field}}`, `@embed $pathVar`). Note the different structure within the `path` field depending on variable type.
    *   `embedTemplate`: Embeds content directly from a multi-line template block (e.g., `@embed [[Inline content {{variable}}]]`).

### `@run` Directive

Executes a shell command, a multi-line script, or a defined command reference.

**Node Structure:**

```typescript
interface RunDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'run';
    subtype: 'runCommand' | 'runCode' | 'runCodeParams' | 'runDefined'; // Determined by syntax
    
    // subtype = 'runCommand' specific fields
    command?: string; // The command string (e.g., "ls -la", "{{variable}}")

    // subtype = 'runCode' | 'runCodeParams' specific fields
    command?: string;          // The multi-line script content (from [[...]])
    language?: string;         // Optional language identifier (e.g., python)
    isMultiLine?: true;        // Flag indicating multi-line content
    parameters?: Array<VariableReferenceNode | string>; // Parameters for runCodeParams (from lang (...) [[...]])

    // subtype = 'runDefined' specific fields
    command?: { // Object representing the command reference
      raw: string; // Raw text (e.g., "$cmd(1, 'arg')")
      name: string; // Name of the command definition
      args: Array<{ type: 'string' | 'variable' | 'raw', value: any }>; // Parsed arguments
    };

    // Optional fields
    underHeader?: string; // Target header for output insertion
  };
}
```

*Grammar Rule:* `RunDirective` (uses `_RunRHS` helper)
*Subtypes:*
    *   `runCommand`: Executes a simple command string in brackets or a direct variable reference (e.g., `@run [ls -la]`, `@run {{commandVar}}`).
    *   `runCode`: Executes a multi-line script block (e.g., `@run [[echo "hello"]]`, `@run python [[print('hi')]]`).
    *   `runCodeParams`: Executes a multi-line script block with parameters (e.g., `@run python (p1, {{p2}}) [[...]]`).
    *   `runDefined`: Executes a previously defined command reference (e.g., `@run $myCommand`, `@run $cmd(arg1)`).

### `@define` Directive

Defines a reusable command reference.

**Node Structure:**

```typescript
interface DefineDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'define';
    name: string;        // Name of the command being defined
    field?: string;      // Optional field like 'risk.high', 'about'
    parameters?: string[]; // Optional list of parameter names
    
    // EITHER value OR command will be present
    value?: string;      // String literal value (less common now)
    command?: {         // Details if defined using @run
      kind: 'run';
      command: string;
    };
  };
}
```

*Grammar Rule:* `DefineDirective`

### `@data` Directive

Assigns a value (literal, embedded file content, command output) to a data variable.

**Node Structure:**

```typescript
interface DataDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'data';
    identifier: string;  // Name of the variable being assigned
    schema?: string;     // Optional schema identifier for validation

    source: 'literal' | 'embed' | 'run'; // Where the value comes from
    
    // Based on source:
    value?: any;          // source = 'literal' (parsed JSON-like object/array/primitive)
    embed?: EmbedRHSAst;  // source = 'embed' (Result from _EmbedRHS rule)
    run?: RunRHSAst;      // source = 'run' (Result from _RunRHS rule)
  };
}

// Represents the structure returned by _EmbedRHS when used in DataValue/TextValue
type EmbedRHSAst = {
    subtype: 'embedPath' | 'embedVariable' | 'embedTemplate';
    // ... fields corresponding to the subtype, same as in EmbedDirectiveNode
    // (e.g., path, section, content, options)
};

// Represents the structure returned by _RunRHS when used in DataValue/TextValue
type RunRHSAst = {
    subtype: 'runCommand' | 'runCode' | 'runCodeParams' | 'runDefined';
    // ... fields corresponding to the subtype, same as in RunDirectiveNode
    // (e.g., command object/string, language, parameters, isMultiLine)
};
```

*Grammar Rule:* `DataDirective`, `DataValue` (uses `_EmbedRHS`, `_RunRHS` helpers)
*Note:* The structure under `embed` or `run` directly mirrors the relevant parts of the standalone `@embed`/`@run` directive ASTs, including the `subtype`, thanks to the `PLAN-RHS.md` refactor.

### `@text` Directive

Assigns a value (literal string, embedded file content, command output) to a text variable.

**Node Structure:**

```typescript
interface TextDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'text';
    identifier: string; // Name of the variable being assigned

    source: 'literal' | 'embed' | 'run'; // Where the value comes from

    // Based on source:
    value?: string;       // source = 'literal' (string or multiline template literal)
    embed?: EmbedRHSAst;  // source = 'embed' (Result from _EmbedRHS rule)
    run?: RunRHSAst;      // source = 'run' (Result from _RunRHS rule)
  };
}
```

*Grammar Rule:* `TextDirective`, `TextValue` (uses `_EmbedRHS`, `_RunRHS` helpers)
*Note:* Similar to `@data`, the structure under `embed` or `run` mirrors the standalone directive ASTs, including the `subtype`.

### `@path` Directive

Assigns a path value to a path variable.

**Node Structure:**

```typescript
interface PathDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'path';
    identifier: string;     // Name of the variable being assigned
    path: PathValueObject; // Object describing the path value
  };
}
```

*Grammar Rule:* `PathDirective`, `PathValue`

### `@var` Directive

Assigns a literal primitive or collection value (string, number, boolean, null, object, array) to a generic variable (often treated as data).

**Node Structure:**

```typescript
interface VarDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'var';
    identifier: string; // Name of the variable being assigned
    value: {
      type: 'string' | 'number' | 'boolean' | 'null' | 'array' | 'object';
      value: any; // The parsed literal value
    };
  };
}
```

*Grammar Rule:* `VarDirective`, `VarValue` 