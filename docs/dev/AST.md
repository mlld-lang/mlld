** NEEDS REVIEW / UPDATE FOLLOWING AST REFACTOR **

# Meld Abstract Syntax Tree (AST) Documentation

This document describes the structure of the Abstract Syntax Tree (AST) generated by the Meld parser (`grammar/meld.peggy`). The parser processes Meld source text and outputs an array of AST nodes.

## Important

If you are EVER making changes to the AST, there is a specific and methodical approach that must be followed:

1. update our tests and fixtures FIRST!
2. make isolated changes -- ONE at a time! 
3. Build and run the grammar CONSTANTLY -- EVERY! SINGLE! TIME! we make a change: `npm run build:grammar && npm test core/ast` 

## Organization 

```
grammar
├── build-grammar.mjs
├── deps
│   ├── directive-kind.js
│   ├── helpers.js
│   └── node-type.js
├── directives
│   ├── data.peggy
│   ├── define.peggy
│   ├── directive-syntax.peggy
│   ├── embed.peggy
│   ├── import.peggy
│   ├── path.peggy
│   ├── run.peggy
│   ├── text.peggy
│   └── variables.peggy
├── docs
│   ├── ADVICE.md
│   ├── DEBUG.md
│   ├── PATHS.md
│   ├── peggy.html
│   └── WARNINGS.md
├── lexer
│   ├── interpolation.peggy
│   ├── literals.peggy
│   ├── tokens.peggy
│   └── whitespace.peggy
└── meld.peggy
```
## Base Node Structure

All nodes generated by the parser share a common base structure:

```typescript
// NodeId is defined in core/syntax/types/interfaces/common.ts
// export type NodeId = string;

interface BaseNode {
  type: string; // The type of the node (e.g., 'Text', 'Comment', 'Directive')
  location: {
    start: { line: number; column: number };
    end: { line: number; column: number };
  };
  readonly nodeId: NodeId; // A unique identifier for this specific node instance.
  // ... other properties specific to the node type
}
```

The `nodeId` is a unique string automatically assigned to every node during parsing. It provides a stable way to reference specific nodes throughout processing and transformation, independent of their position or content.

## Core Node Types

These represent fundamental elements within a Meld document.

### Text

Represents plain text content between directives or other Meld constructs.

```typescript
interface TextNode extends BaseNode {
  type: 'Text';
  content: string; // The raw text content
}
```
*Grammar Rule:* `TextBlock`

### Comment

Represents a Meld comment (`>> ...`).

```typescript
interface CommentNode extends BaseNode {
  type: 'Comment';
  content: string; // The comment text (excluding '>>' and leading/trailing whitespace)
}
```
*Grammar Rules:* `LineStartComment`, `Comment`

### CodeFence

Represents a fenced code block (e.g., ```python ... ```).

```typescript
interface CodeFenceNode extends BaseNode {
  type: 'CodeFence';
  language?: string; // Optional language identifier (e.g., 'python')
  content: string;   // The raw content of the code block, including fences and language tag
}
```
*Grammar Rule:* `CodeFence`

### VariableReference

Represents a reference to a Meld variable. This is a unified node type resulting from the `PLAN-1.md` refactor, replacing the older `TextVar`, `DataVar`, `PathVar` specific nodes.

```typescript
interface VariableReferenceNode extends BaseNode {
  type: 'VariableReference';
  identifier: string;       // Base name of the variable (e.g., 'myVar', 'HOMEPATH')
  valueType: 'text' | 'data' | 'path'; // Indicates the type of variable being referenced
  isVariableReference: true; // Static flag for easy identification
  
  // Specific to valueType = 'data'
  fields?: Array<{ type: 'field', value: string } | { type: 'index', value: number | string }>; 
  
  // Specific to valueType = 'path'
  isSpecial?: boolean;      // True for special paths like $HOMEPATH, $PROJECTPATH, $, ~
  
  // Optional
  format?: string;          // Formatting hint (e.g., 'json' from {{var >> json}})
}
```
*Grammar Rules:*
- `TextVar`: Handles `{{var}}` syntax for text variables
- `DataVar`: Handles `{{var}}` syntax for data variables with field access
- `PathVar`: Handles `$var` syntax for path variables
- `BracketInterpolatableContent`: Handles mixed content in brackets including variables and separators
- `SectionMarkerToken`: Handles section markers in paths

*Note:* The `valueType` field is crucial for downstream processing to understand how to resolve the variable. Path variables use a simpler `$var` syntax while text and data variables use the `{{var}}` syntax.

### Path Value Object

Represents a path value with validation flags and components. Used in directives that accept paths (e.g., `@embed`, `@import`).

```typescript
interface PathValueObject {
  raw: string;              // The raw path string as it appeared in the source
  values: Array<            // Array of components that make up the path
    | TextNode              // Plain text segments
    | VariableReferenceNode // Variables (text or path)
    | PathSeparatorNode     // Forward slashes
    | DotSeparatorNode      // Dots
    | SectionMarkerNode     // Section markers (#)
  >;
  
  // Validation Flags
  isAbsolute: boolean;      // True if path starts with /
  isRelativeToCwd: boolean; // True if path should be resolved relative to cwd
  hasVariables: boolean;    // True if path contains any variables
  hasPathVariables: boolean; // True if path contains $var references
  hasTextVariables: boolean; // True if path contains {{var}} references
  variable_warning: boolean; // True if text variables were found (may need resolution)
}

interface PathSeparatorNode extends BaseNode {
  type: 'PathSeparator';
  value: '/';
}

interface DotSeparatorNode extends BaseNode {
  type: 'DotSeparator';
  value: '.';
}

interface SectionMarkerNode extends BaseNode {
  type: 'SectionMarker';
  value: '#';
}
```
*Grammar Rules:* `TextVar`, `DataVar`, `PathVar` (via `createVariableReferenceNode` helper)
*Note:* The `valueType` field is crucial for downstream processing to understand how to resolve the variable.

## Interpolatable Value Type

Many directive values (strings, paths, commands, templates) can now contain embedded `{{...}}` or `$var` references that are parsed directly into the AST structure. These are represented by the `InterpolatableValue` type:

```typescript
// Represents content that can contain embedded variable references
type InterpolatableValue = Array<TextNode | VariableReferenceNode>;
```

When a field below is typed as `InterpolatableValue`, it means the parser returns this array structure, allowing downstream services to process the mix of literal text and variable references without re-parsing.

## Directive Nodes

Directives are the core functional elements in Meld (`@directive [...]`). They share a common structure:

```typescript
interface BaseDirectiveNode extends BaseNode {
  type: 'Directive';
  directive: {
    kind: string; // The directive name (e.g., 'run', 'embed', 'import')
    // ... other properties specific to the directive kind and subtype
  };
}
```

The specific properties within the `directive` object depend on the `kind` and often a `subtype` field, which was introduced/standardized in the `PLAN-1.md` and `PLAN-RHS.md` refactors for improved clarity.

### `@import` Directive

Imports variables or content from other Meld files or sources.

**Node Structure:**

```typescript
interface ImportDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'import';
    subtype: 'importAll' | 'importStandard' | 'importNamed'; // Determined by syntax
    path: PathValueObject; // Object describing the path to import from (see PathValueObject below)
    imports: Array<{ name: string; alias: string | null }>; // List of named imports or [{ name: '*', alias: null }] for importAll
  };
}

interface PathValueObject {
  raw: string; // The original path string
  structured: {
    base: string; // Base path component (e.g., '.', '$HOMEPATH', '$PROJECTPATH')
    segments: string[]; // Path segments relative to the base
    variables?: { // Variables detected within the path
      text?: string[];    // e.g., {{var}}
      special?: string[]; // e.g., $HOMEPATH
      path?: string[];    // e.g., $pathVar
    };
    cwd?: boolean; // True if the path is relative to the current working directory (no slashes, not starting with $)
    url?: boolean; // True if the path is a URL (starts with http/https)
  };
  normalized?: string; // A normalized representation of the path
  isPathVariable?: boolean; // True if the path itself is a path variable (e.g., $myPath)
  variable_warning?: boolean; // True if text variables were found (often requires resolution)
  interpolatedValue?: InterpolatableValue; // <<< ADDED: Parsed nodes if path came from brackets/quotes
}
```

*Grammar Rule:* `ImportDirective`
*Subtypes:*
    *   `importAll`: `*` or `[{name: '*', alias: null}]` was used (e.g., `@import [path]`, `@import [*] from [path]`).
    *   `importStandard`: Imports without aliases (e.g., `@import [var1, var2] from [path]`).
    *   `importNamed`: At least one import uses an alias (e.g., `@import [var1 as v1] from [path]`).

### `@embed` Directive

Embeds content from files, variables, or inline templates.

**Node Structure:**

```typescript
interface EmbedDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'embed';
    subtype: 'embedPath' | 'embedVariable' | 'embedTemplate'; // Determined by syntax
    
    // subtype = 'embedPath' specific fields
    path?: PathValueObject;        // Object describing the path and its components
    section?: string;              // Section identifier (e.g., #section)
    options?: Record<string,any>;  // Key-value options (e.g., lang="javascript")
    headerLevel?: number;          // Header level adjustment (e.g., as ##)
    underHeader?: string;          // Target header for embedding (e.g., under "Header")

    // subtype = 'embedTemplate' specific fields
    content?: InterpolatableValue; // Represents parsed [[...]] content

    // subtype = 'embedVariable' specific fields
    // 'path' field is used, but structure varies:
    // path?: PathValueObject (for $pathVar) OR 
    //        { raw: string, isVariableReference: true, variable: VariableReferenceNode, structured: { variables: {...} } } (for {{textVar}} or {{dataVar}})

    // Optional fields applicable to multiple subtypes
    options?: { [key: string]: string }; // Key-value options (e.g., key="value")
    headerLevel?: number;               // Header level adjustment (e.g., as ##)
    underHeader?: string;               // Target header for embedding (e.g., under "Header")
  };
}
```

*Grammar Rule:* `EmbedDirective` (uses `_EmbedRHS` helper)
*Subtypes:*
    *   `embedPath`: Embeds content from a file path. Supports:
        - Regular paths: `@embed [./file.md]`
        - Sections: `@embed [./file.md#section]`
        - Path variables: `@embed [$var/file.md]`
        - Text variables: `@embed [path/{{var}}.md]`
        - Combined: `@embed [$base/{{name}}.md#section]`
        Note: When text variables are used in paths, `hasTextVariables` and `variable_warning` flags are set to true.
    *   `embedVariable`: Embeds the resolved value of a variable (e.g., `@embed {{textVar}}`, `@embed {{data.field}}`, `@embed $pathVar`). Note the different structure within the `path` field depending on variable type.
    *   `embedTemplate`: Embeds content directly from a multi-line template block (e.g., `@embed [[Inline content {{variable}}]]`).

### `@run` Directive

Executes a shell command, a multi-line script, or a defined command reference.

**Node Structure:**

```typescript
interface RunDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'run';
    subtype: 'runCommand' | 'runCode' | 'runCodeParams' | 'runDefined'; // Determined by syntax
    
    // subtype = 'runCommand' specific fields
    command?: InterpolatableValue; // <<< CHANGED: Represents parsed [...] content

    // subtype = 'runCode' | 'runCodeParams' specific fields
    command?: InterpolatableValue; // <<< CHANGED: Represents parsed [[...]] script content
    language?: string;         // Optional language identifier (e.g., python)
    isMultiLine?: true;        // Flag indicating multi-line content
    parameters?: Array<VariableReferenceNode | string>; // Parameters for runCodeParams (from lang (...) [[...]])

    // subtype = 'runDefined' specific fields
    command?: { // Object representing the command reference
      raw: string; // Raw text (e.g., "$cmd(1, 'arg')")
      name: string; // Name of the command definition
      // Arguments are parsed but strings remain literal strings, NOT InterpolatableValue
      args: Array<{ type: 'string' | 'variable' | 'raw', value: string | VariableReferenceNode | any }>; // <<< CLARIFIED type
    };

    // Optional fields
    underHeader?: string; // Target header for output insertion
  };
}
```

*Grammar Rule:* `RunDirective` (uses `_RunRHS` helper)
*Subtypes:*
    *   `runCommand`: Executes a simple command string in brackets or a direct variable reference (e.g., `@run [ls -la]`, `@run {{commandVar}}`).
    *   `runCode`: Executes a multi-line script block (e.g., `@run [[echo "hello"]]`, `@run python [[print('hi')]]`).
    *   `runCodeParams`: Executes a multi-line script block with parameters (e.g., `@run python (p1, {{p2}}) [[...]]`).
    *   `runDefined`: Executes a previously defined command reference (e.g., `@run $myCommand`, `@run $cmd(arg1)`).

### `@define` Directive

Defines a reusable command reference.

**Node Structure:**

```typescript
interface DefineDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'define';
    name: string;        // Name of the command being defined
    field?: string;      // Optional field like 'risk.high', 'about'
    parameters?: string[]; // Optional list of parameter names
    
    // EITHER value OR command will be present
    value?: InterpolatableValue; // <<< CHANGED: String literal definitions are interpolatable
    command?: {         // Details if defined using @run (structure from RunRHSAst)
      kind: 'run';
      command: InterpolatableValue; // <<< UPDATED based on RunRHSAst changes
      // ... other fields from RunRHSAst subtype ...
    };
  };
}
```

*Grammar Rule:* `DefineDirective`

### `@data` Directive

Assigns a value (literal, embedded file content, command output) to a data variable.

**Node Structure:**

```typescript
interface DataDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'data';
    identifier: string;  // Name of the variable being assigned
    schema?: string;     // Optional schema identifier for validation

    source: 'literal' | 'embed' | 'run'; // Where the value comes from
    
    // Based on source:
    value?: InterpolatableValue | any; // <<< CHANGED: Literal strings/objects/arrays etc. String literals are interpolatable.
    embed?: EmbedRHSAst;  // source = 'embed' (Result from _EmbedRHS rule - see definition below)
    run?: RunRHSAst;      // source = 'run' (Result from _RunRHS rule - see definition below)
  };
}

// Represents the structure returned by _EmbedRHS when used in DataValue/TextValue
type EmbedRHSAst = {
    subtype: 'embedPath' | 'embedVariable' | 'embedTemplate';
    // subtype = 'embedTemplate' fields:
    content?: InterpolatableValue; // <<< UPDATED
    // ... other fields corresponding to the subtype, same as in EmbedDirectiveNode
    // (e.g., path, section, options)
};

// Represents the structure returned by _RunRHS when used in DataValue/TextValue
type RunRHSAst = {
    subtype: 'runCommand' | 'runCode' | 'runCodeParams' | 'runDefined';
    // subtype = 'runCommand' | 'runCode' | 'runCodeParams' fields:
    command?: InterpolatableValue; // <<< UPDATED
    // ... other fields corresponding to the subtype, same as in RunDirectiveNode
    // (e.g., language, parameters, isMultiLine for runCode*, or command object for runDefined)
};
```

*Grammar Rule:* `DataDirective`, `DataValue` (uses `_EmbedRHS`, `_RunRHS` helpers)
*Note:* The structure under `embed` or `run` directly mirrors the relevant parts of the standalone `@embed`/`@run` directive ASTs, including the `subtype`, thanks to the `PLAN-RHS.md` refactor.

### `@text` Directive

Assigns a value (literal string, embedded file content, command output) to a text variable.

**Node Structure:**

```typescript
interface TextDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'text';
    identifier: string; // Name of the variable being assigned

    source: 'literal' | 'embed' | 'run'; // Where the value comes from

    // Based on source:
    value?: InterpolatableValue; // <<< CHANGED: Literal strings/templates are interpolatable
    embed?: EmbedRHSAst;  // source = 'embed' (Result from _EmbedRHS rule - see @data definition)
    run?: RunRHSAst;      // source = 'run' (Result from _RunRHS rule - see @data definition)
  };
}
```

*Grammar Rule:* `TextDirective`, `TextValue` (uses `_EmbedRHS`, `_RunRHS` helpers)
*Note:* Similar to `@data`, the structure under `embed` or `run` mirrors the standalone directive ASTs, including the `subtype`.

### `@path` Directive

Assigns a path value to a path variable.

**Node Structure:**

```typescript
interface PathDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'path';
    identifier: string;     // Name of the variable being assigned
    path: PathValueObject; // Object describing the path value
  };
}
```

*Grammar Rule:* `PathDirective`, `PathValue`

### `@var` Directive

Assigns a literal primitive or collection value (string, number, boolean, null, object, array) to a generic variable (often treated as data).

**Node Structure:**

```typescript
interface VarDirectiveNode extends BaseDirectiveNode {
  directive: {
    kind: 'var';
    identifier: string; // Name of the variable being assigned
    value: {
      type: 'string' | 'number' | 'boolean' | 'null' | 'array' | 'object';
      // String literals assigned via @var are NOT interpolatable by the parser
      value: any; // The parsed literal value (string remains string)
    };
  };
}
```

*Grammar Rule:* `VarDirective`, `VarValue` 