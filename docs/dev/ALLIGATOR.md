# Alligator Syntax and Load-Content Output Behavior

## Overview

The alligator syntax (`<file>` or `<pattern>`) in mlld provides powerful content loading capabilities with nuanced output behavior. This document explains how content is loaded, transformed, and output in different contexts.

## Basic Syntax

```mlld
>> Single file
/var @content = <file.md>

>> Glob pattern
/var @files = <*.md>

>> Section extraction
/var @intro = <README.md # introduction>

>> With rename pattern
/var @modules = <*.mld.md # tldr> as "### [@mlld/<>.fm.name](<>.relative)"
```

## Output Behavior

### Direct Display (`/show`)

When using `/show` with alligator-loaded content, arrays are automatically concatenated:

```mlld
/var @files = <*.md>
/show @files

>> Output: All file contents concatenated with double newlines
```

### Template Interpolation

Content loaded via alligator syntax maintains special behavior in templates:

```mlld
/var @sections = <*.md # intro> as "## <>.fm.title"
/var @readme = `
# Documentation

@sections

End of document.
`

>> @sections is concatenated, not JSON-serialized
```

## Type System Integration

### LoadContentResult

Single file loads create a `LoadContentResult` object:
- Has a `.content` property containing the file content
- Includes metadata: `filename`, `relative`, `absolute`, `fm` (frontmatter)
- Auto-converts to string using the content

### LoadContentResultArray

Glob patterns create a `LoadContentResultArray`:
- Custom `.content` getter that concatenates all file contents
- Custom `toString()` method for proper string conversion
- Each element is a `LoadContentResult`

### RenamedContentArray

When using the `as "pattern"` syntax:
- Creates a `RenamedContentArray` with formatted content
- Custom `.content` getter applies the rename pattern
- Maintains proper concatenation behavior in templates

## Variable Type Preservation

The mlld type system preserves special behaviors through Variable metadata:

```typescript
// Variables store metadata about array types
{
  type: 'array',
  metadata: {
    arrayType: 'load-content-result' | 'renamed-content'
  }
}
```

This metadata enables the interpreter to:
1. Preserve custom toString() and content getters
2. Apply correct behavior during template interpolation
3. Maintain type information through variable resolution

## Resolution Contexts

Content behavior varies by resolution context:

### Display Context
- Arrays concatenate with double newlines
- Custom content getters are used
- No JSON serialization

### Template Interpolation
- Arrays with custom behaviors use their content getters
- Regular arrays default to JSON representation
- Special handling for LoadContentResultArray and RenamedContentArray

### Pipeline Input
- Content is extracted as raw strings
- Arrays are joined before pipeline processing
- Metadata is not passed through pipelines

## Implementation Details

### Behavior Preservation

The interpreter preserves array behaviors through:

1. **Variable Creation** (`/interpreter/eval/var.ts`):
   - Re-applies behaviors after Variable creation
   - Uses `extractVariableValue` from variable-migration

2. **Variable Resolution** (`/interpreter/utils/variable-resolution.ts`):
   - Checks for special array types via metadata
   - Preserves behaviors during value extraction

3. **Template Interpolation** (`/interpreter/core/interpreter.ts`):
   - Type guards check for LoadContentResultArray/RenamedContentArray
   - Uses content getters instead of JSON serialization

### Type Guards

```typescript
// Check for special array types
function isLoadContentResultArray(value: any): value is LoadContentResultArray {
  return Array.isArray(value) && 
         value.__variable?.metadata?.arrayType === 'load-content-result';
}

function isRenamedContentArray(value: any): value is RenamedContentArray {
  return Array.isArray(value) && 
         value.__variable?.metadata?.arrayType === 'renamed-content';
}
```

## Common Patterns

### Building Documentation

```mlld
>> Load all module docs with formatting
/var @modules = <modules/*.md # description> as "### <>.fm.name\n<>.content"

>> Create README
/var @readme = `
# Project Modules

@modules

Generated by mlld
`

/output @readme to "README.md"
```

### Collecting Sections

```mlld
>> Extract all "Usage" sections
/var @usage = <docs/*.md # usage>

>> Display concatenated
/show @usage

>> Or use in template
/show `
# Usage Guide

@usage
`
```

### File Metadata Access

```mlld
/var @file = <config.json>

>> Access metadata
/show `File: @file.filename`
/show `Path: @file.relative`
/show `Content: @file.content`

>> With frontmatter
/show `Title: @file.fm.title`
/show `Author: @file.fm.author`
```

## Gotchas and Edge Cases

1. **Array Type Loss**: If behaviors are lost during processing, arrays may serialize as JSON
2. **Content Getter**: The `.content` property might not be enumerable but still accessible
3. **Template Context**: Only template interpolation and display preserve concatenation behavior
4. **Pipeline Processing**: Pipelines receive raw content, not Variables or metadata

## Debugging

Enable debug output to trace array behavior:

```bash
MLLD_DEBUG=true mlld script.mld
```

This shows:
- Array type detection in interpolation
- Variable metadata preservation
- Content getter availability