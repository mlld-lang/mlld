<MLLD_COMMANDS>

<RUN_COMMAND>
Execute shell commands or code. Language specifier determines execution context.

**Decision tree:**
- Single line + pipes only → `cmd { ... }` (safe, recommended)
- Needs `&&`, `||`, control flow → `sh { ... }` (full shell)
- JavaScript code → `js { ... }` (in-process) or `node { ... }` (VM-isolated)
- Python code → `py { ... }` or `python { ... }` (subprocess)

```mlld
>> cmd (pipes only, safe)
run cmd {echo Hello | tr '[:lower:]' '[:upper:]'}
var @date = cmd {date}

>> sh (full shell scripts)
run sh {
  npm test && npm run build || echo "Build failed"
}

>> JavaScript (in-process, fast)
run js {console.log("hello")}
var @result = js {return 42}

>> Node.js (VM-isolated, full API)
var @hash = node {
  const crypto = require('crypto');
  return crypto.createHash('md5').update('hello').digest('hex');
}

>> Python (subprocess)
run py {print("hello from python")}
var @sum = py {
result = 2 + 2
print(result)
}
```

**Language comparison:**
| Language | Isolation | Use case |
|----------|-----------|----------|
| `js` | None (in-process) | Fast calculations, simple transforms |
| `node` | VM context | Full Node.js API, require() |
| `py`/`python` | Subprocess | Python libraries, data science |

**Working directory override:**

```mlld
run cmd:/ {pwd}                    >> runs in /
run sh:/tmp {pwd}                  >> runs in /tmp
run js:/tmp {console.log(process.cwd())}
```

**Stdin support:**

```mlld
var @data = '[{"name":"Alice"}]'
run cmd { cat | jq '.[]' } with { stdin: @data }

>> Pipe sugar (equivalent)
run @data | { cat | jq '.[]' }
```

**Parameter syntax by language:**
- `cmd`: interpolate with `@param`
- `sh`: use shell variables as `$param`
- `js`/`node`: parameters as JavaScript variables
- `py`/`python`: parameters as Python variables (strings by default)

```mlld
>> JavaScript - parameters are typed values
exe @process(items) = js { return items.map(x => x * 2) }
var @result = @process([1, 2, 3])  >> [2, 4, 6]

>> Python - parameters arrive as strings
exe @add(a, b) = py { print(int(a) + int(b)) }
var @sum = @add(5, 3)  >> 8

>> Python with complex types (wrapped with metadata)
exe @analyze(data) = py {
import json
parsed = json.loads(data) if isinstance(data, str) else data
print(json.dumps(parsed))
}
```

**Python variable helpers:**
- `mlld.is_variable(x)` - check if value is a wrapped mlld Variable
- Variables have `__mlld_type__` and `__mlld_metadata__` attributes
- Arrays/lists and dicts pass through with metadata preserved
</RUN_COMMAND>

<EXE_EXECUTABLES>
Define reusable commands, code, templates, or multi-statement blocks.

**exe vs var:** `exe` defines functions (takes parameters). `var` creates values (no parameters). Use `exe` when you need to pass arguments; use `var` for computed values.

**Simple forms:**

```mlld
>> Command
exe @list(dir) = cmd {ls -la @dir | head -5}

>> JavaScript (in-process)
exe @add(a, b) = js { return a + b }

>> Node.js (VM-isolated)
exe @hash(text) = node {
  const crypto = require('crypto');
  return crypto.createHash('sha256').update(text).digest('hex');
}

>> Python
exe @add(a, b) = py { print(int(a) + int(b)) }
exe @calculate(x, y) = py {
result = x ** 2 + y ** 2
print(result)
}

>> Template
exe @greet(name) = `Hello @name!`

>> External template file
exe @welcome(name, role) = template "./prompts/welcome.att"

>> Prose (requires config)
exe @analyze(data) = prose:@config { session "Analyze @data" }
```

**Python notes:**
- Use `print()` to return values (captured as string output)
- Parameters arrive as strings; use `int()`, `float()` for math
- Standard library available: `import json`, `import math`, etc.

Executables can include metadata for tooling and type safety.

**Typed parameters:**

```mlld
exe @greet(name: string, times: number) = js { return "Hello " + name; }
exe @process(data: object, format: string) = js { return data; }
exe @count(items: array) = js { return items.length; }
```

Type annotations use `: type` syntax after the parameter name. Supported types: `string`, `number`, `boolean`, `object`, `array`.

**Description metadata:**

```mlld
exe @greet(name: string) = js { return "Hello " + name; } with { description: "Greet a user by name" }
```

The `with { description: "..." }` clause adds a description that appears in MCP tool listings.

**Combined example:**

```mlld
exe @searchIssues(repo: string, query: string, limit: number) = cmd {
  gh issue list -R @repo --search "@query" -L @limit --json number,title
} with { description: "Search GitHub issues by query" }
```

**MCP integration:**

When exported as tools, metadata generates proper JSON schemas:

```mlld
exe @listFiles(dir: string) = cmd { ls @dir } with { description: "List files in directory" }
export { @listFiles }
```

This produces an MCP tool with:
- Input schema with `dir` as required string parameter
- Description in tool listing

**Parameter types vs runtime:**

Type annotations are metadata for tooling. At runtime, parameters arrive as their actual types from the caller. Use type annotations to:
- Generate accurate MCP tool schemas
- Document expected parameter types
- Enable IDE/editor support

**Prose execution** invokes LLM-interpreted DSL skills (OpenProse or custom):

```mlld
import { @opus } from @mlld/prose

>> Inline (interpolates like templates)
exe @summarize(text) = prose:@opus { summarize @text }

>> File reference (.prose files do NOT interpolate)
exe @review(code) = prose:@opus "./review.prose"

>> Template files (.prose.att or .prose.mtt interpolate)
exe @greet(name) = prose:@opus "./greet.prose.att"
```

Interpolation rules:
- `prose:@config { inline }` - interpolates `@var` like templates
- `"file.prose"` - no interpolation, raw content
- `"file.prose.att"` - ATT interpolation (`@var`)
- `"file.prose.mtt"` - MTT interpolation (`{{var}}`)

See `mlld howto prose` for setup, OpenProse syntax, and custom interpreters.

**Block syntax** (multi-statement bodies):

```mlld
exe @process(data) = [
  let @validated = @validate(@data)
  let @transformed = @transform(@validated)
  => @transformed
]

>> With accumulation
exe @countItems(items) = [
  let @count = 0
  for @item in @items [
    let @count += 1
  ]
  => @count
]
```

Block rules:
- Use `[...]` for multi-statement bodies
- `let @var = value` for block-scoped variables
- `let @var += value` for accumulation (arrays/strings/objects)
- `=> value` required as last statement for return

**When-first in exe** (value-returning):

```mlld
exe @classify(score) = when [
  @score >= 90 => "A"
  @score >= 80 => "B"
  @score >= 70 => "C"
  * => "F"
]

>> With blocks for side effects
exe @handler(input) = when [
  @input.valid => [
    show "Processing..."
    let @result = @transform(@input)
    => @result
  ]
  * => { error: "Invalid input" }
]
```

**Shadow environments** expose helpers to all code blocks of that language:

```mlld
>> JavaScript shadow environment
exe @double(n) = js { return n * 2 }
exe @cap(s) = js { return s[0].toUpperCase() + s.slice(1) }
exe js = { double, cap }  >> expose to all js blocks

var @out = js { cap("hello") + ": " + double(5) }  >> "Hello: 10"
```

```mlld
>> Python shadow environment
exe @square(x) = py {
result = int(x) ** 2
print(result)
}
exe @greet(name) = py {
print(f"Hello, {name}!")
}
exe py = { square, greet }  >> expose to all py blocks

run py {
square(4)      >> prints 16
greet("World") >> prints Hello, World!
}
```

**Cross-function calls:** Shadow functions can call each other:

```mlld
exe @add(a, b) = py { print(int(a) + int(b)) }
exe @multiply(x, y) = py { print(int(x) * int(y)) }
exe py = { add, multiply }

exe @calculate(n) = py {
sum_result = add(n, 10)   >> calls shadow function
product = multiply(n, 2)  >> calls shadow function
print(f"Sum: {sum_result}, Product: {product}")
}
exe py = { add, multiply, calculate }  >> update to include calculate
```

**Supported languages:** `js`, `node`, `py`/`python`
</EXE_EXECUTABLES>

<TOOLS_AND_ENVIRONMENTS>
Define tool collections, scope tools, and manage execution environments.

Tool collections define what an agent sees and how tools behave.

```mlld
/exe @readData() = js { return "ok"; }
/exe @deleteData() = js { return "deleted"; }

/var tools @agentTools = {
  safeRead: { mlld: @readData },
  dangerousDelete: {
    mlld: @deleteData,
    labels: ["destructive"],
    description: "Deletes records"
  }
}
```

**Tool definition fields:**
- `mlld` - executable reference
- `labels` - guard/policy labels (`destructive`, `net:w`)
- `bind` - pre-filled parameters
- `expose` - visible parameter subset
- `description` - override tool metadata

**Environment scoping:**

```mlld
/env @agent with { tools: @agentTools } [
  /run cmd { claude -p @task }
]
```

**Import MCP tools:**

```mlld
/import tools { @echo } from mcp "@anthropic/filesystem"
/import tools from mcp "@github/issues" as @github
/show @github.createIssue("title", "body")
```

Reshape tool interfaces using `bind` and `expose` to control what parameters agents see.

**bind - Pre-fill parameters:**

```mlld
exe @createIssue(owner: string, repo: string, title: string, body: string) = cmd {
  gh issue create -R @owner/@repo -t "@title" -b "@body"
}

var tools @agentTools = {
  createIssue: {
    mlld: @createIssue,
    bind: { owner: "mlld", repo: "infra" }
  }
}
```

The agent sees only `title` and `body`. The bound parameters `owner` and `repo` are fixed.

**expose - Limit visible parameters:**

```mlld
var tools @agentTools = {
  createIssue: {
    mlld: @createIssue,
    bind: { owner: "mlld", repo: "infra" },
    expose: ["title", "body"]
  }
}
```

Explicitly list which parameters appear in the tool schema. Parameters not in `expose` are hidden from the agent.

**Default behavior:**

Without `expose`, all parameters except those in `bind` are visible. Adding `expose` overrides this - only listed parameters appear.

**Variable binding:**

Bound values can reference variables:

```mlld
var @org = "mlld"
var @defaultRepo = "main"

var tools @agentTools = {
  createIssue: {
    mlld: @createIssue,
    bind: { owner: @org, repo: @defaultRepo }
  }
}
```

Variables are resolved when the tool collection is defined, not when called.

**Nested objects in bind:**

```mlld
var tools @agentTools = {
  configure: {
    mlld: @configure,
    bind: { config: { timeout: 30, retries: 3 } }
  }
}
```

**Complete example:**

```mlld
exe @searchDocs(index: string, query: string, limit: number, format: string) = cmd {
  search-tool --index @index -q "@query" -n @limit --format @format
}

var tools @agentTools = {
  searchDocs: {
    mlld: @searchDocs,
    bind: { index: "production", format: "json" },
    expose: ["query", "limit"],
    description: "Search documentation"
  }
}
```

The agent sees:
- `query` (string, required)
- `limit` (number, required)

Hidden from agent:
- `index` (always "production")
- `format` (always "json")

The `env` directive creates scoped execution contexts with controlled tool access.

**Basic usage:**

```mlld
var @config = { tools: @agentTools }

env @config [
  run cmd { claude -p @task }
]
```

Commands inside the block see only the tools specified in the config.

**Tool scoping with { tools }:**

```mlld
exe @readData() = js { return "ok"; }
exe @writeData(x) = js { return x; }

var tools @allTools = {
  read: { mlld: @readData },
  write: { mlld: @writeData }
}

env @allTools with { tools: ["read"] } [
  >> Only 'read' tool is available here
  run cmd { claude -p @task }
]
```

The `with { tools: [...] }` clause restricts which tools from the config are visible.

**Tool scope formats:**

```mlld
>> Array of tool names
env @config with { tools: ["read", "write"] } [...]

>> Comma-separated string
env @config with { tools: "read, write" } [...]

>> Wildcard for all tools
env @config with { tools: "*" } [...]

>> Object keys as tool names
var @subset = { read: @readTool, write: @writeTool }
env @config with { tools: @subset } [...]
```

**Environment config object:**

```mlld
var @agentConfig = {
  provider: "@local",
  tools: @agentTools,
  auth: "claude"
}

env @agentConfig [
  run cmd { claude -p @task }
]
```

Common config fields:
- `tools` - Tool collection or list
- `provider` - Environment provider (e.g., "@local", "@mlld/env-docker")
- `auth` - Authentication reference

**Inline tool scoping:**

```mlld
var tools @agentTools = {
  read: { mlld: @readData },
  write: { mlld: @writeData },
  delete: { mlld: @deleteData, labels: ["destructive"] }
}

env @agentTools with { tools: ["read", "write"] } [
  >> Agent cannot access 'delete' tool
  run cmd { claude -p @task }
]
```

**Return values:**

Blocks can return values like exe blocks:

```mlld
var @result = env @config [
  let @data = run cmd { fetch-data }
  => @data
]
```

**Scoped environment:**

The env block creates a child environment. Variables defined inside don't leak out, but the block can access parent scope variables.

```mlld
var @input = "test"

env @config [
  >> Can read @input from parent
  let @processed = @input | @transform
  => @processed
]
```
</TOOLS_AND_ENVIRONMENTS>

<OUTPUT_DIRECTIVE>
Write data to files or streams.

```mlld
output @content to "out.txt"
output @data to "config.json"
output @message to stdout
output @error to stderr
output @config to "settings.yaml" as yaml
```
</OUTPUT_DIRECTIVE>

<LOG_DIRECTIVE>
Syntactic sugar for `output to stdout`. Works in action contexts.

```mlld
log @message                        >> same as output @message to stdout
log `Processing: @item`

>> In action contexts
for @item in @items => log @item
when @debug => log "Debug info"
```
</LOG_DIRECTIVE>

<APPEND_DIRECTIVE>
Append newline-delimited records.

```mlld
append @record to "events.jsonl"        >> JSON object per line
append "raw line" to "events.log"

>> In pipelines
var @_ = @data | append "audit.jsonl"

>> In loops
for @name in @runs => append @name to "pipeline.log"
```

`.jsonl` enforces JSON serialization. Other extensions write text. `.json` blocked.
</APPEND_DIRECTIVE>

<STREAMING>
Stream output during execution.

```mlld
stream @claude("prompt")           >> keyword form
stream @generateReport()           >> directive form

>> Parallel streams
stream @a() || stream @b()         >> concurrent, buffered results
```

Suppress: `--no-stream` flag or `MLLD_NO_STREAM=true`
</STREAMING>

</MLLD_COMMANDS>
