>> Audit Orchestrator (Verified Invalidation)
>> Usage: mlld plugins/mlld/examples/audit/index.mld --glob "src/**/*.ts" [--parallel 20] [--output findings.json]
>>
>> Parallel fan-out codebase review with verified invalidation.
>> 1. Glob source files
>> 2. Fan out: each file reviewed by LLM with limited tools (file content only)
>> 3. Collect findings
>> 4. Verification pass: verifier gets expanded tools to check codebase context
>> 5. Output classified findings (confirmed, false-positive, insufficient-context, needs-human)

import { @claudePoll } from @mlld/claude-poll
import { @logEvent } from "./lib/context.mld"
import "@payload" as @p

>> Parse arguments
var @glob = @p.glob ?? "src/**/*.ts"
var @parallelism = @p.parallel ? @p.parallel * 1 : 20
var @outputPath = @p.output ?? "findings.json"

>> Tool permissions — escalation between phases
>> Phase 1: reviewer sees only the file (Read to load, Write for output)
var @reviewTools = "Read,Write"
>> Phase 2: verifier can explore the codebase for surrounding context
var @verifyTools = "Read,Write,Glob,Grep"

>> Prompt templates
exe @reviewPrompt(file, fileContent) = template "./prompts/review.att"
exe @verifyPrompt(finding, fileContent) = template "./prompts/verify.att"

>> Shell helpers
exe @mkdirp(dir) = sh { mkdir -p "$dir" }

>> Array helpers
exe @flatMap(arrays) = js { return arrays.filter(Boolean).flatMap(a => (a.data || a).findings || []) }
exe @filterByVerdict(results, verdict) = js { return results.filter(r => { r = r.data || r; return r && r.verdict === verdict }) }

>> Set up run directory
var @today = @now.slice(0, 10)
var @runDir = `@root/runs/@today`
run @mkdirp(@runDir)
run @mkdirp(`@runDir/reviews`)
run @mkdirp(`@runDir/verifications`)

show `═══════════════════════════════════════════════════════════════════`
show `Audit: @glob`
show `═══════════════════════════════════════════════════════════════════`
show `Parallelism: @parallelism`
show `Output: @outputPath`
show `Run dir: @runDir`
show `───────────────────────────────────────────────────────────────────`

>> 1. Glob source files
var @files = <@glob>

if @files.length == 0 [
  show `No files matched: @glob`
  let @empty = []
  output @empty to "@outputPath"
] else [
  show `Found @files.length files to review`

  >> 2. Fan out: parallel review (limited tools — reviewer sees only the file)
  show `\nPhase 1: Review (@files.length files, parallel @parallelism)`
  show `  Tools: @reviewTools`
  show `───────────────────────────────────────────────────────────────────`

  let @reviewResults = for parallel(@parallelism) @file in @files [
    let @filename = @file.mx.filename
    let @outPath = `@runDir/reviews/@filename\.json`

    >> Idempotency: skip if already reviewed
    if @exists(@outPath) [
      show `  @filename: skipped (exists)`
      => <@outPath> | @parse
    ]

    >> Build review prompt
    let @prompt = @reviewPrompt(@file, @file)
    let @fullPrompt = `@prompt

IMPORTANT: Write your JSON response to @outPath using the Write tool. Write ONLY valid JSON matching the schema in the prompt.`

    >> Call reviewer (limited tools)
    @claudePoll(@fullPrompt, "sonnet", "@root", @reviewTools, @outPath)
    let @result = <@outPath>?

    if !@result [
      show `  @filename: review failed (no output)`
      let @evtData = { file: @filename }
      @logEvent(@runDir, "review_failed", @evtData)
      => null
    ]

    show `  @filename: @result.findings.length findings`
    let @evtData = { file: @filename, finding_count: @result.findings.length }
    @logEvent(@runDir, "review_complete", @evtData)
    => @result | @parse
  ]

  >> Collect all findings from review results
  let @allFindings = @flatMap(@reviewResults)

  show `\nTotal findings: @allFindings.length`

  if @allFindings.length == 0 [
    let @empty = []
    output @empty to "@outputPath"
    show `No findings. Written empty result to @outputPath`
  ] else [
    >> 3. Verification pass (expanded tools — verifier can explore codebase)
    show `\nPhase 2: Verification (@allFindings.length findings, parallel @parallelism)`
    show `  Tools: @verifyTools`
    show `───────────────────────────────────────────────────────────────────`

    let @verificationResults = for parallel(@parallelism) @finding in @allFindings [
      let @findingId = `@finding.file-@finding.line`
      let @outPath = `@runDir/verifications/@findingId\.json`

      >> Idempotency
      if @exists(@outPath) [
        show `  @findingId: skipped (exists)`
        => <@outPath> | @parse
      ]

      >> Load the source file for the verifier
      let @sourceFile = <@finding.file>?
      let @prompt = @verifyPrompt(@finding, @sourceFile)
      let @fullPrompt = `@prompt

IMPORTANT: Write your JSON response to @outPath using the Write tool. Write ONLY valid JSON.`

      >> Call verifier (expanded tools)
      @claudePoll(@fullPrompt, "sonnet", "@root", @verifyTools, @outPath)
      let @result = <@outPath>?

      if !@result [
        show `  @findingId: verification failed (no output) — keeping as confirmed`
        => { finding: @finding, verdict: "confirmed", reasoning: "verification failed" }
      ]

      let @status = when @result.verdict [
        "confirmed" => "CONFIRMED"
        "false-positive" => "FALSE POSITIVE"
        "insufficient-context" => "NEEDS CONTEXT"
        "needs-human" => "NEEDS HUMAN"
        * => "CONFIRMED"
      ]
      show `  @findingId [@finding.severity]: @status — @result.reasoning`
      let @verEvt = { finding: @findingId, verdict: @result.verdict }
      @logEvent(@runDir, "verification_complete", @verEvt)
      => @result
    ]

    >> 4. Classify results by verdict
    let @confirmed = @filterByVerdict(@verificationResults, "confirmed")
    let @falsePositives = @filterByVerdict(@verificationResults, "false-positive")
    let @needsContext = @filterByVerdict(@verificationResults, "insufficient-context")
    let @needsHuman = @filterByVerdict(@verificationResults, "needs-human")

    >> 5. Output results
    show `\n═══════════════════════════════════════════════════════════════════`
    show `Results: @allFindings.length total findings`
    show `  Confirmed:            @confirmed.length`
    show `  False positives:      @falsePositives.length`
    show `  Insufficient context: @needsContext.length`
    show `  Needs human review:   @needsHuman.length`
    show `═══════════════════════════════════════════════════════════════════`

    let @output = {
      summary: {
        total_findings: @allFindings.length,
        confirmed: @confirmed.length,
        false_positives: @falsePositives.length,
        insufficient_context: @needsContext.length,
        needs_human: @needsHuman.length
      },
      confirmed: @confirmed,
      needs_human: @needsHuman,
      insufficient_context: @needsContext,
      false_positives: @falsePositives
    }

    output @output to "@outputPath"
    let @finalEvt = {
      files_reviewed: @files.length,
      total_findings: @allFindings.length,
      confirmed: @confirmed.length,
      false_positives: @falsePositives.length,
      insufficient_context: @needsContext.length,
      needs_human: @needsHuman.length
    }
    run @logEvent(@runDir, "audit_complete", @finalEvt)

    show `Written to @outputPath`
  ]
]
