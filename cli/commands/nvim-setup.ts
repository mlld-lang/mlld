import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { execSync } from 'child_process';
import chalk from 'chalk';

// Config version - bump when making breaking changes
// nvim-doctor uses this to detect outdated configs
export const NVIM_CONFIG_VERSION = 13;

// File extension semantics:
// - .mld files → strict mode (bare directives like `var @x = 1`)
// - .mld.md files → markdown mode (slash directives like `/var @x = 1`)

export function createNvimSetupCommand() {
  return {
    name: 'nvim-setup',
    description: 'Set up mlld Language Server for Neovim',

    async execute(args: string[], flags: any): Promise<void> {
      console.log(chalk.blue.bold('Setting up mlld Language Server for Neovim...\n'));

      const homeDir = os.homedir();
      const nvimConfig = process.env.XDG_CONFIG_HOME
        ? path.join(process.env.XDG_CONFIG_HOME, 'nvim')
        : path.join(homeDir, '.config', 'nvim');

      // Universal config - works with vanilla Neovim + any plugin manager
      const universalConfig = `-- mlld Language Server Configuration
-- Auto-generated by: mlld nvim-setup
-- Config version: ${NVIM_CONFIG_VERSION}
--
-- File extensions:
--   .mld    → strict mode (bare directives: var, show, exe)
--   .mld.md → markdown mode (slash directives: /var, /show, /exe)

-- Register file types first
vim.filetype.add({
  extension = { mld = 'mld' },
  pattern = { ['.*%.mld%.md'] = 'mld' }
})

-- Detect Neovim version and use appropriate API
local nvim_version = vim.version()
local use_new_api = nvim_version.major > 0 or (nvim_version.major == 0 and nvim_version.minor >= 10)

if use_new_api then
  -- Neovim 0.10+: Use vim.lsp.config() and vim.lsp.enable()
  vim.lsp.config('mlld_ls', {
    cmd = { 'mlld', 'lsp' },
    filetypes = { 'mld' },
    root_markers = { 'mlld.lock.json', 'mlld-config.json', 'package.json', '.git' },
    settings = {
      mlldLanguageServer = {
        enableAutocomplete = true,
        semanticTokenDelay = 250,
        validationDelay = 1000,
        showIncompleteLineErrors = false,
      }
    },
  })

  -- Enable autostart for mlld_ls
  vim.lsp.enable('mlld_ls')

  -- Enable semantic tokens on LSP attach
  vim.api.nvim_create_autocmd('LspAttach', {
    callback = function(args)
      local client = vim.lsp.get_client_by_id(args.data.client_id)
      if client and client.name == 'mlld_ls' and client.server_capabilities.semanticTokensProvider then
        -- Define highlight groups for mlld semantic tokens
        vim.api.nvim_set_hl(0, '@lsp.type.variable.mld', { link = 'Function' })
        vim.api.nvim_set_hl(0, '@lsp.type.property.mld', { link = 'Type' })
        vim.api.nvim_set_hl(0, '@lsp.type.function.mld', { link = 'Identifier', italic = true })
        vim.api.nvim_set_hl(0, '@lsp.type.string.mld', { link = 'String' })
        vim.api.nvim_set_hl(0, '@lsp.type.number.mld', { link = 'Number' })
        vim.api.nvim_set_hl(0, '@lsp.type.keyword.mld', { link = 'Keyword' })
        vim.api.nvim_set_hl(0, '@lsp.type.operator.mld', { link = 'Operator' })
        vim.api.nvim_set_hl(0, '@lsp.type.comment.mld', { link = 'Comment' })
        vim.api.nvim_set_hl(0, '@lsp.type.label.mld', { link = 'Special' })
        vim.api.nvim_set_hl(0, '@lsp.type.type.mld', { link = 'Type' })
        -- Modifiers for additional nuance
        vim.api.nvim_set_hl(0, '@lsp.typemod.variable.declaration.mld', { link = 'Function', bold = true })
        vim.api.nvim_set_hl(0, '@lsp.typemod.function.declaration.mld', { link = 'Identifier', bold = true })
        vim.api.nvim_set_hl(0, '@lsp.typemod.function.reference.mld', { link = 'Identifier', italic = true })
        -- Embedded code styling (italic modifier)
        vim.api.nvim_set_hl(0, '@lsp.mod.italic.mld', { italic = true })

        vim.lsp.semantic_tokens.start(args.buf, client.id)
      end
    end,
  })
else
  -- Neovim 0.9: Use lspconfig
  local ok, lspconfig = pcall(require, 'lspconfig')
  if not ok then
    vim.notify("nvim-lspconfig not found. Install it first!", vim.log.levels.ERROR)
    return
  end

  local configs = require('lspconfig.configs')

  if not configs.mlld_ls then
    configs.mlld_ls = {
      default_config = {
        cmd = { 'mlld', 'lsp' },
        filetypes = { 'mld' },
        root_dir = lspconfig.util.root_pattern('mlld.lock.json', 'mlld-config.json', 'package.json', '.git'),
        single_file_support = true,
        settings = {
          mlldLanguageServer = {
            enableAutocomplete = true,
            semanticTokenDelay = 250,
            validationDelay = 1000,
            showIncompleteLineErrors = false,
          }
        },
      }
    }
  end

  lspconfig.mlld_ls.setup({
    on_attach = function(client, bufnr)
      if client.server_capabilities.semanticTokensProvider then
        vim.lsp.semantic_tokens.start(bufnr, client.id)
      end
    end,
  })
end

-- Helper command to check LSP status
vim.api.nvim_create_user_command('MlldLspInfo', function()
  local clients = vim.lsp.get_clients({ name = 'mlld_ls' })
  if #clients > 0 then
    local client = clients[1]
    vim.notify(string.format('mlld LSP running (id=%d)', client.id), vim.log.levels.INFO)
  else
    vim.notify('mlld LSP not running. Open a .mld file to start.', vim.log.levels.WARN)
  end
end, {})`;

      // LazyVim-specific config
      const lazyVimConfig = `-- mlld Language Server for LazyVim
-- Auto-generated by: mlld nvim-setup
-- Config version: ${NVIM_CONFIG_VERSION}
--
-- File extensions:
--   .mld    → strict mode (bare directives: var, show, exe)
--   .mld.md → markdown mode (slash directives: /var, /show, /exe)

return {
  "neovim/nvim-lspconfig",
  ft = { "mld" },  -- Load when opening .mld files
  event = { "BufReadPre *.mld", "BufNewFile *.mld", "BufReadPre *.mld.md", "BufNewFile *.mld.md" },
  config = function()
    -- Register filetypes first
    vim.filetype.add({
      extension = { mld = "mld" },
      pattern = { [".*%.mld%.md"] = "mld" }
    })

    -- Detect Neovim version and use appropriate API
    local nvim_version = vim.version()
    local use_new_api = nvim_version.major > 0 or (nvim_version.major == 0 and nvim_version.minor >= 10)

    if use_new_api then
      -- Neovim 0.10+: Use vim.lsp.config() and vim.lsp.enable()
      vim.lsp.config('mlld_ls', {
        cmd = { 'mlld', 'lsp' },
        filetypes = { 'mld' },
        root_markers = { 'mlld.lock.json', 'mlld-config.json', 'package.json', '.git' },
        settings = {
          mlldLanguageServer = {
            enableAutocomplete = true,
            semanticTokenDelay = 250,
            validationDelay = 1000,
          }
        },
      })

      -- Enable autostart for mlld_ls
      vim.lsp.enable('mlld_ls')

      -- Enable semantic tokens on LSP attach
      vim.api.nvim_create_autocmd('LspAttach', {
        callback = function(args)
          local client = vim.lsp.get_client_by_id(args.data.client_id)
          if client and client.name == 'mlld_ls' and client.server_capabilities.semanticTokensProvider then
            -- Define highlight groups for mlld semantic tokens
            vim.api.nvim_set_hl(0, '@lsp.type.variable.mld', { link = 'Function' })
            vim.api.nvim_set_hl(0, '@lsp.type.property.mld', { link = 'Type' })
            vim.api.nvim_set_hl(0, '@lsp.type.function.mld', { link = 'Identifier', italic = true })
                vim.api.nvim_set_hl(0, '@lsp.type.string.mld', { link = 'String' })
            vim.api.nvim_set_hl(0, '@lsp.type.number.mld', { link = 'Number' })
            vim.api.nvim_set_hl(0, '@lsp.type.keyword.mld', { link = 'Keyword' })
            vim.api.nvim_set_hl(0, '@lsp.type.operator.mld', { link = 'Operator' })
            vim.api.nvim_set_hl(0, '@lsp.type.comment.mld', { link = 'Comment' })
            vim.api.nvim_set_hl(0, '@lsp.type.label.mld', { link = 'Special' })
            vim.api.nvim_set_hl(0, '@lsp.type.type.mld', { link = 'Type' })
            -- Modifiers for additional nuance
            vim.api.nvim_set_hl(0, '@lsp.typemod.variable.declaration.mld', { link = 'Function', bold = true })
            vim.api.nvim_set_hl(0, '@lsp.typemod.function.reference.mld', { link = 'Identifier', italic = true })
            -- Embedded code styling (italic modifier)
            vim.api.nvim_set_hl(0, '@lsp.mod.italic.mld', { italic = true })

            vim.lsp.semantic_tokens.start(args.buf, client.id)
          end
        end,
      })
    else
      -- Neovim 0.9: Use lspconfig
      local lspconfig = require("lspconfig")
      local configs = require("lspconfig.configs")

      if not configs.mlld_ls then
        configs.mlld_ls = {
          default_config = {
            cmd = { "mlld", "lsp" },
            filetypes = { "mld" },
            root_dir = lspconfig.util.root_pattern("mlld.lock.json", "mlld-config.json", "package.json", ".git"),
            single_file_support = true,
            settings = {
              mlldLanguageServer = {
                enableAutocomplete = true,
                semanticTokenDelay = 250,
                validationDelay = 1000,
              }
            }
          }
        }
      end

      lspconfig.mlld_ls.setup({
        on_attach = function(client, bufnr)
          if client.server_capabilities.semanticTokensProvider then
            vim.lsp.semantic_tokens.start(bufnr, client.id)
          end
        end,
      })
    end
  end
}`;

      // Detect setup type and target file
      const lazyVimDir = path.join(nvimConfig, 'lua', 'plugins');
      const afterPluginDir = path.join(nvimConfig, 'after', 'plugin');

      let targetFile: string;
      let setupType: string;
      let created = false;

      // Check for LazyVim (has lua/plugins directory)
      if (fs.existsSync(lazyVimDir)) {
        setupType = 'LazyVim';
        targetFile = path.join(lazyVimDir, 'mlld.lua');

        if (fs.existsSync(targetFile) && !flags.force) {
          console.log(chalk.yellow(`Config already exists at ${targetFile}`));
          console.log(chalk.dim('  Use --force to overwrite'));
          console.log(chalk.dim('  Or run: mlld nvim-doctor'));
        } else {
          fs.writeFileSync(targetFile, lazyVimConfig);
          created = true;
        }

      } else {
        // Standard Neovim setup
        setupType = 'Neovim';

        if (!fs.existsSync(afterPluginDir)) {
          fs.mkdirSync(afterPluginDir, { recursive: true });
        }

        targetFile = path.join(afterPluginDir, 'mlld-lsp.lua');

        if (fs.existsSync(targetFile) && !flags.force) {
          console.log(chalk.yellow(`Config already exists at ${targetFile}`));
          console.log(chalk.dim('  Use --force to overwrite'));
          console.log(chalk.dim('  Or run: mlld nvim-doctor'));
        } else {
          fs.writeFileSync(targetFile, universalConfig);
          created = true;
        }
      }

      if (created) {
        console.log(chalk.green(`Detected ${setupType} configuration`));
        console.log(chalk.green(`Created: ${targetFile}\n`));
      }

      // Check if mlld is installed globally
      let mlldInstalled = false;
      try {
        const checkCommand = process.platform === 'win32' ? 'where mlld' : 'which mlld';
        execSync(checkCommand, { stdio: 'ignore' });
        mlldInstalled = true;
        console.log(chalk.green('✓ mlld is installed globally'));
      } catch {
        console.log(chalk.yellow('✗ mlld not found in PATH'));
        console.log(chalk.dim('  Install globally: npm install -g mlld'));
      }

      // Test if nvim has lspconfig
      let hasLspConfig = false;
      try {
        const result = execSync('nvim --headless -c "lua print(pcall(require, \'lspconfig\'))" -c "q"',
          { encoding: 'utf-8', timeout: 5000 });
        if (result.includes('true')) {
          hasLspConfig = true;
          console.log(chalk.green('✓ nvim-lspconfig is installed'));
        }
      } catch {
        // Fallback check
        const initLua = path.join(nvimConfig, 'init.lua');
        if (fs.existsSync(initLua)) {
          const content = fs.readFileSync(initLua, 'utf-8');
          if (content.includes('lspconfig')) {
            hasLspConfig = true;
          }
        }
      }

      if (!hasLspConfig) {
        console.log(chalk.yellow('✗ nvim-lspconfig might not be installed'));
        console.log(chalk.dim('  LazyVim: Already included'));
        console.log(chalk.dim('  Lazy:    { "neovim/nvim-lspconfig" }'));
        console.log(chalk.dim('  Packer:  use "neovim/nvim-lspconfig"'));
      }

      // Success message
      console.log(chalk.blue.bold('\nSetup complete!\n'));

      console.log(chalk.bold('Next steps:'));
      console.log('  1. Restart Neovim');
      console.log('  2. Open a .mld file');
      console.log('  3. Run :LspInfo to verify mlld_ls is attached\n');

      console.log(chalk.dim('File types:'));
      console.log(chalk.dim('  .mld    → strict mode (bare directives)'));
      console.log(chalk.dim('  .mld.md → markdown mode (slash directives)\n'));

      console.log(chalk.dim('Commands:'));
      console.log(chalk.dim('  :MlldLspInfo     Check mlld LSP status'));
      console.log(chalk.dim('  :LspInfo         Show all LSP clients'));
      console.log(chalk.dim('  :checkhealth lsp Diagnose LSP issues'));

      if (!mlldInstalled) {
        console.log(chalk.dim('\nFor best performance, install mlld globally:'));
        console.log(chalk.cyan('  npm install -g mlld'));
      }

      // Show config if requested
      if (flags.show || flags['show-config']) {
        console.log(chalk.bold('\nConfig (for reference):'));
        console.log(chalk.dim('─'.repeat(50)));
        console.log(chalk.gray(setupType === 'LazyVim' ? lazyVimConfig : universalConfig));
        console.log(chalk.dim('─'.repeat(50)));
      }
    }
  };
}
