/**
 * Module validation orchestrator
 */

import { ValidationStep } from '../types/PublishingStrategy';
import type {
  ModuleMetadata,
  ModuleData,
  ValidationResult,
  ValidationError,
  ValidationWarning,
  ExportBinding,
  ImportRecord,
  ValidationContext
} from '../types/PublishingTypes';
import { SyntaxValidator } from './SyntaxValidator';
import { ExportValidator } from './ExportValidator';
import { MetadataEnhancer } from './MetadataEnhancer';
import { ImportValidator } from './ImportValidator';
import { DependencyValidator } from './DependencyValidator';

export class ModuleValidator {
  private readonly steps: ValidationStep[];
  private readonly enhancer: MetadataEnhancer;

  constructor() {
    this.steps = [
      new SyntaxValidator(),
      new ExportValidator(),
      new ImportValidator(),
      new DependencyValidator()
    ];
    this.enhancer = new MetadataEnhancer();
  }

  async validate(module: ModuleData, context: ValidationContext): Promise<ValidationResult> {
    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    const exportBindings: ExportBinding[] = [];
    const importRecords: ImportRecord[] = [];

    let metadataUpdates: Partial<ModuleMetadata> = {};
    let needsMetadataRewrite = false;

    // Base metadata validation covers required fields and defaults
    const metadataResult = await this.enhancer.validate(module, context);
    this.mergeValidationResult(metadataResult, errors, warnings, exportBindings, importRecords);

    if (metadataResult.updatedMetadata) {
      metadataUpdates = { ...metadataUpdates, ...metadataResult.updatedMetadata };
      needsMetadataRewrite = true;
    }

    // Ensure the publisher has permission to publish for the declared author
    if (module.metadata.author && context.user) {
      const authorResult = await this.enhancer.validateAuthorPermissions(
        module.metadata,
        context.user,
        context.octokit
      );
      if (!authorResult.valid) {
        errors.push(...authorResult.errors);
      }
    } else if (!module.metadata.author && context.user) {
      metadataUpdates.author = context.user.login;
      needsMetadataRewrite = true;
    }

    // Enrich metadata when not in dry-run mode
    if (!context.dryRun) {
      const enhancedModule = await this.enhancer.enhance(module, context);
      if (enhancedModule !== module) {
        const differences = this.getDifferences(module.metadata, enhancedModule.metadata);
        if (Object.keys(differences).length > 0) {
          metadataUpdates = { ...metadataUpdates, ...differences };
          needsMetadataRewrite = true;
        }
      }
    }

    // Execute remaining validation steps
    for (const step of this.steps) {
      const result = await step.validate(module, context);
      this.mergeValidationResult(result, errors, warnings, exportBindings, importRecords);
    }

    // Generate updated content when metadata changed
    let updatedContent: string | undefined;
    if (needsMetadataRewrite) {
      const mergedMetadata = { ...module.metadata, ...metadataUpdates };
      updatedContent = this.updateFrontmatter(module.content, mergedMetadata);
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
      updatedMetadata: needsMetadataRewrite ? metadataUpdates : undefined,
      updatedContent,
      exports: exportBindings.length > 0 ? exportBindings : undefined,
      imports: importRecords.length > 0 ? importRecords : undefined
    };
  }

  private mergeValidationResult(
    result: ValidationResult,
    errors: ValidationError[],
    warnings: ValidationWarning[],
    exports: ExportBinding[],
    imports: ImportRecord[]
  ): void {
    if (!result) return;
    if (result.errors?.length) {
      errors.push(...result.errors);
    }
    if (result.warnings?.length) {
      warnings.push(...result.warnings);
    }
    if (result.exports?.length) {
      exports.push(...result.exports);
    }
    if (result.imports?.length) {
      imports.push(...result.imports);
    }
  }

  private getDifferences(original: ModuleMetadata, enhanced: ModuleMetadata): Partial<ModuleMetadata> {
    const differences: Partial<ModuleMetadata> = {};
    const fieldsToCheck: (keyof ModuleMetadata)[] = [
      'name',
      'author',
      'version',
      'about',
      'license',
      'repo',
      'bugs',
      'homepage',
      'mlldVersion'
    ];

    for (const field of fieldsToCheck) {
      if (original[field] !== enhanced[field]) {
        (differences as Record<string, unknown>)[field as string] = enhanced[field];
      }
    }

    return differences;
  }

  private updateFrontmatter(content: string, metadata: ModuleMetadata): string {
    const frontmatterMatch = content.match(/^---\s*\n([\s\S]*?)\n---/);

    if (!frontmatterMatch) {
      return this.formatFrontmatter(metadata) + '\n\n' + content;
    }

    const afterFrontmatter = content.substring(frontmatterMatch[0].length);
    return this.formatFrontmatter(metadata) + afterFrontmatter;
  }

  private formatFrontmatter(metadata: ModuleMetadata): string {
    const lines = ['---'];

    lines.push(`name: ${metadata.name}`);
    lines.push(`author: ${metadata.author}`);
    if (metadata.version) lines.push(`version: ${metadata.version}`);
    lines.push(`about: ${metadata.about}`);

    if (metadata.needs) {
      lines.push(`needs: [${metadata.needs.map(n => `"${n}"`).join(', ')}]`);
    }

    if (metadata.needs?.includes('js') && metadata.needsJs) {
      lines.push('needs-js:');
      if (metadata.needsJs.node) lines.push(`  node: "${metadata.needsJs.node}"`);
      if (metadata.needsJs.packages) lines.push(`  packages: [${metadata.needsJs.packages.map(p => `"${p}"`).join(', ')}]`);
    }
    if (metadata.needs?.includes('node') && metadata.needsNode) {
      lines.push('needs-node:');
      if (metadata.needsNode.node) lines.push(`  node: "${metadata.needsNode.node}"`);
      if (metadata.needsNode.packages) lines.push(`  packages: [${metadata.needsNode.packages.map(p => `"${p}"`).join(', ')}]`);
    }
    if (metadata.needs?.includes('py') && metadata.needsPy) {
      lines.push('needs-py:');
      if (metadata.needsPy.python) lines.push(`  python: "${metadata.needsPy.python}"`);
      if (metadata.needsPy.packages) lines.push(`  packages: [${metadata.needsPy.packages.map(p => `"${p}"`).join(', ')}]`);
    }
    if (metadata.needs?.includes('sh') && metadata.needsSh) {
      lines.push('needs-sh:');
      if (metadata.needsSh.shell) lines.push(`  shell: "${metadata.needsSh.shell}"`);
      if (metadata.needsSh.commands) lines.push(`  commands: [${metadata.needsSh.commands.map(c => `"${c}"`).join(', ')}]`);
    }

    if (metadata.bugs) lines.push(`bugs: ${metadata.bugs}`);
    if (metadata.repo) lines.push(`repo: ${metadata.repo}`);
    if (metadata.keywords?.length) {
      lines.push(`keywords: [${metadata.keywords.map(k => `"${k}"`).join(', ')}]`);
    }
    if (metadata.homepage) lines.push(`homepage: ${metadata.homepage}`);
    lines.push(`license: ${metadata.license}`);
    if (metadata.mlldVersion) lines.push(`mlld-version: "${metadata.mlldVersion}"`);

    lines.push('---');
    return lines.join('\n');
  }
}
