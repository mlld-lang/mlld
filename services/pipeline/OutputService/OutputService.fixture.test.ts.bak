import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { mockDeep, mockReset, type DeepMockProxy } from 'vitest-mock-extended';
import { OutputService } from '@services/pipeline/OutputService/OutputService';
import { MeldOutputError } from '@core/errors/MeldOutputError';
import type { MeldNode } from '@core/ast/types';
import type { IStateService } from '@services/state/StateService/IStateService';
import type { IResolutionService, ResolutionContext } from '@services/resolution/ResolutionService/IResolutionService';
import type { OutputFormat, OutputOptions } from '@services/pipeline/OutputService/IOutputService';
import { createTextNode } from '@tests/utils/testFactories';
import { ASTFixtureLoader } from '@tests/utils/ASTFixtureLoader';
import type { ASTFixture } from '@tests/utils/ASTFixtureLoader';
import { TestContextDI } from '@tests/utils/di/TestContextDI';
import { ResolutionServiceClientFactory } from '@services/resolution/ResolutionService/factories/ResolutionServiceClientFactory';
import { VariableReferenceResolverClientFactory } from '@services/resolution/ResolutionService/factories/VariableReferenceResolverClientFactory';
import type { IResolutionServiceClient } from '@services/resolution/ResolutionService/interfaces/IResolutionServiceClient';
import type { IVariableReferenceResolverClient } from '@services/resolution/ResolutionService/interfaces/IVariableReferenceResolverClient';
import { createResolutionServiceMock, createStateServiceMock } from '@tests/utils/mocks/serviceMocks';
import { VariableResolutionError } from '@core/errors/VariableResolutionError';
import { VariableType } from '@core/types/variables';
import { createLLMXML } from 'llmxml';
import type { IVariableReference } from '@core/syntax/types/interfaces/IVariableReference';
import { outputLogger as logger } from '@core/utils/logger';
import { container, type DependencyContainer } from 'tsyringe';
import type { ILogger } from '@core/utils/logger';
import type { IOutputService } from '@services/pipeline/OutputService/IOutputService';

// Define FormatConverter locally for the test
type FormatConverter = (
  nodes: MeldNode[],
  state: IStateService,
  options?: OutputOptions
) => Promise<string>;

describe('OutputService with Fixtures', () => {
  let testContainer: DependencyContainer;
  let outputService: IOutputService;
  let stateService: DeepMockProxy<IStateService>;
  let resolutionService: DeepMockProxy<IResolutionService>;
  let fixtureLoader: ASTFixtureLoader;
  let testContext: TestContextDI;

  beforeEach(() => {
    // Create child container for test isolation
    testContainer = container.createChildContainer();
    
    // Initialize fixture loader
    fixtureLoader = new ASTFixtureLoader();
    
    // Create test DI context
    testContext = new TestContextDI();
    
    // Create service mocks
    stateService = createStateServiceMock();
    stateService.getVariable.mockReturnValue({
      name: 'myVar',
      type: VariableType.TEXT,
      value: 'Hello'
    });
    stateService.getCommand.mockReturnValue(undefined);
    
    resolutionService = createResolutionServiceMock();
    
    // Register mocks in container with interface tokens
    testContainer.register('IStateService', { useValue: stateService });
    testContainer.register('IResolutionService', { useValue: resolutionService });
    
    // Mock ResolutionServiceClient factory
    const mockResolutionServiceClient = {
      resolveVariableReferences: vi.fn().mockResolvedValue({ value: 'resolved value' }),
      resolveVariablePath: vi.fn().mockImplementation(({ variableName }) => ({
        name: variableName,
        type: VariableType.TEXT,
        value: 'mocked value'
      }))
    };
    const mockResolutionFactory = {
      createClient: vi.fn().mockReturnValue(mockResolutionServiceClient)
    };
    testContainer.register(ResolutionServiceClientFactory, { useValue: mockResolutionFactory });
    
    // Mock VariableReferenceResolverClient factory
    const mockVariableReferenceResolverClient = {
      resolveReference: vi.fn().mockImplementation((ref: IVariableReference) => {
        if (ref.name === 'nonExistent') {
          throw new VariableResolutionError(`Variable '${ref.name}' not found`, {
            variableName: ref.name,
            path: ref.path?.map(p => p.value).join('.')
          });
        }
        return 'resolved value';
      })
    };
    const mockVariableResolverFactory = {
      createClient: vi.fn().mockReturnValue(mockVariableReferenceResolverClient)
    };
    testContainer.register(VariableReferenceResolverClientFactory, { useValue: mockVariableResolverFactory });
    
    // Register logger
    const mockLogger: ILogger = {
      debug: vi.fn(),
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      trace: vi.fn(),
      clone: vi.fn()
    } as unknown as ILogger;
    testContainer.register('Logger', { useValue: mockLogger });
    
    // Create service instance directly with optional dependencies
    const mockResolutionServiceClient = {
      resolveVariableReferences: vi.fn().mockResolvedValue({ value: 'resolved value' }),
      resolveVariablePath: vi.fn().mockImplementation(({ variableName }) => ({
        name: variableName,
        type: VariableType.TEXT,
        value: 'mocked value'
      }))
    };
    
    const getVariableResolver = () => testContainer.resolve(VariableReferenceResolverClientFactory).createClient(resolutionService);
    
    outputService = new OutputService(mockResolutionServiceClient, getVariableResolver);
  });

  afterEach(() => {
    mockReset(stateService);
    mockReset(resolutionService);
    vi.clearAllMocks();
    testContainer?.dispose();
  });

  describe('convert method', () => {
    it('should format text assignment nodes', async () => {
      const fixture = fixtureLoader.getFixture('text-assignment-1');
      expect(fixture).toBeDefined();
      
      const nodes = fixture!.ast as MeldNode[];
      const result = await outputService.convert(nodes, stateService, 'markdown');
      
      expect(result).toBeDefined();
      expect(result).toMatch(/greeting = "Hello, world!"/);
    });

    it('should format data object nodes', async () => {
      const fixture = fixtureLoader.getFixture('data-object-1');
      expect(fixture).toBeDefined();
      
      const nodes = fixture!.ast as MeldNode[];
      const result = await outputService.convert('markdown', nodes, stateService);
      
      expect(result).toBeDefined();
      expect(result).toMatch(/user = {/);
      expect(result).toMatch(/name: "John"/);
      expect(result).toMatch(/age: 30/);
    });

    it('should format run command nodes', async () => {
      const fixture = fixtureLoader.getFixture('run-command');
      expect(fixture).toBeDefined();
      
      const nodes = fixture!.ast as MeldNode[];
      const result = await outputService.convert('markdown', nodes, stateService);
      
      expect(result).toBeDefined();
      expect(result).toMatch(/@run/);
      expect(result).toMatch(/echo/);
    });

    it('should handle text output format', async () => {
      const fixture = fixtureLoader.getFixture('text-template-1');
      expect(fixture).toBeDefined();
      
      const nodes = fixture!.ast as MeldNode[];
      const result = await outputService.convert('text', nodes, stateService);
      
      expect(result).toBeDefined();
      expect(result).toMatch(/Hello/);
    });

    it('should handle JSON output format', async () => {
      const fixture = fixtureLoader.getFixture('data-array-1');
      expect(fixture).toBeDefined();
      
      const nodes = fixture!.ast as MeldNode[];
      const result = await outputService.convert('json', nodes, stateService);
      
      expect(result).toBeDefined();
      const parsed = JSON.parse(result);
      expect(parsed).toHaveProperty('nodes');
      expect(parsed.nodes).toBeInstanceOf(Array);
    });

    it('should handle LLMXML output format', async () => {
      const fixture = fixtureLoader.getFixture('import-all-1');
      expect(fixture).toBeDefined();
      
      const nodes = fixture!.ast as MeldNode[];
      const result = await outputService.convert('llmxml', nodes, stateService);
      
      expect(result).toBeDefined();
      expect(result).toContain('<');
      expect(result).toContain('</');
    });

    it('should throw error for unknown format', async () => {
      const fixture = fixtureLoader.getFixture('text-assignment-1');
      const nodes = fixture!.ast as MeldNode[];
      
      await expect(
        outputService.convert('unknown' as OutputFormat, nodes, stateService)
      ).rejects.toThrow(MeldOutputError);
    });

    it('should handle empty nodes array', async () => {
      const result = await outputService.convert('markdown', [], stateService);
      expect(result).toBe('');
    });

    it('should handle undefined nodes', async () => {
      await expect(
        outputService.convert('markdown', undefined as any, stateService)
      ).rejects.toThrow(MeldOutputError);
    });

    it('should handle null nodes', async () => {
      await expect(
        outputService.convert('markdown', null as any, stateService)
      ).rejects.toThrow(MeldOutputError);
    });

    it('should handle variable resolution errors gracefully', async () => {
      // Set up a fixture with variable references
      const fixture = fixtureLoader.getFixture('text-template-1');
      const nodes = fixture!.ast as MeldNode[];
      
      // Mock a variable resolution error
      resolutionService.resolveVariableReferences.mockRejectedValueOnce(
        new VariableResolutionError("Variable 'nonExistent' not found", {
          variableName: 'nonExistent'
        })
      );
      
      // Format should handle the error gracefully
      const result = await outputService.convert('markdown', nodes, stateService);
      expect(result).toBeDefined();
    });
  });

  describe('Complex formatting scenarios', () => {
    it('should format mixed directive types', async () => {
      const textFixture = fixtureLoader.getFixture('text-assignment-1');
      const dataFixture = fixtureLoader.getFixture('data-object-1');
      const pathFixture = fixtureLoader.getFixture('path-assignment-1');
      
      const mixedNodes = [
        ...textFixture!.ast,
        createTextNode('\n\n'),
        ...dataFixture!.ast,
        createTextNode('\n\n'),
        ...pathFixture!.ast
      ] as MeldNode[];
      
      const result = await outputService.convert('markdown', mixedNodes, stateService);
      
      expect(result).toContain('greeting = "Hello, world!"');
      expect(result).toContain('user = {');
      expect(result).toContain('docsDir = ');
    });

    it('should handle output options', async () => {
      const fixture = fixtureLoader.getFixture('exec-code-1');
      const nodes = fixture!.ast as MeldNode[];
      
      const options: OutputOptions = {
        includeMetadata: true,
        prettyPrint: false
      };
      
      const result = await outputService.convert('json', nodes, stateService, options);
      expect(result).toBeDefined();
      const parsed = JSON.parse(result);
      expect(parsed).toHaveProperty('nodes');
    });

    it('should handle deeply nested structures', async () => {
      const fixture = fixtureLoader.getFixture('data-object-nested-1');
      if (fixture) {
        const nodes = fixture.ast as MeldNode[];
        const result = await outputService.convert('markdown', nodes, stateService);
        
        expect(result).toContain('nested = {');
        expect(result).toContain('level1: {');
      }
    });

    it('should format multiline content properly', async () => {
      const fixture = fixtureLoader.getFixture('text-template-multiline-1');
      if (fixture) {
        const nodes = fixture.ast as MeldNode[];
        const result = await outputService.convert('markdown', nodes, stateService);
        
        expect(result).toMatch(/```/);
        expect(result).toMatch(/multiline/i);
      }
    });
  });

  describe('Edge cases and error handling', () => {
    it('should handle malformed nodes gracefully', async () => {
      const malformedNode = {} as any; // Invalid node structure
      
      await expect(
        outputService.convert('markdown', [malformedNode], stateService)
      ).rejects.toThrow();
    });

    it('should preserve formatting for code blocks', async () => {
      const fixturesWithCodeBlocks = ['exec-code-1', 'exec-code-multiline-1'];
      
      for (const fixtureName of fixturesWithCodeBlocks) {
        const fixture = fixtureLoader.getFixture(fixtureName);
        if (fixture) {
          const nodes = fixture.ast as MeldNode[];
          const result = await outputService.convert('markdown', nodes, stateService);
          
          expect(result).toMatch(/```/);
        }
      }
    });

    it('should handle unsupported node types', async () => {
      const unsupportedNode = {
        type: 'Unknown' as any,
        content: 'test'
      } as any;
      
      await expect(
        outputService.convert('markdown', [unsupportedNode], stateService)
      ).rejects.toThrow();
    });
  });
});