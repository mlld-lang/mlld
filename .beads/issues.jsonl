{"id":"mlld-04k","title":"Docs: alternative syntax guide","description":"Document alternative syntax forms in a new docs/user/alternative-syntax.md. Cover:\\n- Backtick + @var templates and .att template file style as primary patterns.\\n- Alternative cases for markdown mode templates and other interpolation styles.\\n- Guidance on when to use markdown mode vs strict.\\n- Cross-link from main docs without promoting alternates as defaults.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:29:23.17602-08:00","updated_at":"2025-12-09T08:29:23.17602-08:00"}
{"id":"mlld-08i","title":"Strings incorrectly flagged as invalid in strict mode","description":"String literals like \"‚ö†Ô∏è Will respond\" and \"üìß Invoking\" marked as errors with red squiggly. Strict mode should allow strings/templates, only bare text lines are invalid. False positive from overly aggressive text detection. Seen in: orchestrate.mld lines 48, 50","notes":"Fixed by same change as mlld-kks - checkStrictModeTextNodes now only checks top-level Text nodes","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-12T18:08:47.706368-08:00","updated_at":"2025-12-12T20:11:19.950168-08:00","closed_at":"2025-12-12T20:11:19.950171-08:00"}
{"id":"mlld-0gd","title":"Phase 1.5: Verify grammar with AST tool","description":"## Summary\n\nValidate all grammar changes by running the AST tool on representative examples.\n\n## ‚ö° Incremental Unblocking\n\nThis verification task can unblock Phase 2 work **incrementally**:\n\n- Once exe block grammar is verified ‚Üí mlld-9id (exe interpreter) can start\n- Once for block grammar is verified ‚Üí mlld-0ic (for interpreter) can start  \n- Once while grammar is verified ‚Üí mlld-ait (while interpreter) can start\n\nDon't wait for all constructs to be verified before starting interpreter work on verified constructs.\n\n## Prereq\n\nAll Phase 1 grammar issues must be complete:\n- mlld-9pl (block patterns)\n- mlld-1sh (while patterns)  \n- mlld-wrb (when syntax)\n- mlld-8d6 (types)\n- mlld-1iz (error recovery)\n\n## Build First\n\n```bash\nnpm run build:grammar\n```\n\n## Test Cases\n\n### Exe Block\n```bash\nnpm run ast -- 'exe @f() = [let @x = 1 =\u003e @x]'\n```\n\nExpected: ExeBlock node with statements array and return value.\n\n### For Block\n```bash\nnpm run ast -- 'for @x in @xs =\u003e [show @x]'\n```\n\nExpected: ForDirective with meta.actionType = 'block'.\n\n### When Oneliner (new syntax)\n```bash\nnpm run ast -- 'when @x \u003e 5 =\u003e \"big\"'\n```\n\nExpected: WhenExpression with oneliner subtype.\n\n### When Block (unchanged)\n```bash\nnpm run ast -- 'when [@x \u003e 5 =\u003e \"big\"]'\n```\n\nExpected: WhenExpression with block subtype.\n\n### While Pipeline Stage\n```bash\nnpm run ast -- 'var @x = @y | while(10) @process'\n```\n\nExpected: Pipeline with WhileStage node.\n\n### Done/Continue Literals\n```bash\nnpm run ast -- 'exe @p(s) = when [@s.done =\u003e done @s.result * =\u003e continue @newState]'\n```\n\nExpected: ControlLiteral nodes with done/continue subtypes.\n\n## Common Errors to Debug\n\n- \"Expected token but...\" - Usually JavaScript in action block has unsupported syntax\n- Type mismatches - Check core/types/ alignment\n- Backtracking errors - Check rule ordering, more specific first\n\n## Debug Mode\n\n```bash\nDEBUG_MLLD_GRAMMAR=1 npm run ast -- '/var @test = \"value\"'\n```\n\n## Validation Checklist\n\n- [ ] Exe block parses correctly ‚Üí **unblocks mlld-9id**\n- [ ] For block parses correctly ‚Üí **unblocks mlld-0ic**\n- [ ] When oneliner parses correctly\n- [ ] When block still works\n- [ ] While stage parses correctly ‚Üí **unblocks mlld-ait**\n- [ ] Done literal parses correctly\n- [ ] Continue literal parses correctly\n- [ ] All AST output matches type definitions","notes":"Ran AST validation after grammar build: /exe block with block+return, /for block action, when simple and block forms, while pipeline stage, and done/continue in when-expression inside /exe; all parsed as expected.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:16.299919-08:00","updated_at":"2025-12-15T20:50:09.174447-08:00","closed_at":"2025-12-10T07:11:46.151059-08:00","dependencies":[{"issue_id":"mlld-0gd","depends_on_id":"mlld-9pl","type":"blocks","created_at":"2025-12-09T22:16:36.27996-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-1sh","type":"blocks","created_at":"2025-12-09T22:16:36.317874-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-wrb","type":"blocks","created_at":"2025-12-09T22:16:36.35831-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-8d6","type":"blocks","created_at":"2025-12-09T22:16:36.432164-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-1iz","type":"blocks","created_at":"2025-12-09T22:27:45.137162-08:00","created_by":"daemon"}]}
{"id":"mlld-0ic","title":"Phase 2.3: Interpreter - Modify for.ts for block action support","description":"## Summary\n\nModify the for loop evaluator to detect block vs single action mode and evaluate blocks with let support.\n\n## Key Insight\n\nForSingleAction already supports everything for blocks need. The change is minimal - detect action type and call the right evaluator.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Iterator values preserve wrappers through loop body\n\n## ‚ùå DON'T DO (Explicit Restrictions)\n\nThese combinations are **NOT supported** in this epic:\n\n1. **Parallel for with blocks**: `for parallel() @x in @xs [...]]`\n   - Error: \"Parallel for loops not supported with block bodies. Use exe wrapper pattern.\"\n   - Workaround: Create an exe that contains the block logic, use parallel for with that exe.\n\n2. **Batch pipelines with blocks**: `for @x in @xs =\u003e [...] =\u003e || @batch()`\n   - Error: \"Batch pipelines not supported with block bodies. Use simple for-expression.\"\n   - Workaround: Use simple for-expression if batch pipeline needed.\n\n3. **Field access mutation in +=**: `let @data[-1].field += value`\n   - Error: \"ETOOCOMPLEX: Augmented assignment only supports simple variables.\"\n   - Only support: `let @variable += value` (simple variable names)\n\n4. **var +=**: There is no `var +=` syntax. Use `let` for accumulation within blocks.\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n- mlld-zeo (Export let functions)\n\n## Files to Modify\n\n- `interpreter/eval/for.ts` - Modify runOne() function\n\n## Implementation\n\nUpdate runOne() function (around line 168):\n\n```typescript\nimport { isLetAssignment, isAugmentedAssignment } from '@core/types/when';\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n\nconst runOne = async (entry: [any, any], idx: number) =\u003e {\n  // ... existing setup code for childEnv, iterationVar, etc.\n\n  const actionNodes = directive.values.action;\n  const retry = new RateLimitRetry();\n\n  while (true) {\n    try {\n      // Handle block vs single action mode\n      if (directive.meta.actionType === 'block') {\n        // Block mode: sequential evaluation with let support\n        let blockEnv = childEnv;\n        for (const stmt of actionNodes) {\n          if (isLetAssignment(stmt)) {\n            blockEnv = await evaluateLetAssignment(stmt, blockEnv);\n          } else if (isAugmentedAssignment(stmt)) {\n            blockEnv = await evaluateAugmentedAssignment(stmt, blockEnv);\n          } else {\n            const result = await evaluate(stmt, blockEnv);\n            blockEnv = result.env || blockEnv;\n          }\n        }\n        childEnv = blockEnv;\n      } else {\n        // Single action mode (existing behavior - unchanged)\n        // ... existing code\n      }\n\n      retry.reset();\n      break;\n    } catch (err: any) {\n      // ... existing retry logic unchanged\n    }\n  }\n  return;\n};\n```\n\n## Scoping Rules\n\n- Each iteration gets fresh child environment\n- Let variables scoped to block (not visible across iterations)\n- `let` in outer exe block CAN be mutated from inner for block (lexical scoping)\n- Parallel execution unchanged (blocks run sequentially within each parallel iteration)\n\n## Validation\n\n- [ ] Block mode detected via meta.actionType\n- [ ] Let assignments create scoped variables per iteration (as StructuredValue)\n- [ ] Augmented assignments work within iteration\n- [ ] Parallel execution still works for single actions\n- [ ] Error messages for unsupported combinations (parallel+block, batch+block)","notes":"‚úÖ PREREQUISITE UPDATE: Type enums completed in mlld-b4f. ForDirective.meta.actionType discriminator ('single' | 'block') verified in AST. ForDirective.meta.block.statementCount field validated. DirectiveSubtype includes 'for'. All regression tests pass. Ready for interpreter implementation once mlld-zeo (export let functions) is complete.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:18:12.164593-08:00","updated_at":"2025-12-15T20:50:09.175825-08:00","closed_at":"2025-12-10T14:00:53.77735-08:00","dependencies":[{"issue_id":"mlld-0ic","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:52.106015-08:00","created_by":"daemon"},{"issue_id":"mlld-0ic","depends_on_id":"mlld-zeo","type":"blocks","created_at":"2025-12-09T22:18:52.193244-08:00","created_by":"daemon"}]}
{"id":"mlld-0rz","title":"Global `@debug` object stopped working at some point","description":"I'm not sure when .... this used to get us most of whatever was in Environment for the purposes of debugging/inspection. It only redacted any env var values but did list the ones it could see.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T14:48:45.092969-08:00","updated_at":"2025-12-09T14:48:45.092969-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe","fizzy:not-now"]}
{"id":"mlld-10r","title":"Grammar: Support cmd(@arg) parameter syntax","description":"Currently 'run cmd(@arg) { ... }' fails to parse. Grammar error: 'Invalid /run syntax. Expected: /run cmd {command}, /run language {code}, or /run @exec'\n\nThis is a GRAMMAR limitation, not a tokenization bug. The grammar needs to be updated to allow parameters for cmd blocks, similar to how js(@arg) and other languages might work.\n\nRequires grammar changes in:\n- grammar/src/* (peggy.js rules for /run directive)\n- AST updates to support cmd parameters\n- Interpreter support for cmd parameters","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-14T07:55:57.593696-08:00","updated_at":"2025-12-14T08:53:03.430069-08:00"}
{"id":"mlld-1ei","title":"CI: Import error handling test failing (exit code 0 vs 1)","description":"Test fails in CI but passes locally:\n- tests/integration/imports/basic-patterns.test.ts \u003e should fail when importing non-existent variable\n\nError: `expected +0 to be 1 // Object.is equality`\n\nThe test expects exitCode 1 when importing a non-existent variable, but CI gets exitCode 0.\n\n## Root Cause\nUnknown - timing issue, error handling difference, or environment-specific behavior\n\n## Local Behavior\nTest passes locally\n\n## Impact\nCI builds fail\n\n## Investigation Needed\n- Check error propagation in CI environment\n- Verify process.exit() behavior in CI\n- May be related to how vitest captures exit codes in CI vs local","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-11T20:51:10.019139-08:00","updated_at":"2025-12-11T20:57:12.091301-08:00","closed_at":"2025-12-11T20:57:12.091301-08:00"}
{"id":"mlld-1iz","title":"Phase 1.6: Grammar Error Recovery Infrastructure","description":"Implement sophisticated error recovery for block syntax to provide accurate error locations and helpful messages.\n\n## Scope\nMake Peggy parse errors inside [...] blocks point to the actual bad token instead of the opening bracket. Apply to exe blocks, for blocks, and while constructs.\n\n## Implementation Details\n\n### 1. Structured Block Rules (No Catch-Alls)\n- Define explicit statement lists without generic fallbacks\n- ExeBlockStatement enumerates: LetAssignment | AugmentedAssignment | EffectAction | WhenRHSVarAssignment | ReturnStatement\n- ForBlockStatement uses ForSingleAction directly\n- Reorder alternatives: specific statements before generic expression fallbacks\n\n### 2. Inline Error Recovery Branches\n- Unterminated block: lookahead for ], error at EOF if missing\n- Return placement: branch for =\u003e not last, error 'Return must be last'\n- Comma separator: match ',' in statement lists, error 'Use whitespace not commas'\n- Missing = after let @id: recovery in let-assignment.peggy\n- Multiple returns: detect second =\u003e in block\n\n### 3. Reparse-on-Failure Helper\nAdd helper in grammar/deps/grammar-core.ts:\nreparseInner(innerText, startRule, offset) - calls peg$parse with startRule, offsets location() by block start, rethrows via mlldError\n\n### 4. Unclosed Delimiter Scanners\n- Add bracket-aware scanner (like existing) honoring strings\n- Use in ExeBlock/ForBlock rules\n- Catch unclosed [ with helpful error\n\n### 5. Baseline Fixtures\nCreate failing fixtures capturing current bad diagnostics for regression guard\n\n## References\n- Source: todo/plan-grammar-errors.md","notes":"Added block grammar recovery: explicit ExeBlockAction surface (effects/assignments/special literals), ensured return must be last with mlldError, and block separators already reject commas. For/Exe blocks enumerate statements (no catch-alls) and reuse unclosed-[ check. Grammar build core passed.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:26:53.223759-08:00","updated_at":"2025-12-15T20:50:09.17624-08:00","closed_at":"2025-12-10T02:39:33.609624-08:00","labels":["enhancement","grammar"],"dependencies":[{"issue_id":"mlld-1iz","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:26:53.224915-08:00","created_by":"daemon"}]}
{"id":"mlld-1sh","title":"Phase 1.2: Grammar - Add While loop patterns with done/continue keywords","description":"## Summary\n\nAdd while loop construct for bounded iteration with `done`/`continue` control keywords.\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) first.\n\n## Syntax\n\n```mlld\n# Pipeline stage\nvar @result = @initial | while(100) @processor\n\n# Directive form\nwhile (100, 1s) @processor\n\n# Processor with done/continue\nexe @processor(state) = when [\n  @state.done =\u003e done @state.result\n  * =\u003e continue @newState\n]\n```\n\n## Files to Modify\n\n- `grammar/base/literals.peggy` - Add DoneLiteral and ContinueLiteral\n- `grammar/patterns/pipeline.peggy` - Add WhilePipelineStage\n- `grammar/directives/while.peggy` (new file) - Add WhileDirective\n\n## Implementation\n\n### DoneLiteral and ContinueLiteral (in literals.peggy)\n\nFollow exact pattern from `retry`, `skip`, `allow`, `denied` (lines 50-74):\n\n```peggy\nDoneLiteral \"done literal\"\n  = \"done\" _ value:WhenRHSValue {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'done',\n        values: { value: [value] },\n        raw: { value: text() },\n        meta: { hasValue: true }\n      };\n    }\n  / \"done\" {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'done',\n        values: { value: [] },\n        raw: { value: 'done' },\n        meta: { hasValue: false }\n      };\n    }\n\nContinueLiteral \"continue literal\"\n  = \"continue\" _ value:WhenRHSValue {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'continue',\n        values: { value: [value] },\n        raw: { value: text() },\n        meta: { hasValue: true }\n      };\n    }\n  / \"continue\" {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'continue',\n        values: { value: [] },\n        raw: { value: 'continue' },\n        meta: { hasValue: false }\n      };\n    }\n```\n\n### WhilePipelineStage\n\n```peggy\nWhilePipelineStage \"while pipeline stage\"\n  = \"while\" _ \"(\" _ cap:Integer _ (\",\" _ rate:Duration)? _ \")\" _ processor:ExeReference {\n      return {\n        type: 'WhileStage',\n        values: {\n          cap: cap,\n          rate: rate || null,\n          processor: processor\n        },\n        meta: {\n          hasCap: true,\n          hasRate: !!rate\n        }\n      };\n    }\n```\n\n## Error Recovery\n\n- Missing cap: \"while() requires a maximum iteration count\"\n- Invalid processor: \"while expects an executable reference like @processor\"\n\n## Context Object\n\nWhile loops provide `@ctx.while.*`:\n- `@ctx.while.iteration` - current iteration number (0-indexed)\n- `@ctx.while.cap` - maximum iterations allowed\n\n## Testing\n\n```bash\nnpm run ast -- 'var @x = @y | while(10) @process'\nnpm run ast -- 'exe @p(s) = when [@s.done =\u003e done @s.result]'\n```\n\n## Validation\n\n- [ ] DoneLiteral parses correctly\n- [ ] ContinueLiteral parses correctly  \n- [ ] WhilePipelineStage parses correctly\n- [ ] Error messages are helpful","notes":"Added while directive grammar, while pipeline stage, and done/continue literals. Directive list now includes /while; pipeline stage supports while(\u003ccap\u003e[,\u003crate\u003e]) @processor with errors; done/continue literals parse via Literal valueType. Grammar build passes.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:15:24.186936-08:00","updated_at":"2025-12-10T00:00:33.554781-08:00","closed_at":"2025-12-10T00:00:33.554783-08:00","dependencies":[{"issue_id":"mlld-1sh","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.094575-08:00","created_by":"daemon"}]}
{"id":"mlld-1x2","title":"Interpreter: Create cwd-resolver utility for path validation","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task creates a utility function to resolve and validate working directory paths before command execution.\n\n## Prerequisites\n- Grammar tasks complete (workingDir is in AST)\n- Type tasks complete (workingDir types defined)\n\n## Task\nCreate `interpreter/utils/cwd-resolver.ts` to handle path interpolation and validation.\n\n## Requirements\n\nThe resolver must:\n1. Interpolate variables in the path (`@mypath`, `/home/@user/dev`)\n2. Validate path is rooted (starts with `/`)\n3. Check directory exists\n4. Check path is actually a directory (not a file)\n5. Return absolute path or throw clear errors\n\n## Implementation\n\nCreate new file: `interpreter/utils/cwd-resolver.ts`\n\n```typescript\nimport * as fs from 'fs';\nimport type { ContentNodeArray } from '@core/types';\nimport type { Environment } from '../env/Environment';\nimport { interpolate, InterpolationContext } from '../core/interpreter';\nimport { MlldCommandExecutionError } from '@core/errors';\n\nexport async function resolveCwd(\n  workingDirNodes: ContentNodeArray,\n  env: Environment,\n  sourceLocation?: any\n): Promise\u003cstring\u003e {\n  // Step 1: Interpolate variables\n  const interpolatedPath = await interpolate(\n    workingDirNodes,\n    env,\n    undefined,\n    { context: InterpolationContext.FilePath }\n  );\n  \n  // Step 2: Validate rooted (absolute) path\n  if (!interpolatedPath.startsWith('/')) {\n    throw new MlldCommandExecutionError(\n      `Working directory must be an absolute path (start with /): ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  // Step 3: Check directory exists\n  if (!fs.existsSync(interpolatedPath)) {\n    throw new MlldCommandExecutionError(\n      `Working directory does not exist: ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  // Step 4: Check is directory\n  const stats = fs.statSync(interpolatedPath);\n  if (!stats.isDirectory()) {\n    throw new MlldCommandExecutionError(\n      `Working directory path is not a directory: ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  return interpolatedPath;\n}\n```\n\n## Error Messages\n\nProvide clear errors for common issues:\n- Undefined variable: \"Cannot resolve working directory: variable @username is not defined\"\n- Not rooted: \"Working directory must be an absolute path (start with /): ./relative\"\n- Doesn't exist: \"Working directory does not exist: /nonexistent/path\"\n- Not a directory: \"Working directory path is not a directory: /etc/hosts\"\n\n## Testing\n\nCreate unit tests in `interpreter/utils/cwd-resolver.test.ts`:\n```typescript\ndescribe('resolveCwd', () =\u003e {\n  it('should resolve absolute path', async () =\u003e {\n    // Test with /tmp\n  });\n  \n  it('should interpolate variables', async () =\u003e {\n    // Test with @mypath variable\n  });\n  \n  it('should error on non-rooted path', async () =\u003e {\n    // Test ./relative fails\n  });\n  \n  it('should error on non-existent path', async () =\u003e {\n    // Test /does/not/exist fails\n  });\n  \n  it('should error on file path', async () =\u003e {\n    // Test /etc/hosts fails (is file not dir)\n  });\n});\n```","notes":"Validation rules: absolute Unix paths only (/ ok); no Windows or '~'; reuse existing path error pattern on missing/non-dir; supports variable interpolation before validation.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:30.564083-08:00","updated_at":"2025-12-08T20:24:26.808179-08:00","closed_at":"2025-12-08T20:24:26.808179-08:00"}
{"id":"mlld-1zd","title":"Analyzer: mode-aware parsing and cache keys","description":"**Summary:**\nEnsure `analyzeModule` respects file extension mode and caches correctly.\n\n**Changes required:**\n\n1. **Mode inference**:\n   - `analyzeModule(filepath)` should infer mode from extension\n   - Add optional `mode` parameter to override\n\n2. **Parser call**:\n   - Pass inferred/explicit mode to parser\n   - Analyzer should parse `.mld` in strict mode, `.mld.md` in markdown mode\n\n3. **Cache keys**:\n   - Include mode in analyzer cache key (if analyzer has its own cache)\n   - Or ensure it uses the shared AST cache which already includes mode (per mlld-ah5)\n\n4. **Analysis results**:\n   - No change to ModuleAnalysis structure needed\n   - Mode affects parsing only, not analysis output\n\n**Testing:**\n- Analyze `.mld` file with bare directives - succeeds\n- Analyze `.mld` file with text content - reports parse error\n- Analyze `.mld.md` file with prose - succeeds","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:56:43.129243-08:00","updated_at":"2025-12-15T20:50:09.176577-08:00","closed_at":"2025-12-11T17:37:39.186076-08:00","dependencies":[{"issue_id":"mlld-1zd","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.407032-08:00","created_by":"daemon"},{"issue_id":"mlld-1zd","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.213788-08:00","created_by":"daemon"}]}
{"id":"mlld-25m","title":"Add .replace() builtin method for strings","description":"The .replace() and .replaceAll() builtin methods are ALREADY IMPLEMENTED in interpreter/eval/exec-invocation.ts (lines 244-256).\n\nCurrent status:\n- .replace(old, new) - replaces first occurrence (like JS replace)\n- .replaceAll(old, new) - replaces all occurrences (like JS replaceAll)\n\nWhat's missing:\n- Test coverage in tests/cases/feat/builtin-methods-string-replace/\n- Documentation in user docs\n\nThe feature exists and works, just needs tests and docs.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:26:24.3089-08:00","updated_at":"2025-12-17T18:29:00.336062-08:00","closed_at":"2025-12-17T18:29:00.336062-08:00","close_reason":"Test coverage added for .replace() and .replaceAll() builtin methods at tests/cases/feat/builtin-methods-string-replace/. Both methods already existed and worked correctly, just lacked dedicated tests. All tests passing."}
{"id":"mlld-25t","title":"Fixed: Variable position bugs including export statements","description":"Fixed offset-based position calculation for variables. Now handles:\n- Bracket expressions like @var[@nested.field]  \n- Export statements where location includes @\n- Variables after datatype labels\n- Multi-byte characters and tabs\n\nChanges:\n1. Use offset-based search (forward and backward) to find @ symbol\n2. Handle 'identifier' valueType when location includes @ (export case)\n3. Use document.positionAt() for accurate coordinates","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-14T07:55:36.443062-08:00","updated_at":"2025-12-14T08:23:02.465434-08:00","closed_at":"2025-12-14T08:07:18.42219-08:00"}
{"id":"mlld-399","title":"Add 'did you mean' checks for template path resolution","description":"Users get confused about path resolution in mlld: 'tmp/file.txt' vs './file.txt' vs '@base/tmp/file.txt'. When ANY file is not found (templates, imports, file loads, etc.), check for similar paths in common locations and suggest alternatives. Add an explanatory error about how paths work in mlld (relative to execution context, use @base for project root). \n\nExamples:\n- Template: 'File not found: tmp/prompt.att. Did you mean: @base/tmp/prompt.att?'\n- Import: 'Module not found: utils.mld. Did you mean: ./utils.mld or @base/utils.mld?'\n- File load: 'File not found: data/input.json. Did you mean: @base/data/input.json?'\n\nShould apply to all file operations: /import, /exe template, \u003cfile\u003e, etc.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-17T08:30:10.46621-08:00","updated_at":"2025-12-17T08:32:20.874796-08:00"}
{"id":"mlld-3bl","title":"Grammar: when-expressions fail with 3+ conditions (comparison + 2 method calls)","description":"Detailed investigation of grammar parsing bug where when-expressions with specific condition combinations fail to parse","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-06T12:16:03.302262-08:00","updated_at":"2025-12-06T18:47:29.68001-08:00","closed_at":"2025-12-06T18:47:29.68001-08:00"}
{"id":"mlld-3e6","title":"Docs: Update for block syntax, while loops, and done/continue keywords","description":"## Summary\n\nUpdate mlld documentation to reflect the new block syntax features, while loops, and done/continue control flow keywords implemented in the block syntax epic.\n\n## Context\n\nEpic mlld-fln introduced three major features:\n1. Block syntax `[...]` for exe/for directives with let/+= support\n2. While loops with done/continue keywords\n3. Unified when syntax\n\nThese features are now implemented and all tests pass (Phase 2 complete, Phase 3 core tests passing). Documentation needs to be updated to reflect:\n- New syntax forms\n- New keywords (done, continue)\n- Let/+= semantics in blocks\n- Scope restrictions (what's NOT supported)\n\n## Documentation Files to Update\n\nBased on typical mlld docs structure, likely need updates in:\n\n### User-Facing Docs\n- `docs/flow-control.md` - Add exe blocks, for blocks, while loops\n- `docs/reference.md` - Add block syntax reference\n- `docs/quickstart.md` - Show simple block examples\n- `docs/introduction.md` - Mention blocks if appropriate\n\n### Developer Docs  \n- `docs/dev/AST.md` - Update with new node types (ExeBlockNode, control literals)\n- `docs/dev/GRAMMAR.md` - Already current, may need minor updates\n- `docs/dev/DATA.md` - Verify numeric value handling documented\n\n## What to Document\n\n### 1. Exe Block Syntax\n\n```mlld\n/exe @greet(name) = [\n  let @greeting = \"Hello\"\n  let @punctuation = \"!\"\n  =\u003e \"@greeting @name@punctuation\"\n]\n```\n\n**Key points:**\n- Multi-statement bodies with `[...]`\n- `let @var = value` for local variables\n- `let @var += value` for accumulation\n- `=\u003e value` for explicit returns (required, must be last)\n- Nested for/when allowed\n\n### 2. For Block Syntax\n\n```mlld\n/for @item in @items [\n  show \"Item: @item\"\n  let @count += 1\n]\n```\n\n**Key points:**\n- Multi-statement iteration bodies\n- Let/+= support\n- Nested control flow\n- Arrow syntax deprecated but still works: `for @x in @xs =\u003e [...]`\n\n### 3. While Loops\n\n```mlld\n/exe @countdown(n) = when [\n  @n \u003c= 0 =\u003e done \"finished\"\n  * =\u003e continue (@n - 1)\n]\n\n/var @result = 5 | while(10) @countdown\n```\n\n**Key points:**\n- Bounded iteration: `while(cap) @processor`\n- Optional pacing: `while(cap, 1s) @processor`\n- Control keywords: `done @value`, `continue @value`\n- Context: `@ctx.while.iteration`, `@ctx.while.limit`, `@ctx.while.active`\n- Retry prohibited (use continue instead)\n\n### 4. Done/Continue Keywords\n\n```mlld\ndone @value      # Terminate with value\ndone             # Terminate with current state\ncontinue @value  # Next iteration with value\ncontinue         # Next iteration with current state\n```\n\n**Key points:**\n- Used in while processors\n- Work in when expression actions\n- Can be used in exe block returns\n- Values are evaluated in current environment\n\n### 5. Scope Restrictions (Important!)\n\nDocument what's NOT supported:\n- ‚ùå Field access mutation: `let @data[-1].field += value` ‚Üí ETOOCOMPLEX\n- ‚ùå Parallel for with blocks: `for parallel() @x [...]` ‚Üí Use exe wrapper\n- ‚ùå Batch pipelines with blocks: `for [...] =\u003e ||` ‚Üí Use simple expressions\n- ‚ùå var +=: Only `let` supports +=, not `var`\n\n### 6. Let vs Var Semantics\n\nClarify the difference:\n- `let` - Block-scoped, supports +=, used in exe/for blocks\n- `var` - File/module-scoped, no +=, used for state\n\n## Validation\n\n- [ ] All examples in docs parse correctly\n- [ ] Examples match test fixtures where possible\n- [ ] Restrictions clearly documented\n- [ ] Migration guidance for existing patterns\n- [ ] AST.md updated with new node types\n\n## References\n\n- Implementation: mlld-zeo, mlld-9id, mlld-0ic, mlld-ait\n- Test fixtures: tests/cases/feat/exe-block, for-block, while\n- Verification: tmp/phase2-implementation-verification.md, tmp/while-loop-verification.md\n- Grammar docs: docs/dev/GRAMMAR.md (already current)","notes":"Documentation updated for block syntax, while loops, and done/continue keywords.\n\nFiles updated:\n- docs/user/flow-control.md: Added exe blocks, for blocks, while loops sections\n- docs/user/reference.md: Added syntax references for blocks and while\n- llms.txt: Added block syntax and while loops to ITERATION/EXE_EXECUTABLES sections\n- docs/dev/AST.md: Added new node types (ExeBlock, For block metadata, While stages, Control literals)\n\nAll examples tested and verified working. No hallucinations - every code example runs successfully.\n\nTest verification:\n- Exe block examples ‚úÖ\n- For block examples ‚úÖ  \n- While loop examples ‚úÖ\n- Control keywords (done/continue) ‚úÖ","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T17:31:20.61021-08:00","updated_at":"2025-12-10T17:56:30.868255-08:00","closed_at":"2025-12-10T17:56:30.868258-08:00","dependencies":[{"issue_id":"mlld-3e6","depends_on_id":"mlld-jw7","type":"blocks","created_at":"2025-12-10T17:31:27.672242-08:00","created_by":"daemon"}]}
{"id":"mlld-3gm","title":"Grammar: template path should support variable interpolation","description":"**Reported by:** partydev during SDK dogfooding\n\n**Current behavior:**\n`template \"../agents/@agent.att\"` treats the path as a literal string - @agent is NOT interpolated.\n\n**Expected behavior:**\nVariables in the template path should be interpolated, same as in backticks or angle brackets.\n\n**Current workarounds:**\n1. Use a variable for the full path:\n```mlld\n/var @templatePath = \\`../agents/@agent.att\\`\n/exe @buildPrompt(message) = template @templatePath\n```\n\n2. Use angle brackets + inline template:\n```mlld\n/var @tpl = \u003c../agents/@agent.att\u003e\n/exe @buildPrompt(message) = ::@tpl::\n```\n\n**Root cause:**\n`QuotedStringPath` in `grammar/patterns/path-expression.peggy` uses `$([^\"]*)` which captures content as-is without parsing for variable references.\n\n**Fix needed:**\nUpdate `QuotedStringPath` to parse variable references similar to how `AlligatorPath` does, or create a new `InterpolatedQuotedPath` pattern for template paths.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-09T08:38:03.216807-08:00","updated_at":"2025-12-09T08:51:14.335259-08:00","closed_at":"2025-12-09T08:51:14.335259-08:00"}
{"id":"mlld-3h3","title":"Dynamic bracket access fails with field access expressions","description":"**Repro:**\n```mlld\n/import templates from \"./agents\" as @agents(msg)\n/var @agentObj = {\"agent\": \"alice\"}\n\n/show @agents[@agentObj.agent](@msg)\n```\n\n**Expected:** Resolves `@agentObj.agent` to `\"alice\"`, then invokes `@agents[\"alice\"](@msg)`\n\n**Actual:** Outputs literal text without executing:\n```\n[@agentObj.agent](@msg)\n```\n\n**Works:**\n```mlld\n/var @name = \"alice\"\n/show @agents[@name](@msg)  # ‚úì works\n```\n\n**Doesn't work:**\n```mlld\n/show @agents[@obj.field](@msg)  # ‚úó literal output\n```\n\nThe bracket expression isn't being evaluated before indexing into the template collection.\n\nReported by @partydev.1 in chat - blocking their orchestration use case.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-11T04:51:24.958764-08:00","updated_at":"2025-12-11T09:43:36.846002-08:00","closed_at":"2025-12-11T09:43:36.846002-08:00"}
{"id":"mlld-3ha","title":"Add error accumulation for parallel execution (for blocks + pipeline groups)","description":"**Scope:** Error accumulation for parallel execution - both for loops and pipeline groups.\n\n**1. Parallel for blocks**\n\n**Current:** Block bodies blocked:\n```mlld\n‚úÖ /for parallel @x in @xs =\u003e show @x\n‚ùå /for parallel @x in @xs [ show @x; let @count += 1 ]\n```\n\n**Desired:**\n```mlld\n/for parallel(3) @agent in @respondingAgents [\n  let @prompt = @agents[@agent.agent](@messageBody)\n  let @response = cmd { claude -p \"@prompt\" }\n  run { bdm post --as @agent.agent\\.1 \"@response\" }\n]\n```\n\n**2. Parallel pipeline groups**\n\n**Current:** `|| @a || @b || @c` fails entire pipeline if one fails\n\n**Desired:** Best-effort with error accumulation:\n```mlld\n/var @data = || @fetchA() || @fetchB() || @fetchC() | @combine\n\n/exe @combine(results) = when [\n  @ctx.errors.length == 0 =\u003e @merge(@results)\n  * =\u003e @handlePartial(@results, @ctx.errors)  # 2/3 succeeded\n]\n```\n\n**Use cases:**\n- Multi-agent orchestration (invoke 5 agents, proceed if 3 respond)\n- Best-of-N with fallback (try multiple LLMs, use what works)\n- Multi-source aggregation (fetch 3 APIs, ok if 2/3 succeed)\n- Validation pipeline (run multiple validators, collect all failures)\n\n**Unified design:**\n\n**Error handling:**\n- Errors accumulate in `@ctx.errors` array instead of throwing\n- Results array contains error markers for failed operations (index-aligned)\n- Error marker: `{ index, key?, message, error, value? }`\n  - `index`: position in input\n  - `key`: for object iteration\n  - `message`: human-readable\n  - `error`: stringified detail\n  - `value`: original input (for retry logic)\n- `@ctx.errors` clears per parallel operation (no state leakage)\n- Caller decides repair via `when @ctx.errors.length \u003e 0`\n\n**Isolation (parallel for only):**\n- Block-scoped `let` only\n- Error on writes to outer variables (race prevention)\n\n**Ordering:**\n- Directive form: streams unordered (fast)\n- Expression form: preserves input order\n\n**Sequential blocks keep current behavior:**\n- Fail fast (no benefit to continuing)\n- Outer writes allowed (no races)\n- No error accumulation\n\n**Pattern:**\n```mlld\n/exe @invokeAll(agents, msg) = [\n  let @results = for parallel @a in @agents =\u003e @invoke(@a, @msg)\n  =\u003e when [\n    @ctx.errors.length == 0 =\u003e @results\n    * =\u003e @repair(@results, @ctx.errors, @msg)  # AI-driven repair\n  ]\n]\n\n/exe @aggregate(sources) = [\n  let @data = || @fetch(@sources[0]) || @fetch(@sources[1]) || @fetch(@sources[2])\n  =\u003e when [\n    @ctx.errors.length == 0 =\u003e @data\n    @data.length \u003e= 2 =\u003e @data  # 2/3 is good enough\n    * =\u003e retry \"Need at least 2 sources\"\n  ]\n]\n```\n\nDesign from @partydev.1, implementation by gpt5.1.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-11T05:04:30.901599-08:00","updated_at":"2025-12-11T09:43:55.079981-08:00","closed_at":"2025-12-11T09:43:55.079981-08:00"}
{"id":"mlld-3jk","title":"MJS bundle: Dynamic require of fs error in Node 24 ESM projects","description":"**Reported by:** partydev during SDK dogfooding\n\n**Environment:**\n- Node 24\n- ESM project (type: module in package.json)\n- Using `import { execute } from 'mlld'`\n\n**Error:**\n`Dynamic require of fs is not supported` when importing from the MJS bundle.\n\n**Workaround:**\nRemove `type: module` from package.json and let tsx handle ESM imports, or use createRequire with the CJS bundle.\n\n**Root cause (suspected):**\nThe MJS bundle is pulling in a CJS-only dependency that uses `require('fs')` or similar. Our tsup build generates both .mjs and .cjs outputs but the MJS bundle may not be fully tree-shaken or may include CJS-style imports.\n\n**To investigate:**\n1. Check tsup build config for ESM externals\n2. Look for dynamic requires in dependencies\n3. Test with Node 24 ESM project","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T04:53:12.510232-08:00","updated_at":"2025-12-15T20:50:09.176914-08:00","closed_at":"2025-12-11T21:25:49.684146-08:00"}
{"id":"mlld-3ma","title":"Migration: lint warning for prose in .mld files","description":"**Summary:**\nHelp users migrate by warning when `.mld` files contain prose that will error in strict mode.\n\n**Changes required:**\n\n1. **Lint rule / diagnostic**:\n   - Scan `.mld` files for lines that would be text content\n   - Emit warning: \"This file contains prose on line X. Rename to .mld.md or remove text.\"\n\n2. **CLI flag**:\n   - `mlld lint --check-mode` or similar\n   - Could be part of `mlld check` if that exists\n\n3. **Error message enhancement**:\n   - When strict mode parser errors on text, include helpful message:\n   - \"Text content not allowed in .mld files. Either:\\n  1. Rename to .mld.md to embed prose\\n  2. Remove or comment out text lines\"\n\n4. **Migration script** (optional):\n   - `mlld migrate --to-strict` - rename files and report issues\n   - Low priority, users can do this manually\n\n**Testing:**\n- Lint `.mld` file with prose - warns with line numbers\n- Lint clean `.mld` file - no warnings\n- Error message on strict parse failure includes migration hint","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T20:57:14.29758-08:00","updated_at":"2025-12-08T20:57:14.29758-08:00","dependencies":[{"issue_id":"mlld-3ma","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.522074-08:00","created_by":"daemon"},{"issue_id":"mlld-3ma","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T20:59:32.324654-08:00","created_by":"daemon"}]}
{"id":"mlld-3s8","title":"parallel keyword and arguments need unique highlighting","description":"The 'parallel' keyword in for loops should be highlighted distinctly:\n\nExample: for parallel(3) @agent in @agents =\u003e ...\n\nIssues:\n1. 'parallel' should be highlighted uniquely (not as directive, not as datatype label)\n2. Parentheses ( ) not highlighted  \n3. Numeric argument (3) not highlighted\n\nparallel is a modifier keyword that affects execution semantics and should stand out.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T05:33:53.486058-08:00","updated_at":"2025-12-14T16:38:47.447033-08:00","closed_at":"2025-12-14T16:38:47.447033-08:00","dependencies":[{"issue_id":"mlld-3s8","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:33:53.486552-08:00","created_by":"daemon"}]}
{"id":"mlld-45d","title":"Optimize @exists() for file paths to avoid loading content","description":"Performance optimization for @exists() builtin.\n\n**Current behavior:**\n```mlld\n@exists(\"large-file.json\")    // Loads entire file just to check\n@exists(\u003chuge-dataset.csv\u003e)    // Same - loads full content\n```\n\n**Optimization:**\nFor file path strings and file load expressions, use lightweight fs.exists() check instead of full content load:\n\n```mlld\n@exists(\"file.md\")         // Use fs.exists(), no load\n@exists(\"@base/dir/file\")  // Same, after path resolution\n@exists(\u003cfile.md\u003e)          // Detect file load AST, use fs.exists()\n```\n\n**Keep current behavior for:**\n- Non-file expressions: @exists(@obj.field)\n- When unclear if it's a file: let evaluation happen\n\n**Tradeoffs:**\n- More complex implementation\n- Special-casing file paths vs general expressions\n- May not matter unless users check existence of many/large files\n\n**Dependencies:**\n- Requires mlld-bqc (base @exists() implementation) to be done first\n- Only pursue if performance becomes an issue\n\nThis is a nice-to-have optimization, not critical functionality.","status":"open","priority":4,"issue_type":"feature","created_at":"2025-12-17T17:58:16.983003-08:00","updated_at":"2025-12-17T17:58:16.983003-08:00"}
{"id":"mlld-4bf","title":"LSP: Highlight function execution in /run directive (GH#331)","description":"## Summary\nFunction execution in /run directive not highlighted.\n\nGitHub: https://github.com/mlld-lang/mlld/issues/331\n\n## Problem\n```mlld\n/run @processor(@data)  \u003c\u003c @processor not highlighted as function call\n```\n\n## Root Cause\nThe /run directive with exe invocation (calling a defined function) isn't being tokenized properly.\n\n## Investigation\n```bash\nnpm run ast -- '/run @processor(@data)'\n# Check the AST structure - is it CommandReference, ExecInvocation, or something else?\n```\n\n## Analysis\nWhen /run uses an @function() call, it should be parsed as an ExecInvocation. The CommandVisitor should handle this but may be missing the case.\n\n## Implementation\n\n### Check CommandVisitor\nIn `services/lsp/visitors/CommandVisitor.ts`:\n\n```typescript\n// Ensure ExecInvocation case is handled\nvisitNode(node: any, context: VisitorContext): void {\n  if (node.type === 'ExecInvocation') {\n    this.visitExecInvocation(node, context);\n    return;\n  }\n  // ... other cases\n}\n\nvisitExecInvocation(node: any, context: VisitorContext): void {\n  // Token for @functionName\n  if (node.name) {\n    this.tokenBuilder.addToken({\n      line: node.location.start.line - 1,\n      char: node.location.start.column - 1,\n      length: node.name.length + 1, // +1 for @\n      tokenType: 'variable',\n      modifiers: ['reference']\n    });\n  }\n  \n  // Tokenize parentheses and arguments\n  // ...\n}\n```\n\n### Check DirectiveVisitor /run Handling\nThe DirectiveVisitor may need to delegate to CommandVisitor for the RHS:\n\n```typescript\n// In visitRunDirective or similar\nif (node.values?.command?.type === 'ExecInvocation') {\n  this.mainVisitor.visitNode(node.values.command, context);\n}\n```\n\n## Testing\n```typescript\nit('highlights function calls in /run', async () =\u003e {\n  const tokens = await getSemanticTokens('/run @processor(@data)');\n  expect(tokens).toContainToken({ type: 'variable', text: '@processor' });\n  expect(tokens).toContainToken({ type: 'variable', text: '@data' });\n});\n```\n\n## Files to Modify\n- `services/lsp/visitors/CommandVisitor.ts`\n- `services/lsp/visitors/DirectiveVisitor.ts`\n\n## Size\nSmall","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:36.760769-08:00","updated_at":"2025-12-11T22:17:34.784659-08:00","closed_at":"2025-12-11T22:17:34.784659-08:00","dependencies":[{"issue_id":"mlld-4bf","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.226226-08:00","created_by":"daemon"}]}
{"id":"mlld-4cs","title":"Short urls for every beads task","description":"`/bd/proj-id` should jump straight to a project's card.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T15:15:37.642987-08:00","updated_at":"2025-12-07T19:33:09.48891-08:00","closed_at":"2025-12-07T19:33:09.48891-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-4cw","title":"Docs: restructure llms.txt into modules","description":"Restructure llms.txt into modular sections using existing XML structure: a concise getting","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T08:29:52.689432-08:00","updated_at":"2025-12-15T20:50:09.177253-08:00"}
{"id":"mlld-4nt","title":"CI: gray-matter tests failing in GitHub Actions","description":"Three tests fail in CI but pass locally:\n- slash/exe/exe-node-gray-matter-access\n- slash/exe/exe-node-mlld-dependencies  \n- slash/exe/exe-node-shadow-env-always-created\n\nError: `Command execution failed: node: const matter = require('gray-matter');`\n\n## Root Cause\nLikely missing `gray-matter` dependency in CI environment or NODE_PATH issue.\n\n## Local Behavior\nAll tests pass locally (2527/2527)\n\n## Impact\nCI builds fail even though code is correct\n\n## Investigation Needed\n- Check if gray-matter is in package.json dependencies\n- Verify NODE_PATH includes node_modules in CI\n- May need to add gray-matter as explicit dependency vs peer dependency","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-11T20:51:09.910316-08:00","updated_at":"2025-12-11T20:57:17.184111-08:00","closed_at":"2025-12-11T20:57:17.184111-08:00"}
{"id":"mlld-4p5","title":"LSP: Highlight end-of-line comments in when expressions (GH#329)","description":"## Summary\nEnd-of-line comments not highlighted in when expressions.\n\nGitHub: https://github.com/mlld-lang/mlld/issues/329\n\n## Problem\n```mlld\n/when @x \u003e 0 =\u003e \"positive\"  \u003c\u003c This comment not highlighted\n     @x \u003c 0 =\u003e \"negative\"   \u003c\u003c Nor this one\n```\n\n## Root Cause\nThe ExpressionVisitor or DirectiveVisitor handling when expressions doesn't process trailing comments.\n\n## Investigation\n```bash\nnpm run ast -- '/when @x \u003e 0 =\u003e \"yes\" \u003c\u003c comment'\n# Check if comment appears in AST and has location\n```\n\nComments in mlld use `\u003e\u003e` (start of line) and `\u003c\u003c` (end of line) syntax. The CommentTokenHelper exists but may not be called for when expression arms.\n\n## Implementation\n\n### Check CommentTokenHelper Usage\nIn `services/lsp/utils/CommentTokenHelper.ts`, there should be methods for tokenizing comments.\n\n### Add to When Expression Handling\nIn DirectiveVisitor's `visitWhenDirective` or ExpressionVisitor's when handling:\n\n```typescript\n// After processing each when arm, check for trailing comment\nif (arm.comment) {\n  this.commentHelper.tokenizeComment(arm.comment);\n}\n\n// Or if comments are separate nodes in AST:\nif (arm.trailingComment) {\n  this.mainVisitor.visitNode(arm.trailingComment, context);\n}\n```\n\n### Verify Comment AST Structure\nComments may be:\n1. Attached to the when arm node\n2. Separate sibling nodes\n3. Part of a comments array\n\n## Testing\n```typescript\nit('highlights end-of-line comments in when', async () =\u003e {\n  const tokens = await getSemanticTokens('/when @x =\u003e \"yes\" \u003c\u003c comment');\n  expect(tokens).toContainToken({ type: 'comment', text: '\u003c\u003c comment' });\n});\n```\n\n## Files to Modify\n- `services/lsp/visitors/DirectiveVisitor.ts` - When handling\n- `services/lsp/visitors/ExpressionVisitor.ts` - WhenExpression handling\n\n## Size\nSmall","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:37.063973-08:00","updated_at":"2025-12-11T22:17:34.698125-08:00","closed_at":"2025-12-11T22:17:34.698125-08:00","dependencies":[{"issue_id":"mlld-4p5","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.309833-08:00","created_by":"daemon"}]}
{"id":"mlld-4qd","title":"run syntax not supported in exe/for blocks","description":"## Problem\n\nThe grammar doesn't support `run` forms inside exe blocks and for blocks:\n- `run @func()` - execute function via run\n- `run cmd {command}` - shell commands\n- `run js {code}`, `run node {code}`, `run py {code}`, `run sh {code}`, `run bash {code}` - language executors\n\nThis is a major gap since blocks are now the primary way to write multi-statement logic in mlld.\n\n## Expected behavior\n\nAll run forms should work inside `[...]` blocks:\n\n```mlld\nexe @process() = [\n  let @data = run cmd {curl https://api.example.com}\n  let @parsed = run js { return JSON.parse(@data) }\n  let @result = run @transform(@parsed)\n  =\u003e @result\n]\n```\n\n## Current status\n\nNeed to check:\n1. Which run forms are missing from BlockStatement grammar\n2. Whether this affects exe blocks, for blocks, or both\n3. Test coverage needed\n\n## Fix location\n\nLikely `grammar/mlld.peggy` - BlockStatement rule needs to include all run forms that work at top level.","status":"open","priority":0,"issue_type":"bug","created_at":"2025-12-15T14:30:22.329257-08:00","updated_at":"2025-12-15T14:30:33.826531-08:00"}
{"id":"mlld-4xm","title":"When expressions returning numbers produce empty output","description":"## Summary\n\nUser partydev.3 reported that `/exe` with `when first` returning numeric values produces empty output instead of the number.\n\n## Root Cause\n\nGrammar was inconsistent about primitive handling:\n- Some patterns returned raw primitives (`42`)\n- Some returned Literal AST nodes (`{type: 'Literal', value: 42}`)\n- Interpreter had gaps in Literal node handling\n\nThis violated the fundamental principle: **Grammar should always return AST nodes, interpreter extracts values.**\n\n## Policy Decision (Documented in DATA.md)\n\n**Primitives are NEVER StructuredValues:**\n1. Grammar returns Literal AST nodes: `{type: 'Literal', value: 42}`\n2. Interpreter extracts native values: `42`\n3. Variables wrap primitives: `PrimitiveVariable{value: 42, ctx: {...}}`\n4. StructuredValue is ONLY for dual representations (loaded content, pipeline results)\n\n**Rationale:**\n- Primitives have no dual representation (`42` is just `42`)\n- No provenance for literals in code\n- Variables already provide metadata layer\n- Performance - no wasteful wrapping\n\n## Fixes Applied\n\n1. **Grammar (`var-rhs.peggy`)**: `PrimitiveValue` now wraps all primitives in Literal nodes\n2. **When evaluator (`when-expression.ts`)**: `normalizeActionValue()` extracts values from Literal nodes\n3. **Data evaluator (`PrimitiveEvaluator.ts`)**: Added Literal node handling\n4. **Object processing (`var.ts`)**: `evaluateArrayItem()` extracts values from Literal nodes\n\n## Testing\n\n- ‚úÖ All 2367 tests pass\n- ‚úÖ Numeric returns in when expressions work\n- ‚úÖ Object serialization preserves types: `{\"count\":42}` not `{\"count\":\"42\"}`\n- ‚úÖ Array methods with numeric args work: `@arr.includes(3)`\n\n## Follow-up\n\nCreated mlld-62p for full codebase audit to ensure all primitive handling is consistent.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T11:59:53.332409-08:00","updated_at":"2025-12-09T12:31:20.38644-08:00","closed_at":"2025-12-09T12:31:20.38644-08:00"}
{"id":"mlld-4yq","title":"Better error for missing @ prefix in pipeline filters","description":"When user writes '| json' instead of '| @json', the parse error isn't clear. We should detect this pattern (| followed by a bare word that matches a known filter name) and provide a helpful error like: 'Did you mean | @json? Filters require the @ prefix.'","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-17T08:30:09.986607-08:00","updated_at":"2025-12-17T08:30:09.986607-08:00"}
{"id":"mlld-4zhv","title":"SDK execute() treats .mld files as templates/docs instead of executing code","description":"When calling execute('path/to/file.mld', payload) from SDK, .mld files without / prefixes are being treated as templates/docs instead of executable code.\n\nUser report from @partydev:\n- File: /Users/adam/dev/party/proto-4.1/llm/routes/orchestrate.mld\n- Contains .mld code without / prefixes (valid strict mode syntax)\n- execute() result shows effects array with type: 'doc' instead of executing\n- Output contains entire file source as string\n- No show statements execute\n\nThis may be related to mlld-s4qi but affecting the SDK execute() path specifically, not import path.\n\nNeed to investigate:\n1. Does execute() use same mode detection as imports?\n2. Is there a different code path for SDK that wasn't fixed?\n3. Does the isVirtual() fix apply to SDK execution?\n\nBlocking user: @partydev proto-4.1 routing","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-18T21:25:51.602984-08:00","updated_at":"2025-12-19T02:52:26.29787-08:00","closed_at":"2025-12-19T02:52:26.29787-08:00","close_reason":"Fixed MemoryAstCache.parseSource() to pass mode parameter to parse() function. The mode was being used in the cache key but not passed to the parser, causing files to be parsed in the wrong mode."}
{"id":"mlld-4zy","title":"Formatter: mode-aware slash prefix handling","description":"**Summary:**\nFormatter should emit appropriate slash prefix based on mode.\n\n**Changes required:**\n\n1. **Mode detection**:\n   - Formatter receives mode from file extension or explicit option\n   - Track mode throughout formatting pass\n\n2. **Directive formatting**:\n   - Markdown mode: always emit `/` prefix on directives\n   - Strict mode: configurable behavior:\n     - Option A: emit bare directives (no `/`)\n     - Option B: preserve input style (if had `/`, keep it)\n     - Option C: always emit `/` for compatibility\n   - Recommend Option A as default, Option B for `--preserve-style`\n\n3. **Blank line handling**:\n   - Strict mode: blank lines are formatting whitespace, preserve for readability\n   - Markdown mode: blank lines may be content, preserve carefully\n\n4. **Config option**:\n   - `strictModeSlash: 'omit' | 'preserve' | 'include'`\n   - Or simpler: `--bare-directives` flag for strict mode\n\n**Testing:**\n- Format `.mld` file - outputs bare directives (if Option A)\n- Format `.mld.md` file - outputs `/` prefixed directives\n- Format `.mld` with mixed slash usage - normalizes per config","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T20:57:03.568773-08:00","updated_at":"2025-12-08T20:57:03.568773-08:00","dependencies":[{"issue_id":"mlld-4zy","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.486165-08:00","created_by":"daemon"},{"issue_id":"mlld-4zy","depends_on_id":"mlld-gj7","type":"blocks","created_at":"2025-12-08T20:59:32.287836-08:00","created_by":"daemon"}]}
{"id":"mlld-514","title":"Bracket property access causes undefined token length","description":"Complex expressions like @agentTemplates[@responder.agent](@messageBody) produce tokens with undefined length. Partially mitigated with safety checks but underlying calculation bug remains. Line 54 of orchestrate.mld","notes":"Fixed bracket property access: added variableIndex handling in OperatorTokenHelper and VariableVisitor to visit nested VariableReferences","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-12T18:09:31.610153-08:00","updated_at":"2025-12-12T20:53:32.017559-08:00","closed_at":"2025-12-12T20:53:32.017562-08:00"}
{"id":"mlld-587","title":"Differentiate embedded code from mlld (italic style)","description":"Code inside js/sh/py/node blocks should be visually distinct (italic). Currently standard JS syntax highlighting works via WASM. Need to modify embedded code styling.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T07:55:55.765199-08:00","updated_at":"2025-12-14T09:05:29.431346-08:00","closed_at":"2025-12-14T09:05:29.431346-08:00"}
{"id":"mlld-593","title":"Change var/exe/guard/policy directives to use 'modifier' semantic type (pink)","description":"Found via color testing: 'modifier' semantic token type renders as pink italic in user's theme.\n\nChange these definition directives from 'directive' (maps to 'keyword' = light teal) to 'modifier' (pink italic):\n- var\n- exe  \n- guard\n- policy (when added)\n\nFiles to modify:\n- DirectiveVisitor.ts: Update getDirectiveTokenType() or create directiveDefinition token\n- TOKEN_TYPE_MAP: Add 'directiveDefinition': 'modifier'\n- Remove test code after confirming colors\n\nThis gives definitions (var/exe/guard/policy) a distinct pink color from prepositions (for/when/while in light teal).","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-14T11:49:05.508759-08:00","updated_at":"2025-12-14T12:06:02.468864-08:00","closed_at":"2025-12-14T12:06:02.468864-08:00"}
{"id":"mlld-5d2","title":"Clarify template vs module directory imports in docs","description":"Users are confused about when to use:\n- `/import templates from \"dir\" as @name(params)` - for .att/.mtt files\n- `/import \"dir\" as @name` - for index.mld modules\n\n**Confusion:**\nBoth import directories but have different syntax and use cases. Not obvious which to use when.\n\n**Where to clarify:**\n- docs/user/modules.md (import section)\n- llms.txt RULE_9 \n- Error messages when wrong syntax is used\n\n**Better error example:**\n```\nDirectory contains .att/.mtt files. Did you mean:\n  /import templates from \"dir\" as @name(param1, param2)\n```\n\nIdentified by @partydev during scaffold work.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-18T08:58:34.56179-08:00","updated_at":"2025-12-18T08:58:34.56179-08:00"}
{"id":"mlld-5ik","title":"Phase 4: Integration Tests and Polish (Optional)","description":"## Summary\n\nExtended integration tests and polish after core features work. Optional but recommended for production readiness.\n\n## Prereq\n\nPhase 3 core tests (mlld-jw7) must pass first.\n\n## Comprehensive Test Cases\n\n### Test A: Exe Block with Nested For and When\n\n```\n/exe @summarize(projects) = [\n  let @out = []\n  let @errors = []\n\n  for @project in @projects [\n    let @rows = []\n\n    for @task in @project.tasks [\n      when [\n        @task.state == \"done\" =\u003e let @rows += { id: @task.id, pts: @task.points }\n        @task.state == \"blocked\" =\u003e let @errors += { id: @task.id, reason: @task.blocker }\n      ]\n    ]\n\n    let @out += {\n      name: @project.name,\n      total: @rows.length,\n      tasks: @rows\n    }\n  ]\n\n  show \"Projects: @out.length, errors: @errors.length\"\n  =\u003e { results: @out, errors: @errors }\n]\n```\n\n### Test B: For Block with Nested Loop (wrapped in exe)\n\n```\n/exe @processUsers(users) = [\n  for @user in @users [\n    let @active = []\n\n    for @msg in @user.inbox [\n      when [\n        @msg.status == \"unread\" =\u003e let @active += @msg\n      ]\n    ]\n\n    show `User @user.name: @active.length unread`\n  ]\n  =\u003e \"done\"\n]\n\n/show @processUsers(@users)\n```\n\n### Test C: Simple Accumulation Pattern (no var +=)\n\n```\n/exe @buildResults(rows) = [\n  let @results = []\n\n  for @row in @rows [\n    let @acc = { id: @row.id, tags: [] }\n\n    for @tag in @row.tags [\n      let @acc.tags += @tag\n    ]\n\n    let @results += @acc\n  ]\n\n  =\u003e @results\n]\n\n/show @buildResults(@rows) | @json\n```\n\n**Note**: Accumulation uses `let` within exe block scope. No `var +=` syntax exists.\n\n### Test D: Strict Mode (No Slashes)\n\n```\nexe @process(items) = [\n  let @results = []\n\n  for @item in @items [\n    let @results += @item.value\n    show \"Processed: @item.id\"\n  ]\n\n  =\u003e @results\n]\n\nvar @output = @process([{ id: 1, value: \"a\" }])\nshow @output\n```\n\n### Test E: Loose Mode (Top-Level Slashes Only)\n\n```\n/exe @process(items) = [\n  let @results = []\n\n  for @item in @items [\n    let @results += @item.value\n    show \"Processed: @item.id\"\n  ]\n\n  =\u003e @results\n]\n\n/var @output = @process([{ id: 1, value: \"a\" }])\n/show @output\n```\n\n## Edge Cases\n\n- [ ] Empty blocks: `[ ]` should be valid, returns undefined\n- [ ] Return without value: `=\u003e` alone should error\n- [ ] Let without value: Should error at parse time\n- [ ] Nested parallel: Verify parallel specs stack correctly\n- [ ] Error mid-block: Should preserve completed let assignments\n\n## Validation\n\n- [ ] All integration tests pass\n- [ ] Edge cases covered\n- [ ] No regressions in existing functionality\n\n## Notes\n\nScope tightened: no standalone error fixtures; docs handled in mlld-3e6.","notes":"Scope tightened: drop error fixtures; focus on integration/edge tests. Docs handled in mlld-3e6.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T22:20:01.49389-08:00","updated_at":"2025-12-15T20:50:09.177702-08:00","closed_at":"2025-12-10T18:34:10.913029-08:00","dependencies":[{"issue_id":"mlld-5ik","depends_on_id":"mlld-jw7","type":"blocks","created_at":"2025-12-09T22:20:07.023716-08:00","created_by":"daemon"}]}
{"id":"mlld-5jz","title":"CLI: add --loose/--strict mode flags","description":"Partially done: --mode and --strict flags exist. Still need: --loose flag (aliases: --markdown, --md, --prose) to force markdown mode.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T08:28:19.903908-08:00","updated_at":"2025-12-15T20:50:09.178084-08:00","closed_at":"2025-12-11T17:36:42.617941-08:00"}
{"id":"mlld-5n7","title":"Interpreter: thread mode through parser invocation","description":"**Summary:**\nWire the mode flag from entry points through to the parser, with extension-based defaults.\n\n**Changes required:**\n\n1. **Extension ‚Üí mode mapping** (likely in `services/PathService.ts` or new utility):\n   ```typescript\n   function getModeFromPath(filepath: string): 'strict' | 'markdown' {\n     if (filepath.endsWith('.mld.md') || filepath.endsWith('.md')) return 'markdown';\n     if (filepath.endsWith('.mld')) return 'strict';\n     return 'markdown'; // fallback for unknown\n   }\n   ```\n\n2. **Entry points to update:**\n   - `processMlld(script, options)` - add `mode` option, default `'strict'` for raw strings\n   - `interpret(script, options)` - thread mode to parser\n   - `execute(filepath, payload, options)` - derive mode from extension\n   - CLI entry point - derive mode from input file extension\n\n3. **Parser invocation** (wherever `parse()` is called):\n   ```typescript\n   const ast = parse(source, { \n     ...existingOptions,\n     mode: options.mode ?? getModeFromPath(options.filePath) \n   });\n   ```\n\n4. **Options types** (`types/` or relevant interface files):\n   - Add `mode?: 'strict' | 'markdown'` to ProcessOptions, InterpretOptions, ExecuteOptions\n\n**Testing:**\n- Unit test: `.mld` file parses in strict mode\n- Unit test: `.mld.md` file parses in markdown mode\n- Unit test: raw string defaults to strict\n- Unit test: explicit mode option overrides extension inference","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:57:44.878318-08:00","updated_at":"2025-12-15T20:50:09.178444-08:00","closed_at":"2025-12-11T17:17:58.529905-08:00","dependencies":[{"issue_id":"mlld-5n7","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.431674-08:00","created_by":"daemon"},{"issue_id":"mlld-5n7","depends_on_id":"mlld-gj7","type":"blocks","created_at":"2025-12-08T19:59:14.754308-08:00","created_by":"daemon"}]}
{"id":"mlld-5p8","title":"Grammar: extend VariableBoundary escape to all interpolation contexts","description":"**Reported by:** partydev during SDK dogfooding\n\n**Problem:**\nWhen parsing `@agent.att` in paths/strings, the grammar greedily consumes `.att` as field access. Users need a way to say \"stop here, `.att` is literal text (a file extension).\"\n\n**Example:**\n```mlld\n/exe @buildPrompt(msg) = template \"../agents/@agent.att\"\n\u003e\u003e Currently: @agent with field access .att\n\u003e\u003e Wanted: @agent variable + literal .att extension\n```\n\n**Current state:**\n- `VariableBoundary` mechanism exists in `unified-variables.peggy`\n- Syntax: `@var\\` terminates variable, `@var\\\\` produces literal backslash\n- BUT: only used in `UnifiedTemplateVariableReference` (template contexts)\n- AND: boundary check happens AFTER greedy field consumption (wrong order)\n\n**Fix needed:**\n1. Reorder grammar so boundary check happens BEFORE field access consumption\n2. Apply `VariableBoundary` pattern to ALL variable interpolation contexts:\n   - Double-quoted strings\n   - Path contexts (angle brackets)\n   - Template paths in /exe\n   - Any other interpolation context\n\n**User syntax after fix:**\n```mlld\n/exe @buildPrompt(msg) = template \"../agents/@agent\\.att\"\n\u003e\u003e @agent\\ = terminate variable here\n\u003e\u003e .att = literal file extension\n```\n\n**Files to modify:**\n- grammar/base/unified-variables.peggy - fix ordering, ensure boundary works\n- Verify all variable-consuming patterns use the unified pattern\n\n**Future enhancement:**\nConsider adding `@{var}` braced syntax as a more intuitive alternative (separate issue).","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T08:00:13.723859-08:00","updated_at":"2025-12-09T08:06:28.583781-08:00","closed_at":"2025-12-09T08:06:28.583781-08:00"}
{"id":"mlld-5qm","title":"Make @mlld/stream-claude-agent-sdk module work with single-quoted templates","description":"The published module @mlld/stream-claude-agent-sdk uses double-quoted templates which get interpolated as mlld variables during import. Need to republish with single-quoted templates and test.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T20:50:05.396861-08:00","updated_at":"2025-12-08T02:53:01.835237-08:00","closed_at":"2025-12-08T02:53:01.835237-08:00"}
{"id":"mlld-5x5","title":"SDK/CLI: expose mode option and set defaults","description":"**Summary:**\nExpose `mode` option in SDK APIs and CLI, with sensible defaults.\n\n**SDK changes:**\n\n1. **processMlld(script, options)**:\n   - Add `mode?: 'strict' | 'markdown'` to options\n   - Default: `'strict'` when no `filePath` provided (raw strings)\n   - Default: infer from extension when `filePath` provided\n\n2. **interpret(script, options)**:\n   - Add `mode` option, same defaults as processMlld\n\n3. **execute(filepath, payload, options)**:\n   - Add `mode` option\n   - Default: infer from filepath extension\n   - Explicit option overrides inference\n\n4. **Type exports**:\n   - Export `MlldMode = 'strict' | 'markdown'` type\n\n**CLI changes:**\n\n1. **Flag**: `--mode \u003cstrict|markdown\u003e`\n   - Overrides extension-based inference\n   - Useful for testing or unusual file extensions\n\n2. **Extension inference**:\n   - `.mld` ‚Üí strict\n   - `.mld.md` / `.md` ‚Üí markdown\n   - stdin without `--mode` ‚Üí strict (matches SDK raw string default)\n\n3. **Help text**:\n   - Document mode flag and extension defaults\n\n**Testing:**\n- SDK: raw string without filePath uses strict\n- SDK: `.mld` file uses strict\n- SDK: `.mld.md` file uses markdown\n- SDK: explicit mode overrides extension\n- CLI: `--mode markdown` on `.mld` file uses markdown\n- CLI: stdin defaults to strict","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T20:56:33.43397-08:00","updated_at":"2025-12-15T20:50:09.178772-08:00","closed_at":"2025-12-11T17:18:10.75636-08:00","dependencies":[{"issue_id":"mlld-5x5","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.360437-08:00","created_by":"daemon"},{"issue_id":"mlld-5x5","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.172773-08:00","created_by":"daemon"}]}
{"id":"mlld-5y6","title":"Docs: clarify pipeline data shape vs parallel stage output","description":"Docs promise StructuredValue pipeline stages, but still mention parallel groups handing JSON array strings to next stage. Validate actual behavior and update docs to reflect structured pipeline inputs/outputs (including parallel aggregation semantics) once aligned with executor/state machine.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:40:56.370878-08:00","updated_at":"2025-12-08T19:40:56.370878-08:00"}
{"id":"mlld-62p","title":"Audit: Ensure universal StructuredValue compliance","description":"## Goal\n\nAudit and fix the codebase to ensure **universal StructuredValue compliance**:\n\n**All runtime values are StructuredValues** - primitives, strings, arrays, objects, loaded content.\n\n## Policy (now in DATA.md)\n\n**Universal StructuredValue flow:**\n1. **Grammar**: Returns AST Literal nodes `{type: 'Literal', value: 42}`\n2. **Interpreter**: Wraps ALL values in StructuredValue `{type: 'number', text: '42', data: 42, ctx: {...}}`\n3. **Variables**: Wrap StructuredValues (StructuredValueVariable)\n4. **Boundaries**: Use `asData()` for computation, `asText()` for display\n\n## Rationale\n\nWe tried making primitives exceptions but the system fights that. The evidence:\n- `wrapExecResult`, `ensureStructuredValue`, pipelines already wrap primitives\n- Dual representation IS useful: `.text` for templates, `.data` for comparisons, `.ctx` for guards\n- Consistency wins: one model is simpler than special cases\n- We were adding unwrapping hacks everywhere - fighting the design\n\n## Audit Strategy\n\n### Find places that DON'T use asData()/asText()\n\n**Computation boundaries that need `asData()`:**\n- ‚úÖ Comparisons (`toNumber`, `isEqual`) - FIXED\n- Array methods (`.includes()`, `.indexOf()`, `.join()`, etc.)\n- String methods (`.startsWith()`, `.substring()`, etc.)\n- Arithmetic operations\n- Boolean operations\n- Object property access\n- Array indexing\n\n**Display boundaries that need `asText()`:**\n- Template interpolation\n- Shell command arguments  \n- `/show` output\n- Log messages\n- JSON.stringify contexts\n\n### Find places trying to unwrap primitives\n\nSearch for patterns like:\n- Checking `typeof value === 'number'` without extracting first\n- Creating PrimitiveVariable instead of StructuredValueVariable for exec results\n- Avoiding wrapping in `ensureStructuredValue`\n\n### Implementation\n\nUse mlld to parallelize:\n1. Spawn haiku agents for each file category\n2. Each outputs JSON: `{file, needsAsData: [...], needsAsText: [...], wrongUnwrap: [...]}`\n3. Aggregate to `audit-results.jsonl`\n4. Generate fix plan\n5. Apply fixes (parallelized if many)\n\n## Current Status\n\n**Fixed:**\n- ‚úÖ `toNumber()` extracts `.data` from StructuredValue\n- ‚úÖ `extractValue()` in expression.ts handles StructuredValue\n- ‚úÖ Grammar returns Literal nodes consistently\n- ‚úÖ PrimitiveEvaluator extracts Literal values\n- ‚úÖ Object property evaluation handles Literal nodes\n\n**Likely still broken:**\n- ‚ùì Array/string method arg processing\n- ‚ùì Arithmetic expression evaluation\n- ‚ùì Direct property access on StructuredValues\n\n## Next Steps\n\n1. Run the audit script to find all missing `asData()`/`asText()` calls\n2. Prioritize by user impact (comparison operators were P1)\n3. Fix systematically","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T12:26:52.590565-08:00","updated_at":"2025-12-09T15:21:29.593082-08:00"}
{"id":"mlld-6fq","title":"Audit all visitors for column-based position calculations","description":"Many visitors use column arithmetic which is fragile and breaks in specific cases:\n\nUnsafe pattern:\n  const charPos = node.location.start.column + keyword.length + 1;\n\nProblems:\n- Breaks with datatype labels (exe datatype @func)\n- Breaks with multi-byte UTF-8 characters  \n- Breaks with tabs vs spaces\n- Breaks with text between directive and token\n\nSafe pattern:\n  const source = this.document.getText();\n  const atIndex = source.indexOf('@' + identifier, startOffset);\n  const atPos = this.document.positionAt(startOffset + atIndex);\n\nFiles to audit:\n- VariableVisitor.ts lines 129-131 (has WORKAROUND comment)\n- CommandVisitor.ts line 431-439 (simple function calls)\n- ExpressionVisitor.ts (keyword positioning)\n- DirectiveVisitor.ts (mostly fixed, but check other methods)\n\nSearch commands:\n  grep -n '\\.start\\.column.*[+-]' services/lsp/visitors/*.ts\n  grep -n 'start\\.column' services/lsp/visitors/*.ts | grep -v 'positionAt'\n\nAny column + number or column - number is suspect unless immediately passed to positionAt().","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-13T14:24:43.061079-08:00","updated_at":"2025-12-13T14:24:43.061079-08:00","dependencies":[{"issue_id":"mlld-6fq","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T14:24:43.06237-08:00","created_by":"daemon"}]}
{"id":"mlld-6fr","title":"Pipeline: Builtin transformers (@upper, @lower, @trim) not working","description":"Builtin transformers like @upper, @lower, @trim fail in pipeline expressions with 'Pipeline command not found' error.\n\n**Reproduction:**\n```mlld\n/var @x = \"hello\" | @upper\n/show @x\n```\n\n**Error:** `Pipeline command upper not found`\n\n**Root cause:** Two different pipeline code paths exist:\n- unified-processor.ts checks isBuiltinTransformer() and includes builtins\n- executor.ts:636 uses resolveCommandReference() which doesn't check builtin transformers\n\nWhen pipelines execute via /show or /var, they hit executor.ts path which only looks for user-defined executables.\n\n**Fix needed:** resolveCommandReference() should check isBuiltinTransformer(name) before returning null.\n\n**Workaround:** Define transformations explicitly:\n```mlld\n/exe @upper(text) = js { return text.toUpperCase(); }\n```\n\nGitHub issue: #537","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-18T10:20:55.059639-08:00","updated_at":"2025-12-18T10:20:55.059639-08:00"}
{"id":"mlld-6gn","title":"orchestrate.mld tokenization gaps - retest with new validator","description":"Need to retest with improved validator (requireExactType now working).\n\nPrevious: 15 gaps at 93.2% coverage\nAfter validator improvements: Need to rerun to see real gaps vs false positives\n\nThe enhanced validator now correctly distinguishes:\n- Error gaps (missing tokens) vs warning gaps (wrong token type)\n- Only counts error gaps in coverage percentage\n- Shows exact diagnostic info for why tokens are missing\n\nRun: npm run dump:tokens orchestrate.mld -- --diagnostics","notes":"Improved from 93.2% ‚Üí 97.7% coverage using diagnostic system. Remaining 5 gaps: function args not visited (1), variables in run{} shell strings (4 - not in AST). Diagnostic system shows exact root causes.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-12T21:19:49.360719-08:00","updated_at":"2025-12-14T13:40:07.774948-08:00","closed_at":"2025-12-14T13:40:07.774948-08:00","dependencies":[{"issue_id":"mlld-6gn","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-12T21:19:49.36147-08:00","created_by":"daemon"}]}
{"id":"mlld-6vh","title":"'with' keyword should highlight like for/when/while prepositions","description":"The 'with' keyword in pipeline configurations should highlight the same as for/when/while (light teal italic keyword color):\n\nExample: @data | @transform with { parallel: 3 }\nThe 'with' should be light teal italic like 'for'/'when'\n\nCurrently: Not tokenized or using wrong type\nShould: Same as other preposition keywords (keyword semantic type)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T12:15:12.496767-08:00","updated_at":"2025-12-14T14:04:15.024458-08:00","closed_at":"2025-12-14T14:04:15.024458-08:00"}
{"id":"mlld-70b","title":"Change security labels to parameter token type","description":"Change security labels (like 'label' in 'var label @x') from 'label' ‚Üí 'parameter' for light orange/beige color.\n\nFiles to modify:\n- DirectiveVisitor.ts tokenizeSecurityLabels() - change tokenType from 'label' to 'parameter'\n- Update highlight group in nvim config (already has @lsp.type.parameter.mld)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T11:25:57.343106-08:00","updated_at":"2025-12-14T13:46:04.360335-08:00","closed_at":"2025-12-14T13:46:04.360335-08:00"}
{"id":"mlld-72k","title":"Pipeline functions should highlight as functions not variables","description":"Pipeline functions should highlight as functions (purple italic) not variables (light blue).\n\nExample: @data | @transform | @format\nCurrently: @transform and @format highlight as light blue (variable)\nShould: Purple italic (function) since they're function invocations with implicit stdin\n\nAlso: Pipeline highlighting inconsistent across different contexts:\n- Works in some places\n- Broken in others (variables in pipeline position don't get function token type)\n\nSolution: When VariableReference appears in pipeline context, check if it's in a pipe chain and use 'function' token type instead of 'variable'.\n\nFiles: VariableVisitor.ts - check context.inPipeline or similar flag","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T12:15:11.541168-08:00","updated_at":"2025-12-14T13:50:13.735161-08:00","closed_at":"2025-12-14T13:50:13.735161-08:00"}
{"id":"mlld-75e","title":"Allow escaping `@` everywhere with `@@` ","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T08:30:56.452213-08:00","updated_at":"2025-12-09T08:51:20.348654-08:00","closed_at":"2025-12-09T08:51:20.348654-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-76c","title":"LSP Semantic Token Highlighting - Major Progress","description":"MASSIVE progress this session:\n\n‚úÖ Completed:\n- Enhanced validator with requireExactType flag (96.2% coverage, 51 fixtures passing)\n- Fixed variable position bugs (off-by-one/two, bracket expressions, exports)\n- Parameters now gold colored and working everywhere\n- Function call arguments highlighting (fixed computed property call bug)\n- var/exe/guard/policy ‚Üí pink italic (modifier semantic type)\n- exe declarations ‚Üí purple bold (function token type)\n- var declarations ‚Üí light blue bold (variable token type)\n- Variables ‚Üí light blue, Functions ‚Üí purple italic (swapped from original)\n- Embedded code ‚Üí italic with variable interpolation support\n- Language labels (js/py/sh/cmd) ‚Üí teal (type semantic type)\n- Security labels ‚Üí Special color, tokenize for exe blocks\n\n‚ö†Ô∏è Remaining P1 issues:\n- mlld-og8: Action keywords (allow/deny/continue/retry/done)\n- mlld-72k: Pipeline functions should highlight as functions\n- mlld-6vh: 'with' keyword highlighting\n- mlld-ccf: Guard condition highlighting\n- mlld-r2c: run/show/output directives color distinction\n- mlld-7v5: Language labels final color\n- mlld-70b: Security labels final color\n- mlld-6gn: orchestrate.mld remaining gaps\n- mlld-6fq: Column-based calculation audit\n\nValidator improvements documented in LSP-TOKEN-VALIDATOR.md","notes":"Reopening with new issues found in production testing:\n\nProgress:\n- ‚úÖ Variables now highlighting (added highlight groups)\n- ‚úÖ Diagnostic system built (shows WHY tokens missing)\n- ‚úÖ Basic tokenization working (100% on fixtures)\n- ‚ö†Ô∏è Production files reveal nuance and quality issues\n\nNew blocking issues created:\n- mlld-8sn: Parameter highlighting lost [P0]\n- mlld-yd9: Function declarations off-by-two [P0]  \n- mlld-sp9: Import variables not tokenized [P0]\n- mlld-cvf: =\u003e operator needs distinction [P1]\n- mlld-k53: cmd blocks not tokenized [P1]\n- mlld-rxs: datatype labels need prominence [P1]\n- mlld-a1h: Brackets need distinction [P1]\n- mlld-buc: String color inconsistent [P1]\n- mlld-cyz: Comment inconsistency [P2]\n- mlld-3s8: parallel keyword highlighting [P1]\n- mlld-6gn: orchestrate.mld coverage [P0]\n\nDiagnostic system enables rapid fixes - each issue shows exact root cause.","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-12T18:10:20.873684-08:00","updated_at":"2025-12-15T15:38:01.330707-08:00","closed_at":"2025-12-15T15:38:01.330707-08:00","dependencies":[{"issue_id":"mlld-76c","depends_on_id":"mlld-ghp","type":"blocks","created_at":"2025-12-12T18:12:31.136073-08:00","created_by":"daemon"},{"issue_id":"mlld-76c","depends_on_id":"mlld-7t7","type":"blocks","created_at":"2025-12-12T18:12:31.184462-08:00","created_by":"daemon"},{"issue_id":"mlld-76c","depends_on_id":"mlld-ktr","type":"blocks","created_at":"2025-12-12T18:12:31.223626-08:00","created_by":"daemon"},{"issue_id":"mlld-76c","depends_on_id":"mlld-kks","type":"blocks","created_at":"2025-12-12T18:12:31.258569-08:00","created_by":"daemon"},{"issue_id":"mlld-76c","depends_on_id":"mlld-08i","type":"blocks","created_at":"2025-12-12T18:12:31.298441-08:00","created_by":"daemon"},{"issue_id":"mlld-76c","depends_on_id":"mlld-514","type":"blocks","created_at":"2025-12-12T18:12:45.698865-08:00","created_by":"daemon"},{"issue_id":"mlld-76c","depends_on_id":"mlld-ddn","type":"blocks","created_at":"2025-12-12T18:12:45.739929-08:00","created_by":"daemon"},{"issue_id":"mlld-76c","depends_on_id":"mlld-drm","type":"blocks","created_at":"2025-12-12T18:12:45.780623-08:00","created_by":"daemon"}]}
{"id":"mlld-7bi","title":"Detect and warn about --output-format json without streaming","description":"When using --output-format json with the Claude CLI helper without streaming support, it causes JavaScript heap OOM. We should detect this configuration and either: (1) suggest adding 'stream' keyword to the function, or (2) provide a clear error explaining that large JSON responses need streaming. See docs/dev/ERRORS.md for error enhancement patterns.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-17T08:30:10.232247-08:00","updated_at":"2025-12-17T08:30:10.232247-08:00"}
{"id":"mlld-7e7","title":"Executors: Add cwd support to CommandExecutionOptions and executors","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task adds `cwd` support to the command executor options and modifies all executors to use it.\n\n## Prerequisites\n- mlld-e0b in progress or complete (run evaluator passing cwd)\n\n## Task\n1. Add `cwd?: string` to `CommandExecutionOptions` interface\n2. Modify all executors to use `options.cwd` when provided\n\n## Implementation\n\n### Step 1: Update CommandExecutionOptions interface\n\nLocation: `interpreter/env/executors/BaseCommandExecutor.ts` (or wherever CommandExecutionOptions is defined)\n\nFind the interface (likely around line 10-20):\n```typescript\nexport interface CommandExecutionOptions {\n  env?: Record\u003cstring, string\u003e;\n  timeout?: number;\n  captureOutput?: boolean;\n  // ... other options\n  cwd?: string;  // NEW: Optional working directory\n}\n```\n\n### Step 2: Modify ShellCommandExecutor\n\nLocation: `interpreter/env/executors/ShellCommandExecutor.ts`\n\nFind where `spawn` is called (likely around line 340):\n\n**Before:**\n```typescript\nconst child = spawn(safeCommand, {\n  cwd: this.workingDirectory,\n  env,\n  shell: true,\n  // ...\n});\n```\n\n**After:**\n```typescript\nconst child = spawn(safeCommand, {\n  cwd: options?.cwd || this.workingDirectory,  // Use options.cwd if provided\n  env,\n  shell: true,\n  // ...\n});\n```\n\nAlso find the `execAsync` call (around line 297) and update similarly:\n```typescript\nconst { stdout, stderr } = await execAsync(finalCommand, {\n  encoding: 'utf8',\n  cwd: options?.cwd || this.workingDirectory,  // Use options.cwd if provided\n  env: { ...process.env, ...(options?.env || {}) },\n  maxBuffer: 10 * 1024 * 1024\n});\n```\n\n### Step 3: Modify BashExecutor\n\nLocation: `interpreter/env/executors/BashExecutor.ts`\n\nApply the same pattern - find spawn calls and update cwd:\n```typescript\ncwd: options?.cwd || this.workingDirectory\n```\n\n### Step 4: Modify other executors\n\nCheck and update these if they execute processes:\n- `NodeExecutor.ts` - for `/run js {}`\n- `PythonExecutor.ts` - for `/run python {}`\n- `JavaScriptExecutor.ts` - if separate from NodeExecutor\n\nFor each, find where child processes are spawned and apply:\n```typescript\ncwd: options?.cwd || this.workingDirectory\n```\n\n## Pattern\n\nThe pattern is consistent across all executors:\n1. Check if `options?.cwd` is provided\n2. If yes, use it\n3. If no, fall back to `this.workingDirectory` (existing behavior)\n\n## Testing\n\nAfter implementation, test that cwd is actually used:\n\n```bash\necho '/run cmd:/tmp {pwd}' | ./dist/cli.cjs\n# Should output: /tmp\n\necho '/run sh:/home {pwd}' | ./dist/cli.cjs  \n# Should output: /home (if exists)\n```\n\nCheck that commands without cwd still work:\n```bash\necho '/run cmd {pwd}' | ./dist/cli.cjs\n# Should output: current working directory\n```","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:42.69404-08:00","updated_at":"2025-12-08T20:24:57.116324-08:00","closed_at":"2025-12-08T20:24:57.116324-08:00"}
{"id":"mlld-7fa","title":"Tests: add balanced loose/strict coverage post-rollout","description":"Follow-up after fixing current failures: ensure test suites include both strict (.mld) and markdown (.mld.md/raw) coverage, add explicit mode flags where appropriate, and document the defaults. Blocked by mlld-7ng.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T05:16:39.824334-08:00","updated_at":"2025-12-15T20:50:09.179115-08:00","closed_at":"2025-12-11T17:53:35.147288-08:00","dependencies":[{"issue_id":"mlld-7fa","depends_on_id":"mlld-7ng","type":"blocks","created_at":"2025-12-09T05:16:54.846728-08:00","created_by":"adam"}]}
{"id":"mlld-7he","title":"Label semantic type not linked to highlight group","description":"Label token type works for 'var label @name =' but not 'exe label @func() ='. Should use 'macro' highlight group. Currently not linked so appears unhighlighted.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T07:55:53.957012-08:00","updated_at":"2025-12-14T08:37:08.28464-08:00","closed_at":"2025-12-14T08:37:08.28464-08:00"}
{"id":"mlld-7j7","title":"Exe RHS pipeline syntax broken: value | cmd and cmd | cmd patterns fail","description":"## Summary\n\nMultiple  RHS pipeline patterns are failing to parse or execute correctly in strict mode.\n\n## Expected Working Patterns\n\nAll of these should work:\n\n```mlld\n/exe @func(value) = @value | cmd { claude -p --model haiku }\n/exe @func(value) = cmd { @value | claude -p --model haiku }\n/exe @func(value) = @other(value) | cmd { claude -p --model haiku }\n/exe @func(value) = js { return \"hi\" } | cmd { claude -p --model haiku }\n/exe @func(value) = cmd { echo \"hello\" } | cmd { claude -p --model haiku }\n/exe @func(value) = @value | cmd { claude -p } | cmd { claude -p \"wdyt?\" }\n```\n\nBonus (if we can handle escaping):\n```mlld\n/exe @func(value) = cmd { claude -p \"@prompt\" --model haiku }\n```\n\n## Current Behavior\n\n- `@value | cmd {...}` fails with \"Invalid /exe syntax\" parse error\n- `run @value | cmd {...}` also fails\n- User changed to `cmd { @value | claude... }` which should work but returns null/empty\n\n## Why This Matters\n\n**Piping is critical for large/complex content:**\n- Escaping multi-line prompts with special chars is fragile\n- Stdin piping is robust and standard Unix pattern\n- Current audit script (audit-primitive-handling.mld) blocked by this\n\n## Context\n\nWe use this pattern extensively:\n- `scripts/mlld/audit-pathcontext-flow.mld` has `/exe @claude(prompt) = run @prompt | {claude -p}`\n- But it's unclear if this actually works or silently fails\n- We may have tests but they might be too simple (not testing large complex file content)\n\n## Investigation Needed\n\n1. Check grammar for exe RHS pipeline syntax - what's actually supported?\n2. Test with real Claude calls and large file content\n3. Verify existing tests actually cover this (not just toy examples)\n4. Consider deprecating `run` in RHS position (accept but mark deprecated in grammar/CHANGELOG)\n\n## Workaround\n\nUnknown - need to investigate what actually works.\n\n## Impact\n\nBlocks parallel audit script and potentially other mlld-scripting-mlld patterns.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T14:20:38.374747-08:00","updated_at":"2025-12-15T20:50:09.179458-08:00","closed_at":"2025-12-10T19:08:40.540628-08:00"}
{"id":"mlld-7ng","title":"Tests: fix failing suites for strict-mode rollout","description":"Failing test files after strict mode changes:\n- cli/commands/mcp.test.ts\n- interpreter/index.structured.test.ts\n- interpreter/interpreter.fixture.test.ts\n- interpreter/output-formats.test.ts\n- interpreter/output-management.test.ts\n- tests/heredoc.e2e.test.ts\n- tests/integration/imports/basic-patterns.test.ts\n- tests/integration/node-shadow-cleanup.test.ts\n- tests/pipeline/parallel-runtime.test.ts\n\n## interpreter.fixture.test.ts tests/cases\n\n\n  - effects: append-jsonl-basic; append-pipeline-basic; exe-for-effects; exe-for-nested-\n    effects; exe-for-pipeline-retry-effects; exe-when-basic; for-basic-effects; nested-\n    contexts; output-directive-effects; pipeline-function-effects; pipeline-inline-log;\n    pipeline-inline-output-file; pipeline-inline-output-stderr; pipeline-inline-output-\n    stdout; pipeline-inline-retry-replay; pipeline-inline-show; pipeline-retry-effects;\n    var-for-immediate-effects\n  - exe: command-ref-array-preserve\n  - alligator: alligator-glob-concat; ast-name-list-all/class/fn/glob/var; ast-selection;\n    ast-selector-variable; ast-type-filter-all/class/fn/var; ast-wildcard-contains/\n    prefix/single/suffix; edge-cases-boundary; file-references-legitimate; function-args-\n    operators; glob-as-transform; json-autoparse; keep-in-loops; keep-metadata-access;\n    metadata-file/json/url; pipe-transformations; pipeline-contexts; section-extraction;\n    section-list-all/glob/h2/h3; security-labels-files; unified-json-file; unified-text-\n    file; url-markdown-conversion; xml-html-literal\n  - array-operations: slice-basic; slice-negative; slice-variable-indices\n  - augmented-assignment\n  - bash: heredoc-prevents-e2big; large-variable-heredoc\n  - bracket-notation-comprehensive\n  - builtin: typeof-function; builtin-methods-array/string/variables; builtin-type-\n    checking\n  - command-substitution-tty\n  - comments/inline\n  - exe: command-ref-arg-interpolation-basic; function-call-syntax; param-shadowing\n  - expressions-operators; expressions-operators-parsing\n  - file-reference-interpolation\n  - for: directive-actions; exe-template-params; nested-basic/function-calls/output/\n    triple; pipeline-multiple/single; run-command; template-interpolation; when-with-none\n  - frontmatter: alias; basic\n  - html-conversion: basic-article; complex-elements; edge-cases; heading-hierarchy;\n    metadata-extraction; readability-extraction; url-section-extraction\n  - input: env-vars-allowed; input-new-syntax\n  - issue-fixes/issue-459-run-json-field-access\n  - json-backslash-n-preserved\n  - keep-structured\n  - literals-in-function-args\n  - load-content: js-edge-cases; js-unwrap; node-unwrap\n  - method-chain-after-array-access\n  - module-system: command-ref-imports; directive-guard; security-exe-roundtrip;\n    template-interpolation\n  - native-object: github-pattern; node-return; property-access\n  - object-property-access in exec args/functions\n  - object-spread\n  - optional-slash-comprehensive\n  - pipeline: chained-multiple; exe-command-ref-pipeline; exe-reusable-pipes; foreach-\n    structured-value; inline-log-suppressed; inline-output-file; inline-show-basic/retry-\n    replay; interpolation-contexts; native-json-stages; parallel-syntax-parity; pipeline-\n    alias-p-negative-index; pipeline-array-indexing; pipeline-context-basic/edge-cases/\n    preservation; pipeline-multi-stage-retry; pipeline-ordering-integrity; pipes-with-\n    arguments; retry-attempt-tracking; retry-basic/best-of-n/complex-logic/conditional-\n    fallback/hint-function-value/hint-interpolated/hint-object/hint-reception/when-\n    expression/with-none; show-invocation-inline-retry; show-vs-with-basic/retry;\n    vertical-stacked-pipes; when-actions-pipes; when-all-any-pipes; with-clause-pipes\n  - policy: import-policy; union; wants-basic\n  - reserved: input-variable; now-variable; now-variable-lowercase; projectpath-variable\n  - resolver-contexts\n  - run: command-escape-newline-in-quoted\n  - security: guard-after-allow/deny-handled/transform/transform-chain; guard-allow;\n    guard-always; guard-before-after-compose; guard-deny-handled; guard-multiple-\n    handlers; guard-retry; expression-tracking; pipeline-taint; after-guard-retry\n    variants (nonpipeline hints/success/transform; pipeline effects/success); before-\n    guard-retry-success; guard-context-inside-guards; guard-overrides-disable-all/except/\n    only; guard-structured-equality\n  - shell-interpolation: array-from-js-function; array-of-mixed-types/objects-command/\n    objects-stdin; array-with-nulls; booleans-in-objects; deeply-nested-structures;\n    empty-array-command; exec-stdin-complex-array/object; exec-with-complex-param;\n    foreach-complex-elements; jq-with-complex-stdin; json-transformer-output; loader-to-\n    command; mixed-complex-array; mixed-wrapped-simple; multiple-complex-params; nested-\n    arrays-command/stdin; numbers-in-nested-array; object-array-in-template; object-\n    in-command; object-nested-properties; object-via-stdin; object-with-array-property;\n    pipe-sugar-complex-array; pipeline-complex-data; simple-array-expansion/stdin;\n    single-quoted-complex/+apostrophe; special-chars-in-object; structured-value-wrapped;\n    three-level-nesting; undefined-variable-interpolation; user-full-scenario-435; user-\n    scenario-435\n  - template-inline: for-backtick; for-double-colon; inline-show-double-bracket; inline-\n    show-triple; triple-alligator-literal\n  - template-syntax-migration\n  - transformers: chain; csv-basic; json-basic/fromlist/llm-extract-array/generic-fence/\n    inline-prose/invalid/nested/no-json/with-comments; json-llm-extract; json-loose-\n    syntax; json-strict-basic; md-basic; xml-basic\n  - variable-methods: direct-rhs-indexing; method-chaining\n  - when: when-preserve-type-through-pipeline; expression-none-with-vars\n  - with: combined; needs-node; pipeline-basic/input/termination\n  - integration: exe-invocation-module; exe-sh-module; modules/auto-export/explicit-\n    export/metadata; pipeline/ctx-hint-flow-basic/ctx-hint-multistage-mixed-hints/ctx-\n    hint-object/ctx-hint-template-code; executable-transform; formatted-input; hint-\n    command-ref-interpolation; triple-colon-exec\n  - regression: alligator-for-expressions; angle-bracket-literals\n  - slash/exe: code-brackets; command-substitution-interactive/sh; double-colon-\n    content; exe-node-console-log-capture; exe-node-gray-matter-access; exe-node-mlld-\n    dependencies; exe-node-shadow-env-always-created; exe-parameterized-command; js-\n    shadow-env-test; nested-executable-field-access/-var; node-shadow-env; node-\n    undefined-params; optional-slash-run; param-at-syntax; param-interpolation; run-\n    template-exec; shadow-env-undefined-params; shadow-environment/+simple\n  - slash/for: exe-for-expression/nested; for-basic; var-for-function-composition\n  - slash/import: alias; explicit-export-success/wildcard; import-triple-colon-template;\n    imported-array-behavior; mixed; namespace-json/nested/shorthand/special-chars; stdin-\n    json/live/shorthand/text/deprecated; type-static/type-static-inferred; url\n  - slash/output: alligator-content; blank-line-normalization; command; document;\n    file; literal; quoted-path; resolver; security-imported-exec; template-invocation;\n    variable; when-action\n  - slash/path: url; variable-assignment\n  - slash/run: bash-env-vars/multiline/parameters/bash/bash-array-at-syntax; code-with-\n    variables; command-bases-npm-run/ operators/special-patterns; file-content-escaping;\n    no-reinterpret; pipe-operator; quoted-special-chars; run-cmd-syntax-consistency; run-\n    command-bracket-nesting; run-node-console-log-no-capture; shell-escaping; stdin-\n    support\n  - slash/show: all-template-types; alligator-section-as-substring; backtick-template;\n    backtick-with-colon\n  - slash/var: data-array-ast-fix/data-array-path-disambiguation/data-array-valid-\n    patterns/data-object-literals-in-arrays/data-primitive-values; exe-invocation-direct-\n    data/direct-text; foreach-bash-env/foreach-text-template; now-basic-compat; text-\n    assignment-run-slash; text-url; text-variable-copy\n  - slash/when: add-variable-in-action; all-block-action; all-individual-actions; any-\n    block-action; bare-block-action; bare-individual-actions; block-all; exe-conditions;\n    exe-invocation-add/run/tail; exe-when-all-matches; exe-when-expressions/+operators;\n    exe-wildcard-default; first-individual-actions; implicit-actions; let-local-\n    var; negation/+bare-when/+block; none-vs-wildcard; operators-chained; operators-\n    comparison; optional-slash-combined/output/run/show; simple-none; truthiness-edge-\n    cases; var-complex-types; var-function-calls; when-literal-condition; when-negation-\n    switch; when-switch; wildcard-always-true\n  - warnings: bare-variable-reference; directive-in-text-line; template-syntax-in-text\n\nUpdate fixtures/expectations as needed, prioritizing non-strict-text errors first.","notes":"Plan for strict-mode test migration:\n- Default most feature/integration fixtures to strict (.mld, optional slash), unless they assert prose/blank-line semantics.\n- Keep markdown (.mld.md) only where prose behavior matters (content/blank lines/formatter/doc-style output).\n- Duplicate or parametrize only when mode changes behavior: prose handling, bare directives vs text, formatter/prose outputs, LSP/token sensitivity.\n- Use explicit mode in raw-string tests; SDK/CLI defaults stay strict unless prose is expected.\n- Keep LOOSE_TESTMODE=1 as default for stability; add targeted strict runs/subsets to catch regressions.\n- Migration order: 1) convert generic fixtures to strict; 2) add strict variants only for prose-sensitive cases; 3) wire a small strict subset run; 4) align docs/examples mode with intent.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T05:16:23.953965-08:00","updated_at":"2025-12-15T20:50:09.179778-08:00","closed_at":"2025-12-11T17:53:05.285765-08:00"}
{"id":"mlld-7oa","title":"Better error/docs for template collection export limitations","description":"Users try to export template collections from modules and get confusing errors:\n\n```mlld\n/import templates from \"./prompts\" as @prompts(msg, ctx)\n/export { @prompts }  // Error: Variable reference @msg not found\n```\n\nThe error is misleading - the issue is that template collections with parameters can't be exported from modules because the parameters aren't available at import time.\n\n**Solutions:**\n1. Better error message explaining this limitation\n2. Documentation showing the right pattern (import templates at top level, not in modules)\n3. Or support wrapping in /exe for export:\n   ```mlld\n   /exe @prompts.greeting(msg, ctx) = @templates[\"greeting\"](@msg, @ctx)\n   /export { @prompts.greeting }\n   ```\n\nIdentified by @partydev during scaffold work.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-18T08:58:34.850001-08:00","updated_at":"2025-12-18T08:58:34.850001-08:00"}
{"id":"mlld-7t7","title":"@variables appear as plain text in LSP highlighting","description":"Variable highlighting issues in LSP:\n\n1. Method highlighting broken - counting is off, parens inconsistent (e.g., .indexOf(@agent) has wrong positions)\n2. @ symbol should be colored as part of variable name, not separate. Methods (.trim(), .startsWith()) should match variable color\n3. Special variables (@ctx, @state, @time, @input) need distinct highlighting from regular variables\n\nFile: orchestrate.mld - multiple lines affected","notes":"Fixed variable highlighting: combined @ with name, added field tokenization for {{var.field}}, achieved 100% token coverage","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-12T18:07:56.013209-08:00","updated_at":"2025-12-12T20:11:03.597523-08:00","closed_at":"2025-12-12T20:11:03.597526-08:00"}
{"id":"mlld-7v5","title":"Change js/py/sh/cmd/node to property (darker teal, no italic)","description":"Change language labels from 'type' to 'property' semantic type for darker teal (like property_example), without italic.\n\nCurrently: 'embedded' ‚Üí 'type' (lighter teal)\nTarget: 'embedded' ‚Üí 'property' (darker teal, no italic)\n\nFiles: TOKEN_TYPE_MAP change 'embedded' mapping, ensure no italic modifier on language labels","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T11:25:56.256628-08:00","updated_at":"2025-12-14T13:46:04.48655-08:00","closed_at":"2025-12-14T13:46:04.48655-08:00"}
{"id":"mlld-7we","title":"Parser error: newline after bracket expression in exe block let statement","description":"Parser error specific to /for blocks with bracket notation in let statements:\n\n**Fails:**\n```mlld\n/exe @test(registry) = for @id in @registry.ctx.keys =\u003e [\n  let @agent = @registry[@id]\n  =\u003e @agent.tldr\n]\n```\n\n**Works:**\n```mlld\n/exe @test(registry, id) = [\n  let @agent = @registry[@id]  // Standalone exe block OK\n  =\u003e @agent.tldr\n]\n```\n\nThe issue is specific to `for ... =\u003e [...]` block syntax, not general exe blocks.\n\nError: 'Expected end of input but \"\\n\" found' at newline after bracket expression.\n\nBlocking @partydev's multi-agent routing implementation.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-17T21:23:00.932589-08:00","updated_at":"2025-12-18T05:20:54.660592-08:00","closed_at":"2025-12-18T05:20:54.660592-08:00","close_reason":"Fixed for block return statement support. Added ForBlockBody grammar rule to handle let statements with =\u003e return in for ... =\u003e [...] syntax. Regression test at tests/cases/feat/for-block-return/ covers bracket notation and let+return patterns. All tests passing."}
{"id":"mlld-8d6","title":"Phase 1.4: Types - Define AST node types for blocks and while","description":"## Summary\n\nAdd TypeScript type definitions for the new AST nodes introduced by the grammar changes.\n\n## ‚ö†Ô∏è CRITICAL: Types Must Match Grammar Output\n\nThe type definitions below are **starting points**. After grammar is implemented:\n\n1. Run `npm run ast -- '\u003csyntax\u003e'` on each construct\n2. Compare actual grammar output to type definitions\n3. Adjust types to match grammar output exactly\n4. Pay special attention to:\n   - `values` vs direct properties\n   - `with`/pipeline metadata flow\n   - Array wrapping conventions\n\n**DO NOT assume these types are correct** - verify against actual grammar output!\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) to understand existing type hierarchy.\n\n## Files to Modify\n\n- `core/types/index.ts` - Add ExeBlockNode\n- `core/types/for.ts` - Extend ForDirective with actionType\n- `core/types/while.ts` (new) - WhilePipelineStage, WhileDirective types\n- `core/types/control.ts` (new or existing) - DoneLiteral, ContinueLiteral types\n\n## Type Definitions (Starting Points)\n\n### ExeBlockNode\n\n```typescript\nexport interface ExeBlockNode extends BaseMlldNode {\n  type: 'ExeBlock';\n  subtype: 'exeBlock';\n  values: {\n    statements: BaseMlldNode[];\n    return?: BaseMlldNode[];\n  };\n  raw: {\n    statements: string;\n    hasReturn: boolean;\n  };\n  meta: {\n    statementCount: number;\n    hasReturn: boolean;\n  };\n}\n\nexport function isExeBlockNode(node: BaseMlldNode): node is ExeBlockNode {\n  return node.type === 'ExeBlock';\n}\n```\n\n### ForDirective Extension\n\n```typescript\nexport interface ForDirective extends DirectiveNode {\n  kind: 'for';\n  subtype: 'for';\n  values: {\n    variable: VariableReferenceNode[];\n    source: BaseMlldNode[];\n    action: BaseMlldNode[];\n    forOptions?: {\n      parallel?: boolean;\n      cap?: number;\n      rateMs?: number;\n    };\n  };\n  meta: {\n    hasVariables: true;\n    actionType: 'single' | 'block';  // NEW FIELD\n  };\n}\n```\n\n### While Types\n\n```typescript\nexport interface WhilePipelineStage extends BaseMlldNode {\n  type: 'WhileStage';\n  values: {\n    cap: number;\n    rate: number | null;\n    processor: ExeReferenceNode;\n  };\n  meta: {\n    hasCap: true;\n    hasRate: boolean;\n  };\n}\n\nexport interface DoneLiteral extends BaseMlldNode {\n  type: 'ControlLiteral';\n  subtype: 'done';\n  values: {\n    value: BaseMlldNode[];\n  };\n  meta: {\n    hasValue: boolean;\n  };\n}\n\nexport interface ContinueLiteral extends BaseMlldNode {\n  type: 'ControlLiteral';\n  subtype: 'continue';\n  values: {\n    value: BaseMlldNode[];\n  };\n  meta: {\n    hasValue: boolean;\n  };\n}\n\nexport function isDoneLiteral(node: BaseMlldNode): node is DoneLiteral {\n  return node.type === 'ControlLiteral' \u0026\u0026 node.subtype === 'done';\n}\n\nexport function isContinueLiteral(node: BaseMlldNode): node is ContinueLiteral {\n  return node.type === 'ControlLiteral' \u0026\u0026 node.subtype === 'continue';\n}\n```\n\n## Validation\n\n- [ ] All new types extend BaseMlldNode correctly\n- [ ] Type guards are implemented\n- [ ] **Types verified against actual grammar output**\n- [ ] No circular dependencies introduced\n- [ ] Pipeline/with metadata flows correctly","notes":"Added types for exe blocks, while directive/stage, and control literals. Updated pipeline stage union, ForDirective meta actionType union, LiteralNode to allow done/continue payload arrays, and added control type guards. Build passes.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:00.189932-08:00","updated_at":"2025-12-10T00:06:55.847506-08:00","closed_at":"2025-12-10T00:06:55.847508-08:00","dependencies":[{"issue_id":"mlld-8d6","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.241807-08:00","created_by":"daemon"}]}
{"id":"mlld-8ie","title":"LSP: Update for rc78 grammar changes","description":"## Summary\nUpdate language server semantic tokens for all rc78 grammar changes.\n\n**Depends on:** mlld-p25 (mode detection) must be completed first.\n\n## Syntax Changes to Support\n\n### Block Syntax `[...]` (HIGH PRIORITY)\nExe, for, when blocks using bracket delimiters:\n```mlld\n/exe @func() = [\n  let @x = 1\n  let @y = 2\n  =\u003e @x + @y\n]\n\n/for @item in @items [\n  show @item\n  let @count += 1\n]\n```\n\n**Files:** DirectiveVisitor.ts, ExpressionVisitor.ts\n**Tokens needed:**\n- `[` and `]` as operators\n- Block body contents (delegate to existing visitors)\n\n### let Keyword (MEDIUM)\nBlock-scoped variable declarations:\n```mlld\nlet @x = value\nlet @count += 1\n```\n\n**Files:** DirectiveVisitor.ts\n**Tokens:** `let` as keyword, variable as declaration\n\n### while Loops (MEDIUM)\n```mlld\n/while (100) @processor\ndone @value\ncontinue @newState\n```\n\n**Files:** DirectiveVisitor.ts (new handler)\n**Tokens:** `while` as keyword, `done`/`continue` as keywords, limit number\n\n### stream Keyword (LOW)\n```mlld\n/stream @output\nstream @pipe\n```\n\n**Files:** DirectiveVisitor.ts\n**Tokens:** `stream` as keyword\n\n### Command Working Directories (LOW)\n```mlld\n/run cmd:/abs/path { command }\n/run sh:/abs/path { script }\n```\n\n**Files:** CommandVisitor.ts\n**Tokens:** language label includes path, `:` and path as string\n\n### When Semicolons (LOW)\n```mlld\n/when @x \u003e 0 =\u003e \"positive\"; @x \u003c 0 =\u003e \"negative\"; true =\u003e \"zero\"\n```\n\n**Files:** DirectiveVisitor.ts, ExpressionVisitor.ts\n**Tokens:** `;` as operator between arms\n\n### Comments in Blocks (LOW)\n```mlld\n/exe @func() = [\n  \u003e\u003e This is a comment\n  let @x = 1  \u003c\u003c inline comment\n]\n```\n\n**Files:** DirectiveVisitor.ts (already has CommentHelper)\n**Tokens:** Use existing comment tokenization\n\n### AST Selector Wildcards (MEDIUM)\n```mlld\n\u003cfile.ts { handle* }\u003e\n\u003cfile.ts { *fn }\u003e\n\u003cfile.ts { ?? }\u003e\n```\n\n**Files:** FileReferenceVisitor.ts or new\n**Tokens:** `*`, `?`, `??` patterns\n\n### Variable Boundary Escaping (LOW)\n```mlld\n@var\\.ext\n```\n\n**Files:** VariableVisitor.ts\n**Tokens:** Handle backslash-dot as part of variable\n\n## Implementation Approach\n\n1. Start with block syntax `[...]` as it's most visible\n2. Add `let` keyword support\n3. Add `while` loop support\n4. Handle remaining items\n\n## Testing\n```bash\nnpm test services/lsp/semantic-tokens.test.ts\nnpm test services/lsp/semantic-tokens-unit.test.ts\n```\n\n## Acceptance Criteria\n- [ ] Block syntax `[...]` highlights correctly\n- [ ] `let` keyword highlighted as keyword\n- [ ] `while`/`done`/`continue` keywords highlighted\n- [ ] `stream` keyword highlighted\n- [ ] Working directory paths highlighted as strings\n- [ ] Semicolon separators highlighted as operators\n- [ ] Comments in blocks work\n- [ ] AST selector wildcards highlighted\n- [ ] Variable boundary escaping works","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-11T20:12:18.008524-08:00","updated_at":"2025-12-12T01:10:54.982175-08:00","closed_at":"2025-12-12T01:10:54.982175-08:00","dependencies":[{"issue_id":"mlld-8ie","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:42.970143-08:00","created_by":"daemon"},{"issue_id":"mlld-8ie","depends_on_id":"mlld-p25","type":"blocks","created_at":"2025-12-11T21:00:51.03615-08:00","created_by":"daemon"}]}
{"id":"mlld-8l8","title":"Add ?? null coalescing operator","description":"User request from @partydev for simplified optional value handling.\n\nCurrent syntax for default values:\nwhen first [\n  @value =\u003e show \"Result: @value\"\n  * =\u003e show \"Result: (none)\"\n]\n\nProposed syntax:\nshow `Result: @value ?? \"(none)\"`\n\nCommon pattern across JS, C#, Swift, etc. Cleaner for simple default value cases.\n\nSee: /Users/adam/dev/party/mlld-feature-request-routing.md","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-12-18T17:51:38.827652-08:00","updated_at":"2025-12-19T03:04:36.920791-08:00","closed_at":"2025-12-18T19:19:33.083242-08:00"}
{"id":"mlld-8ml","title":"Pipeline state machine uses text channel instead of structured values","description":"PipelineExecutor loops state machine transitions on the .text string while stage inputs/outputs are StructuredValue. State machine START/STAGE_RESULT transitions only see text, so metadata/provenance/security are invisible to control flow and retries. Align state machine payloads with structured values (or dual channel) so pipeline retries and downstream guards use full data.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-08T19:40:41.102258-08:00","updated_at":"2025-12-15T20:50:09.18016-08:00","closed_at":"2025-12-10T23:07:34.419718-08:00"}
{"id":"mlld-8sn","title":"Parameters not highlighting in editor despite validator passing","description":"VERIFIED FIXED: Parameters now gold colored.\n\nFinal solution:\n- Keep parameters as 'parameter' semantic type\n- Remove highlight group override (let theme's natural parameter color apply)\n- Theme's natural parameter color = gold ‚úì\n- Fixed argument visiting bug in CommandVisitor.ts for computed property calls\n\nParameters now work everywhere:\n- exe declarations: @func(agent, msg) ‚Üí gold ‚úì\n- Import templates: @agentTemplates(message) ‚Üí gold ‚úì\n- Function call args: @haiku(@prompt) ‚Üí highlighted ‚úì\n- Computed calls: @templates[@key](@arg) ‚Üí highlighted ‚úì","notes":"Validator investigation complete:\n- Parameter tokens ARE being generated correctly (validator shows 100% coverage)\n- Positions are correct: agent@19, msg@26, turnP@31 on line 8\n- FileReferenceVisitor.visitParameter() is correctly registered and implemented\n- TOKEN_TYPES includes 'parameter' at index 6\n- Same ASTSemanticVisitor used by both validator and LSP server\n\nIssue must be in:\n1. LSP protocol encoding/transmission\n2. Editor not receiving tokens\n3. Different code path in actual LSP server\n4. Or editor configuration issue\n\nNext: Test actual LSP server output to editor","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-13T05:32:26.559376-08:00","updated_at":"2025-12-14T12:55:49.665512-08:00","closed_at":"2025-12-14T12:55:49.665514-08:00","dependencies":[{"issue_id":"mlld-8sn","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:32:26.55984-08:00","created_by":"daemon"}]}
{"id":"mlld-8zi","title":"Grammar: @ in method string arguments incorrectly parsed as variable reference","description":"In when-expressions, method calls with double-quoted string arguments containing @ like `.startsWith(\"@\")` fail to parse because the @ is being interpreted as a variable reference instead of a literal character in the string.\n\nReproduction:\n```\n/exe @fn(msg) = when first [\n  @msg.body.startsWith(\"@\") =\u003e \"yes\"\n  * =\u003e \"no\"\n]\n```\n\nThis should parse successfully but fails with 'Invalid /exe syntax'.\n\nWorkaround: Use single quotes instead: `.startsWith('@')`","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T11:35:40.40568-08:00","updated_at":"2025-12-09T11:42:04.332574-08:00","closed_at":"2025-12-09T11:42:04.332574-08:00"}
{"id":"mlld-964","title":"Add /prompt directive for SDK-coordinated user input","description":"Enable scripts to request user input without bailing out, for SDK-based interactive workflows:\n\n```mlld\n/var @answer = prompt \"Continue with deployment? (y/n)\"\n/when @answer == \"y\" =\u003e /run sh {./deploy.sh}\n```\n\n**Design:**\n- /prompt emits a special effect (type: 'prompt') with the question\n- SDK intercepts this, pauses execution\n- SDK collects user input through its own UI/CLI\n- SDK resumes execution with the user's response\n- Script continues with @answer populated\n\n**Use cases:**\n- Agent workflows that need human confirmation\n- Interactive deployment/migration scripts\n- Multi-step processes with decision points\n\n**NOT for:**\n- Non-interactive batch execution (should fail gracefully)\n- CLI-only usage (use shell read instead)\n\nThis enables SDK-based agents to coordinate with users without breaking out of the mlld script entirely.\n\nRequested by @partydev for agent scaffold pattern.","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-17T17:31:29.710415-08:00","updated_at":"2025-12-17T17:31:29.710415-08:00"}
{"id":"mlld-9i7","title":"LSP: Add semantic token support for .att and .mtt template files","description":"## Summary\nAdd Language Server Protocol support for mlld template files (.att and .mtt), providing semantic tokens for syntax highlighting.\n\n## Background\n\nmlld has two template file types:\n- `.att` - \"At Template\" - uses `@var` interpolation (like `::...::` templates)\n- `.mtt` - \"Mustache Template\" - uses `{{var}}` interpolation (like `:::...:::` templates)\n\nBoth support:\n- `/for @item in @collection` ... `/end` loops\n- `/when @condition` ... `/end` conditionals\n- `\u003cfile.md\u003e` file references\n- `\u003e\u003e` and `\u003c\u003c` comments\n\nCurrently the LSP only supports `.mld` and `.mld.md` files.\n\n## Implementation\n\n### 1. Register File Extensions\nIn `cli/commands/language-server-impl.ts`, update `getModeFromUri`:\n```typescript\nfunction getModeFromUri(uri: string): MlldMode {\n  const path = uri.replace('file://', '');\n  if (path.endsWith('.mld.md') || path.endsWith('.mlld.md')) {\n    return 'markdown';\n  }\n  if (path.endsWith('.mld') || path.endsWith('.mlld')) {\n    return 'strict';\n  }\n  if (path.endsWith('.att') || path.endsWith('.mtt')) {\n    return 'template'; // New mode for template files\n  }\n  return 'markdown';\n}\n```\n\n### 2. Add Template Mode to Parser\nCheck if grammar already supports parsing template files. If not:\n- Templates are simpler - mainly text with interpolation and control flow\n- May need a `startRule: 'Template'` option\n\n### 3. Create Template Visitors\nTemplate files have different syntax than full mlld:\n- No `/var`, `/exe`, `/import`, etc. - just content with interpolation\n- Control flow: `/for`, `/when`, `/end`\n- File references: `\u003cfile.md\u003e`\n\nOptions:\na) Reuse existing visitors with template context\nb) Create specialized `TemplateFileVisitor`\n\n### 4. Handle Interpolation Differences\n- `.att` files: tokenize `@var` as interpolation\n- `.mtt` files: tokenize `{{var}}` as interpolation\n\nThe visitor needs to know which template type based on extension.\n\n### 5. Update Document State\nStore template type in DocumentState:\n```typescript\ninterface DocumentState {\n  uri: string;\n  mode: MlldMode;\n  templateType?: 'att' | 'mtt'; // NEW\n  // ...\n}\n```\n\n## Files to Modify\n- `cli/commands/language-server-impl.ts` - Extension detection, document state\n- `cli/commands/language-server.ts` - DocumentState interface\n- `services/lsp/visitors/` - Template handling (new or modified visitors)\n- Grammar may need template parsing support\n\n## Testing\n```bash\n# Create test files\necho '@name said: @message' \u003e tmp/test.att\necho '{{name}} said: {{message}}' \u003e tmp/test.mtt\n\nnpm test services/lsp/semantic-tokens.test.ts\n```\n\n## Acceptance Criteria\n- [ ] .att files recognized by LSP\n- [ ] .mtt files recognized by LSP\n- [ ] @var in .att highlighted as interpolation\n- [ ] {{var}} in .mtt highlighted as interpolation\n- [ ] /for, /when, /end highlighted as keywords\n- [ ] \u003cfile.md\u003e highlighted as file reference\n- [ ] Comments \u003e\u003e and \u003c\u003c highlighted\n\n## Depends On\n- Check if grammar supports template file parsing\n- May need grammar work first","notes":"**NEEDS BETTER DESIGN** - Wrapping approach proved too fragile\n\n**What was tried:**\n- Wrapping .att content as `/var @_template = ::content::` before parsing\n- Extracting template parts from the directive AST\n- Adjusting node locations back to original file positions\n- Attempting to handle line/column/offset adjustments\n\n**Why it failed:**\n- Location adjustment is extremely fragile (offset vs line vs column)\n- Multi-line content makes column adjustment inconsistent\n- Nested structures (TemplateForBlock, FileReference) have deep location trees\n- Only got 1 of 4 variables to highlight, errant highlighting everywhere\n- Too many edge cases, too much complexity\n\n**What we need:**\nA proper design that either:\n1. Adds a grammar start rule for template content (parse as TemplateContent not Document)\n2. Creates a dedicated template file parser (separate from main mlld grammar)\n3. Uses a different tokenization strategy that doesn't require AST wrapping/unwrapping\n\n**What works so far:**\n- ‚úÖ Filetype registration in nvim (reverted for now)\n- ‚úÖ File extension detection (reverted for now)\n- ‚úÖ Template context concept (doubleColon for .att, tripleColon for .mtt)\n\n**Preserved improvement:**\n- Added onDidOpen handler to language-server-impl.ts (fixes initial document analysis for ALL file types)\n\n**Next steps:**\n- Research grammar start rules and template parsing strategies\n- Design a clean approach before implementing\n- Consider if .att/.mtt really need full LSP or just basic syntax highlighting","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-12T07:22:57.491298-08:00","updated_at":"2025-12-18T18:02:38.333464-08:00","dependencies":[{"issue_id":"mlld-9i7","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-12T07:23:09.694583-08:00","created_by":"daemon"}]}
{"id":"mlld-9id","title":"Phase 2.2: Interpreter - Add evaluateExeBlock() to exe.ts","description":"## Summary\n\nAdd exe block evaluation to the interpreter, reusing the exported let/augmented assignment functions from when.ts.\n\n## Key Insight\n\nExe blocks are ~80% the same as exe..when! An exe block is just a when expression without conditions (or with implicit `* =\u003e`). Massive reuse opportunity.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Return values should preserve wrappers\n\n## ‚ùå DON'T DO (Explicit Restrictions)\n\n1. **Field access mutation in +=**: `let @data[-1].field += value`\n   - Error: \"ETOOCOMPLEX: Augmented assignment only supports simple variables.\"\n   - Only support: `let @variable += value` (simple variable names)\n\n2. **Multiple return statements**: `=\u003e @x ... =\u003e @y`\n   - Error at parse time: \"Return statement must be last in exe block\"\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n- mlld-zeo (Export let functions)\n\n## Files to Modify\n\n- `interpreter/eval/exe.ts` - Add evaluateExeBlock() function\n\n## Implementation\n\nAdd after existing exe evaluation code (around line 50):\n\n```typescript\nimport { isLetAssignment, isAugmentedAssignment } from '@core/types/when';\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n\nasync function evaluateExeBlock(\n  block: ExeBlockNode,\n  env: Environment,\n  args: Record\u003cstring, unknown\u003e\n): Promise\u003cunknown\u003e {\n  // Create child environment for block scope\n  let blockEnv = env.createChild();\n\n  // Bind parameters to arguments\n  for (const [param, value] of Object.entries(args)) {\n    const importer = new VariableImporter();\n    const variable = importer.createVariableFromValue(\n      param, \n      value, \n      'exe-param', \n      undefined, \n      { env: blockEnv }\n    );\n    blockEnv.setVariable(param, variable);\n  }\n\n  // Execute statements sequentially\n  for (const stmt of block.values.statements) {\n    if (isLetAssignment(stmt)) {\n      blockEnv = await evaluateLetAssignment(stmt, blockEnv);\n    } else if (isAugmentedAssignment(stmt)) {\n      blockEnv = await evaluateAugmentedAssignment(stmt, blockEnv);\n    } else {\n      const result = await evaluate(stmt, blockEnv);\n      blockEnv = result.env || blockEnv;\n    }\n  }\n\n  // Handle return statement (required, must be last)\n  if (block.values.return) {\n    const returnResult = await evaluate(block.values.return, blockEnv);\n    return returnResult.value;\n  }\n\n  return undefined;\n}\n```\n\n## Wire into evaluateExe()\n\nUpdate around line 500 to detect and handle ExeBlock:\n\n```typescript\n// After checking for when expressions, add:\nif (content \u0026\u0026 content.type === 'ExeBlock') {\n  return await evaluateExeBlock(content, env, boundArgs);\n}\n```\n\n## Validation\n\n- [ ] Block creates child environment\n- [ ] Parameters bound correctly\n- [ ] Let assignments create scoped variables (as StructuredValue)\n- [ ] Augmented assignments work on arrays/strings/objects\n- [ ] Return statement evaluates and returns value (preserving wrapper)\n- [ ] Environment chaining preserved\n- [ ] Field access mutation throws helpful error","notes":"‚úÖ PREREQUISITE UPDATE: Type enums completed in mlld-b4f. ExeBlockNode interface verified in core/types/exe.ts. DirectiveSubtype includes 'exeBlock'. Type guard available: isExeBlockNode(). All AST structures validated. Ready for interpreter implementation once mlld-zeo (export let functions) is complete.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:17:46.580094-08:00","updated_at":"2025-12-15T20:50:09.180501-08:00","closed_at":"2025-12-10T14:00:49.063251-08:00","dependencies":[{"issue_id":"mlld-9id","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:51.917186-08:00","created_by":"daemon"},{"issue_id":"mlld-9id","depends_on_id":"mlld-zeo","type":"blocks","created_at":"2025-12-09T22:18:52.011176-08:00","created_by":"daemon"}]}
{"id":"mlld-9k6","title":"Fix function call arguments not highlighting","description":"Arguments in function invocation position not highlighting:\n\nExample: @agentTemplates[@responder.agent](@messageBody)\nThe @messageBody in argument position is not highlighted.\n\nAlso: @haiku(@prompt) - @prompt not highlighted\n\nIssue: ExecInvocation arguments need tokenization. Currently only the function name and operators are tokenized, but the arguments (VariableReference nodes in args array) are not being visited.\n\nFiles: CommandVisitor.ts - check ExecInvocation handling","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-14T12:27:03.205854-08:00","updated_at":"2025-12-14T12:36:03.767907-08:00","closed_at":"2025-12-14T12:36:03.767907-08:00"}
{"id":"mlld-9o7","title":"alias @base -\u003e @root, make @root default everywhere","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T13:18:31.724492-08:00","updated_at":"2025-12-09T13:18:31.724492-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-9pl","title":"Phase 1.1: Grammar - Add ExeStatementBlock and ForActionBlock patterns","description":"## Summary\n\nAdd `[...]` block patterns to exe and for directives, reusing existing when-block infrastructure.\n\n## üîë Critical Design Decision: `[...]` Not `{...}`\n\n**Why blocks use `[...]` instead of `{...}`:**\n- `{...}` is already used for code/commands/data objects\n- `[...]` is consistent with when blocks (already use this)\n- Zero ambiguity, no lookahead needed\n- LLM-friendly: clear visual separation from JS/shell\n\n**Array vs Block Disambiguation:**\n- In exe/for context, `[...]` is **ALWAYS** a block\n- Array literals only valid in `var` context\n- Context determines meaning - no grammar tricks needed\n\n**Examples:**\n```mlld\nexe @func() = [let @x = 1 =\u003e @x]    # Block (statements)\nexe @func() = [1, 2, 3]              # Also block (3 expressions - likely error)\nexe @arr() = {[1, 2, 3]}             # Escape hatch: object containing array\nvar @arr = [1, 2, 3]                 # Array literal (var context)\n```\n\n## ‚ö†Ô∏è IMPORTANT: Grammar Snippets Are Starting Points\n\nThe grammar snippets below are **starting points pending abstraction discovery findings** (mlld-cw9). The discovery phase may reveal better patterns to reuse. Don't copy these verbatim - use them as inspiration after understanding what already exists.\n\n## Strict vs Loose Mode Clarification\n\n- **Strict mode**: No slashes on directives (pure mlld)\n- **Loose mode**: Requires `/` on top-level directives (markdown-friendly)\n- **Inner statements**: Slashless in BOTH modes (inside blocks)\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) first to understand what can be reused.\n\n## Files to Modify\n\n- `grammar/patterns/exe-rhs.peggy` - Add ExeBlockPattern\n- `grammar/directives/for.peggy` - Add ForActionVariant\n- `grammar/patterns/iteration.peggy` - Add ForBlockAction pattern\n\n## Grammar Implementation (Starting Points)\n\n### ExeBlockPattern (in exe-rhs.peggy)\n\nBased on discovery, likely reuses `WhenExpressionEntry` + return statement:\n\n```peggy\nExeStatementBlock \"exe statement block\"\n  = \"[\" _ statements:ExeBlockStatementList _ returnStmt:ExeReturnStatement? _ \"]\" {\n      return {\n        type: 'ExeBlock',\n        subtype: 'exeBlock',\n        source: 'block',\n        values: {\n          statements: statements,\n          ...(returnStmt ? { return: returnStmt } : {})\n        },\n        raw: {\n          statements: helpers.reconstructRawString(statements),\n          hasReturn: !!returnStmt\n        },\n        meta: {\n          statementCount: statements.length,\n          hasReturn: !!returnStmt\n        }\n      };\n    }\n```\n\n### ExeBlockStatementList\n\nLikely reuses existing patterns:\n\n```peggy\nExeBlockStatementList\n  = first:ExeBlockStatement rest:(_ stmt:ExeBlockStatement { return stmt; })* {\n      return [first, ...rest];\n    }\n\nExeBlockStatement \"exe block statement\"\n  = LetAssignment              // let @x = value\n  / AugmentedAssignment        // @x += value\n  / EffectAction               // show, log, output, append\n  / WhenRHSVarAssignment       // var @x = value (outer scope)\n  / WhenRHSCommandAction       // cmd {...}\n  / WhenRHSFunctionCall        // @func()\n  / VarRHSContent              // Any expression\n```\n\n### ForActionVariant\n\n```peggy\nForActionVariant\n  = \"=\u003e\" _ action:ForSingleAction {\n      return { type: 'single', action: Array.isArray(action) ? action : [action] };\n    }\n  / \"[\" _ statements:ForBlockStatementList _ \"]\" {\n      return { type: 'block', statements };\n    }\n```\n\n### Update ExeRHSContent ordering\n\n```peggy\nExeRHSContent \"exe assignment value\"\n  = WhenExpression              # when [...]\n  / ForExpressionExe            # for =\u003e [...]\n  / ExeCodePattern              # js {...}\n  / ExeCommandPattern           # cmd {...}\n  / ExeDataPattern              # {key: value}\n  / ExeStatementBlock           # NEW - [statements] (after data)\n  / ... rest\n```\n\n## Error Recovery\n\nAdd helpful error messages for:\n- Unterminated `[` - \"Unterminated block. Expected ']' to close block.\"\n- Comma separators - \"Use newlines between statements, not commas\"\n- Multiple returns - \"Only one return allowed as last statement\"\n\n## Statement Separator Rules\n\nUse whitespace separation like when blocks:\n- When.peggy lines 440-457 show the pattern\n- Error helpfully on commas\n\n## Testing\n\nAfter building grammar:\n```bash\nnpm run build:grammar\nnpm run ast -- 'exe @f() = [let @x = 1 =\u003e @x]'\nnpm run ast -- 'for @x in @xs =\u003e [show @x]'\n```\n\n## Validation\n\n- [ ] ExeStatementBlock parses correctly\n- [ ] ForActionBlock parses correctly  \n- [ ] Error recovery works for common mistakes\n- [ ] AST output matches type definitions\n- [ ] Strict mode works (no leading /)\n- [ ] Loose mode works (requires leading /)","notes":"Grammar: added exe statement blocks and for block actions with block separators, return handling, and error recovery; ForActionVariant handles block vs single; ExeRHSContent routes to blocks. build:grammar/build passed.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:14:45.573522-08:00","updated_at":"2025-12-15T20:50:09.180953-08:00","closed_at":"2025-12-10T02:36:55.739254-08:00","dependencies":[{"issue_id":"mlld-9pl","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.021026-08:00","created_by":"daemon"}]}
{"id":"mlld-9pv","title":"Epic: Block error reparse helper","description":"Add reparse-on-failure helper to surface inner-line parse errors for all [..] block constructs (exe blocks, for blocks, when blocks/match, guard blocks, foreach if applicable). Deliver: grammar-core helper + per-block wiring to reparse inner text with correct offsets, plus fixtures for improved diagnostics.","notes":"Block reparse helper landed across exe/for/when/guard, docs updated, changelog noted, targeted test added; grammar build passes.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T02:50:58.903344-08:00","updated_at":"2025-12-10T07:06:03.718621-08:00","closed_at":"2025-12-10T07:06:03.718623-08:00"}
{"id":"mlld-9pv.1","title":"Grammar-core: add reparseInner helper","description":"Add helpers.reparseInner(innerText, startRule, offset) in grammar/deps/grammar-core.ts to reparse block contents and rethrow mlldError with corrected locations. Should offset location() by block start and be safe for block contexts only.","notes":"Reparse helper implemented and wired; tests added.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:04.553133-08:00","updated_at":"2025-12-10T07:05:42.428859-08:00","closed_at":"2025-12-10T07:05:42.428861-08:00","dependencies":[{"issue_id":"mlld-9pv.1","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:04.553578-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.2","title":"Wire reparse helper for exe blocks","description":"Use grammar-core reparse helper in exe statement block parsing to re-run inner text on failure and surface inner-line errors; include unterminated block and return-last checks.","notes":"Exe block reparse wiring done; regression test covers block errors.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:11.017812-08:00","updated_at":"2025-12-10T07:05:48.053412-08:00","closed_at":"2025-12-10T07:05:48.053413-08:00","dependencies":[{"issue_id":"mlld-9pv.2","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:11.018285-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.3","title":"Wire reparse helper for for blocks","description":"Apply reparse helper to for block actions so inner errors point to the failing statement; handle unterminated block and comma/return diagnostics.","notes":"For block reparse wiring complete; included in shared block error test.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:15.726975-08:00","updated_at":"2025-12-10T07:05:53.976319-08:00","closed_at":"2025-12-10T07:05:53.97632-08:00","dependencies":[{"issue_id":"mlld-9pv.3","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:15.727462-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.4","title":"Wire reparse helper for when/guard blocks","description":"Integrate reparse helper for when block/match and guard block parsing so inner condition/action errors report precise locations; ensure comma/unterminated handling remains.","notes":"When/guard block reparsing wired; block error test covers when/guard.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:22.663089-08:00","updated_at":"2025-12-10T07:05:59.402809-08:00","closed_at":"2025-12-10T07:05:59.40281-08:00","dependencies":[{"issue_id":"mlld-9pv.4","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:22.663541-08:00","created_by":"adam"}]}
{"id":"mlld-9qq","title":"Docs: audit strict vs markdown defaults","description":"Audit user/dev docs and examples to align with strict vs markdown modes. Scope:\\n- Default examples to strict unless prose semantics are needed.\\n- Identify docs needing mode updates and open individual cards per doc for edits.\\n- Ensure flags/CLI/SDK mode defaults are documented, with strict for modules and markdown for prose.\\n- Recommend keeping LOOSE_TESTMODE noted for test guidance.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:28:51.672034-08:00","updated_at":"2025-12-09T08:28:51.672034-08:00"}
{"id":"mlld-a03","title":"LSP: Comprehensive update for rc78 and editor support","description":"Epic tracking comprehensive LSP updates for:\n1. rc78 grammar changes (blocks, let, while, streaming, etc.)\n2. Strict mode support\n3. Outstanding editor-support GitHub issues\n\n## Architecture Overview\n\nThe LSP implementation uses a visitor-based architecture:\n\n**Core Files:**\n- `cli/commands/language-server-impl.ts` - Main LSP server, handles parsing and semantic tokens\n- `services/lsp/ASTSemanticVisitor.ts` - Dispatches nodes to specialized visitors\n- `services/lsp/visitors/` - Specialized visitors for different node types:\n  - `DirectiveVisitor.ts` - Handles /var, /show, /when, /for, /exe, etc.\n  - `ExpressionVisitor.ts` - Binary, unary, ternary, when, for expressions\n  - `VariableVisitor.ts` - Variable references and field access\n  - `CommandVisitor.ts` - Command execution and references\n  - `TemplateVisitor.ts` - String literals and templates\n  - `StructureVisitor.ts` - Objects, arrays, properties\n  - `FileReferenceVisitor.ts` - File references, comments, frontmatter\n  - `ForeachVisitor.ts` - Foreach command syntax\n\n**Helper Classes in `services/lsp/utils/`:**\n- `OperatorTokenHelper.ts` - Operator tokenization\n- `CommentTokenHelper.ts` - Comment handling\n- `LanguageBlockHelper.ts` - Embedded language blocks\n- `TemplateTokenHelper.ts` - Template contexts\n- `TokenBuilder.ts` - Token generation\n\n**Current Gap:** The LSP always parses with `mode: 'markdown'` (hardcoded default). It doesn't detect file extensions or pass mode to the parser.\n\n## Execution Strategy\n\n### Phase 1: Mode-Aware Foundation (CRITICAL PATH)\nUnblocks all other work. Must complete first.\n- Detect `.mld` vs `.mld.md` from document URI\n- Pass mode to parser in all parse() calls\n- Adjust DirectiveVisitor for bare directives in strict mode\n\n### Phase 2: rc78 Grammar Changes (HIGH VALUE)\nIndependent features, can be parallelized:\n- Block syntax `[...]` for exe/for/when\n- `let` keyword for block-scoped variables\n- `while` loops with `done`/`continue`\n- `stream` keyword and `/stream` directive\n- Working directories `cmd:/path`\n- When semicolons\n- Comments in blocks\n- AST selector wildcards\n- Variable boundary escaping\n\n### Phase 3: Bug Fixes (QUICK WINS)\nSmall, scoped fixes from GitHub issues:\n- GH#327: when block assignment\n- GH#328: pipe transform parity\n- GH#329: EOL comments in when\n- GH#330: variable interpolation in /run\n- GH#331: function execution in /run\n- GH#332: array/object value highlighting\n\n### Phase 4: Error Recovery (LARGER SCOPE)\n- Chunk-based parsing for better error recovery (GH#335)\n\n## Testing\n\n```bash\n# Run LSP tests\nnpm test services/lsp/\n\n# Run specific test file\nnpm test services/lsp/semantic-tokens.test.ts\n\n# Run coverage tests\nMLLD_TOKEN_COVERAGE=1 npm test services/lsp/semantic-tokens-coverage.test.ts\n```\n\n## Debugging\n\n```bash\n# Server-side debug logging\nDEBUG=mlld:lsp mlld language-server\n\n# AST inspection\nnpm run ast -- 'your syntax here'\n```\n\nSee `docs/dev/LANGUAGE-SERVER.md` for full documentation.","status":"open","priority":0,"issue_type":"epic","created_at":"2025-12-11T20:12:45.617648-08:00","updated_at":"2025-12-11T21:00:02.162072-08:00"}
{"id":"mlld-a09","title":"LSP: Fix when block assignment highlighting (GH#327)","description":"## Summary\nExplicit assignment in when blocks shows 'Other' type instead of proper highlighting.\n\nGitHub: https://github.com/mlld-lang/mlld/issues/327\n\n## Problem\nWhen using explicit variable assignment in when blocks, the assignment doesn't get highlighted:\n\n```mlld\n/when @condition [\n  var @result = \"value\"  \u003c\u003c 'var' and '@result' show as 'Other'\n]\n```\n\n## Root Cause\nThe DirectiveVisitor's when block handling doesn't process nested `var` declarations inside block bodies.\n\n## Implementation\n\n### Locate the Issue\nIn `services/lsp/visitors/DirectiveVisitor.ts`, find `visitWhenDirective` method.\n\nThe when block body contains statements that need to be visited. Check if the body is being recursively visited:\n\n```typescript\n// In visitWhenDirective, ensure body statements are visited\nif (node.values?.body \u0026\u0026 Array.isArray(node.values.body)) {\n  for (const stmt of node.values.body) {\n    this.mainVisitor.visitNode(stmt, context);\n  }\n}\n```\n\n### Fix Approach\n1. Ensure when block bodies are recursively visited\n2. Var/let statements inside blocks should be processed as directives\n3. Variable declarations should get 'variable' token with 'declaration' modifier\n\n## Testing\n```bash\nnpm run ast -- '/when @x [var @y = 1]'\n# Check AST structure to understand node types\n\nnpm test services/lsp/semantic-tokens.test.ts\n```\n\n## Files to Modify\n- `services/lsp/visitors/DirectiveVisitor.ts` - visitWhenDirective method\n\n## Size\nSmall - likely a few lines to add recursive visitation","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:37.357221-08:00","updated_at":"2025-12-11T22:05:24.320612-08:00","closed_at":"2025-12-11T22:05:24.320612-08:00","dependencies":[{"issue_id":"mlld-a09","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.386572-08:00","created_by":"daemon"}]}
{"id":"mlld-a1h","title":"Brackets {} and [] need distinct highlighting","description":"Curly braces {} and square brackets [] should have distinct highlighting to make structure clearer. Currently both are generic operators.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T05:31:44.802002-08:00","updated_at":"2025-12-14T15:40:43.263397-08:00","closed_at":"2025-12-14T15:40:43.263397-08:00","dependencies":[{"issue_id":"mlld-a1h","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:31:44.802485-08:00","created_by":"daemon"}]}
{"id":"mlld-a2x","title":"mlld needs simple math operators and logic","description":"Math operators are ALREADY fully implemented in grammar and interpreter.\n\n**Current state (VERIFIED working)**:\n```mlld\n/var @sum = @x + @y\n/var @product = @x * @y\n/var @calc = (@a + @b) * @c / @d\n/when [@x + @y \u003e 10 =\u003e show \"sum exceeds 10\"]\n```\n\n**Operators supported**:\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n- Comparison: `==`, `\\!=`, `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `~=`\n- Logical: `\u0026\u0026`, `||`, `\\!`\n- Ternary: `condition ? true : false`\n\n**Grammar**: `UnifiedExpression` in `grammar/base/unified-expressions.peggy` (lines 41-49 for arithmetic)\n**Interpreter**: `evaluateBinaryExpression` in `interpreter/eval/expressions.ts` (lines 151-158)\n\n**Where they work NOW**:\n1. ‚úÖ `/var` assignments via `ExpressionWithOperator` pattern\n2. ‚úÖ `/when` conditions via `WhenConditionAdapter`\n3. ‚úÖ Array filters: `@items[?@price \u003e 100]`\n4. ‚ùå `/exe` blocks - NOT YET (exe blocks not implemented - see mlld-9id)\n5. ‚ùå `let` assignments - NOT YET (let not exported from when.ts - see mlld-zeo)\n\n**What's needed**:\nNOTHING for var/when. For exe blocks and let:\n- mlld-zeo exports let functions ‚Üí then math works in let automatically\n- mlld-9id implements exe blocks ‚Üí then math works in exe returns automatically\n\n**Close this card?** Math operators are done. The gaps are exe blocks/let implementation, not math support.","notes":"Fixed: Math operators now work everywhere including exe blocks and let assignments.\n\nFix applied: Changed interpreter/core/interpreter.ts line 672-674 to use evaluateUnifiedExpression (from expressions.ts) instead of evaluateExpression (from expression.ts). The OLD evaluator only supported comparison/logical operators; the NEW evaluator supports all operators including arithmetic (+, -, *, /, %).\n\nTest coverage added:\n- tests/cases/feat/arithmetic/exe-block-basic/ (addition in exe blocks)\n- tests/cases/feat/arithmetic/let-basic/ (multiplication in let)\n- tests/cases/feat/arithmetic/all-operators/ (all 5 operators)\n\nAll tests pass: 2419/2419 (100%)\n\nRefactoring issue created: mlld-xju (consolidate duplicate expression files)\n\nVerified working:\n- @a + @b in exe blocks ‚úÖ\n- @x * @y in let assignments ‚úÖ\n- All operators: +, -, *, /, % ‚úÖ\n- Existing var/when math still works ‚úÖ","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T16:37:38.005938-08:00","updated_at":"2025-12-15T20:50:09.181334-08:00","closed_at":"2025-12-10T18:33:07.587692-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-a4o","title":"Semicolon separator for single-line blocks","description":"Support semicolon as statement separator in exe/for blocks when written on single line.\n\n**Current**: Whitespace-separated works but hard to read\n```mlld\n/exe @func() = [let @x = 1  let @y = 2  =\u003e @x + @y]\n```\n\n**Target**: Semicolon separator for clarity\n```mlld\n/exe @func() = [let @x = 1; let @y = 2; =\u003e @x + @y]\n/for @item in @items [show @item; let @count += 1]\n```\n\n**Grammar changes needed**:\n- Update `BlockStatementSeparator` in `grammar/patterns/iteration.peggy` to accept `;` in addition to whitespace\n- Update `ExeBlockBody` in `grammar/patterns/exe-rhs.peggy` similarly\n- Ensure semicolon is optional (whitespace/newline still works)\n- AST unchanged - semicolon is purely syntactic sugar for readability\n\n**Test cases**:\n- Single-line with semicolons parses correctly\n- Multi-line without semicolons still works\n- Mixed: some semicolons, some newlines works\n- Error: comma rejected with helpful message (already implemented)\n\n**CHANGELOG**: Already documented in rc78 - this makes it real.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T10:45:20.704254-08:00","updated_at":"2025-12-10T23:08:09.182517-08:00","closed_at":"2025-12-10T23:08:09.182517-08:00","labels":["enhancement","grammar"]}
{"id":"mlld-agg","title":"External .att templates not interpolating object field access","description":"External template files (.att) return literal @var.field text instead of interpolating. Inline templates work correctly. Blocking @partydev's multi-agent work.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-16T00:17:39.681845-08:00","updated_at":"2025-12-16T00:29:32.307323-08:00","closed_at":"2025-12-16T00:29:32.307323-08:00","close_reason":"Fixed by adding TemplateBodyAtt and TemplateBodyMtt to allowedStartRules in grammar/build-grammar.mjs. External .att templates now properly parse object field access. Regression test added at tests/cases/feat/exe-template-file-field-access/. All tests passing."}
{"id":"mlld-ah5","title":"Cache: include mode in AST cache keys","description":"**Summary:**\nEnsure AST cache doesn't return wrong-mode cached AST.\n\n**Changes required:**\n\n1. **Locate AST cache** (likely in interpreter or execute flow):\n   - Find where parsed ASTs are cached by filepath\n\n2. **Update cache key**:\n   ```typescript\n   // Before\n   const cacheKey = filepath;\n   \n   // After\n   const cacheKey = `${filepath}:${mode}`;\n   ```\n   \n   Or use a composite key object if the cache supports it.\n\n3. **Cache invalidation**:\n   - Same file parsed with different mode = different cache entries\n   - mtime-based invalidation still applies per entry\n\n**Testing:**\n- Parse same file in strict mode, cache hit\n- Parse same file in markdown mode, cache miss (different key)\n- Modify file, both cache entries invalidate","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:57:52.664361-08:00","updated_at":"2025-12-15T20:50:09.181681-08:00","closed_at":"2025-12-11T17:39:52.611246-08:00","dependencies":[{"issue_id":"mlld-ah5","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.46839-08:00","created_by":"daemon"},{"issue_id":"mlld-ah5","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.797125-08:00","created_by":"daemon"}]}
{"id":"mlld-ait","title":"Phase 2.4: Interpreter - Add while loop evaluator","description":"## Summary\n\nAdd while loop evaluation for bounded iteration with done/continue control flow.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- Pipeline stages receive/return StructuredValue\n- State passed between iterations preserves wrappers\n- done/continue values should preserve wrappers\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n\n## Files to Create/Modify\n\n- `interpreter/eval/while.ts` (new file)\n- `interpreter/eval/pipeline/executor.ts` - Wire in while stage\n\n## Context Variables (@ctx.while.*)\n\nProcessors have access to iteration context:\n\n- `@ctx.while.iteration` (number) - Current iteration, **1-based**\n- `@ctx.while.limit` (number) - Configured cap\n- `@ctx.while.active` (boolean) - true when inside while loop\n\n```mlld\nexe @processor(state) = when [\n  @ctx.while.iteration \u003e 5 =\u003e done @state\n  @ctx.while.iteration == @ctx.while.limit =\u003e done \"hit cap\"\n  * =\u003e continue @state\n]\n```\n\n## Pacing Semantics\n\n- Parameter: `(cap, pacing)` e.g., `while(100, 1s)`\n- Pacing is minimum delay BETWEEN iterations\n- Applied after each iteration (except last)\n- Uses same TimeDuration format as other mlld features (ms, s, m, h)\n\n## Retry Interaction Rules (CRITICAL)\n\n- Processors **CANNOT** use `retry` keyword (use `continue` instead)\n- If processor returns `retry`, throw error: \"Use 'continue' instead of 'retry' in while processors\"\n- Downstream stages CAN retry the entire while stage\n- Example: `@initial | while(100) @iterate | @validate` (validate can retry the whole while)\n\n## Implementation\n\n### New File: while.ts\n\n```typescript\nimport { Environment } from '@interpreter/env/Environment';\nimport { isDoneLiteral, isContinueLiteral, isRetryLiteral, WhilePipelineStage } from '@core/types';\nimport { MlldWhileError } from '@core/errors';\nimport { evaluate } from '../evaluate';\n\ninterface WhileContext {\n  iteration: number;  // 1-based\n  limit: number;\n  active: boolean;\n}\n\nexport async function evaluateWhileStage(\n  stage: WhilePipelineStage,\n  input: unknown,\n  env: Environment\n): Promise\u003cunknown\u003e {\n  const cap = stage.values.cap;\n  const rate = stage.values.rate;\n  const processorRef = stage.values.processor;\n  \n  let state = input;\n  \n  for (let iteration = 1; iteration \u003c= cap; iteration++) {\n    // Create context for this iteration\n    const whileCtx: WhileContext = { \n      iteration,  // 1-based\n      limit: cap,\n      active: true \n    };\n    \n    // Set up iteration environment with @ctx.while\n    const iterEnv = env.createChild();\n    iterEnv.setContextValue('while', whileCtx);\n    \n    // Invoke processor with current state\n    const result = await invokeProcessor(processorRef, state, iterEnv);\n    \n    // Check for forbidden retry\n    if (isRetryLiteral(result)) {\n      throw new MlldWhileError(\n        \"Use 'continue' instead of 'retry' in while processors\",\n        { iteration, limit: cap }\n      );\n    }\n    \n    // Handle control flow\n    if (isDoneLiteral(result)) {\n      // Terminal - return the done value\n      return result.values.value.length \u003e 0 \n        ? await evaluate(result.values.value[0], iterEnv)\n        : state;\n    }\n    \n    if (isContinueLiteral(result)) {\n      // Continue with new state\n      state = result.values.value.length \u003e 0\n        ? await evaluate(result.values.value[0], iterEnv)\n        : state;\n    } else {\n      // Implicit continue with result as new state\n      state = result;\n    }\n    \n    // Apply pacing if specified (except on last iteration)\n    if (rate \u0026\u0026 iteration \u003c cap) {\n      await delay(rate);\n    }\n  }\n  \n  // Reached cap without done - throw error with hint\n  throw new MlldWhileError(\n    `While loop reached cap (${cap}) without 'done'. Consider increasing cap or check termination logic.`,\n    { iteration: cap, limit: cap }\n  );\n}\n```\n\n### Wire into Pipeline Executor\n\nIn `interpreter/eval/pipeline/executor.ts`, add handling for WhileStage:\n\n```typescript\nimport { evaluateWhileStage } from '../while';\n\n// In stage execution logic:\nif (stage.type === 'WhileStage') {\n  return await evaluateWhileStage(stage, input, env);\n}\n```\n\n## Control Flow Semantics\n\n- `done @value` - Terminate iteration, return value\n- `done` (no value) - Terminate, return current state\n- `continue @value` - Next iteration with value as new state\n- `continue` (no value) - Next iteration with current state\n- Implicit return - Treated as continue with result\n\n## Error Handling\n\n- **Cap exceeded**: `MlldWhileError` with hint to increase cap or check logic\n- **Retry used**: Error telling to use `continue` instead\n- **Invalid return**: Must return done/continue, error if neither recognized\n- **Processor errors**: Propagate normally with iteration number in stack\n\n## Validation\n\n- [ ] While stage executes bounded iterations\n- [ ] Done terminates and returns value (preserving StructuredValue)\n- [ ] Continue advances to next iteration (preserving StructuredValue)\n- [ ] Cap limit enforced with helpful error\n- [ ] Rate limiting (pacing) works\n- [ ] Context (@ctx.while.*) available in processor\n- [ ] Retry throws helpful error message\n- [ ] Iteration is 1-based (not 0-based)","notes":"‚úÖ PREREQUISITE UPDATE: Type enums completed in mlld-b4f. WhileDirective interface verified in core/types/while.ts (kind: 'while', subtype: 'while'). Pipeline stage type 'whileStage' validated in AST. DoneLiteralNode and ContinueLiteralNode interfaces exist in core/types/control.ts with type guards. DirectiveKind includes 'while', DirectiveSubtype includes 'while'. Ready for interpreter implementation.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:18:37.290469-08:00","updated_at":"2025-12-15T20:50:09.182002-08:00","closed_at":"2025-12-10T15:00:24.555534-08:00","dependencies":[{"issue_id":"mlld-ait","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:52.279935-08:00","created_by":"daemon"}]}
{"id":"mlld-ajm","title":"let statement doesn't support template RHS inside blocks","description":"**Repro:**\n```mlld\n/for @item in @items [\n  let @x = template \"alice.att\"\n  show @x\n]\n```\n\n**Error:**\n```\nParse error: Expected for block statement list but \"l\" found\n```\n\n**Expected:** `let` should accept `template \"path.att\"` as a valid RHS, same as `/exe` does.\n\nReported by @mllddev.1 in chat.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-10T20:21:29.989668-08:00","updated_at":"2025-12-11T11:27:33.036078-08:00","closed_at":"2025-12-11T11:27:33.036078-08:00","dependencies":[{"issue_id":"mlld-ajm","depends_on_id":"mlld-sus","type":"related","created_at":"2025-12-11T11:16:10.909589-08:00","created_by":"daemon"}]}
{"id":"mlld-atl","title":"Support template collections for registry modules","description":"**Current:** Template collections only work with local directories:\n```mlld\n‚úÖ /import templates from \"@base/agents\" as @agents(msg, ctx)\n‚úÖ /import templates from \"./agents\" as @agents(msg, ctx)\n‚ùå /import templates from @alice/templates as @tmp(msg, ctx)  # fails\n```\n\n**Desired:** Enable template collections for published registry modules:\n```mlld\n/import templates from @alice/agents as @agents(message, context)\n/show @agents[\"alice\"](@msg, @ctx)\n/show @agents.support[\"helper\"](@msg, @ctx)\n```\n\n**Implementation challenges:**\n1. **Packaging** - How to publish directory structures to registry?\n   - Option A: Zip archive in module metadata\n   - Option B: Manifest listing all template paths\n   - Option C: Multi-file gist (GitHub API supports this)\n\n2. **Resolution** - RegistryResolver needs to:\n   - Detect `importType === 'templates'`\n   - Fetch directory structure (not single file)\n   - Provide directory walker interface\n\n3. **Caching** - Template collections need directory-level cache invalidation\n\n**Workaround:** Publish individual template executables:\n```mlld\n\u003e\u003e In @alice/templates module\n/exe @alice(msg, ctx) = template \"alice.att\"\n/exe @bob(msg, ctx) = template \"bob.att\"\n/export { @alice, @bob }\n\n\u003e\u003e Usage\n/import { @alice, @bob } from @alice/templates\n```\n\n**Priority:** P3 - the workaround works, but UX would be better with collection syntax.\n\n**Related:** mlld-drq (local template collections)","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T22:32:56.758945-08:00","updated_at":"2025-12-10T22:32:56.758945-08:00"}
{"id":"mlld-b0e","title":"Grammar: Add WorkingDirPath pattern for :path suffix parsing","description":"## Context\nPart of implementing cmd:path/sh:path feature to allow setting working directory for command execution.\n\nExample syntax:\n```mlld\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n/run sh:@mypath {echo \"hello world\"}\n/run cmd:@base/scripts {./build.sh}\n/run sh:/Users/@username/dev/@dir {somecommand}\n```\n\n## Task\nCreate a new grammar pattern `WorkingDirPath` to parse the `:path` suffix that appears after `cmd` or language keywords (`sh`, `bash`, etc).\n\n## Requirements\n\n1. Path must be rooted (absolute) - starts with `/` or `@`\n2. Support variable interpolation: `@mypath`, `@base/subdir`, `/home/@user/dev`\n3. No relative paths allowed (no `./` or bare names)\n\n## Implementation\n\nLocation: `grammar/patterns/unified-run-content.peggy`\n\nAdd these patterns:\n\n```peggy\n// Working directory path suffix for cmd and sh\nWorkingDirPath \"working directory path\"\n  = \":\" path:WorkingDirPathContent {\n      return path;\n    }\n\n// Path content with variable interpolation\nWorkingDirPathContent\n  = parts:WorkingDirPathPart+ {\n      const flatParts = parts.flat();\n      const raw = helpers.reconstructRawString(flatParts);\n      \n      return {\n        type: 'workingDir',\n        parts: flatParts,\n        raw: raw,\n        meta: helpers.createPathMetadata(raw, flatParts)\n      };\n    }\n\n// Individual path parts - variables or literal path segments\nWorkingDirPathPart\n  = UnifiedVariableNoTail       // @mypath or @base etc.\n  / WorkingDirPathLiteral       // /path/segments\n\n// Literal path segments (no whitespace, not braces)\nWorkingDirPathLiteral\n  = chars:WorkingDirPathChar+ {\n      return helpers.createNode(NodeType.Text, { \n        content: chars.join(''), \n        location: location() \n      });\n    }\n\nWorkingDirPathChar\n  = [^\\s\\t\\n\\r\\{\\}@]  // Any char except whitespace, braces, @\n```\n\n## Key Points\n\n- Reuse `UnifiedVariableNoTail` for variable parsing (already exists)\n- Return structure with `parts` (AST nodes) and `raw` (string)\n- Use `helpers.createPathMetadata()` to create metadata\n- Must stop at whitespace or `{` (command block start)\n\n## Testing\n\nAfter implementation, test with `npm run ast`:\n```bash\nnpm run ast -- 'cmd:/absolute/path {ls}'\nnpm run ast -- 'cmd:@variable {ls}'\nnpm run ast -- 'cmd:@base/subdir {ls}'\n```","notes":"Grammar pattern should parse :path suffix for cmd/sh etc; path content allows absolute Unix paths only; no Windows or '~'; '/' valid.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:06.303866-08:00","updated_at":"2025-12-08T20:23:24.305345-08:00","closed_at":"2025-12-08T20:23:24.305345-08:00"}
{"id":"mlld-b4f","title":"Phase 1.7: Verify AST/Types alignment with design principles","description":"Comprehensive verification that all new grammar changes (exe blocks, for blocks, while loops, done/continue literals) produce ASTs that align with existing mlld design principles and type system.\n\n## Context\n\nPhase 1 grammar work is \"complete\" but we need thorough verification that:\n1. AST structure follows mlld conventions (docs/dev/AST.md, docs/dev/GRAMMAR.md)\n2. Types align with existing enums and interfaces (core/types/)\n3. StructuredValue patterns are correct (docs/dev/DATA.md)\n4. No regressions or inconsistencies introduced\n\n## Required Reading\n\n- **docs/dev/AST.md** - Context-aware AST design principles (may be slightly outdated but principles are sound)\n- **docs/dev/GRAMMAR.md** - Grammar architecture and abstraction patterns\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n\n## Verification Checklist\n\n### 1. AST Structure Verification\n\nFor each new construct, verify AST follows mlld conventions:\n\n**Exe Blocks** (`/exe @f() = [...]`):\n- [ ] `directive.kind === 'exe'`\n- [ ] `directive.subtype === 'exeBlock'`\n- [ ] `values.statements` is array of statement nodes\n- [ ] `values.return` has proper ExeReturn structure\n- [ ] `meta.statementCount`, `meta.hasReturn` set correctly\n- [ ] Location tracking includes block boundaries\n\n**For Blocks** (`for @x in @xs [...]`):\n- [ ] `directive.kind === 'for'`\n- [ ] `meta.actionType === 'block'` or `'single'`\n- [ ] `values.action` is array when actionType='block'\n- [ ] `meta.blockMeta.statementCount` set when block\n- [ ] Arrow form still parses (`for @x in @xs =\u003e [...]`)\n\n**While Loops** (`/while(100) @processor`):\n- [ ] Directive form: `kind === 'while'`, `subtype === 'whileDirective'`\n- [ ] Pipeline form: node type for pipeline stage\n- [ ] `values.cap` (number), `values.processor` (VariableReference)\n- [ ] Optional `values.rateMs` for pacing\n- [ ] Location tracking correct\n\n**Done/Continue Literals**:\n- [ ] `type === 'Literal'`\n- [ ] `valueType === 'done'` or `valueType === 'continue'`\n- [ ] `value` is array (may be empty or contain expression)\n- [ ] Works in return position, when expression actions\n- [ ] Proper location tracking for error messages\n\n### 2. Type System Verification\n\nCheck alignment with existing types:\n\n**DirectiveKind enum** (core/types/):\n- [ ] 'exe' already exists (verify exeBlock subtype)\n- [ ] 'for' already exists (verify block metadata)\n- [ ] 'while' added if new directive kind needed\n- [ ] No duplicate or conflicting enum values\n\n**Literal valueType** (core/types/):\n- [ ] 'done' added to valueType union\n- [ ] 'continue' added to valueType union\n- [ ] Literal node interface supports array value\n- [ ] No conflicts with existing literal types\n\n**Meta flags**:\n- [ ] `actionType: 'block' | 'single'` on ForDirective\n- [ ] `statementCount`, `hasReturn` on ExeBlock\n- [ ] `blockMeta` for nested block info\n- [ ] No namespace collisions with existing meta\n\n### 3. StructuredValue Patterns\n\nVerify alignment with DATA.md:\n\n**Let assignments**:\n- [ ] Store StructuredValue wrappers (not raw values)\n- [ ] Preserve .text, .data, .ctx through assignments\n- [ ] Augmented assignment (+=) works with StructuredValue\n\n**Block returns**:\n- [ ] Exe block return preserves StructuredValue wrapper\n- [ ] Done/continue values preserve wrappers\n- [ ] No unwrapping until boundaries (asData/asText)\n\n**Iteration values**:\n- [ ] For loop iterator values wrapped\n- [ ] While loop state values wrapped\n- [ ] Context (@ctx) values properly structured\n\n### 4. Regression Testing\n\nRun existing tests to ensure no breaks:\n\n```bash\nnpm run build:grammar\nnpm test grammar/\nnpm run ast -- '/exe @f() = when [* =\u003e \"test\"]'  # Existing exe..when\nnpm run ast -- '/for @x in @xs =\u003e show @x'        # Existing for single\nnpm run ast -- '/var @x = 1'                       # Basic directive\n```\n\nExpected: All existing syntax still parses correctly.\n\n### 5. AST Inspection\n\nUse ast tool to verify structure:\n\n```bash\n# Exe block\nnpm run ast -- '/exe @add(x, y) = [let @sum = @x + @y; =\u003e @sum]'\n\n# For block  \nnpm run ast -- '/for @item in @items [show @item; let @count += 1]'\n\n# While directive\nnpm run ast -- '/while(100, 1s) @processor'\n\n# Done/continue\nnpm run ast -- '/exe @f() = when [@x \u003e 5 =\u003e done @x]'\nnpm run ast -- '/exe @f() = when [* =\u003e continue (@x - 1)]'\n```\n\nInspect output for:\n- Correct node types\n- Proper nesting structure  \n- Meta flags set appropriately\n- No unexpected fields\n- Location data present\n\n### 6. Type Alignment Check\n\n```bash\n# Type check should pass\nnpm run build\n\n# Look for type errors in:\n# - core/types/directive.ts\n# - core/types/literal.ts  \n# - interpreter/eval/exe.ts\n# - interpreter/eval/for.ts\n# - interpreter/eval/while.ts\n```\n\n### 7. Documentation Updates\n\nIf AST.md or GRAMMAR.md are outdated:\n- [ ] Update AST.md with new node types/patterns\n- [ ] Update GRAMMAR.md if new abstractions added\n- [ ] Document any new meta flags\n- [ ] Add examples for new constructs\n\n## Common Issues to Check\n\n1. **Location offsets**: Block reparsing must have correct offsets\n2. **Meta consistency**: Same construct different contexts should have consistent meta\n3. **Array wrapping**: All directive values should be node arrays (except primitives in var)\n4. **Type discriminators**: Objects/arrays use type field, not structure alone\n5. **Context flags**: isDataValue, isRHSRef set correctly for embedded directives\n\n## Acceptance Criteria\n\n- [ ] All new constructs parse to valid AST\n- [ ] AST structure follows mlld conventions (AST.md)\n- [ ] Types compile without errors\n- [ ] No regressions in existing grammar tests\n- [ ] Meta flags consistent with patterns\n- [ ] StructuredValue patterns correct\n- [ ] Location tracking works for error messages\n\n## Deliverable\n\nCreate `tmp/phase1-ast-verification.md` documenting:\n1. AST samples for each new construct (pretty-printed JSON)\n2. Type alignment verification (enum values, interfaces)\n3. Any issues found and fixes applied\n4. Confirmation that all principles followed\n\n## Time Estimate\n\n60-90 minutes (thorough inspection, not quick pass)","notes":"Phase 1 AST verification complete. All constructs verified and aligned with design principles. See tmp/phase1-ast-verification.md for full report. Key findings: All tests pass (2391/2391), AST structures correct, types align. Minor action: add 'while' to DirectiveKind enum. Ready for Phase 2.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T11:26:55.803735-08:00","updated_at":"2025-12-10T11:47:25.491635-08:00","closed_at":"2025-12-10T11:47:25.491638-08:00","dependencies":[{"issue_id":"mlld-b4f","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-10T11:26:55.804511-08:00","created_by":"daemon"}]}
{"id":"mlld-bbu","title":"LSP: Highlight variable interpolation in /run blocks (GH#330)","description":"## Summary\nVariable interpolation not highlighted in /run command blocks.\n\nGitHub: https://github.com/mlld-lang/mlld/issues/330\n\n## Problem\n```mlld\n/run cmd { echo @message }  \u003c\u003c @message not highlighted as variable\n/run sh { curl @url }       \u003c\u003c @url not highlighted\n```\n\n## Root Cause\nThe CommandVisitor or embedded code handling doesn't process variable references inside command blocks.\n\n## Investigation\n```bash\nnpm run ast -- '/run cmd { echo @message }'\n# Check if @message appears as VariableReference in AST\n# Or if it's captured as raw string content\n```\n\n## Analysis\nCommand blocks `{ ... }` may be parsed as:\n1. Raw string content (no interpolation tracking)\n2. Template with interpolation nodes\n\nIf it's raw string content, the grammar would need to track interpolations for the LSP to highlight them.\n\nIf interpolations ARE in the AST, then CommandVisitor needs to visit them.\n\n## Implementation\n\n### If Interpolations in AST\nIn `services/lsp/visitors/CommandVisitor.ts`:\n\n```typescript\n// When processing command block content\nif (node.content?.parts) {\n  for (const part of node.content.parts) {\n    if (part.type === 'VariableReference') {\n      this.mainVisitor.visitNode(part, context);\n    }\n  }\n}\n```\n\n### If Raw String Content\nThis may require grammar changes to preserve interpolation locations, which is a larger change.\n\nCheck the AST structure first to determine the approach.\n\n## Testing\n```typescript\nit('highlights variables in command blocks', async () =\u003e {\n  const tokens = await getSemanticTokens('/run cmd { echo @message }');\n  expect(tokens).toContainToken({ type: 'variable', text: '@message' });\n});\n```\n\n## Files to Modify\n- `services/lsp/visitors/CommandVisitor.ts`\n\n## Size\nSmall to Medium (depending on AST structure)","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:36.916573-08:00","updated_at":"2025-12-11T22:17:34.743593-08:00","closed_at":"2025-12-11T22:17:34.743593-08:00","dependencies":[{"issue_id":"mlld-bbu","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.268595-08:00","created_by":"daemon"}]}
{"id":"mlld-bgl","title":"Security: Policy-based working directory path restrictions","description":"Add security policy support for restricting working directory paths in cmd:path/sh:path syntax.\n\n## Background\nCurrently cmd:path and sh:path allow any absolute path the user has filesystem access to. We need policy-based restrictions to:\n- Define allowed path prefixes (e.g., only /Users/adam/dev/)\n- Prevent access to sensitive directories (/etc, /root, etc.)\n- Support guards that test path compliance before execution\n\n## Requirements\n1. Extend security policy to include working directory constraints\n2. Add path validation against policy in cwd-resolver\n3. Create guards that can inspect and approve/deny workingDir\n4. Clear error messages when path violates policy\n\n## Examples\nPolicy:\n```\n/needs cmd.cwd:/Users/adam/dev/**\n```\n\nGuard:\n```\n/guard [cmd.cwd =\u003e {\n  # Validate working directory is within allowed paths\n}]\n```\n\nThis issue should be tackled after the basic cmd:path/sh:path feature is implemented and working.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T12:53:10.831611-08:00","updated_at":"2025-12-08T12:53:10.831611-08:00","labels":["future","security"]}
{"id":"mlld-bj2","title":"sh/py block contents should be tokenized as string","description":"sh {} and py {} contents should be treated as 'string' token type for now. Add comment to enable proper syntax highlighting later once WASM parsers are set up.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T07:55:56.685587-08:00","updated_at":"2025-12-14T09:05:20.542427-08:00","closed_at":"2025-12-14T09:05:20.542427-08:00"}
{"id":"mlld-bqc","title":"Add file/directory existence checks","description":"Add general-purpose @exists() builtin that returns true if expression evaluates without error.\n\n**Design:**\n```mlld\n@exists(\"file.md\")              // String path - interpolates first\n@exists(\"@base/dir/path\")       // Resolver paths work\n@exists(\u003cfile.md\u003e)               // File load - true if loads\n@exists(\u003cdir/*.md\u003e)              // Glob - true if any match\n@exists(@var[@key])              // Array/object access\n@exists(@obj.field.nested)       // Field access\n```\n\n**Semantics:**\n- Evaluates the expression\n- Returns true if no error, false if any error\n- For globs, true if at least one file matches\n- Catches ALL errors (ENOENT, EACCES, timeout, etc) and returns false\n- Side effects happen (file actually loads in @exists(\u003cfile\u003e))\n\n**Implementation:**\n- Add as builtin in interpreter/eval/exec-invocation.ts\n- Wrap expression evaluation in try/catch\n- For string args, treat as file paths and attempt load via \u003c...\u003e syntax\n\n**Test cases needed:**\n- @exists(\"existing.md\") and @exists(\"missing.md\")\n- @exists(\"@base/tmp/file.md\") with resolver\n- @exists(\u003cfile.md\u003e) with actual file load\n- @exists(\u003cdir/*.md\u003e) with glob (true if any match)\n- @exists(\u003cdir/*.md\u003e) with glob (false if no matches)\n- @exists(@obj.field) existing vs missing field\n- @exists(@arr[99]) out of bounds array access\n\n**Follow-up:** mlld-??? (P4) for performance optimization - lazy fs.exists() for file paths","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:26:24.546183-08:00","updated_at":"2025-12-17T20:40:45.582844-08:00","closed_at":"2025-12-17T20:40:45.582844-08:00","close_reason":"Implemented @exists() as a built-in transformer following @typeof() pattern. Registered in interpreter/builtin/transformers.ts:151, executed via builtin-transformer path at interpreter/eval/exec-invocation.ts:1183. Tests at tests/cases/feat/builtin-exists/ cover: string paths, resolver paths, file loads, globs, object fields, array access, missing variables. All tests passing."}
{"id":"mlld-buc","title":"String highlighting inconsistent across contexts","description":"Strings render in different colors depending on context:\n- show \"text\" in when/for =\u003e appears one color\n- show \"text\" standalone =\u003e appears different color\n- Strings with emoji appear different from plain strings\n\nAll are tokenized as 'string' type but render inconsistently. Likely colorscheme applying different colors in different syntactic contexts. Need explicit @lsp.type.string.mld highlight group to override context-specific defaults.","notes":"**THREE CRITICAL FIXES APPLIED:**\n\n**Fix 1: Text nodes not registered (ASTSemanticVisitor.ts:74)**\n- Added: this.registerVisitor('Text', templateVisitor)\n\n**Fix 2: Legacy exe template code removed (DirectiveVisitor.ts:282-310)**  \n- Deleted special-case that tokenized whole string as one token\n\n**Fix 3: Missing return statements (DirectiveVisitor.ts:511,515,518)**\n- exe templates were falling through to visitChildren() after visitTemplateValue()\n- visitChildren() visited values.identifier AGAIN (already tokenized as function)\n- Created duplicate/overlapping token at wrong position (char=26 \"g wit\")\n- Added early returns to prevent re-visiting\n\n**Result:**\nexe @func(@value) = \"string with @value etc...\" now tokenizes correctly:\n- @func ‚Üí function (char=4) ‚úÖ\n- @value param ‚Üí parameter (char=10) ‚úÖ  \n- \"string with \" ‚Üí string (char=21) ‚úÖ\n- @value in string ‚Üí interpolation (char=33) ‚úÖ\n- \" etc...\" ‚Üí string (char=39) ‚úÖ\n- NO duplicate @func token at char=26 ‚úÖ\n\nAll string highlighting now consistent across all contexts!","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T05:32:12.666309-08:00","updated_at":"2025-12-15T13:34:10.086029-08:00","closed_at":"2025-12-15T13:34:10.086029-08:00","dependencies":[{"issue_id":"mlld-buc","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:32:12.667049-08:00","created_by":"daemon"}]}
{"id":"mlld-bw5","title":"Directory imports with auto-loading index.mld","description":"Support importing entire directories that auto-load */index.mld files:\n\n```mlld\n/import \"@agents\" as @agents\n// Returns: {party: {...}, mllddev: {...}}\n// Each subdirectory's index.mld exports become fields\n\n// Default skipDirs: [\"_*\", \".*\"]\n/import \"@agents\" as @agents with { skipDirs: [] }  // override\n```\n\nUse case: Multi-agent systems where each agent is a directory with index.mld defining its interface.\n\nRequested by @partydev for scaffold pattern.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-17T17:26:24.077681-08:00","updated_at":"2025-12-17T22:37:12.699527-08:00","closed_at":"2025-12-17T22:37:12.699527-08:00","close_reason":"Implemented directory imports for .mld modules. Imports immediate subdirectories' index.mld files into object keyed by directory name. Default skipDirs: ['_*', '.*']. Implementation at interpreter/eval/import/ImportDirectiveEvaluator.ts:525-630. Tests at interpreter/eval/import/import-types.test.ts. All tests passing."}
{"id":"mlld-ccf","title":"Guard condition highlighting wrong - should match when conditions","description":"Guard blocks not tokenizing like exe when blocks. Two issues:\n\n1. Guard block body (after =\u003e) should tokenize exactly like exe when blocks:\n   guard before label = when [ @condition =\u003e allow @action() ]\n   The condition block should tokenize identically to:\n   exe @func = when first [ @idx == -1 =\u003e 0 ]\n\n2. 'when first' grouping: The 'when first' keywords should be grouped/highlighted together (both light teal italic).\n\nCurrently: Guard condition blocks have broken/inconsistent highlighting\nTarget: Match exe when block highlighting exactly\n\nFiles: DirectiveVisitor.ts visitGuardDirective()","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-14T11:49:26.697866-08:00","updated_at":"2025-12-14T14:54:34.174728-08:00","closed_at":"2025-12-14T14:54:34.174728-08:00"}
{"id":"mlld-cgb","title":"LSP: update highlighting for strict and markdown modes","description":"## Summary\nUpdate LSP semantic tokens and visitors to correctly highlight strict vs markdown modes.\n\n**Depends on:** mlld-p25 (mode detection) must be completed first.\n\n## Key Difference\n\n**Strict Mode (.mld files):**\n- Bare directives (`var`, `show`, `exe`) are valid and should highlight as keywords\n- Text lines produce parse errors\n- Slash prefix optional (`/var` and `var` both work)\n\n**Markdown Mode (.mld.md files):**\n- Only `/directive` syntax highlighted as keywords\n- Text lines become content (no error)\n- Slash prefix required\n\n## Implementation\n\n### DirectiveVisitor Changes\nIn `services/lsp/visitors/DirectiveVisitor.ts`, the `visitNode` method currently adds directive tokens assuming slash prefix (line 37-45):\n\n```typescript\n// Current code adds token with length = kind.length + 1 (for /)\nthis.tokenBuilder.addToken({\n  line: node.location.start.line - 1,\n  char: node.location.start.column - 1,\n  length: (node.kind?.length || 0) + 1,  // +1 assumes slash\n  tokenType: 'directive',\n  modifiers: []\n});\n```\n\n**Changes needed:**\n1. Accept mode in visitor context\n2. Check if directive has slash prefix or is bare\n3. Adjust token length accordingly\n\n```typescript\n// Check if bare directive (no slash) in strict mode\nconst hasSlash = !node.meta?.bare;  // or check source text\nconst tokenLength = hasSlash \n  ? (node.kind?.length || 0) + 1 \n  : (node.kind?.length || 0);\n\nthis.tokenBuilder.addToken({\n  line: node.location.start.line - 1,\n  char: node.location.start.column - 1,\n  length: tokenLength,\n  tokenType: 'directive',\n  modifiers: []\n});\n```\n\n### ASTSemanticVisitor Changes\nPass mode through visitor context so DirectiveVisitor can access it:\n\n```typescript\n// In ASTSemanticVisitor constructor or visitAST\nthis.contextStack.push({ mode: options.mode });\n```\n\n### Test Coverage\nAdd tests for both modes:\n\n```typescript\ndescribe('strict mode highlighting', () =\u003e {\n  it('highlights bare directives', async () =\u003e {\n    const tokens = await getSemanticTokens('var @x = \"test\"', { mode: 'strict' });\n    expect(tokens).toContainToken({ type: 'keyword', text: 'var' });\n  });\n});\n\ndescribe('markdown mode highlighting', () =\u003e {\n  it('requires slash prefix', async () =\u003e {\n    const tokens = await getSemanticTokens('/var @x = \"test\"', { mode: 'markdown' });\n    expect(tokens).toContainToken({ type: 'keyword', text: '/var' });\n  });\n});\n```\n\n## Files to Modify\n- `services/lsp/visitors/DirectiveVisitor.ts` - Handle bare vs slashed\n- `services/lsp/context/VisitorContext.ts` - Add mode to context type\n- `services/lsp/ASTSemanticVisitor.ts` - Pass mode to context\n- `services/lsp/semantic-tokens.test.ts` - Add mode-specific tests\n\n## Acceptance Criteria\n- [ ] Bare directives in strict mode highlighted as keywords\n- [ ] Slash directives work in both modes\n- [ ] Token lengths correct for both styles\n- [ ] Test coverage for both modes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T08:30:21.961653-08:00","updated_at":"2025-12-15T20:50:09.182343-08:00","closed_at":"2025-12-11T22:05:24.274026-08:00","dependencies":[{"issue_id":"mlld-cgb","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.051024-08:00","created_by":"daemon"},{"issue_id":"mlld-cgb","depends_on_id":"mlld-p25","type":"blocks","created_at":"2025-12-11T21:00:51.120639-08:00","created_by":"daemon"}]}
{"id":"mlld-cjt","title":"Consider removing prettyprint default","description":"We prettyprinted all JSON output early on because mlld was simplistic and also completely string based. I think it is probably unnecessary to prettyprint by default, but I'm not sure about it yet.\n\nIt's very nice to just have any JSON output be immediately readable which is very hard for humans dealing with compact JSON ‚Äî but given that most of the content is likely to be read by LLMs it's probably not necessary at all.\n\nWe could instead have a `| @pretty` built-in to allow that if the user wants it.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T09:02:59.292539-08:00","updated_at":"2025-12-11T22:26:58.05638-08:00","labels":["creator:adamavenir@hey.com","fizzy:not-now"]}
{"id":"mlld-cu0","title":"Support semicolon separation for when arms (universal block separator)","description":"**Current:** When arms require newlines:\n```mlld\n/var @arr = for @x in @xs =\u003e when [\n  @x == 1 =\u003e @x\n  none =\u003e skip\n]\n```\n\n**Desired:** Semicolons should work as universal block separators:\n```mlld\n/var @arr = for @x in @xs [ when [ @x == 1 =\u003e @x; none =\u003e skip ] ]\n```\n\nCurrently fails with: \"Syntax error: Invalid variable syntax, but found \";\"\"\n\nOther blocks support semicolon separation - this should be universal for consistency and one-liner convenience.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T20:59:07.161018-08:00","updated_at":"2025-12-10T20:59:07.161018-08:00"}
{"id":"mlld-cvf","title":"Arrow operator =\u003e needs distinct highlighting from = \u0026\u0026 as from","description":"The =\u003e operator should stand out visually from other operators and keywords:\n- = (assignment)\n- \u0026\u0026 (logical and)\n- as, from (keywords)\n\nCurrently they all look similar. =\u003e is the most important flow control operator and should be highly visible.","notes":"‚úÖ COMPLETE - All =\u003e operators now use 'modifier' semantic type (pink like var/exe)\n\n**Final fix count: 12 locations across 2 files**\n\nDirectiveVisitor.ts (9 locations):\n1. Line 2481 - /for inline syntax (=\u003e action)\n2. Line 2568 - /exe block return statement (=\u003e expression)  \n3. Line 2792 - /guard rules (condition =\u003e action)\n4. Line 1460 - /when directive single condition (=\u003e action)\n5. Line 1761 - /when directive pairs with arrowLocation\n6. Line 1778 - /when directive pairs fallback\n7. Line 1897 - /when directive condition =\u003e action\n8. Line 1859 - /when blocks after ] =\u003e action\n9. Line 1922 - /when =\u003e operator (was never tokenized before - now added!)\n\nExpressionVisitor.ts (3 locations):\n10. Line 400 - ForExpression inline (for @x in @xs =\u003e @x)\n11. Line 234 - WhenExpression condition =\u003e action (primary)\n12. Line 241 - WhenExpression fallback (condition =\u003e action)\n\n**Result:**\nALL =\u003e operators now render in pink italic (same as var/exe directives), including:\n- exe blocks with return statements\n- exe when expressions (exe @f() = when first [ @x \u003e 0 =\u003e @y ])\n- for loops (inline and directive forms)\n- when expressions and directives\n- guard rules\n\nMaking flow control transitions highly visible everywhere!","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T05:31:33.985242-08:00","updated_at":"2025-12-15T08:20:40.60837-08:00","closed_at":"2025-12-14T21:46:14.490095-08:00","dependencies":[{"issue_id":"mlld-cvf","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:31:33.986195-08:00","created_by":"daemon"}]}
{"id":"mlld-cw9","title":"Phase 0: Abstraction Discovery for Block Syntax Epic","description":"**CRITICAL: This must be done FIRST before any implementation!**\n\n## Purpose\n\nBefore writing any new grammar, systematically identify what already exists. The plan was created with \"late-context chaotic planning energy\" - a fresh implementer's brain will see patterns we missed.\n\n## Time Budget\n\n60-90 minutes of reading before writing code.\n\n## Required Reading\n\n### 1. Grammar Files to Review\n\n**`grammar/patterns/exe-rhs.peggy`**\n- What can `WhenExpression` currently contain? (lines 438-517)\n- What's in `WhenExpressionEntry`? (line 502-505)\n- What's `WhenRHSAction`? (references when-rhs-action.peggy)\n- Can we reuse `WhenExpressionConditionList` for exe blocks?\n\n**`grammar/patterns/when-rhs-action.peggy`**\n- What actions are supported? (line 8-17)\n- What directives can appear in when RHS?\n- Which of these should work in exe blocks?\n\n**`grammar/patterns/iteration.peggy`**\n- What's in `ForSingleAction`? (lines 55-101)\n- Does it already support everything for blocks need?\n- What's `WhenRHSAction` reused here?\n\n**`grammar/base/literals.peggy`**\n- How are `retry`, `skip`, `allow`, `denied` defined? (lines 50-74)\n- Follow exact same pattern for `done` and `continue`\n\n**`grammar/patterns/let-assignment.peggy`**\n- How do `LetAssignment` and `AugmentedAssignment` work?\n- Can we reuse directly or need exe-specific variants?\n\n### 2. Type Files to Review\n\n**`core/types/` for exe/for/when**\n- Understand `ExecutableDefinition` variants\n- How does dispatch work?\n- Where does `ExeBlockNode` fit in hierarchy?\n\n### 3. Data Handling (CRITICAL!)\n\n**`docs/dev/DATA.md`** - Required reading!\n- StructuredValue system (.text, .data, .ctx)\n- When to use asData() vs asText()\n- Boundary rules for unwrapping\n\n### 4. Files to AVOID\n\n**`grammar/directives/for-template.peggy`** - NOT reusable (text substitution)\n\n## Key Insight from Plan\n\nExe blocks are ~80% the same as exe..when! An exe block is just when expression without conditions (or with implicit `* =\u003e`). Massive reuse opportunity.\n\n## Critical Disambiguation (SOLVED in plan)\n\nIn exe/for contexts, `[...]` is **always a block**:\n```mlld\nexe @func() = [1, 2, 3]           # Block with 3 expressions (likely error)\nexe @func() = {[1, 2, 3]}         # Escape hatch: object with array\nexe @func() = @identity([1, 2, 3]) # Or use function\n\nfor @x in @xs =\u003e [statements]     # Always block\n```\n\n**No lookahead needed** - Context determines meaning.\n\n## Deliverable\n\nCreate `tmp/abstraction-reuse-findings.md` documenting:\n1. What patterns exist and can be reused (with line numbers)\n2. What needs creating (minimal list)\n3. Gap analysis: exe..when vs exe blocks\n4. Solution for array literal disambiguation\n5. Type hierarchy understanding\n6. StructuredValue usage patterns\n\n## Validation\n\n- [ ] Read all listed files\n- [ ] Created findings document\n- [ ] Identified reuse opportunities\n- [ ] Ready to start Phase 1\n\n## Warning\n\nThe plan shows test examples with BOTH `{...}` and `[...]` syntax due to iteration during planning. **The final decision is `[...]` for all mlld blocks**. When implementing, convert all block examples to use `[...]` brackets, not `{...}` curly braces.","notes":"Phase 0 reading done; documented reuse/gaps in tmp/abstraction-reuse-findings.md; ready to proceed to block grammar/AST work.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-09T22:14:05.424356-08:00","updated_at":"2025-12-09T23:42:33.072751-08:00","closed_at":"2025-12-09T23:42:33.072751-08:00"}
{"id":"mlld-cyz","title":"Comment highlighting inconsistent - first comment after stanza not highlighted","description":"Comment highlighting is inconsistent. First \u003e\u003e comment line after another stanza (exe, var, etc) doesn't highlight as comment, but subsequent \u003e\u003e lines do.\n\nExamples in orchestrate.mld:\n- Line with '\u003e\u003e Evaluate a single agent...' after exe block ‚Üí not highlighted\n- Subsequent \u003e\u003e comments ‚Üí highlighted correctly\n\nLikely a grammar issue - parser may be in wrong state after closing stanza, treating first \u003e\u003e as something else. Check Comment node generation in grammar.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-13T05:33:40.413955-08:00","updated_at":"2025-12-14T12:15:28.296826-08:00","closed_at":"2025-12-14T12:15:28.296826-08:00","dependencies":[{"issue_id":"mlld-cyz","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:33:40.414469-08:00","created_by":"daemon"}]}
{"id":"mlld-d0p","title":"Use the SDK's analyze module function to extract the required base-level `/needs` and check them against the user's module when publishing","description":"If the user doesn't have required items listed, we should suggest `/needs` and suggest they break it up into `/wants` tiers if there is a requirement hierarchy.\n\nThis issue needs to be thought through in more depth.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-07T13:50:42.30443-08:00","updated_at":"2025-12-08T12:20:15.296359-08:00","labels":["creator:adamavenir@hey.com"]}
{"id":"mlld-d9y","title":"Add .mx.keys, .mx.values, .mx.entries for objects","description":"Add discoverable object utility fields instead of relying on the _key suffix pattern:\n\n```mlld\n/var @obj = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n@obj.mx.keys      // [\"a\", \"b\", \"c\"]\n@obj.mx.values    // [1, 2, 3]  \n@obj.mx.entries   // [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n```\n\n**Current workaround:** Use the _key suffix during iteration:\n```mlld\n/exe @getKeys(obj) = for @val in @obj =\u003e @val_key\n```\n\nThis is not discoverable and requires explaining a hidden pattern. Proper fields would be much more intuitive.\n\n**Use case:** @partydev needs to iterate over agent registry keys for multi-agent routing.\n\n**Implementation:** Add to StructuredValue metadata system, similar to how arrays have .length.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-18T06:29:43.574038-08:00","updated_at":"2025-12-18T18:02:38.334645-08:00","closed_at":"2025-12-18T09:24:01.860524-08:00"}
{"id":"mlld-ddn","title":"Object property keys not highlighted","description":"Object keys like 'agent:', 'replyPressure:', 'responseRequired:' should be highlighted as properties. Currently appearing as plain text. Example: { agent: @responder.agent, replyPressure: @replyP } - keys should be highlighted. orchestrate.mld lines 29, 51, 68","notes":"Object keys are properly tokenized - verified with 100% coverage on test cases","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-12T18:09:04.794716-08:00","updated_at":"2025-12-12T20:50:57.783831-08:00","closed_at":"2025-12-12T20:50:57.783833-08:00"}
{"id":"mlld-dk4","title":"Object keys should match JavaScript key highlighting","description":"Object property keys (agent:, replyPressure:, etc) are currently highlighted as Type (purple/magenta). They should match the same color as JavaScript object keys in the same colorscheme for consistency and familiarity.\n\nExample: { agent: @agent, score: 0.5 }\nKeys should use colorscheme's JS object key color.","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-13T05:31:59.470602-08:00","updated_at":"2025-12-13T05:31:59.470602-08:00","dependencies":[{"issue_id":"mlld-dk4","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:31:59.471993-08:00","created_by":"daemon"}]}
{"id":"mlld-dk5","title":"Document @var_key suffix pattern for object iteration","description":"The @var_key suffix for accessing keys during object iteration is not documented in user-facing docs.\n\nCurrent behavior (works but undocumented):\n```mlld\n/for @agent in @agentRegistry =\u003e show \"@agent_key: @agent.tldr\"\n```\n\nWhere to document:\n- llms.txt RULE_11 (iteration section)\n- docs/user/flow-control.md\n- docs/user/reference.md\n\nThis pattern is critical for object iteration but users have to be told about it. Should be prominent in docs until mlld-d9y (P1, .mx.keys) is implemented.\n\nIdentified by @partydev during dogfooding.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-18T08:58:34.27006-08:00","updated_at":"2025-12-18T08:58:34.27006-08:00"}
{"id":"mlld-dp5","title":"Add 'when @value first [patterns]' syntax for pattern matching with bound value","description":"User request from @partydev building proto-4.1 multi-agent routing.\n\nCurrent syntax requires repeating the variable in each condition:\nwhen first [\n  @score \u003e= 0.7 =\u003e \"REQUIRED\"\n  @score \u003e= 0.3 =\u003e \"OPTIONAL\"\n]\n\nProposed syntax binds the value upfront:\nwhen @score first [\n  \u003e= 0.7 =\u003e \"REQUIRED\"\n  \u003e= 0.3 =\u003e \"OPTIONAL\"\n]\n\nThis is a natural extension of 'when first' that reduces repetition and improves readability.\n\nSee: /Users/adam/dev/party/mlld-feature-request-routing.md","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-12-18T17:51:28.115945-08:00","updated_at":"2025-12-19T03:04:36.921815-08:00","closed_at":"2025-12-18T19:19:33.071834-08:00"}
{"id":"mlld-drm","title":"Comment highlighting inconsistent across files","description":"Some \u003e\u003e comments are highlighted (lines 15, 20, 22) but others aren't (lines 6, 10). All should be consistently highlighted. May be related to comment position or parsing context.","notes":"Comment highlighting is consistent - verified with 100% coverage on test cases","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-12T18:08:21.004887-08:00","updated_at":"2025-12-12T20:51:04.703341-08:00","closed_at":"2025-12-12T20:51:04.703344-08:00"}
{"id":"mlld-drq","title":"Template collection import: /import templates from dir as @name","description":"**Problem:** Users can't dynamically load templates based on runtime values. The current `/exe @name() = template \"path.att\"` resolves the path at definition time, so parameters can't be used in paths.\n\n**Syntax:**\n```mlld\n/import templates from \"@base/agents\" as @agents(message, context)\n/import templates from \"@base/formatters\" as @formatters(data, format)\n\n\u003e\u003e All templates in agents/ share the (message, context) signature\n/show @agents[\"alice\"](@msg, @ctx)\n/show @agents[\"bob\"](@msg, @ctx)\n\n\u003e\u003e Nested directories via dot notation\n/show @agents.support[\"helper\"](@msg, @ctx)\n\n\u003e\u003e Dynamic in loops\n/for @agent in @agentList [\n  show @agents[@agent.name](@message, @context)\n]\n```\n\n**Key design: Explicit parameter contract**\n- Parameters declared in the import: `as @agents(message, context)`\n- ALL templates in that directory must accept those params\n- Different param signatures = different template groups\n- No inference needed - contract is explicit\n\n**Validation:**\n- Template uses `@message` ‚úì (in declared signature)\n- Template uses `@foo` ‚úó ‚Üí \"Template 'alice.att' references @foo but signature only declares (message, context)\"\n- Unused params are fine (template doesn't have to use all declared params)\n\n**Directory structure:**\n- `agents/alice.att` ‚Üí `@agents[\"alice\"]`\n- `agents/support/helper.att` ‚Üí `@agents.support[\"helper\"]`\n- Directories become dot segments, filenames stay in brackets\n\n**Errors:**\n- Template not found: \"Template 'unknown' not found in @agents. Available: alice, bob, support/helper\"\n- Param mismatch at parse time (template references undeclared var)\n\n**Implementation notes (via gpt5.1 analysis):**\n- Add `templates` import type to grammar\n- Detect `importType === 'templates'` and walk directory instead of blocking\n- Build nested moduleObject with `__executable` entries keyed by path\n- Parse each template with `parseSync(..., {startRule: 'TemplateBodyAtt'})`\n- Validate template AST against declared params at parse time\n- Keep single-file `.att` import banned - use `/exe @name() = template \"file.att\"` for that\n- Consider lazy loading (don't parse until first invocation) for performance\n- Security: ensure traversal stays under base dir, taint labels track each file\n\n**Security:** Base directory fixed at definition time, only filename/index varies at runtime. Provenance trackable. All templates get taint from their source file.\n\nReported by @partydev's use case in chat.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T20:20:32.153268-08:00","updated_at":"2025-12-10T20:55:40.462412-08:00"}
{"id":"mlld-e0b","title":"Interpreter: Modify run evaluator to resolve and pass cwd","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task modifies the run evaluator to check for workingDir in the AST, resolve it, and pass it to command executors.\n\n## Prerequisites\n- mlld-1x2 complete (cwd-resolver exists)\n- mlld-u8r complete (workingDir types defined)\n- Grammar tasks complete (workingDir in AST)\n\n## Task\nModify `interpreter/eval/run.ts` to handle the optional `workingDir` field from the AST.\n\n## Implementation\n\nLocation: `interpreter/eval/run.ts`\n\n### Step 1: Import the resolver\n\nAdd import at top of file:\n```typescript\nimport { resolveCwd } from '../utils/cwd-resolver';\n```\n\n### Step 2: Find command execution locations\n\nLook for calls to:\n- `env.executeCommand()`\n- `env.executeCode()`\n\nThese are likely in functions like:\n- `evaluateRunCommand()` - for `cmd {...}`\n- `evaluateRunCode()` - for `sh {...}`, `bash {...}`, etc.\n\n### Step 3: Add cwd resolution before execution\n\nFor each execution point, add cwd resolution:\n\n```typescript\n// Check if workingDir is present in AST\nlet resolvedCwd: string | undefined;\nif (node.values?.workingDir) {\n  resolvedCwd = await resolveCwd(\n    node.values.workingDir,\n    env,\n    node.location\n  );\n}\n\n// Pass to executor\nconst result = await env.executeCommand(command, {\n  ...existingOptions,\n  cwd: resolvedCwd\n});\n```\n\n### Step 4: Handle both cmd and code execution\n\nMake sure both paths are covered:\n\n**For cmd execution:**\n```typescript\nconst result = await env.executeCommand(command, {\n  env: envVars,\n  cwd: resolvedCwd,  // NEW\n  // ... other options\n});\n```\n\n**For code execution (sh, bash, js, python):**\n```typescript\nconst result = await env.executeCode(language, code, {\n  args: resolvedArgs,\n  cwd: resolvedCwd,  // NEW\n  // ... other options\n});\n```\n\n## Edge Cases\n\n1. **workingDir is optional**: Only resolve if present in AST\n2. **Error propagation**: Let `resolveCwd` errors bubble up naturally\n3. **Pipeline context**: Each command gets its own cwd resolution\n\n## Testing\n\nAfter implementation, test with actual mlld scripts:\n\n```bash\necho '/var @mypath = \"/tmp\"\n/run cmd:@mypath {pwd}' | ./dist/cli.cjs\n\n# Should output: /tmp\n```\n\n```bash\necho '/run cmd:/nonexistent {ls}' | ./dist/cli.cjs\n\n# Should error: Working directory does not exist\n```","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:35.93044-08:00","updated_at":"2025-12-08T20:24:42.061534-08:00","closed_at":"2025-12-08T20:24:42.061534-08:00"}
{"id":"mlld-e4j","title":"Improve error message when .att parsed as field access","description":"When users write `@x.name.att` intending a path like `alice.att`, they get a confusing error:\n\n\"Cannot access field att on non-object value (string)\"\n\nThis is because the parser interprets `.att` as field access on `@x.name`.\n\n**Expected**: A helpful error message suggesting the user might need to escape the dot: `@x.name\\.att`\n\n**Current**: Generic field access error that doesn't hint at the likely cause.\n\nThis is a common gotcha for users working with .att template files in dynamic paths.\n\nReported by @partydev in chat.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-10T19:40:11.908742-08:00","updated_at":"2025-12-10T23:08:53.126333-08:00","closed_at":"2025-12-10T23:08:53.126333-08:00"}
{"id":"mlld-ecy","title":"Support comments (\u003e\u003e and \u003c\u003c) inside block bodies","description":"**Current:** Comments aren't allowed inside `[...]` blocks:\n```mlld\n/exe @func() = [\n  let @x = 1        \u003e\u003e this comment causes parse error\n  let @y = 2  \u003c\u003c so does this\n  =\u003e @x + @y\n]\n```\n\nParse error: \"Expected ... but '#' found\" or \"Invalid variable syntax, but found '\u003c'\"\n\n**Desired:** Comments should work inside blocks just like they work everywhere else:\n```mlld\n/exe @func() = [\n  let @x = 1        \u003e\u003e start-of-line comment\n  let @y = 2  \u003c\u003c end-of-line comment\n  =\u003e @x + @y  \u003c\u003c return value\n]\n\n/for @item in @items [\n  \u003e\u003e explain this step\n  let @processed = @transform(@item)\n  show @processed  \u003c\u003c debug output\n]\n\n/when [\n  let @check = @validate(@input)  \u003e\u003e validate first\n  @check.valid =\u003e @process(@input)  \u003c\u003c process if valid\n  * =\u003e show \"Invalid\"  \u003c\u003c fallback\n]\n```\n\n**Use case:** Documenting complex block logic, especially for multi-step orchestration patterns where each step needs explanation.\n\n**Grammar location:** Block statement parsing (exe blocks, for blocks, when blocks) needs to accept comment tokens.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-11T09:49:06.410873-08:00","updated_at":"2025-12-11T09:51:28.767535-08:00","closed_at":"2025-12-11T09:51:28.767535-08:00"}
{"id":"mlld-emu","title":"CLI: add --payload alias for --inject flag","description":"**Reported by:** partydev during SDK dogfooding\n\n**Request:**\nAdd `--payload` as an alias for `--inject` in the CLI for consistency with the SDK.\n\n**Rationale:**\n- SDK uses `execute(file, payload)`\n- CLI uses `--inject`\n- For consistency, `mlld file.mld --payload '{...}'` would be more intuitive\n\n**Implementation:**\nAdd alias in ArgumentParser - straightforward change.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-09T07:50:59.202687-08:00","updated_at":"2025-12-09T08:06:20.371517-08:00","closed_at":"2025-12-09T08:06:20.371517-08:00"}
{"id":"mlld-evv","title":"Add .mx.key accessor for object values during iteration","description":"Currently users can access keys during iteration via @var_key suffix. But now that we have .mx.keys, .mx.values, .mx.entries on objects, it would be more consistent to also support .mx.key on individual items when iterating.\n\nExample use case:\n/for @agent in @agentRegistry =\u003e show `Key: @agent.mx.key`\n\nThis would be cleaner than @agent_key suffix and more consistent with the new .mx namespace for objects.\n\nNote: .mx.value is probably unnecessary since the item itself IS the value. But .mx.key would be useful for consistency.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-18T11:54:55.980867-08:00","updated_at":"2025-12-18T16:15:50.629027-08:00","closed_at":"2025-12-18T16:15:50.629027-08:00","close_reason":"Fixed by agent. Added .mx.key accessor for iteration and fixed directory import exports. Tests pass."}
{"id":"mlld-eyv","title":"LSP: Fix pipe transform highlighting parity bug (GH#328)","description":"## Summary\nPipe transforms only highlight correctly with odd number of pipes in /var directives.\n\nGitHub: https://github.com/mlld-lang/mlld/issues/328\n\n## Problem\n```mlld\n/var @x = @data | @transform1 | @transform2  \u003c\u003c Second pipe not highlighted\n/var @y = @data | @transform1                \u003c\u003c Works fine (1 pipe)\n/var @z = @data | @t1 | @t2 | @t3           \u003c\u003c Works (3 pipes = odd)\n```\n\n## Root Cause\nLikely an off-by-one error or loop issue in pipeline operator tokenization.\n\n## Investigation\n1. Check `services/lsp/utils/OperatorTokenHelper.ts` - `tokenizePipelineOperators` method\n2. Check DirectiveVisitor's handling of pipeline RHS\n\n```bash\nnpm run ast -- '/var @x = @data | @t1 | @t2'\n# Examine pipeline structure in AST\n```\n\n## Implementation\nThe issue is likely in how we iterate through pipeline stages:\n\n```typescript\n// Possible bug pattern:\nfor (let i = 0; i \u003c stages.length - 1; i++) {\n  // Tokenize pipe between stages[i] and stages[i+1]\n  // If we're skipping every other, check the loop logic\n}\n```\n\nLook for:\n- Loop bounds issues\n- Alternating pattern in tokenization\n- Missing pipe operators between certain stage pairs\n\n## Testing\n```bash\nnpm test services/lsp/semantic-tokens.test.ts\n```\n\nAdd test case:\n```typescript\nit('highlights all pipe operators in chain', async () =\u003e {\n  const tokens = await getSemanticTokens('/var @x = @data | @t1 | @t2');\n  const pipeTokens = tokens.filter(t =\u003e t.text === '|');\n  expect(pipeTokens).toHaveLength(2);\n});\n```\n\n## Files to Modify\n- `services/lsp/utils/OperatorTokenHelper.ts` or\n- `services/lsp/visitors/DirectiveVisitor.ts`\n\n## Size\nSmall - likely a loop bounds fix","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:37.208122-08:00","updated_at":"2025-12-11T22:05:24.417279-08:00","closed_at":"2025-12-11T22:05:24.417279-08:00","dependencies":[{"issue_id":"mlld-eyv","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.34824-08:00","created_by":"daemon"}]}
{"id":"mlld-f2q","title":"Harden path resolution story across the board for monorepo setups","description":"Inconsistent where various parts of the codebase think things are rooted\n\nWe need to find the way different parts of the codebase root paths and what assumptions and fallbacks they use\n\nThen we need to make sure these work completely consistently in cases where a dir is inside another dir that possesses qualities that might make other parts of the codebase infer paths differently.\n\nHaving `/monorepo/.git` seems to set where `mlld-config.json` gets written if `mlld setup` is run in `/monorepo/subproject` -- instead of writing/updating the new mlld-config.json in subproject, it writes/updates it at the root or at leaset SEEMS to.\n\nThis will be a research task first, then a discussion to decide how to reconcile and standardize for reasonably expected UX.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T04:11:07.083517-08:00","updated_at":"2025-12-11T04:41:01.81153-08:00","closed_at":"2025-12-11T04:41:01.811532-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-fln","title":"Epic: Block Syntax, While Loops, and Grammar Error Handling","description":"A unified grammar epic that adds three major features to mlld:\n\n1. **Block syntax `[...]`** for exe/for directives with `let`/`+=` support\n2. **While loops** with `done`/`continue` keywords for bounded iteration\n3. **Unified when syntax** - one form: `when [condition =\u003e action]`\n4. **Improved error handling** - proper location tracking in blocks\n\n## Key Insight\n\nAll three features use `[...]` delimiter for mlld constructs, creating clear visual separation from JS/shell `{...}` syntax. This helps LLMs distinguish mlld from embedded languages.\n\n## Why Together\n\nSame files, same patterns, shared error infrastructure. More efficient as one epic than three separate PRs.\n\n## Block Syntax (CRITICAL)\n\n**For loops**:\n- Preferred: `for @x in @xs [...]` (no arrow)\n- Deprecated: `for @x in @xs =\u003e [...]` (arrow still works but deprecated)\n\n**Exe blocks**:\n- `exe @f() = [...]`\n\n**When**:\n- Block: `when [...]`\n- Simple: `when @condition =\u003e action`\n\n## Delimiter Rules\n\n- `{...}` ‚Üí code/command/data (requires prefix or property syntax)\n- `[...]` ‚Üí mlld blocks in exe/for/when contexts\n- `[...]` ‚Üí array literals in var/argument contexts\n- **Context determines meaning** - No ambiguity!\n\n## New Keywords\n\n- `done` and `continue` (for while loops)\n- `let` already exists for when blocks\n\n## Scope Restrictions (Pragmatic)\n\n**NOT Implementing:**\n- Field access mutation: `let @data[-1].field += value` ‚Üí ETOOCOMPLEX\n- Parallel for with blocks: `for parallel() @x [...]` ‚Üí Use exe wrapper\n- Batch pipelines with blocks: `for [...] =\u003e ||` ‚Üí Use simple expressions\n- When match form: `when @var: [...]` ‚Üí Use `when [@var == value =\u003e ...]`\n- **var +=**: No augmented assignment for var; use `let` in blocks\n\n**ARE Implementing:**\n- Block syntax `[...]` for multi-statement bodies (exe, for)\n- Simple let/+=: `let @var = value` and `let @var += value` (variable name only, no field access)\n- Nested control flow: for/when inside blocks\n- While loops: Bounded iteration with done/continue\n- Explicit returns: `=\u003e @value` (required in exe blocks, must be last)\n- Proper error handling: Location tracking, helpful messages\n- Strict/loose mode: No slashes in strict, top-level only in loose\n\n## Implementation Phases\n\n1. **Phase 0**: Abstraction Discovery (60-90 min reading before code) ‚úÖ\n2. **Phase 1**: Grammar + Types (all features, parse-only focus) ‚úÖ\n3. **Phase 2**: Interpreter (one construct at a time) - IN PROGRESS\n4. **Phase 3**: Core Tests (minimal golden set - 5 tests)\n5. **Phase 4**: Integration \u0026 Polish (optional)\n\n## Success Criteria\n\n1. All core test cases pass\n2. Exe blocks can have sequential statements with let/+=\n3. For blocks can have nested control flow\n4. Let variables properly scoped to blocks\n5. Augmented assignment works on arrays, strings, objects\n6. Return statements work in exe blocks\n7. Error messages clear and actionable\n8. Nested blocks maintain separate scopes\n\n## Estimate\n\n3-5 Claude sessions (grammar-first approach, abstraction reuse focus)\n\n## Reference\n\nSee `todo/plan-grammar-next.md` for full implementation details.","notes":"Epic complete! All features implemented, tested, and documented.\n\nCompleted:\n‚úÖ Block syntax for exe/for with [...]\n‚úÖ While loops with done/continue\n‚úÖ Let/+= in blocks\n‚úÖ All tests passing (2419 tests)\n‚úÖ Documentation updated (flow-control.md, reference.md, llms.txt, AST.md)\n‚úÖ Bonus: Math operators fixed (mlld-a2x)\n\nAll phases complete:\n- Phase 0: Abstraction Discovery ‚úÖ\n- Phase 1: Grammar + Types (6 tasks) ‚úÖ\n- Phase 2: Interpreter (4 tasks) ‚úÖ\n- Phase 3: Core Tests ‚úÖ\n- Phase 4: Integration Tests ‚úÖ\n\nReady for production!","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-09T22:13:32.943942-08:00","updated_at":"2025-12-15T20:50:09.182649-08:00","closed_at":"2025-12-10T18:38:54.293529-08:00","dependencies":[{"issue_id":"mlld-fln","depends_on_id":"mlld-cw9","type":"parent-child","created_at":"2025-12-09T22:14:11.122384-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-9pl","type":"parent-child","created_at":"2025-12-09T22:16:29.283436-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-1sh","type":"parent-child","created_at":"2025-12-09T22:16:29.35034-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-wrb","type":"parent-child","created_at":"2025-12-09T22:16:29.417501-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-8d6","type":"parent-child","created_at":"2025-12-09T22:16:29.524287-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-0gd","type":"parent-child","created_at":"2025-12-09T22:16:29.592885-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-zeo","type":"parent-child","created_at":"2025-12-09T22:18:43.391952-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-9id","type":"parent-child","created_at":"2025-12-09T22:18:43.463166-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-0ic","type":"parent-child","created_at":"2025-12-09T22:18:43.545022-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-ait","type":"parent-child","created_at":"2025-12-09T22:18:43.615165-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-jw7","type":"parent-child","created_at":"2025-12-09T22:19:32.661253-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-5ik","type":"parent-child","created_at":"2025-12-09T22:20:06.935882-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-1iz","type":"parent-child","created_at":"2025-12-09T22:27:45.067721-08:00","created_by":"daemon"}]}
{"id":"mlld-fsa","title":"Add @root as alias for @base","description":"**Rationale:** `@root` is a more common/intuitive term for project root than `@base`. Should work as an alias.\n\n**Desired:**\n```mlld\n/var @readme = \u003c@root/README.md\u003e    # same as @base/README.md\n/import { @cfg } from \"@root/config.mld\"\n/import templates from \"@root/templates\" as @tmp(msg)\n```\n\n**Implementation:**\n1. Add `'root'` to reserved function resolvers list (Environment.ts:516)\n2. Update resolver checks to include `root`:\n   - ImportDirectiveEvaluator.ts:245 - static import validation\n   - ImportDirectiveEvaluator.ts:265 - templates import validation\n   - Any other places checking `resolverName === 'base'`\n3. Add `@root` to resolver config with same behavior as `@base`\n4. Update docs to mention `@root` as alias\n\n**Priority:** P3 - nice to have, `@base` works fine but `@root` is more intuitive for new users.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-10T22:48:01.085959-08:00","updated_at":"2025-12-10T23:08:24.861834-08:00"}
{"id":"mlld-fzr","title":"init incorrectly names files `.mlld.md` instead of `.mld.md`","description":"We don't want `.mlld` or `.mlld.md` to become standard -- just `.mld` and `.mld.md` ","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T05:17:57.376218-08:00","updated_at":"2025-12-08T12:18:32.986333-08:00","closed_at":"2025-12-08T12:18:32.986333-08:00","labels":["creator:adamavenir@hey.com"]}
{"id":"mlld-ghp","title":"Negative token position on line 14 causing tokenization failure","description":"LSP error: char: -1, length: 17, tokenType: 'variableRef' on line 14 of orchestrate.mld. This invalid token causes entire semantic token response to fail (0 tokens sent). Blocks all highlighting. Line: /exe @getReplyPressure(agent, msg) = [","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-12T18:09:19.520324-08:00","updated_at":"2025-12-12T19:05:05.998115-08:00","closed_at":"2025-12-12T19:05:05.998115-08:00"}
{"id":"mlld-gj7","title":"Grammar: add mode flag and optional slash prefix","description":"**Summary:**\nAdd a `mode: 'strict' | 'markdown'` option to the parser and make the leading `/` optional on directives.\n\n**Changes required:**\n\n1. **Parser options** (`grammar/parser/index.ts` or entry point):\n   - Accept `mode` option, default to `'markdown'` for backward compat during transition\n   - Thread mode into grammar context\n\n2. **Grammar helper** (`grammar/deps/grammar-core.ts`):\n   - Replace `isSlashDirectiveContext` with `isDirectiveContext`\n   - In both modes, match optional `/` followed by directive keyword at line start\n   - The difference is handled at top-level line classification, not here\n\n3. **Directive rules** (`grammar/mlld.peggy` or modular files):\n   - Change directive prefix from `\"/\"` to `\"/\"?`\n   - All directives: var, exe, run, show, for, when, import, export, guard, output, log, append, stream, needs, wants\n   - Keep semantic actions unchanged\n\n4. **Top-level line rule**:\n   ```peggy\n   Line \n     = Directive\n     / BlankLine\n     / \u0026{ return options.mode === 'markdown' } TextLine\n     / \u0026{ return options.mode === 'strict' } StrictModeTextError\n   \n   StrictModeTextError = (!Directive .)+ { \n     error(\"Text content not allowed in strict mode (.mld). Use .mld.md for prose.\") \n   }\n   ```\n\n5. **Blank line handling**:\n   - Strict mode: blank lines are whitespace, produce no AST node\n   - Markdown mode: blank lines may become content nodes (current behavior)\n\n**Testing:**\n- Add grammar unit tests for optional slash parsing\n- Verify existing tests pass with mode='markdown'","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:57:33.602447-08:00","updated_at":"2025-12-15T20:50:09.182983-08:00","closed_at":"2025-12-11T17:17:42.628808-08:00","dependencies":[{"issue_id":"mlld-gj7","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.389438-08:00","created_by":"daemon"}]}
{"id":"mlld-jw7","title":"Phase 3: Core Tests - Minimal golden set for block syntax epic","description":"## Summary\n\nCreate 5 core test cases that validate each feature works in isolation. These are the minimal golden set before moving to integration tests.\n\n## Prereq\n\nAll Phase 2 interpreter issues must be complete:\n- mlld-zeo (Export let functions)\n- mlld-9id (Exe blocks)\n- mlld-0ic (For blocks)\n- mlld-ait (While loops)\n\n## Test Structure\n\n```\ntests/cases/feat/\n‚îú‚îÄ‚îÄ exe-block/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ for-block/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ when-unified/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ while/\n‚îÇ   ‚îî‚îÄ‚îÄ basic-done-continue/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\ntests/cases/exceptions/\n‚îî‚îÄ‚îÄ augmented-assignment/\n    ‚îî‚îÄ‚îÄ undefined-variable/\n        ‚îú‚îÄ‚îÄ example.md\n        ‚îî‚îÄ‚îÄ error.md\n```\n\n## Test 1: Exe Block Happy Path\n\nFile: `tests/cases/feat/exe-block/basic/example.md`\n```mlld\n/exe @greet(name) = [\n  let @greeting = \"Hello\"\n  let @punctuation = \"!\"\n  =\u003e \"@greeting @name@punctuation\"\n]\n\n/show @greet(\"World\")\n```\n\nExpected: `expected.md`\n```\nHello World!\n```\n\n**Purpose**: Exe block with let assignments and explicit return.\n\n---\n\n## Test 2: For Block Happy Path (UPDATED)\n\nFile: `tests/cases/feat/for-block/basic/example.md`\n```mlld\n/exe @countAndShow(items) = [\n  let @count = 0\n  for @item in @items [\n    show \"Item: @item\"\n    let @count += 1\n  ]\n  =\u003e @count\n]\n\n/show \"Total: @countAndShow([\"a\", \"b\", \"c\"])\"\n```\n\nExpected: `expected.md`\n```\nItem: a\nItem: b\nItem: c\nTotal: 3\n```\n\n**Purpose**: For block with let/let+= for accumulation (wrapped in exe block since let is block-scoped).\n\n**Note**: `var +=` is NOT supported. Use `let` for accumulation within exe blocks.\n\n---\n\n## Test 3: When Unified Syntax\n\nFile: `tests/cases/feat/when-unified/basic/example.md`\n```mlld\n/exe @classify(x) = when [\n  @x \u003e 100 =\u003e \"large\"\n  @x \u003e 10 =\u003e \"medium\"\n  * =\u003e \"small\"\n]\n\n/show @classify(150)\n/show @classify(50)\n/show @classify(5)\n```\n\nExpected: `expected.md`\n```\nlarge\nmedium\nsmall\n```\n\n**Purpose**: When expression with unified `[condition =\u003e action]` syntax.\n\n---\n\n## Test 4: While Loop Happy Path\n\nFile: `tests/cases/feat/while/basic-done-continue/example.md`\n```mlld\n/exe @countdown(n) = when [\n  @n \u003c= 0 =\u003e done \"finished\"\n  * =\u003e continue (@n - 1)\n]\n\n/var @result = 5 | while(10) @countdown\n/show @result\n```\n\nExpected: `expected.md`\n```\nfinished\n```\n\n**Purpose**: While loop with done/continue keywords.\n\n---\n\n## Test 5: Error - Augmented Assignment Without Let\n\nFile: `tests/cases/exceptions/augmented-assignment/undefined-variable/example.md`\n```mlld\n/exe @bad() = [\n  let @count += 1\n]\n/show @bad()\n```\n\nExpected: `error.md`\n```\nCannot use += on undefined variable @count. Use \"let @count = ...\" first.\n```\n\n**Purpose**: Runtime error for += without prior let.\n\n---\n\n## Running Tests\n\n```bash\n# Build fixtures first\nnpm run build:fixtures\n\n# Run all block syntax tests\nnpm run test:case -- feat/exe-block\nnpm run test:case -- feat/for-block\nnpm run test:case -- feat/when-unified\nnpm run test:case -- feat/while\n\n# Run exception tests\nnpm run test:case -- exceptions/augmented-assignment\n```\n\n## Validation\n\n- [ ] All 5 test cases created\n- [ ] Fixtures generated without errors\n- [ ] All tests pass\n- [ ] Edge cases identified for Phase 4","notes":"‚úÖ PREREQUISITE UPDATE: Phase 1 AST verification (mlld-b4f) complete. All grammar constructs parse correctly. Type enums updated. Test Results: 2391/2391 passed (100%). All AST structures validated and documented in tmp/phase1-ast-verification.md. Ready to implement Phase 3 core tests once Phase 2 interpreters are complete.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:19:25.090487-08:00","updated_at":"2025-12-15T20:50:09.18328-08:00","closed_at":"2025-12-10T17:37:42.175858-08:00","dependencies":[{"issue_id":"mlld-jw7","depends_on_id":"mlld-9id","type":"blocks","created_at":"2025-12-09T22:19:32.747661-08:00","created_by":"daemon"},{"issue_id":"mlld-jw7","depends_on_id":"mlld-0ic","type":"blocks","created_at":"2025-12-09T22:19:32.834833-08:00","created_by":"daemon"},{"issue_id":"mlld-jw7","depends_on_id":"mlld-ait","type":"blocks","created_at":"2025-12-09T22:19:32.960034-08:00","created_by":"daemon"}]}
{"id":"mlld-k3o","title":"4 locally passing tests failing  in CI","description":"Commit 5bf290514933486073ce8c44090411dd76542972 was supposed to fix our CI but the exact same issues persist in GitHub, blocking the PR.\n\n‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ Failed Tests 4 ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ\n\n FAIL  interpreter/interpreter.fixture.test.ts \u003e Mlld Interpreter - Fixture Tests \u003e should handle slash/exe/exe-node-gray-matter-access\nMlldCommandExecutionError: Command execution failed: node: \n  const matter = require('gray-matter');\n  const ...\n‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[1/4]‚éØ\n\n FAIL  interpreter/interpreter.fixture.test.ts \u003e Mlld Interpreter - Fixture Tests \u003e should handle slash/exe/exe-node-mlld-dependencies\nMlldCommandExecutionError: Command execution failed: node: \n  const matter = require('gray-matter');\n  const ...\n‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[2/4]‚éØ\n\n FAIL  interpreter/interpreter.fixture.test.ts \u003e Mlld Interpreter - Fixture Tests \u003e should handle slash/exe/exe-node-shadow-env-always-created\nAssertionError: expected '# Test Node Shadow Environment Always‚Ä¶' to be '# Test Node Shadow Environment Always‚Ä¶' // Object.is equality\n\n- Expected\n+ Received\n\n@@ -12,6 +12,6 @@\n  ## Test 3: VM Context is used (not subprocess)\n\n  VM context check: Running in VM context\n  ## Test 4: Module resolution includes mlld dependencies\n\n- Module access: Can access mlld dependencies\n+ Module access: Cannot access mlld dependencies\n\n ‚ùØ interpreter/interpreter.fixture.test.ts:1555:36\n    1553|           const normalizedResult = result.trim();\n    1554|           const normalizedExpected = fixture.expected.trim();\n    1555|           expect(normalizedResult).toBe(normalizedExpected);\n       |                                    ^\n    1556|           } else if (isSmokeTest) {\n    1557|             // For smoke tests, just verify it doesn't crash and produ‚Ä¶\n\n‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[3/4]‚éØ\n\n FAIL  tests/integration/imports/basic-patterns.test.ts \u003e Import Pattern: Selected Imports \u003e Import Error Handling \u003e should fail when importing non-existent variable\nAssertionError: expected +0 to be 1 // Object.is equality\n\n- Expected\n+ Received\n\n- 1\n+ 0\n\n ‚ùØ tests/integration/imports/basic-patterns.test.ts:124:31\n    122|       \n    123|       expect(result.success).toBe(true); // Test expects an error\n    124|       expect(result.exitCode).toBe(1);\n       |                               ^\n    125|     });\n    126|     \n\n‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ[4/4]‚éØ\n\n\n Test Files  2 failed | 191 passed | 6 skipped (199)\n      Tests  4 failed | 2548 passed | 68 skipped (2620)","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-11T22:14:23.914668-08:00","updated_at":"2025-12-11T22:27:16.715736-08:00","labels":["bug","creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-k4k","title":"Strict mode for .mld files","description":"Implement a strict execution mode for .mld files that eliminates LLM-unfriendly ambiguities:\n\n**Problem:**\n- Current mlld requires `/` prefix on directive lines, which creates ambiguity\n- Non-directive lines become implicit content output, which LLMs can accidentally trigger\n- This makes mlld harder for LLMs to generate correctly\n\n**Solution:**\nTwo modes based on file extension:\n- `.mld` ‚Üí strict mode: bare directives, text lines error, blank lines ignored\n- `.mld.md` ‚Üí markdown mode: `/` required, text becomes content (current behavior)\n\n**Key decisions:**\n- Optional `/` prefix in strict mode for backward compatibility\n- Blank lines are no-ops in strict mode (formatting whitespace)\n- Raw strings in SDK default to strict mode\n- Mode included in AST cache keys\n\n**Line handling by mode:**\n\n| Line Type          | Strict Mode   | Markdown Mode   |\n|--------------------|---------------|-----------------|\n| `/directive`       | ‚úì Execute     | ‚úì Execute       |\n| `directive` (bare) | ‚úì Execute     | Text content    |\n| Blank              | ‚úì Ignore      | Content         |\n| Text               | ‚úó Error       | Content         |\n\nSee child issues for implementation breakdown.\n\nIMPORTANT: Ensure compatibility with \n1. current .mld.md module format which mixes ```mlld``` and ```mlld-run``` in markdown + frontmatter files‚Äîthis should be valid.\n2. `/for`...`/end` loops in templates","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-08T19:57:11.921576-08:00","updated_at":"2025-12-15T20:50:09.183587-08:00","dependencies":[{"issue_id":"mlld-k4k","depends_on_id":"mlld-5jz","type":"blocks","created_at":"2025-12-09T08:28:34.440584-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-9qq","type":"blocks","created_at":"2025-12-09T08:29:07.286149-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-04k","type":"blocks","created_at":"2025-12-09T08:29:37.475238-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-4cw","type":"blocks","created_at":"2025-12-09T08:30:06.896625-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-cgb","type":"blocks","created_at":"2025-12-09T08:30:38.780886-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-o2u","type":"blocks","created_at":"2025-12-09T08:31:10.514377-08:00","created_by":"adam"}]}
{"id":"mlld-k53","title":"cmd and run lang {} blocks not tokenized inside exe/for blocks","description":"Code blocks inside exe/for/when blocks aren't being tokenized.\n\nNot working:\n- for parallel(3) @r in @agents [ run cmd { bdm post } ]\n- exe @func = [ run js { console.log('hi') } ]\n\nShould work same as top-level:\n- /run cmd { bdm post } ‚úì works\n- /run js { console.log('hi') } ‚úì works\n\nIssue: Nested run directives inside blocks not getting tokenized.\n\nFiles: Check how run directives are visited when inside block statements","notes":"**ROOT CAUSE IDENTIFIED**\n\nThe tokenization code is correct, but highlighting fails when parse errors occur.\n\n**Discovery:**\n- With 'run @function()' inside blocks ‚Üí parse error ‚Üí broken tokenization\n- Without 'run' (valid syntax) ‚Üí parse succeeds ‚Üí highlighting works ‚úÖ\n\n**Conclusion:**\nThe tokenization fix I added (CommandVisitor.tokenizeCodeWithVariables) is correct and working.\nThe highlighting issues only appear when invalid 'run' keywords cause parse failures.\n\n**Resolution:**\nOnce mlld-93g (Grammar: Support explicit 'run' keyword inside exe blocks) is fixed, the tokenization will work correctly because parsing will succeed.\n\n**Status:**\nTokenization code: ‚úÖ Fixed and working\nHighlighting issues: Blocked by mlld-93g (grammar enhancement needed)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T05:32:55.2151-08:00","updated_at":"2025-12-15T11:06:20.503428-08:00","closed_at":"2025-12-15T08:43:23.508268-08:00","dependencies":[{"issue_id":"mlld-k53","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:32:55.215665-08:00","created_by":"daemon"}]}
{"id":"mlld-k69","title":"Tests: Add comprehensive test coverage for cmd:path/sh:path","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task creates comprehensive test coverage for the new syntax.\n\n## Prerequisites\n- All implementation tasks complete (grammar, types, interpreter, executors)\n\n## Task\nCreate test cases covering valid syntax, invalid syntax, runtime exceptions, and edge cases.\n\n## Test Structure\n\nmlld uses a fixture-based test system:\n- `tests/cases/` - valid test cases\n- `tests/cases/invalid/` - syntax/parse errors\n- `tests/cases/exceptions/` - runtime errors\n- `tests/fixtures/` - generated fixture files (gitignored)\n\n### Test File Naming\n\n**CRITICAL**: Test names must be unique across ALL tests. Use prefixes like:\n- `cmd-path-absolute.md` \n- `cmd-path-variable.md`\n- `sh-path-interpolation.md`\n\nNOT just `path.md` or `test.md`!\n\n## Valid Test Cases\n\nLocation: `tests/cases/cmd-path/` (create new directory)\n\n### 1. cmd-path-absolute.md\n```markdown\n/run cmd:/tmp {pwd}\n```\n\nexpected.md:\n```\n/tmp\n```\n\n### 2. cmd-path-variable.md\n```markdown\n/var @mypath = \"/tmp\"\n/run cmd:@mypath {pwd}\n```\n\nexpected.md:\n```\n/tmp\n```\n\n### 3. cmd-path-interpolation.md\n```markdown\n/var @base = \"/tmp\"\n/var @subdir = \"test\"\n/run cmd:@base/@subdir {pwd}\n```\n\nexpected.md:\n```\n/tmp/test\n```\n\n### 4. sh-path-absolute.md\n```markdown\n/run sh:/tmp {pwd}\n```\n\n### 5. bash-path-variable.md\n```markdown\n/var @dir = \"/tmp\"\n/run bash:@dir {pwd}\n```\n\n### 6. cmd-path-loop-iteration.md\n```markdown\n/var @dirs = [\"/tmp\", \"/home\"]\n/for @dir in @dirs {\n  /run cmd:@dir {pwd}\n}\n```\n\nexpected.md:\n```\n/tmp\n/home\n```\n\n### 7. cmd-no-path-still-works.md\nTest that existing cmd without :path still works:\n```markdown\n/run cmd {pwd}\n```\n\n## Invalid Test Cases (Parse Errors)\n\nLocation: `tests/cases/invalid/cmd-path/`\n\n### 1. cmd-path-invalid-relative.md\n```markdown\n/run cmd:./relative {ls}\n```\n\nerror.md:\n```\nParse error: working directory must start with / or @\n```\n\n### 2. cmd-path-invalid-bare.md\n```markdown\n/run cmd:relative {ls}\n```\n\nNote: This might parse successfully but fail at runtime if it doesn't start with `/` or `@`. Adjust test category as needed.\n\n## Exception Test Cases (Runtime Errors)\n\nLocation: `tests/cases/exceptions/cmd-path/`\n\n### 1. cmd-path-exception-undefined-var.md\n```markdown\n/run cmd:@undefined {pwd}\n```\n\nerror.md:\n```\nVariable @undefined is not defined\n```\n\n### 2. cmd-path-exception-not-rooted.md\n```markdown\n/var @rel = \"relative\"\n/run cmd:@rel {pwd}\n```\n\nerror.md:\n```\nWorking directory must be an absolute path\n```\n\n### 3. cmd-path-exception-not-exists.md\n```markdown\n/run cmd:/does/not/exist/path {ls}\n```\n\nerror.md:\n```\nWorking directory does not exist\n```\n\n### 4. cmd-path-exception-not-directory.md\n```markdown\n/run cmd:/etc/hosts {ls}\n```\n\nerror.md:\n```\nWorking directory path is not a directory\n```\n\n## Grammar Tests\n\nLocation: `grammar/tests/run.test.ts`\n\nAdd test cases to verify AST structure:\n\n```typescript\ndescribe('cmd:path syntax', () =\u003e {\n  it('should parse cmd with absolute path', () =\u003e {\n    const result = parse('/run cmd:/tmp {ls}');\n    expect(result.values.workingDir).toBeDefined();\n    expect(result.raw.workingDir).toBe('/tmp');\n  });\n  \n  it('should parse cmd with variable path', () =\u003e {\n    const result = parse('/run cmd:@mypath {ls}');\n    expect(result.values.workingDir).toHaveLength(1);\n    expect(result.values.workingDir[0].type).toBe('VariableReference');\n  });\n  \n  it('should parse sh with interpolated path', () =\u003e {\n    const result = parse('/run sh:@base/subdir {pwd}');\n    expect(result.values.workingDir).toHaveLength(2); // variable + text\n    expect(result.meta.hasWorkingDir).toBe(true);\n  });\n});\n```\n\n## Running Tests\n\n```bash\n# Generate fixtures\nnpm run build:fixtures\n\n# Run specific test directory\nnpm run test:case -- cmd-path\n\n# Run all tests\nnpm test\n```\n\n## Acceptance Criteria\n\n- [ ] All valid syntax parses and executes correctly\n- [ ] Undefined variables produce clear errors\n- [ ] Non-rooted paths are rejected\n- [ ] Non-existent directories are detected\n- [ ] File paths (not directories) are rejected  \n- [ ] Loop iterations work with different paths\n- [ ] Existing cmd/sh without :path still works\n- [ ] Grammar tests verify AST structure","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:49.842606-08:00","updated_at":"2025-12-08T20:25:12.829395-08:00","closed_at":"2025-12-08T20:25:12.829395-08:00"}
{"id":"mlld-kks","title":"False error on valid import with 'as' clause","description":"Line marked as error: /import templates from \"@templates/agents\" as @agentTemplates(message). This is valid syntax but LSP reports it as invalid. Red squiggly appearing on valid import directive. File: orchestrate.mld line 18","notes":"Fixed by updating checkStrictModeTextNodes to only check top-level Text nodes","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-12T18:08:33.943636-08:00","updated_at":"2025-12-12T20:11:11.438146-08:00","closed_at":"2025-12-12T20:11:11.438149-08:00"}
{"id":"mlld-ktr","title":"@exe() function calls not highlighted","description":"Exec invocations like @getReplyPressure(agent, msg) appear as plain text. Should be highlighted as function calls. Currently tokenized as 'function' type but not showing in editor. Seen in: orchestrate.mld lines 10, 26, 27","notes":"Fixed by refactoring ExecInvocation handling in CommandVisitor - now properly combines @ with function name and handles method calls","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-12T18:08:09.362773-08:00","updated_at":"2025-12-12T20:47:23.165201-08:00","closed_at":"2025-12-12T20:47:23.165203-08:00"}
{"id":"mlld-nco4","title":"Spurious DataValueEvaluator errors on directory import with nested property access in for-loops","description":"When using directory imports with for-loops that access nested properties, DataValueEvaluator errors are logged to stderr even though the script executes correctly and produces the right output.\n\nReproduction:\n```mlld\n/import \"@agents\" as @agentRegistry\n/for @agent in @agentRegistry =\u003e show @agent.meta.name\n```\n\nOutput:\n- Error: DataValueEvaluator error: (logged to stderr)\n- But the correct values are still shown and script completes successfully\n\nReproduction rate: 100% when all three conditions are met:\n1. Directory import is used\n2. For-loop iterates over the import\n3. Nested property accessed in loop body (@item.meta.name)\n\nImpact: Low severity\n- Functionality works correctly\n- Output is correct\n- Only creates noise in stderr\n- May confuse users seeing errors with correct results\n\nInvestigation needed:\n1. Find where error is being caught and swallowed\n2. Determine if this is legitimate error recovery or a bug\n3. Either fix underlying issue or suppress spurious logging\n4. Add better error context to logger.error call\n\nUser report: @partydev via devrel in proto-4.1 testing","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-18T21:19:01.323563-08:00","updated_at":"2025-12-18T21:19:01.323563-08:00"}
{"id":"mlld-nlu","title":"[Epic] LSP: Chunk-based parsing for error recovery (GH#335)","description":"## Summary\nImplement chunk-based parsing for better error recovery in the language server.\n\nGitHub: https://github.com/mlld-lang/mlld/issues/335\n\n## Problem\nWhen a document has a syntax error, the entire document may fail to parse, losing all semantic tokens.\n\n## Current Implementation\n\nLocated in `cli/commands/language-server-impl.ts`:\n- `attemptPartialParsing(text, originalError, mode)` at **line 1438**\n- `tryParseBlock(block, startLine, nodes, errors, mode)` at **line 1502**\n- `adjustLineNumbers(ast, offset)` at **line 1530**\n- Called from `analyzeDocument` at **line 566**\n\n### Current Behavior\n1. Parse text before error line\n2. Iterate lines, detect \"top-level\" constructs by checking for `/`, `\u003e\u003e`, `---`, code fences\n3. Parse each block, adjust line numbers, accumulate nodes\n\n### Current Limitations\n- **No bracket depth tracking** - splits inside `[...]` blocks, `{...}` code, templates\n- **Only adjusts line numbers** - doesn't rebase `offset` or `column` in locations\n- **Mutates AST nodes directly** - shared reference bugs possible\n- **Strict mode not fully handled** - bare directives (`var`, `show`) not detected as top-level\n\n## Proposed Approach\n\n### Chunk-Based Strategy\n1. Split document into logical chunks with **depth tracking** for `[]`, `{}`, `()`, templates\n2. Parse each chunk independently with mode\n3. Rebase **all location fields** (line, column, offset)\n4. Merge successful ASTs, mark failed chunks with error spans\n\n### Key Implementation Details\n\n**Chunk Boundary Detection:**\n```typescript\n// Must track depth for these constructs:\n// - Block syntax: [...] (rc78 exe/for/when blocks)\n// - Code blocks: {...} (commands, data)\n// - Templates: `, ::, ::: (multi-line)\n// - Parentheses: (...) (conditions, params)\n\n// Valid split points (when all depths === 0):\n// - Blank line followed by directive\n// - Markdown mode: line starting with /\n// - Strict mode: line starting with directive keyword\n```\n\n**Location Rebasing (critical for semantic tokens):**\n```typescript\n// Current adjustLineNumbers only does:\nnode.location.start.line += offset;\nnode.location.end.line += offset;\n\n// Must also adjust (used by TokenBuilder/visitors):\nnode.location.start.offset += chunkStartOffset;\nnode.location.end.offset += chunkStartOffset;\nnode.location.start.column  // only if chunk doesn't start at column 0\n```\n\n**Integration Point:**\n```typescript\n// In analyzeDocument (~line 566):\nconst partialAst = await attemptPartialParsing(text, error, mode);\n// Replace with:\nconst partialAst = await parseWithChunks(text, error, mode);\n```\n\n## Files to Modify\n- `cli/commands/language-server-impl.ts` - Replace attemptPartialParsing\n\n## Testing\nCreate documents with errors at different positions:\n- Error in first line\n- Error in middle of document\n- Error inside a `[...]` block\n- Error inside a template\n- Multiple errors\n- Strict mode with bare directives\n\n## Environment Variables\n- `MLLD_CHUNK_PARSING=0` - Disable chunk parsing (fallback to current behavior)\n- `DEBUG=mlld:lsp` - Existing debug logging, add chunk-specific logs\n\n## Acceptance Criteria\n- [ ] Documents with single error have mostly valid highlighting\n- [ ] Error recovery preserves tokens before and after error\n- [ ] Block constructs `[...]` not split incorrectly\n- [ ] Multi-line templates not split incorrectly\n- [ ] Performance acceptable (cap chunk count)\n- [ ] Offsets correctly rebased for semantic tokens\n\n## Size\nMedium - requires careful design of chunk splitting strategy\n\nNotes:\nEpic for chunk-based parsing recovery; child phases P0-P11 cover grounding through finalize.","notes":"Epic for chunk-based parsing recovery; child phases P0-P11 cover grounding through finalize.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T20:12:36.462075-08:00","updated_at":"2025-12-12T09:10:51.961205-08:00","closed_at":"2025-12-12T09:10:51.961205-08:00","labels":["epic"],"dependencies":[{"issue_id":"mlld-nlu","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.13203-08:00","created_by":"daemon"}]}
{"id":"mlld-nlu.1","title":"mlld-nlu P0: Grounding","description":"## Grounding - Understand Current Implementation\n\n### Files to Read\n1. `cli/commands/language-server-impl.ts` - Main LSP implementation\n\n### Key Functions (with line numbers)\n- **`attemptPartialParsing`** (line 1438): Entry point for error recovery\n  ```typescript\n  async function attemptPartialParsing(\n    text: string,\n    originalError: any,\n    mode: MlldMode  // Added recently - strict vs markdown\n  ): Promise\u003c{ nodes: any[], errors: Diagnostic[] }\u003e\n  ```\n\n- **`tryParseBlock`** (line 1502): Parses individual blocks\n  ```typescript\n  async function tryParseBlock(\n    block: string,\n    startLine: number,\n    nodes: any[],\n    errors: Diagnostic[],\n    mode: MlldMode\n  ): Promise\u003cvoid\u003e\n  ```\n\n- **`adjustLineNumbers`** (line 1530): Rebases AST locations\n  - Currently only adjusts `.line` - **NOT `.offset` or `.column`**\n  - Mutates nodes directly (potential shared reference issue)\n\n### Call Chain\n```\nanalyzeDocument (line 478)\n  ‚Üí parse() fails\n  ‚Üí attemptPartialParsing (line 566)\n    ‚Üí tryParseBlock (line 1483, 1496)\n      ‚Üí parse()\n      ‚Üí adjustLineNumbers()\n  ‚Üí returned nodes fed to ASTSemanticVisitor\n```\n\n### Current Top-Level Detection (line 1476)\n```typescript\nconst isTopLevel = trimmedLine.startsWith('/') || \n                  trimmedLine.startsWith('\u003e\u003e') ||\n                  trimmedLine.startsWith('---') ||\n                  trimmedLine.startsWith('```');\n```\n**Missing:** Bare directives in strict mode, bracket depth tracking\n\n### Debug Logging\n- `DEBUG=mlld:lsp` enables server-side logging\n- Look for `logger.debug()` patterns to follow\n\n### Semantic Token Dependencies\nVisitors use `node.location.start.offset` extensively:\n- `DirectiveVisitor.ts` line ~40: `node.location.start.offset`\n- `OperatorTokenHelper.ts`: offset-based operator search\n- `TokenBuilder.addToken()`: requires accurate positions\n\n### Deliverable\nDocument findings in a comment or notes. Confirm:\n- [ ] Understood current splitting logic limitations\n- [ ] Understood location rebase requirements (line + offset + column)\n- [ ] Understood mode parameter flow\n- [ ] Identified debug logging patterns","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:10:12.629701-08:00","updated_at":"2025-12-12T07:44:41.651414-08:00","closed_at":"2025-12-12T07:44:41.651414-08:00","dependencies":[{"issue_id":"mlld-nlu.1","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:10:12.630352-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.10","title":"mlld-nlu P9: Acceptance verification","description":"## Acceptance Verification\n\n### Test Scenarios\n\nRun each scenario and verify expected behavior:\n\n#### Scenario 1: Error in Middle\n```mlld\n/var @before = \"works\"\n\n/var @broken = INVALID\n\n/var @after = \"also works\"\n```\n**Expected:**\n- `@before` and `@after` highlighted as variables\n- Error squiggle on `INVALID` line\n- `/var` keywords highlighted\n\n#### Scenario 2: Error in Block\n```mlld\n/var @good = 1\n\n/exe @f() = [\n  let @x = BROKEN SYNTAX\n]\n\n/var @alsoGood = 2\n```\n**Expected:**\n- `@good` and `@alsoGood` highlighted\n- Error for the exe block (entire block fails)\n- Block `[...]` may or may not be highlighted depending on implementation\n\n#### Scenario 3: Multiple Errors\n```mlld\n/var @a = 1\nBROKEN LINE 1\n/var @b = 2\nBROKEN LINE 2\n/var @c = 3\n```\n**Expected:**\n- `@a`, `@b`, `@c` all highlighted\n- Two error squiggles for broken lines\n\n#### Scenario 4: Error at Start\n```mlld\nBROKEN FIRST LINE\n/var @works = \"yes\"\n```\n**Expected:**\n- `@works` highlighted\n- Error on first line\n\n#### Scenario 5: Error at End\n```mlld\n/var @works = \"yes\"\nBROKEN LAST LINE\n```\n**Expected:**\n- `@works` highlighted\n- Error on last line\n\n#### Scenario 6: Strict Mode\n```mlld\nvar @a = 1\n\nBROKEN\n\nvar @b = 2\n```\n**Expected (strict mode):**\n- `var` keywords highlighted (not just `/var`)\n- `@a` and `@b` highlighted\n- Error on BROKEN line\n\n#### Scenario 7: Multi-line Template Preserved\n```mlld\n/var @msg = `\nfirst line\n\nsecond line\n`\n\n/var @other = \"test\"\n```\n**Expected:**\n- Template not split (treated as single chunk)\n- Both variables highlighted\n\n### Verification Commands\n```bash\n# Run semantic token tests\nnpm test services/lsp/semantic-tokens.test.ts\n\n# Check specific error recovery tests\nnpm test -- --grep \"error recovery\"\n\n# Manual verification\nDEBUG=mlld:lsp mlld language-server\n# Then open test files in editor\n```\n\n### Acceptance Criteria Checklist\n- [ ] Scenario 1: Error in middle - PASS\n- [ ] Scenario 2: Error in block - PASS\n- [ ] Scenario 3: Multiple errors - PASS\n- [ ] Scenario 4: Error at start - PASS\n- [ ] Scenario 5: Error at end - PASS\n- [ ] Scenario 6: Strict mode - PASS\n- [ ] Scenario 7: Multi-line template - PASS\n- [ ] All existing LSP tests still pass\n- [ ] No performance regression (subjective)\n\n### Deliverable\n- [ ] Run all scenarios\n- [ ] Document any failures or edge cases\n- [ ] Fix issues found during verification\n- [ ] Sign off on acceptance criteria","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:12:33.16285-08:00","updated_at":"2025-12-12T09:10:44.196593-08:00","closed_at":"2025-12-12T09:10:44.196593-08:00","dependencies":[{"issue_id":"mlld-nlu.10","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:12:33.16416-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.10","depends_on_id":"mlld-nlu.9","type":"blocks","created_at":"2025-12-11T22:15:16.565701-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.11","title":"mlld-nlu P10: Fallback and toggle","description":"## Fallback and Toggle\n\n### Environment Variable Toggle\nFollow existing patterns in the codebase:\n```typescript\n// Existing patterns:\n// - MLLD_STRICT=1/0 for mode override\n// - DEBUG=mlld:lsp for logging\n// - MLLD_NO_STREAM for streaming\n\n// New toggle:\nconst CHUNK_PARSING_ENABLED = process.env.MLLD_CHUNK_PARSING !== '0';\n```\n\n### Implementation\n```typescript\nasync function parseWithChunks(\n  text: string,\n  originalError: any,\n  mode: MlldMode\n): Promise\u003cMergedParseResult\u003e {\n  \n  // Toggle: disable chunk parsing via env var\n  if (!CHUNK_PARSING_ENABLED) {\n    logger.debug('Chunk parsing disabled via MLLD_CHUNK_PARSING=0');\n    const result = await attemptPartialParsing(text, originalError, mode);\n    return { nodes: result.nodes, errors: result.errors, failedRanges: [] };\n  }\n  \n  // ... chunk parsing logic ...\n  \n  // Fallback: if all chunks fail, try legacy approach\n  if (merged.nodes.length === 0 \u0026\u0026 results.every(r =\u003e !r.success)) {\n    logger.debug('All chunks failed, falling back to legacy parsing');\n    const legacy = await attemptPartialParsing(text, originalError, mode);\n    return { nodes: legacy.nodes, errors: legacy.errors, failedRanges: [] };\n  }\n  \n  return merged;\n}\n```\n\n### Fallback Scenarios\n1. **Env var disabled** (`MLLD_CHUNK_PARSING=0`): Use legacy `attemptPartialParsing`\n2. **Too many chunks** (\u003e200): Fall back to single chunk\n3. **All chunks fail**: Try legacy approach as last resort\n4. **Splitter error**: Catch and fall back to legacy\n\n### Error Handling\n```typescript\ntry {\n  const chunks = splitIntoChunks(text, mode);\n  // ...\n} catch (e) {\n  logger.warn('Chunk splitting failed, using legacy parsing', { error: e.message });\n  const legacy = await attemptPartialParsing(text, originalError, mode);\n  return { nodes: legacy.nodes, errors: legacy.errors, failedRanges: [] };\n}\n```\n\n### Documentation for Users\nAdd to `docs/dev/LANGUAGE-SERVER.md`:\n```markdown\n### Chunk-Based Error Recovery\n\nThe language server uses chunk-based parsing to recover from syntax errors.\nWhen a document has errors, it splits the document into chunks and parses\neach independently, preserving highlighting for valid sections.\n\nTo disable (for debugging):\n```bash\nMLLD_CHUNK_PARSING=0 mlld language-server\n```\n```\n\n### Deliverable\n- [ ] Add `MLLD_CHUNK_PARSING` env var check\n- [ ] Implement all fallback scenarios\n- [ ] Add error handling around splitter\n- [ ] Document env var in LANGUAGE-SERVER.md\n- [ ] Test fallback behavior","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:12:48.175647-08:00","updated_at":"2025-12-12T09:10:44.197348-08:00","closed_at":"2025-12-12T09:10:44.197348-08:00","dependencies":[{"issue_id":"mlld-nlu.11","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:12:48.176896-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.11","depends_on_id":"mlld-nlu.10","type":"blocks","created_at":"2025-12-11T22:15:31.275005-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.12","title":"mlld-nlu P11: Finalize","description":"## Finalize\n\n### Pre-Merge Checklist\n\n**Code Quality:**\n- [ ] All functions have JSDoc comments\n- [ ] Type definitions are complete\n- [ ] No `any` types without justification\n- [ ] Error messages are user-friendly\n- [ ] Debug logging follows existing patterns\n\n**Testing:**\n- [ ] All unit tests pass\n- [ ] Integration tests pass\n- [ ] Manual testing with real documents\n- [ ] Tested with strict and markdown modes\n- [ ] Tested env var toggle\n\n**Performance:**\n- [ ] Chunk splitting is O(n) in document size\n- [ ] No memory leaks from cloning\n- [ ] Acceptable latency for typical documents\n- [ ] Chunk count cap prevents runaway splitting\n\n**Backwards Compatibility:**\n- [ ] Legacy `attemptPartialParsing` still available\n- [ ] Same return shape for callers\n- [ ] No breaking changes to LSP protocol\n- [ ] Env var allows disabling new behavior\n\n### Final Verification\n\n```bash\n# Build\nnpm run build\n\n# Run all LSP tests\nnpm test services/lsp/\n\n# Manual test with debug logging\nDEBUG=mlld:lsp mlld language-server\n\n# Test in editor\n# 1. Open .mld file with syntax error\n# 2. Verify highlighting works before/after error\n# 3. Verify error squiggle appears on error line\n```\n\n### PR Description Template\n\n```markdown\n## Summary\nImplements chunk-based parsing for LSP error recovery (closes #335).\n\n## Changes\n- Add `splitIntoChunks` with depth-aware boundary detection\n- Add `parseChunk` with location rebasing\n- Add `mergeChunkResults` for AST/diagnostic combination\n- Replace `attemptPartialParsing` call with `parseWithChunks`\n- Add `MLLD_CHUNK_PARSING=0` toggle for fallback\n\n## Testing\n- Unit tests for chunk splitting\n- Unit tests for location rebasing\n- Integration tests for error recovery scenarios\n- Manual testing in VSCode\n\n## Notes\n- Falls back to legacy parsing if all chunks fail\n- Respects block syntax, templates, and code fences\n- Caps chunk count at 200 for safety\n```\n\n### Deliverable\n- [ ] Complete pre-merge checklist\n- [ ] Run final verification\n- [ ] Create PR with description\n- [ ] Address review feedback","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:13:03.650862-08:00","updated_at":"2025-12-12T09:10:44.197838-08:00","closed_at":"2025-12-12T09:10:44.197838-08:00","dependencies":[{"issue_id":"mlld-nlu.12","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:13:03.651531-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.12","depends_on_id":"mlld-nlu.11","type":"blocks","created_at":"2025-12-11T22:15:44.517148-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.2","title":"mlld-nlu P1: Data structures and contracts","description":"## Data Structures and Contracts\n\n### Chunk Data Structure\n```typescript\ninterface Chunk {\n  text: string;           // The chunk content\n  startLine: number;      // 0-based line number in original document\n  endLine: number;        // 0-based end line (inclusive)\n  startOffset: number;    // Character offset from document start\n  endOffset: number;      // Character offset of chunk end\n  startColumn: number;    // Column of first char (usually 0)\n}\n```\n\n### Parse Result Structure\n```typescript\ninterface ChunkParseResult {\n  success: boolean;\n  chunk: Chunk;\n  ast: MlldNode[];        // Empty if failed\n  diagnostics: Diagnostic[];\n  error?: Error;          // Original parse error if failed\n}\n```\n\n### Merged Result Structure\n```typescript\ninterface MergedParseResult {\n  nodes: MlldNode[];      // All successfully parsed nodes\n  errors: Diagnostic[];   // All diagnostics including chunk failures\n  failedRanges: Range[];  // Ranges that couldn't be parsed (for token gaps)\n}\n```\n\n### Location Rebase Requirements\n\n**Current AST location shape:**\n```typescript\nnode.location = {\n  start: { line: number, column: number, offset: number },\n  end: { line: number, column: number, offset: number }\n}\n```\n\n**All fields must be rebased:**\n```typescript\nfunction rebaseLocation(loc: Location, chunk: Chunk): Location {\n  return {\n    start: {\n      line: loc.start.line + chunk.startLine,\n      column: loc.start.line === 1 ? loc.start.column + chunk.startColumn : loc.start.column,\n      offset: loc.start.offset + chunk.startOffset\n    },\n    end: {\n      line: loc.end.line + chunk.startLine,\n      column: loc.end.line === 1 ? loc.end.column + chunk.startColumn : loc.end.column,\n      offset: loc.end.offset + chunk.startOffset\n    }\n  };\n}\n```\n\n### Invariants (document in code comments)\n1. Chunks are ordered by startOffset, no overlaps\n2. Rebased locations are globally valid (can index into original text)\n3. AST nodes are cloned before mutation (no shared references)\n4. Failed chunks produce diagnostics covering their full range\n\n### Deliverable\n- [ ] Define types in `language-server-impl.ts` or new file\n- [ ] Document invariants in JSDoc comments\n- [ ] Ensure rebase handles first-line column edge case","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:10:28.642294-08:00","updated_at":"2025-12-12T07:44:41.653067-08:00","closed_at":"2025-12-12T07:44:41.653067-08:00","dependencies":[{"issue_id":"mlld-nlu.2","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:10:28.642935-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.2","depends_on_id":"mlld-nlu.1","type":"blocks","created_at":"2025-12-11T22:13:21.336762-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.3","title":"mlld-nlu P2: Chunk splitter","description":"## Chunk Splitter Implementation\n\n### Core Function\n```typescript\nfunction splitIntoChunks(text: string, mode: MlldMode): Chunk[]\n```\n\n### Depth Tracking State\n```typescript\ninterface SplitterState {\n  bracketDepth: number;   // [...]  - rc78 blocks\n  braceDepth: number;     // {...}  - code/data\n  parenDepth: number;     // (...)  - conditions\n  templateStack: ('`' | '::' | ':::')[];  // Nested templates\n  inComment: boolean;     // \u003e\u003e ... (to newline)\n  inCodeFence: boolean;   // ``` ... ```\n}\n```\n\n### Constructs That Prevent Splitting\n1. **Block syntax `[...]`** - rc78 exe/for/when blocks can span many lines\n2. **Code blocks `{...}`** - Commands, data objects\n3. **Templates** - Backticks, `::`, `:::` can be multi-line\n4. **Code fences** - ``` blocks in markdown mode\n5. **Comments** - `\u003e\u003e` to end of line\n\n### Split Point Detection\n```typescript\nfunction isSplitPoint(line: string, prevLine: string, state: SplitterState, mode: MlldMode): boolean {\n  // Never split when inside a construct\n  if (state.bracketDepth \u003e 0 || state.braceDepth \u003e 0 || \n      state.parenDepth \u003e 0 || state.templateStack.length \u003e 0 ||\n      state.inCodeFence) {\n    return false;\n  }\n  \n  // Split on blank line followed by directive\n  if (prevLine.trim() === '' \u0026\u0026 isDirectiveStart(line, mode)) {\n    return true;\n  }\n  \n  // Split at document start directive\n  return false;\n}\n\nfunction isDirectiveStart(line: string, mode: MlldMode): boolean {\n  const trimmed = line.trim();\n  \n  // Markdown mode: must start with /\n  if (mode === 'markdown') {\n    return trimmed.startsWith('/');\n  }\n  \n  // Strict mode: bare directives are also valid\n  const bareDirectives = /^(var|show|exe|run|for|when|while|stream|guard|import|export|output|append|log|path)\\b/;\n  return trimmed.startsWith('/') || bareDirectives.test(trimmed);\n}\n```\n\n### Scanner Algorithm\n```typescript\nfunction splitIntoChunks(text: string, mode: MlldMode): Chunk[] {\n  const chunks: Chunk[] = [];\n  const lines = text.split('\\n');\n  const state: SplitterState = { /* init zeros */ };\n  \n  let chunkStart = 0;\n  let chunkStartOffset = 0;\n  let currentOffset = 0;\n  \n  for (let i = 0; i \u003c lines.length; i++) {\n    const line = lines[i];\n    const prevLine = i \u003e 0 ? lines[i-1] : '';\n    \n    // Update state by scanning line\n    updateState(state, line);\n    \n    // Check for split point\n    if (i \u003e 0 \u0026\u0026 isSplitPoint(line, prevLine, state, mode)) {\n      // Emit previous chunk\n      chunks.push({\n        text: lines.slice(chunkStart, i).join('\\n'),\n        startLine: chunkStart,\n        endLine: i - 1,\n        startOffset: chunkStartOffset,\n        endOffset: currentOffset - 1, // exclude newline\n        startColumn: 0\n      });\n      chunkStart = i;\n      chunkStartOffset = currentOffset;\n    }\n    \n    currentOffset += line.length + 1; // +1 for newline\n  }\n  \n  // Emit final chunk\n  // ...\n  \n  return chunks;\n}\n```\n\n### Safety Limits\n- Cap chunk count at 200 - if exceeded, return single chunk (full document)\n- Minimum chunk size: 1 line\n- Log warning when falling back to single chunk\n\n### Edge Cases\n- Empty document ‚Üí single empty chunk\n- Document with only errors ‚Üí single chunk\n- Unclosed bracket at EOF ‚Üí include in last chunk\n- Template spanning entire document ‚Üí single chunk\n\n### Deliverable\n- [ ] Implement `splitIntoChunks` with depth tracking\n- [ ] Handle all template types (`, ::, :::)\n- [ ] Support both strict and markdown modes\n- [ ] Add chunk count safety limit\n- [ ] Unit tests for split point detection","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:10:44.610126-08:00","updated_at":"2025-12-12T07:46:53.43169-08:00","closed_at":"2025-12-12T07:46:53.43169-08:00","dependencies":[{"issue_id":"mlld-nlu.3","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:10:44.610845-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.3","depends_on_id":"mlld-nlu.2","type":"blocks","created_at":"2025-12-11T22:13:36.003189-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.4","title":"mlld-nlu P3: Per-chunk parsing","description":"## Per-Chunk Parsing\n\n### Core Function\n```typescript\nasync function parseChunk(chunk: Chunk, mode: MlldMode): Promise\u003cChunkParseResult\u003e\n```\n\n### Implementation\n```typescript\nasync function parseChunk(chunk: Chunk, mode: MlldMode): Promise\u003cChunkParseResult\u003e {\n  try {\n    const result = await parse(chunk.text, { mode });\n    \n    if (!result.success) {\n      return {\n        success: false,\n        chunk,\n        ast: [],\n        diagnostics: [createChunkDiagnostic(chunk, result.error)],\n        error: result.error\n      };\n    }\n    \n    // Clone and rebase AST nodes\n    const rebasedAst = rebaseAst(result.ast, chunk);\n    \n    // Rebase any warnings/diagnostics from parser\n    const rebasedDiagnostics = result.warnings.map(w =\u003e \n      rebaseDiagnostic(w, chunk)\n    );\n    \n    return {\n      success: true,\n      chunk,\n      ast: rebasedAst,\n      diagnostics: rebasedDiagnostics\n    };\n  } catch (error) {\n    return {\n      success: false,\n      chunk,\n      ast: [],\n      diagnostics: [createChunkDiagnostic(chunk, error)],\n      error\n    };\n  }\n}\n```\n\n### AST Rebasing (Critical)\n```typescript\nfunction rebaseAst(ast: MlldNode[], chunk: Chunk): MlldNode[] {\n  // Deep clone to avoid mutating shared references\n  const cloned = JSON.parse(JSON.stringify(ast));\n  \n  // Recursively rebase all locations\n  function rebaseNode(node: any): void {\n    if (!node || typeof node !== 'object') return;\n    \n    if (node.location) {\n      // Rebase ALL location fields\n      if (node.location.start) {\n        node.location.start.line += chunk.startLine;\n        node.location.start.offset += chunk.startOffset;\n        // Column only needs adjustment for first line of chunk\n        if (node.location.start.line === chunk.startLine \u0026\u0026 chunk.startColumn \u003e 0) {\n          node.location.start.column += chunk.startColumn;\n        }\n      }\n      if (node.location.end) {\n        node.location.end.line += chunk.startLine;\n        node.location.end.offset += chunk.startOffset;\n        if (node.location.end.line === chunk.startLine \u0026\u0026 chunk.startColumn \u003e 0) {\n          node.location.end.column += chunk.startColumn;\n        }\n      }\n    }\n    \n    // Recurse into all properties\n    for (const key in node) {\n      const value = node[key];\n      if (Array.isArray(value)) {\n        value.forEach(rebaseNode);\n      } else if (value \u0026\u0026 typeof value === 'object') {\n        rebaseNode(value);\n      }\n    }\n  }\n  \n  cloned.forEach(rebaseNode);\n  return cloned;\n}\n```\n\n### Why Clone is Necessary\nThe parser may return cached AST nodes or share references between nodes. Without cloning:\n- Rebasing one chunk could corrupt another\n- Cached parse results would have wrong locations on reuse\n\n### Chunk Diagnostic Creation\n```typescript\nfunction createChunkDiagnostic(chunk: Chunk, error: any): Diagnostic {\n  // Try to get specific location from error\n  const errorLine = error?.location?.start?.line ?? 1;\n  const errorCol = error?.location?.start?.column ?? 0;\n  \n  return {\n    severity: DiagnosticSeverity.Error,\n    range: {\n      start: { \n        line: chunk.startLine + errorLine - 1, \n        character: errorCol \n      },\n      end: { \n        line: chunk.startLine + errorLine - 1, \n        character: errorCol + 1 \n      }\n    },\n    message: error?.message || 'Syntax error',\n    source: 'mlld'\n  };\n}\n```\n\n### Short-Circuit Optimization\n```typescript\n// If document is a single chunk and fails, return immediately\n// (equivalent to current full-parse failure behavior)\nif (chunks.length === 1 \u0026\u0026 !parseResult.success) {\n  return { nodes: [], errors: [originalDiagnostic] };\n}\n```\n\n### Deliverable\n- [ ] Implement `parseChunk` with proper error handling\n- [ ] Implement `rebaseAst` with deep clone and full location rebase\n- [ ] Verify offsets are correct by testing with TokenBuilder\n- [ ] Add short-circuit for single-chunk failures","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:11:00.099048-08:00","updated_at":"2025-12-12T09:03:07.36759-08:00","closed_at":"2025-12-12T09:03:07.36759-08:00","dependencies":[{"issue_id":"mlld-nlu.4","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:11:00.099637-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.4","depends_on_id":"mlld-nlu.3","type":"blocks","created_at":"2025-12-11T22:13:49.886246-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.5","title":"mlld-nlu P4: Merge results","description":"## Merge Results\n\n### Core Function\n```typescript\nfunction mergeChunkResults(results: ChunkParseResult[]): MergedParseResult\n```\n\n### Implementation\n```typescript\nfunction mergeChunkResults(results: ChunkParseResult[]): MergedParseResult {\n  const nodes: MlldNode[] = [];\n  const errors: Diagnostic[] = [];\n  const failedRanges: Range[] = [];\n  \n  // Results are already in order (chunks were ordered)\n  for (const result of results) {\n    if (result.success) {\n      nodes.push(...result.ast);\n    } else {\n      // Track failed range for token gap handling\n      failedRanges.push({\n        start: { line: result.chunk.startLine, character: 0 },\n        end: { line: result.chunk.endLine, character: 0 }\n      });\n    }\n    \n    // Always include diagnostics (warnings from successful, errors from failed)\n    errors.push(...result.diagnostics);\n  }\n  \n  return { nodes, errors, failedRanges };\n}\n```\n\n### Ordering Guarantees\n- Chunks are split in document order\n- Results processed in same order\n- No sorting needed\n- No deduplication needed (chunks don't overlap)\n\n### Failed Range Handling\nFailed ranges tell the token generator which parts of the document have no AST:\n- Don't generate tokens for these ranges\n- Show error squiggles instead\n- Prevents \"holes\" in highlighting from causing confusion\n\n### Edge Cases\n- All chunks succeed ‚Üí normal AST, no failed ranges\n- All chunks fail ‚Üí empty AST, full document is failed range\n- Interleaved success/fail ‚Üí partial AST with gaps\n\n### Integration with Semantic Tokens\nThe `failedRanges` can be used by `ASTSemanticVisitor`:\n```typescript\n// In token generation, skip nodes that fall in failed ranges\n// Or: generate error tokens for failed ranges\n```\n\n### Deliverable\n- [ ] Implement `mergeChunkResults`\n- [ ] Maintain ordering invariant\n- [ ] Track failed ranges for downstream use\n- [ ] No mutation of input results","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:11:15.143493-08:00","updated_at":"2025-12-12T09:03:07.368745-08:00","closed_at":"2025-12-12T09:03:07.368745-08:00","dependencies":[{"issue_id":"mlld-nlu.5","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:11:15.144439-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.5","depends_on_id":"mlld-nlu.4","type":"blocks","created_at":"2025-12-11T22:14:03.959365-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.6","title":"mlld-nlu P5: LSP integration","description":"## LSP Integration\n\n### Integration Point\nIn `cli/commands/language-server-impl.ts`, around **line 566**:\n```typescript\n// Current code:\nconst partialAst = await attemptPartialParsing(text, error, mode);\nast = partialAst.nodes;\nerrors.push(...partialAst.errors);\n```\n\n### New Flow\n```typescript\nasync function parseWithChunks(\n  text: string, \n  originalError: any, \n  mode: MlldMode\n): Promise\u003c{ nodes: any[], errors: Diagnostic[], failedRanges: Range[] }\u003e {\n  \n  // Fast path: if chunk parsing disabled, use old method\n  if (process.env.MLLD_CHUNK_PARSING === '0') {\n    const result = await attemptPartialParsing(text, originalError, mode);\n    return { ...result, failedRanges: [] };\n  }\n  \n  // Split into chunks\n  const chunks = splitIntoChunks(text, mode);\n  \n  // Safety: if too many chunks, fall back to single-chunk\n  if (chunks.length \u003e 200) {\n    logger.warn('Too many chunks, falling back to single chunk');\n    chunks.splice(0, chunks.length, { text, startLine: 0, startOffset: 0, ... });\n  }\n  \n  // Parse each chunk\n  const results = await Promise.all(\n    chunks.map(chunk =\u003e parseChunk(chunk, mode))\n  );\n  \n  // Merge results\n  const merged = mergeChunkResults(results);\n  \n  // Final fallback: if all chunks failed, try old strategy\n  if (merged.nodes.length === 0 \u0026\u0026 results.every(r =\u003e !r.success)) {\n    logger.debug('All chunks failed, trying legacy partial parsing');\n    const legacy = await attemptPartialParsing(text, originalError, mode);\n    return { ...legacy, failedRanges: [] };\n  }\n  \n  return merged;\n}\n```\n\n### Wiring into analyzeDocument\n```typescript\n// Replace line ~566:\nconst partialAst = await parseWithChunks(text, error, mode);\nast = partialAst.nodes;\nerrors.push(...partialAst.errors);\n\n// Optionally store failedRanges in DocumentState for token generation\nstate.failedRanges = partialAst.failedRanges;\n```\n\n### Semantic Token Handling\nThe `ASTSemanticVisitor` receives the merged AST. It should work normally since:\n- All locations are rebased to global positions\n- Nodes are in document order\n- Failed ranges just mean fewer nodes (gaps in tokens)\n\n### Diagnostic Pipeline\nDiagnostics from chunk failures should appear as normal errors:\n- Position already rebased\n- Message indicates syntax error\n- No special handling needed\n\n### Backwards Compatibility\n- Keep `attemptPartialParsing` as fallback\n- Environment variable to disable: `MLLD_CHUNK_PARSING=0`\n- Same return shape as current implementation\n\n### Deliverable\n- [ ] Implement `parseWithChunks` as wrapper\n- [ ] Wire into `analyzeDocument` at line 566\n- [ ] Add `MLLD_CHUNK_PARSING` env var check\n- [ ] Keep legacy fallback for safety\n- [ ] Verify semantic tokens still work\n- [ ] Verify diagnostics appear correctly","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:11:30.692991-08:00","updated_at":"2025-12-12T09:03:07.369238-08:00","closed_at":"2025-12-12T09:03:07.369238-08:00","dependencies":[{"issue_id":"mlld-nlu.6","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:11:30.69371-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.6","depends_on_id":"mlld-nlu.5","type":"blocks","created_at":"2025-12-11T22:14:18.079302-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.7","title":"mlld-nlu P6: Debug and telemetry","description":"## Debug and Telemetry\n\n### Existing Debug Pattern\nThe LSP uses `DEBUG=mlld:lsp` environment variable:\n```typescript\nimport { logger } from '@core/utils/logger';\n\n// Usage throughout language-server-impl.ts:\nlogger.debug('message', { data });\nlogger.warn('message');\n```\n\n### Chunk-Specific Logging\nAdd logging for chunk operations:\n```typescript\n// In splitIntoChunks:\nlogger.debug('Splitting document into chunks', { \n  totalLines: lines.length,\n  mode \n});\n\n// After splitting:\nlogger.debug('Created chunks', { \n  count: chunks.length,\n  sizes: chunks.map(c =\u003e c.endLine - c.startLine + 1)\n});\n\n// In parseChunk:\nlogger.debug('Parsing chunk', { \n  startLine: chunk.startLine,\n  endLine: chunk.endLine,\n  length: chunk.text.length\n});\n\n// On chunk failure:\nlogger.debug('Chunk parse failed', {\n  startLine: chunk.startLine,\n  error: error.message\n});\n\n// In mergeChunkResults:\nlogger.debug('Merged chunk results', {\n  totalNodes: nodes.length,\n  failedChunks: results.filter(r =\u003e !r.success).length,\n  successChunks: results.filter(r =\u003e r.success).length\n});\n```\n\n### Performance Telemetry\nTrack timing for optimization:\n```typescript\nconst splitStart = Date.now();\nconst chunks = splitIntoChunks(text, mode);\nconst splitTime = Date.now() - splitStart;\n\nconst parseStart = Date.now();\nconst results = await Promise.all(chunks.map(c =\u003e parseChunk(c, mode)));\nconst parseTime = Date.now() - parseStart;\n\nlogger.debug('Chunk parsing performance', {\n  splitTime,\n  parseTime,\n  totalTime: splitTime + parseTime,\n  chunkCount: chunks.length\n});\n```\n\n### Debug Output Format\nWhen `DEBUG=mlld:lsp`, output should show:\n```\n[mlld:lsp] Splitting document into chunks { totalLines: 50, mode: 'strict' }\n[mlld:lsp] Created chunks { count: 5, sizes: [10, 8, 12, 15, 5] }\n[mlld:lsp] Parsing chunk { startLine: 0, endLine: 9 }\n[mlld:lsp] Parsing chunk { startLine: 10, endLine: 17 }\n[mlld:lsp] Chunk parse failed { startLine: 18, error: 'Unexpected token' }\n[mlld:lsp] Parsing chunk { startLine: 30, endLine: 44 }\n[mlld:lsp] Parsing chunk { startLine: 45, endLine: 49 }\n[mlld:lsp] Merged chunk results { totalNodes: 12, failedChunks: 1, successChunks: 4 }\n[mlld:lsp] Chunk parsing performance { splitTime: 2, parseTime: 45, totalTime: 47 }\n```\n\n### Deliverable\n- [ ] Add chunk splitting logs\n- [ ] Add per-chunk parse logs\n- [ ] Add merge summary log\n- [ ] Add performance timing\n- [ ] Follow existing logger patterns","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:11:46.583203-08:00","updated_at":"2025-12-12T09:04:41.056523-08:00","closed_at":"2025-12-12T09:04:41.056523-08:00","dependencies":[{"issue_id":"mlld-nlu.7","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:11:46.583944-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.7","depends_on_id":"mlld-nlu.6","type":"blocks","created_at":"2025-12-11T22:14:33.291936-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.8","title":"mlld-nlu P7: Tests and fixtures","description":"## Tests and Fixtures\n\n### Test File Location\nAdd tests to `services/lsp/` following existing patterns:\n- `services/lsp/chunk-parsing.test.ts` - Unit tests for chunk logic\n- Or extend `services/lsp/semantic-tokens.test.ts` with error recovery tests\n\n### Unit Tests for Chunk Splitter\n\n```typescript\ndescribe('splitIntoChunks', () =\u003e {\n  it('splits on blank lines between directives', () =\u003e {\n    const text = `/var @a = 1\n\n/var @b = 2`;\n    const chunks = splitIntoChunks(text, 'markdown');\n    expect(chunks).toHaveLength(2);\n  });\n\n  it('does not split inside block syntax', () =\u003e {\n    const text = `/exe @f() = [\n  let @x = 1\n  \n  let @y = 2\n]`;\n    const chunks = splitIntoChunks(text, 'markdown');\n    expect(chunks).toHaveLength(1);\n  });\n\n  it('does not split inside multi-line template', () =\u003e {\n    const text = `/var @msg = \\`\nline 1\n\nline 2\n\\``;\n    const chunks = splitIntoChunks(text, 'markdown');\n    expect(chunks).toHaveLength(1);\n  });\n\n  it('handles strict mode bare directives', () =\u003e {\n    const text = `var @a = 1\n\nvar @b = 2`;\n    const chunks = splitIntoChunks(text, 'strict');\n    expect(chunks).toHaveLength(2);\n  });\n\n  it('caps chunk count at 200', () =\u003e {\n    const text = Array(300).fill('/var @x = 1\\n\\n').join('');\n    const chunks = splitIntoChunks(text, 'markdown');\n    expect(chunks.length).toBeLessThanOrEqual(200);\n  });\n});\n```\n\n### Unit Tests for Location Rebasing\n\n```typescript\ndescribe('rebaseAst', () =\u003e {\n  it('rebases line numbers', () =\u003e {\n    const ast = [{ location: { start: { line: 1 }, end: { line: 1 } } }];\n    const chunk = { startLine: 10, startOffset: 100 };\n    const rebased = rebaseAst(ast, chunk);\n    expect(rebased[0].location.start.line).toBe(11);\n  });\n\n  it('rebases offsets', () =\u003e {\n    const ast = [{ location: { start: { offset: 0 }, end: { offset: 10 } } }];\n    const chunk = { startLine: 0, startOffset: 50 };\n    const rebased = rebaseAst(ast, chunk);\n    expect(rebased[0].location.start.offset).toBe(50);\n    expect(rebased[0].location.end.offset).toBe(60);\n  });\n\n  it('does not mutate original ast', () =\u003e {\n    const ast = [{ location: { start: { line: 1 } } }];\n    rebaseAst(ast, { startLine: 10 });\n    expect(ast[0].location.start.line).toBe(1);\n  });\n});\n```\n\n### Integration Tests (Error Recovery)\n\n```typescript\ndescribe('error recovery', () =\u003e {\n  it('recovers tokens after syntax error', async () =\u003e {\n    const text = `/var @a = 1\n/var @b = INVALID SYNTAX HERE\n/var @c = 3`;\n    \n    const tokens = await getSemanticTokens(text);\n    \n    // Should have tokens for @a and @c, error for middle line\n    expect(tokens.some(t =\u003e t.text === '@a')).toBe(true);\n    expect(tokens.some(t =\u003e t.text === '@c')).toBe(true);\n  });\n\n  it('recovers tokens before syntax error', async () =\u003e {\n    const text = `/var @good = 1\nBROKEN SYNTAX`;\n    \n    const tokens = await getSemanticTokens(text);\n    expect(tokens.some(t =\u003e t.text === '@good')).toBe(true);\n  });\n\n  it('handles error inside block without losing surrounding code', async () =\u003e {\n    const text = `/var @before = 1\n\n/exe @f() = [\n  let @x = BROKEN\n]\n\n/var @after = 2`;\n    \n    const tokens = await getSemanticTokens(text);\n    expect(tokens.some(t =\u003e t.text === '@before')).toBe(true);\n    expect(tokens.some(t =\u003e t.text === '@after')).toBe(true);\n  });\n});\n```\n\n### Test Fixtures\nCreate fixture files in `tests/fixtures/lsp/`:\n- `error-recovery-middle.mld` - Error in middle of document\n- `error-recovery-block.mld` - Error inside block\n- `error-recovery-multiple.mld` - Multiple errors\n\n### Deliverable\n- [ ] Unit tests for splitIntoChunks\n- [ ] Unit tests for rebaseAst\n- [ ] Integration tests for error recovery\n- [ ] Test strict mode splitting\n- [ ] Test chunk count cap","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:12:02.3358-08:00","updated_at":"2025-12-12T09:09:09.486151-08:00","closed_at":"2025-12-12T09:09:09.486151-08:00","dependencies":[{"issue_id":"mlld-nlu.8","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:12:02.336864-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.8","depends_on_id":"mlld-nlu.7","type":"blocks","created_at":"2025-12-11T22:14:48.358645-08:00","created_by":"adam"}]}
{"id":"mlld-nlu.9","title":"mlld-nlu P8: Docs","description":"## Documentation\n\n### Update docs/dev/LANGUAGE-SERVER.md\n\nAdd section after \"Graceful Incomplete Line Handling\" (~line 340):\n\n```markdown\n### Chunk-Based Error Recovery\n\nWhen the parser encounters a syntax error, the language server uses chunk-based\nparsing to recover as much valid AST as possible:\n\n1. **Document Splitting**: The document is split into logical chunks at directive\n   boundaries, respecting nested constructs (blocks, templates, code fences)\n\n2. **Independent Parsing**: Each chunk is parsed independently with the appropriate\n   mode (strict or markdown)\n\n3. **Location Rebasing**: AST node locations are adjusted to global document positions\n\n4. **Result Merging**: Successfully parsed chunks are merged; failed chunks produce\n   error diagnostics\n\n**Benefits:**\n- Syntax errors don't break highlighting for the entire document\n- Valid code before and after errors remains highlighted\n- Multiple errors can be shown simultaneously\n\n**Configuration:**\n- Disable with `MLLD_CHUNK_PARSING=0` environment variable\n- Falls back to line-by-line parsing if chunk parsing fails completely\n\n**Limitations:**\n- Errors inside multi-line constructs (blocks, templates) affect the entire construct\n- Performance overhead for documents with many chunk boundaries\n```\n\n### Update Troubleshooting Section\n\nAdd under \"Semantic Highlighting Not Working\":\n\n```markdown\n7. **Error Recovery Not Working**:\n   - Chunk-based parsing requires valid chunk boundaries\n   - Errors inside `[...]` blocks affect the entire block\n   - Try `MLLD_CHUNK_PARSING=0` to use legacy line-by-line recovery\n   - Check debug logs: `DEBUG=mlld:lsp mlld language-server`\n```\n\n### Update Architecture Section\n\nAdd to \"Analysis Pipeline\" (~line 315):\n\n```markdown\n### Analysis Pipeline\n\n1. **Parse** - Use mlld grammar to parse documents\n2. **Chunk Recovery** - If parse fails, split and parse chunks (NEW)\n3. **Analyze** - Extract variables, imports, exports\n4. **Generate Tokens** - Create semantic tokens using AST visitor pattern\n5. **Cache** - Store analysis results and text extracts for performance\n6. **Update** - Send diagnostics, completions, and semantic tokens\n```\n\n### Deliverable\n- [ ] Add \"Chunk-Based Error Recovery\" section\n- [ ] Update troubleshooting section\n- [ ] Update architecture section\n- [ ] Keep consistent with existing doc style","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T22:12:17.943335-08:00","updated_at":"2025-12-12T09:05:01.081037-08:00","closed_at":"2025-12-12T09:05:01.081037-08:00","dependencies":[{"issue_id":"mlld-nlu.9","depends_on_id":"mlld-nlu","type":"parent-child","created_at":"2025-12-11T22:12:17.944-08:00","created_by":"adam"},{"issue_id":"mlld-nlu.9","depends_on_id":"mlld-nlu.8","type":"blocks","created_at":"2025-12-11T22:15:02.487868-08:00","created_by":"adam"}]}
{"id":"mlld-nwu","title":"sh/bash executor not emitting CHUNK events to StreamBus for format adapters","description":"When using 'stream sh { ... }' the FormatAdapterSink doesn't receive CHUNK events. Works with 'stream cmd { ... }'. FormatAdapterSink.handle never called for sh/bash executors.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-07T20:51:28.696466-08:00","updated_at":"2025-12-07T20:51:28.696466-08:00"}
{"id":"mlld-o2u","title":"Regex syntax highlighting: strict vs markdown","description":"## Summary\nUpdate TextMate/regex-based syntax highlighting to handle strict and markdown modes, plus add support for template files (.att, .mtt).\n\n## Background\n\nmlld has two highlighting mechanisms:\n1. **Semantic Tokens (LSP)** - AST-based, context-aware, preferred\n2. **TextMate Grammar** - Regex-based, fallback for non-LSP editors\n\nTextMate grammars provide basic highlighting when LSP isn't available.\n\n## Current TextMate Files\n```\neditors/vscode/syntaxes/\n‚îú‚îÄ‚îÄ mlld.tmLanguage.json           # Main grammar for .mld/.mlld\n‚îú‚îÄ‚îÄ mlld-markdown.tmLanguage.json  # Markdown mode\n‚îú‚îÄ‚îÄ mlld-markdown.injection.json   # Injection grammar\n‚îî‚îÄ‚îÄ mlld-minimal.tmLanguage.json   # Minimal fallback\n```\n\n## Tasks\n\n### 1. Mode-Aware Directive Patterns\nUpdate `mlld.tmLanguage.json` to make `/` optional in directive patterns:\n\n```json\n{\n  \"match\": \"^\\\\s*(/?)(?:var|show|exe|run|for|when|while|stream|guard|import|export|output|append|log|path)\\\\b\",\n  \"name\": \"keyword.directive.mlld\"\n}\n```\n\nThis allows both `var @x = 1` and `/var @x = 1` to highlight.\n\n### 2. Add rc78 Keywords\nAdd new keywords to directive patterns:\n- `while`, `done`, `continue`\n- `stream`\n- `guard` (with `before`, `after`, `always`, `allow`, `deny`, `retry`)\n- `let` (in block contexts)\n- `append`\n\n### 3. Add .att Template File Support\nCreate `mlld-att.tmLanguage.json` for `.att` files (double-colon template syntax):\n- `@var` interpolation\n- `/for`, `/when`, `/end` directives\n- `\u003cfile.md\u003e` file references\n- Comments `\u003e\u003e` and `\u003c\u003c`\n\nRegister in `package.json`:\n```json\n{\n  \"id\": \"mlld-att\",\n  \"aliases\": [\"mlld Template (ATT)\"],\n  \"extensions\": [\".att\"],\n  \"configuration\": \"./language-configuration.json\"\n}\n```\n\n### 4. Add .mtt Template File Support\nCreate `mlld-mtt.tmLanguage.json` for `.mtt` files (triple-colon template syntax):\n- `{{var}}` interpolation (NOT @var)\n- `/for`, `/when`, `/end` directives\n- `\u003cfile.md\u003e` file references\n- Comments `\u003e\u003e` and `\u003c\u003c`\n\nRegister in `package.json`:\n```json\n{\n  \"id\": \"mlld-mtt\",\n  \"aliases\": [\"mlld Template (MTT)\"],\n  \"extensions\": [\".mtt\"],\n  \"configuration\": \"./language-configuration.json\"\n}\n```\n\n## Implementation Notes\n\n### ATT Interpolation Pattern\n```json\n{\n  \"match\": \"@[a-zA-Z_][a-zA-Z0-9_]*\",\n  \"name\": \"variable.other.mlld\"\n}\n```\n\n### MTT Interpolation Pattern\n```json\n{\n  \"begin\": \"\\\\{\\\\{\",\n  \"end\": \"\\\\}\\\\}\",\n  \"name\": \"meta.interpolation.mlld\",\n  \"patterns\": [\n    { \"match\": \"[a-zA-Z_][a-zA-Z0-9_]*\", \"name\": \"variable.other.mlld\" }\n  ]\n}\n```\n\n### Template Directive Pattern (both)\n```json\n{\n  \"match\": \"^\\\\s*/(?:for|when|end)\\\\b\",\n  \"name\": \"keyword.control.mlld\"\n}\n```\n\n### File Reference Pattern (both)\n```json\n{\n  \"begin\": \"\u003c\",\n  \"end\": \"\u003e\",\n  \"name\": \"string.other.link.mlld\"\n}\n```\n\n## Files to Modify/Create\n- `editors/vscode/syntaxes/mlld.tmLanguage.json` - Add rc78 keywords, optional slash\n- `editors/vscode/syntaxes/mlld-att.tmLanguage.json` - NEW\n- `editors/vscode/syntaxes/mlld-mtt.tmLanguage.json` - NEW\n- `editors/vscode/package.json` - Register new languages\n\n## Testing\n1. Disable LSP (semantic tokens)\n2. Open .mld file - verify bare directives highlight\n3. Open .att file - verify @var interpolation\n4. Open .mtt file - verify {{var}} interpolation\n\n## Acceptance Criteria\n- [ ] Bare directives highlight in strict mode\n- [ ] rc78 keywords (while, stream, let, etc.) highlight\n- [ ] .att files: @var, /for, /when, /end, \u003cfile\u003e highlight\n- [ ] .mtt files: {{var}}, /for, /when, /end, \u003cfile\u003e highlight\n- [ ] package.json registers .att and .mtt extensions","status":"open","priority":0,"issue_type":"task","created_at":"2025-12-09T08:30:53.814723-08:00","updated_at":"2025-12-18T18:02:38.335012-08:00","dependencies":[{"issue_id":"mlld-o2u","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.013201-08:00","created_by":"daemon"}]}
{"id":"mlld-og8","title":"Guard/when action keywords need standout color (allow/deny/continue/retry/done)","description":"Action keywords in =\u003e position of guard/when blocks need distinct highlighting (could be pink like var/exe):\n- allow\n- deny\n- continue\n- retry\n- done\n\nExample: guard before label = when [ @condition == 1 =\u003e allow @action() ]\nThe 'allow' keyword should be pink or another standout color.\n\nThese are special control flow actions, distinct from regular keywords.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T12:15:10.594452-08:00","updated_at":"2025-12-14T14:11:07.510994-08:00","closed_at":"2025-12-14T14:11:07.510994-08:00"}
{"id":"mlld-om1","title":"LSP: mode-aware syntax highlighting and errors","description":"## Summary\nComprehensive mode-aware LSP behavior including syntax highlighting, diagnostics, and completion.\n\n**Depends on:** mlld-p25 (mode detection), mlld-cgb (highlighting basics)\n\n**Overlap note:** mlld-cgb covers basic highlighting. This task covers the broader UX including error messages, completion, and formatting hints.\n\n## Scope\n\n### 1. File Extension Detection ‚úì (covered by mlld-p25)\n- `.mld` ‚Üí strict mode\n- `.mld.md` ‚Üí markdown mode\n\n### 2. Syntax Highlighting ‚úì (covered by mlld-cgb)\n- Strict: bare directives as keywords\n- Markdown: only `/keyword` as keywords\n\n### 3. Error Diagnostics (THIS TASK)\nWhen text lines appear in strict mode:\n```mlld\nvar @x = \"test\"\nThis is prose content  \u003c\u003c Should show error squiggle\n```\n\n**Implementation:**\nIn `language-server-impl.ts`, when mode is strict and we encounter text nodes:\n\n```typescript\n// During validation, if mode is strict\nif (mode === 'strict') {\n  for (const node of ast) {\n    if (node.type === 'Text' \u0026\u0026 node.content?.trim()) {\n      diagnostics.push({\n        severity: DiagnosticSeverity.Error,\n        range: getNodeRange(node),\n        message: 'Text content not allowed in strict mode (.mld files). Use /show for output or rename to .mld.md for prose.',\n        source: 'mlld'\n      });\n    }\n  }\n}\n```\n\n### 4. Hover/Completion (THIS TASK)\nDirective completions should adapt to mode:\n\n**Strict mode:**\n- Suggest both `var` and `/var`\n- Prefer bare form in suggestions\n\n**Markdown mode:**\n- Only suggest `/var` form\n\n**Implementation:**\nIn completion provider around line 750+:\n\n```typescript\nconst mode = getModeFromUri(document.uri);\nconst prefix = mode === 'strict' ? '' : '/';\n\nconst directives = ['var', 'show', 'exe', 'run', 'for', 'when', ...];\nreturn directives.map(d =\u003e ({\n  label: `${prefix}${d}`,\n  kind: CompletionItemKind.Keyword,\n  // ...\n}));\n```\n\n### 5. Formatter Hints (OPTIONAL/FUTURE)\nCould suggest normalizing to bare directives in strict mode:\n```\nHint: In strict mode, '/var' can be simplified to 'var'\n```\n\n## Files to Modify\n- `cli/commands/language-server-impl.ts` - Diagnostics and completion\n- Consider: `services/lsp/` if visitor changes needed\n\n## Testing\n```bash\nnpm test cli/commands/language-server.test.ts\n```\n\n## Acceptance Criteria\n- [ ] Text in strict mode shows error diagnostic\n- [ ] Error message suggests renaming to .mld.md\n- [ ] Completions adapt to mode\n- [ ] Bare directive completions in strict mode\n\n## Size\nMedium","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-08T19:58:27.625577-08:00","updated_at":"2025-12-15T20:50:09.184192-08:00","closed_at":"2025-12-12T01:09:36.38096-08:00","dependencies":[{"issue_id":"mlld-om1","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.595916-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T19:59:14.906243-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-ah5","type":"blocks","created_at":"2025-12-08T20:59:32.37355-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.088821-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-cgb","type":"blocks","created_at":"2025-12-11T21:04:25.902928-08:00","created_by":"daemon"}]}
{"id":"mlld-p25","title":"LSP: Add mode detection from file URI","description":"## Summary\nAdd mode detection to the language server so it correctly parses .mld files in strict mode and .mld.md files in markdown mode.\n\n**This is the critical foundation that unblocks all other LSP work.**\n\n## Current State\n- `cli/commands/language-server-impl.ts` calls `parse(text)` without passing mode\n- `grammar/parser/index.ts` defaults to `mode: 'markdown'`\n- DirectiveVisitor doesn't know about mode, always expects `/` prefix\n\n## Implementation\n\n### Step 1: Add getModeFromUri helper\nAdd to `language-server-impl.ts` around line 40:\n\n```typescript\nimport type { MlldMode } from '@core/types';\n\nfunction getModeFromUri(uri: string): MlldMode {\n  // file:///path/to/file.mld -\u003e strict\n  // file:///path/to/file.mld.md -\u003e markdown\n  // file:///path/to/file.md -\u003e markdown\n  const path = uri.replace('file://', '');\n  if (path.endsWith('.mld.md') || path.endsWith('.mlld.md')) {\n    return 'markdown';\n  }\n  if (path.endsWith('.mld') || path.endsWith('.mlld')) {\n    return 'strict';\n  }\n  // Default to markdown for .md and unknown\n  return 'markdown';\n}\n```\n\n### Step 2: Update analyzeDocument function\nAround line 478, change:\n```typescript\nconst result = await parse(text);\n```\nto:\n```typescript\nconst mode = getModeFromUri(document.uri);\nconst result = await parse(text, { mode });\n```\n\n### Step 3: Update attemptPartialParsing\nAround line 1378 and 1435, ensure mode is passed to parse() calls.\n\n### Step 4: Store mode in document state\nUpdate the DocumentState interface and getOrCreateDocumentState to track mode.\n\n### Step 5: Pass mode to ASTSemanticVisitor\nThe visitor needs to know the mode to correctly tokenize bare directives in strict mode.\n\n## Files to Modify\n- `cli/commands/language-server-impl.ts` - Main changes\n- `services/lsp/ASTSemanticVisitor.ts` - Accept mode parameter\n- `services/lsp/visitors/DirectiveVisitor.ts` - Handle bare directives\n\n## Testing\n```bash\n# Create test files\necho 'var @x = \"test\"' \u003e tmp/test-strict.mld\necho '/var @x = \"test\"' \u003e tmp/test-markdown.mld.md\n\n# Run LSP tests\nnpm test services/lsp/semantic-tokens.test.ts\n```\n\n## Acceptance Criteria\n- [ ] .mld files parse in strict mode\n- [ ] .mld.md files parse in markdown mode\n- [ ] Mode is available in DirectiveVisitor\n- [ ] Bare directives in strict mode get keyword highlighting","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-11T21:00:19.943624-08:00","updated_at":"2025-12-11T22:05:24.227461-08:00","closed_at":"2025-12-11T22:05:24.227461-08:00","dependencies":[{"issue_id":"mlld-p25","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T21:00:50.94718-08:00","created_by":"daemon"}]}
{"id":"mlld-qew","title":"Grammar bug: Special resolver imports parsed as Text not VariableReference","description":"Multiple grammar bugs where variables are parsed as Text nodes instead of VariableReference:\n\n1. Special resolver imports (@payLoad, @state, @input, @now, @time):\n   Location: grammar/directives/import.peggy:411-502\n   Creates: helpers.createNode(NodeType.Text, { content: matched })\n   Should be: VariableReference with proper valueType\n\n2. Import alias names (@agentTemplates):\n   The alias in 'as @agentTemplates' is a Text node with content='agentTemplates' (no @)\n   Should be: VariableReference or at minimum include @ in content\n\nImpact:\n- LSP can't tokenize these properly without workarounds\n- AST semantics incorrect (they're variable references, not text)\n- Fixed with workarounds in DirectiveVisitor but should fix in grammar for correctness\n\nWorkarounds added:\n- DirectiveVisitor:2080-2089 - Detects Text nodes starting with @ in import paths\n- DirectiveVisitor:2206-2250 - Tokenizes import alias and parameters from raw data","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-13T06:38:44.36124-08:00","updated_at":"2025-12-13T06:41:38.704934-08:00","labels":["ast","grammar"]}
{"id":"mlld-qxb","title":"cmd:path / sh:path for rooted commands","description":"One thing that both `cmd` and `sh` often need is to set the path for their operation. \n\n`cmd` intentionally disallows chaining which makes it impossible to just do `cd /some/dir \u0026\u0026 mycommand`\n\nBut given this is a common use case‚Äîand one which enforces security and clarity‚Äîwe should allow a way to set the path for `cmd` and `sh`\n\n```\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n/run sh:@mypath {echo \"hello world\"}\n/run cmd:@base/path/to/file {mycommand param}\n/run sh:/Users/@username/dev/@dir {somecommand --flag}\n```\n\nthe `:path` would be an option everywhere `sh` and `cmd` are used; if not set the path would be set to whatever the system defaults to currently (which has its own rules)","design":"## Design Overview\n\nThis feature adds `:path` syntax to `cmd` and language executors (`sh`, `bash`, `js`, `python`, etc.) to set the working directory for command execution.\n\n## Motivation\n\nCurrently, `cmd` intentionally disallows chaining (no `\u0026\u0026` inside `cmd {...}`), which makes it impossible to do:\n```\n/run cmd {cd /some/dir \u0026\u0026 mycommand}  # NOT ALLOWED\n```\n\nThe `:path` syntax provides a clean, explicit alternative that:\n1. Enforces security through validation\n2. Makes working directory changes explicit in the syntax\n3. Supports variable interpolation\n4. Maintains cmd's no-chaining principle\n\n## Syntax Examples\n\n```mlld\n# Absolute path\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n\n# Variable path\n/var @mypath = \"/tmp\"\n/run sh:@mypath {echo \"hello world\"}\n\n# Interpolated path\n/var @base = \"/Users/adam\"\n/run cmd:@base/dev/mlld {git status}\n\n# With multiple variables\n/run sh:/Users/@username/dev/@project {make test}\n\n# Works with all language executors\n/run bash:/tmp {pwd}\n/run js:/home/user/scripts {console.log(process.cwd())}\n/run python:@workspace {import os; print(os.getcwd())}\n```\n\n## Design Decisions\n\n### 1. Rooted Paths Only\n\nPaths MUST be rooted (absolute):\n- ‚úÖ `/tmp` - absolute path\n- ‚úÖ `@mypath` - variable (must resolve to absolute)\n- ‚úÖ `@base/subdir` - variable + path (variable must be absolute)\n- ‚ùå `./relative` - REJECTED\n- ‚ùå `relative` - REJECTED\n\n**Rationale**: Relative paths are ambiguous (relative to what?). Rooted paths are explicit and secure.\n\n### 2. Variable Interpolation\n\nVariables in paths are interpolated at runtime using existing `interpolate()` infrastructure:\n```mlld\n/var @user = \"alice\"\n/run cmd:/home/@user/work {ls}  # Resolves to /home/alice/work\n```\n\n**Rationale**: Consistent with how variables work elsewhere in mlld.\n\n### 3. Fail Fast Validation\n\nPath validation happens BEFORE command execution:\n1. Interpolate variables (error if undefined)\n2. Check path starts with `/` (error if not)\n3. Check directory exists (error if not)\n4. Check is directory not file (error if file)\n\n**Rationale**: Better error messages, prevents confusing command failures.\n\n### 4. No Security Policy (Yet)\n\nInitial implementation allows ANY absolute path the user has filesystem access to. Security policy integration is deferred to mlld-bgl.\n\n**Future**: Policy will allow restricting to specific path prefixes:\n```mlld\n/needs cmd.cwd:/Users/adam/dev/**  # Only allow paths under this\n```\n\n### 5. Scope is Per-Command\n\nThe `:path` only affects the specific command it's attached to, not global state:\n```mlld\n/run cmd:/tmp {pwd}        # runs in /tmp\n/run cmd {pwd}             # runs in default cwd\n/run @data | cmd:/app {process.sh}  # only process.sh runs in /app\n```\n\n**Rationale**: Explicit scope prevents action-at-a-distance bugs.\n\n## Implementation Order\n\nThe subtasks have dependencies:\n\n**Phase 1: Foundation (can be parallel)**\n1. mlld-u8r - Types (no dependencies)\n2. mlld-b0e - Grammar: WorkingDirPath pattern\n\n**Phase 2: Grammar Integration (depends on phase 1)**\n3. mlld-zgb - Grammar: cmd support (depends on mlld-b0e)\n4. mlld-rn5 - Grammar: sh/bash support (depends on mlld-b0e)\n\n**Phase 3: Runtime (depends on phase 1-2)**\n5. mlld-1x2 - cwd-resolver utility (depends on mlld-u8r)\n6. mlld-e0b - run evaluator (depends on mlld-1x2, mlld-u8r)\n7. mlld-7e7 - executors (depends on mlld-e0b)\n\n**Phase 4: Testing (depends on all)**\n8. mlld-k69 - comprehensive tests\n\n## Technical Architecture\n\n```\nGrammar Layer:\n  WorkingDirPath pattern ‚Üí parses :path syntax\n  ‚Üì\n  CmdCommandBrackets / RunLanguageCodeCore ‚Üí includes workingDir in AST\n  ‚Üì\nAST:\n  values.workingDir: ContentNodeArray (nodes with variables)\n  raw.workingDir: string (raw text)\n  meta.hasWorkingDir: boolean\n  meta.workingDirMeta: PathMeta\n  ‚Üì\nInterpreter:\n  run evaluator ‚Üí checks for workingDir in AST\n  ‚Üì\n  cwd-resolver ‚Üí interpolates variables, validates path\n  ‚Üì\n  executeCommand/executeCode ‚Üí passes cwd in options\n  ‚Üì\nExecutors:\n  ShellCommandExecutor / BashExecutor / etc ‚Üí use options.cwd || this.workingDirectory\n```\n\n## Error Handling\n\nClear, actionable error messages:\n\n```\nError: Cannot resolve working directory path\n  Path: /home/@username/dev\n  Reason: Variable @username is not defined\n  Location: example.mld:5:10\n```\n\n```\nError: Working directory must be an absolute path (start with /)\n  Provided: ./relative\n  Location: example.mld:8:15\n```\n\n```\nError: Working directory does not exist\n  Path: /nonexistent/directory\n  Location: example.mld:12:10\n```\n\n## Testing Strategy\n\n1. **Grammar tests**: Verify AST structure for various syntax forms\n2. **Valid cases**: Test execution with different path types\n3. **Invalid cases**: Test parse errors for unsupported syntax\n4. **Exception cases**: Test runtime errors for undefined vars, bad paths\n5. **Integration**: Test with loops, pipelines, different executors","notes":"Decisions: '/' allowed; paths must be absolute Unix; no Windows or '~'; reuse existing missing/non-dir path errors at runtime; :path applies to cmd/sh/etc including /exe forms like /exe @run(path, foo) = cmd:@path {...}.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T11:49:05.80685-08:00","updated_at":"2025-12-08T20:25:28.959279-08:00","closed_at":"2025-12-08T20:25:28.959279-08:00","labels":["creator:adamavenir@hey.com","epic","feature"],"dependencies":[{"issue_id":"mlld-qxb","depends_on_id":"mlld-b0e","type":"blocks","created_at":"2025-12-08T12:54:49.696952-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-zgb","type":"blocks","created_at":"2025-12-08T12:54:49.737084-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-rn5","type":"blocks","created_at":"2025-12-08T12:54:49.774931-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-u8r","type":"blocks","created_at":"2025-12-08T12:54:49.809626-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-1x2","type":"blocks","created_at":"2025-12-08T12:54:49.842686-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-e0b","type":"blocks","created_at":"2025-12-08T12:54:49.878847-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-7e7","type":"blocks","created_at":"2025-12-08T12:54:49.913983-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-k69","type":"blocks","created_at":"2025-12-08T12:54:49.949208-08:00","created_by":"daemon"}]}
{"id":"mlld-r2c","title":"Change run/show/output/append/log/stream to property + italic (darker teal)","description":"Change action directives to use 'property' semantic type with italic modifier for darker teal italic appearance (like property_example in .ts).\n\nToken type: 'directiveAction' ‚Üí maps to 'property' in TOKEN_TYPE_MAP\nAdd italic modifier when tokenizing\n\nCurrently: 'directive' ‚Üí 'keyword' (light teal italic)\nTarget: 'property' + italic (darker teal italic)\n\nFiles: DirectiveVisitor.ts, TOKEN_TYPE_MAP","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-14T11:25:55.135558-08:00","updated_at":"2025-12-14T13:46:04.607096-08:00","closed_at":"2025-12-14T13:46:04.607096-08:00"}
{"id":"mlld-r6u","title":"Detect JSON in markdown code fences and suggest @json.llm","description":"When @json filter fails to parse, check if the input looks like JSON wrapped in markdown code fences (starts with ```json or ```). If so, suggest using @json.llm filter instead. This is a common pattern when working with LLM responses.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-17T08:30:09.750552-08:00","updated_at":"2025-12-17T08:30:09.750552-08:00"}
{"id":"mlld-rn5","title":"Grammar: Extend RunLanguageCodeCore to support :path for sh/bash","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task extends language code execution (`sh`, `bash`, `js`, `python`, etc.) to support the `:path` suffix.\n\n## Prerequisites\n- mlld-b0e must be complete (WorkingDirPath pattern exists)\n\n## Task\nModify `RunLanguageCodeCore` to optionally parse and include working directory path for language executors.\n\n## Implementation\n\nLocation: `grammar/core/code.peggy`\n\n### Step 1: Add language with path pattern\n\n```peggy\n// Shared working directory pattern for language codes\nLanguageWorkingDirPath \"language working directory path\"\n  = \":\" path:WorkingDirPathContent {\n      return path;\n    }\n\n// Run language with optional working directory\nRunCodeLanguageWithPath\n  = language:RunCodeLanguage workingDir:LanguageWorkingDirPath? {\n      return {\n        language: language,\n        workingDir: workingDir || null\n      };\n    }\n```\n\n### Step 2: Modify RunLanguageCodeCore\n\nFind `RunLanguageCodeCore` pattern (around line 208) and update it to:\n1. Use `RunCodeLanguageWithPath` instead of `RunCodeLanguage`\n2. Extract `workingDir` from `langInfo`\n3. Add workingDir to values/raw/meta when present\n\n```peggy\nRunLanguageCodeCore\n  = streamPrefix:StreamKeyword? _ langInfo:RunCodeLanguageWithPath _ code:UnifiedCodeBrackets {\n      const language = langInfo.language;\n      const workingDir = langInfo.workingDir;\n      \n      // ... existing code to process language and code ...\n      \n      const values = {\n        lang: [langNode],\n        args: [],\n        code: [codeNode]\n      };\n      \n      if (workingDir) {\n        values.workingDir = workingDir.parts;\n      }\n      \n      const raw = {\n        lang: language,\n        args: [],\n        code: codeContent\n      };\n      \n      if (workingDir) {\n        raw.workingDir = workingDir.raw;\n      }\n      \n      const meta = {\n        isMultiLine: code.isMultiLine || codeContent.includes('\\n'),\n        language: language,\n        hasVariables: false,\n        hasWorkingDir: \\!\\!workingDir\n      };\n      \n      if (workingDir) {\n        meta.workingDirMeta = workingDir.meta;\n      }\n      \n      // ... rest of existing code ...\n    }\n```\n\n## Examples\n\n```mlld\n/run sh:/tmp {echo \"hello\"}\n/run bash:@mypath {pwd}\n/run js:/home/@user/scripts {console.log(process.cwd())}\n```\n\n## Testing\n\n```bash\nnpm run ast -- '/run sh:/tmp {echo hello}'\nnpm run ast -- '/run bash:@base {pwd}'\nnpm run ast -- '/run python:/scripts {print(1)}'\n```","notes":"RunLanguageCodeCore needs :path using WorkingDirPath; absolute Unix paths only ('/' ok); no Windows or '~'.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:18.829051-08:00","updated_at":"2025-12-08T20:23:54.14086-08:00","closed_at":"2025-12-08T20:23:54.14086-08:00"}
{"id":"mlld-rxs","title":"datatype labels need distinct highlighting - should stand out","description":"Type labels in exe definitions like 'datatype' are currently highlighted as generic identifiers (same as variables).\n\nExample: exe datatype @getReplyPressure(agent, msg) = [...]\n\nThe 'datatype' label declares return type and should be visually prominent - different from both variables and keywords. Should be tokenized as 'type' or 'label' token type.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-13T05:33:08.56308-08:00","updated_at":"2025-12-14T15:07:18.493317-08:00","closed_at":"2025-12-14T15:07:18.493317-08:00","dependencies":[{"issue_id":"mlld-rxs","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:33:08.56413-08:00","created_by":"daemon"}]}
{"id":"mlld-s4a","title":"npm run test:case shows all tests skipped instead of running specified test","description":"**Repro:**\n```bash\nnpm run test:case -- feat/for-when-filter\n```\n\n**Expected:** Runs the specific test fixture\n\n**Actual:**\n```\nTest Files  1 skipped (1)\nTests  1012 skipped (1012)\n```\n\nAll tests show as skipped instead of running the specified test. This broke recently - the test:case runner should isolate and run only the matching fixture(s).\n\n**Impact:** Can't quickly test individual fixtures during development.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-10T22:57:01.302139-08:00","updated_at":"2025-12-10T23:08:36.644989-08:00"}
{"id":"mlld-s4qi","title":"Directory imports treat .mld files without / prefixes as templates instead of executing them","description":"When importing .mld files (via directory import or direct import), files without / prefixes are treated as templates instead of being executed.\n\nReproduction:\nFile agents/party/index.mld contains:\nvar @meta = { id: \"party\" }\nexport { @meta }\n\nWhen imported, shows as template instead of executing the code.\n\nThe grammar supports auto-directive mode (directives without /) in .mld files, but the import system is treating them as templates.\n\nRoot cause: Need to check ModuleContentProcessor to see why .mld files aren't being parsed/executed when they lack / prefixes.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-18T19:31:09.263332-08:00","updated_at":"2025-12-18T19:44:14.723652-08:00","closed_at":"2025-12-18T19:44:14.723652-08:00","close_reason":"Fixed. .mld files without / prefixes now execute correctly when imported. The bug was that Unix absolute paths were being incorrectly classified as virtual test files. Added check to distinguish real paths (with multiple slashes) from virtual paths (single slash only). All tests pass."}
{"id":"mlld-slk","title":"Exe blocks with let statements return null in for loops","description":"**Critical regression - exe blocks with let statements broken.**\n\n**Repro 1 - In for loop:**\n```mlld\n/exe @wrap(agent, turnP) = [\n  let @turn = @turnP[@agent]\n  =\u003e { name: @agent, turn: @turn }\n]\n/var @results = for @a in [\"alice\"] [@wrap(@a, @turnP)]\n\u003e\u003e Returns: [null]\n```\n\n**Repro 2 - Direct call:**\n```mlld\n/exe @wrap(agent, turnP) = [\n  let @turn = @turnP[@agent]\n  =\u003e { name: @agent, turn: @turn }\n]\n/show @wrap(\"alice\", @turnP)\n\u003e\u003e Error: Variable not found for index: [object Object]\n```\n\n**Without let:**\n```mlld\n/exe @wrap(agent, turnP) = { name: @agent, turn: @turnP[@agent] }\n\u003e\u003e Works perfectly\n```\n\n**Impact:** \n- Blocking @partydev.1's proto-3.6/3.7 testing\n- Breaks all exe blocks that use let statements\n- Introduced with recent parallel for blocks changes\n\n**Priority:** P0 - critical regression in core functionality","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-11T10:46:49.078819-08:00","updated_at":"2025-12-11T11:05:22.235996-08:00","closed_at":"2025-12-11T11:05:22.235996-08:00"}
{"id":"mlld-sp9","title":"VERIFY FIXED: Import statement tokenization complete","description":"Import statements have multiple untokenized elements:\n\nimport templates from \"@templates/agents\" as @agentTemplates(message)\n\nMissing:\n1. 'templates' - the import identifier\n2. '@payLoad' in other imports  \n3. '@agentTemplates(message)' - the template with parameters\n\nAll three should be tokenized. Check DirectiveVisitor.visitImportDirective() to ensure all import components are visited.","notes":"Fixed:\n- Import type identifier (templates) \n- @payLoad/@state/@input sources (workaround for grammar bug mlld-qew)\n- Import alias @agentTemplates\n- Template parameters (message)\nNeed to verify all pieces highlight in editor.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-13T05:33:24.899099-08:00","updated_at":"2025-12-14T13:10:42.953327-08:00","closed_at":"2025-12-14T13:10:42.953327-08:00","dependencies":[{"issue_id":"mlld-sp9","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:33:24.899899-08:00","created_by":"daemon"}]}
{"id":"mlld-sqg","title":"MCP: Inline server orchestration with /mcp directive","description":"Add inline MCP server orchestration to mlld scripts using /mcp directive.\n\n**Syntax:**\n```mlld\n/exe @tool() = node { return 'data'; }\n\n/mcp @server = {\n  tools: [@tool],\n  config: { MLLD_TOKEN: \"secret\" }\n}\n\n/exe @agent(task) = @task | { claude } with { mcp: @server }\n```\n\n**Features:**\n- /mcp directive defines server config\n- with { mcp: @server } spawns server and pipes stdio\n- with { mcp: inherit } for nested commands\n- Script-scoped lifecycle (spawn on first use, kill at end)\n\n**Implementation plan in GH#495:**\n- Day 1: Grammar + types\n- Day 2: Directive eval + server manager\n- Day 3: Pipeline integration\n- Day 4: Testing + docs\n\n**v1a limitations:** One server per command (multi-server requires proxy in v1b)\n\nGitHub issue: #495","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-18T10:21:10.33158-08:00","updated_at":"2025-12-18T10:21:10.33158-08:00"}
{"id":"mlld-sqt","title":"`log` folder should only be created if user sets a flag ","description":"Need to think about what the design for this is, but the current approach isn't great, and it's not even clear what is supposed to be going in `log` I just see them littering things whenever I run mlld files ‚Äî and the output that I've seen is empty!! ","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-07T13:44:47.291457-08:00","updated_at":"2025-12-08T12:17:37.089103-08:00","labels":["bug","creator:adamavenir@hey.com"]}
{"id":"mlld-st4l","title":"Add 'when @value [...]' for bound-value all-match evaluation","description":"User request from @partydev. Companion to mlld-dp5 (when @value first).\n\nCurrent: when [] already executes all matching conditions.\nNeeded: when @value [] - bind a value upfront, then all matching conditions fire.\n\nExample:\nwhen @selectedAgents by @agent.meta.id [\n  \"mllddev\" =\u003e { agent: @agent, docs: gatherDocs(...) }\n  \"party\" =\u003e { agent: @agent, history: loadHistory(...) }\n]\n\nThis is the all-match version of 'when @value first'. No 'parallel' keyword needed since bare 'when' already executes all matches.\n\nSee: /Users/adam/dev/party/mlld-feature-request-routing.md","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-12-18T17:51:58.899693-08:00","updated_at":"2025-12-19T03:04:36.922163-08:00","closed_at":"2025-12-18T19:19:33.093718-08:00"}
{"id":"mlld-sus","title":"let statements should support all /var RHS forms (cmd, sh, js, template, etc)","description":"**Issue:** `let` statements execute commands but variable interpolation broken for sh/js forms.\n\n**Working (executes AND interpolates):**\n```mlld\nlet @x = cmd { echo \"@item\" }  # ‚úÖ interpolates @item correctly\n```\n\n**Broken (executes but NO interpolation):**\n```mlld\nlet @x = sh { echo \"@item\" }   # ‚ùå outputs literal \"@item\"\nlet @x = js { return \"@item\" } # ‚ùå outputs literal \"@ITEM\"\n```\n\n**Test results:**\n```mlld\n/for @item in [\"alice\"] [\n  let @a = cmd { echo \"@item\" }  # \"alice\" ‚úÖ\n  let @b = sh { echo \"@item\" }   # \"@item\" ‚ùå\n  let @c = js { return \"@item\" } # \"@ITEM\" ‚ùå\n]\n```\n\n**Impact:** Limits @partydev.1 to `cmd` form only. Most use cases work with `cmd` for claude calls, but sh/js interpolation needed for complex orchestration.\n\n**Root cause:** sh/js code execution in let context missing interpolation step that cmd has.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-11T11:13:41.312532-08:00","updated_at":"2025-12-11T13:18:07.095675-08:00","closed_at":"2025-12-11T13:18:07.095675-08:00"}
{"id":"mlld-sxd","title":"for-when filter syntax with implicit skip","description":"**New syntax for filter-map in one step:**\n\n```mlld\n\u003e\u003e Dense block form\n/var @positive = for @x in @xs when [\n  @x \u003e 0 =\u003e @x\n  @x \u003e 10 =\u003e \"big\"\n]\n\n\u003e\u003e One-liner  \n/var @positive = for @x in @xs when @x \u003e 0 =\u003e @x\n\n\u003e\u003e With transform\n/var @labels = for @x in @xs when @x \u003e 0 =\u003e \"positive: @x\"\n```\n\n**Behavior changes:**\n1. `for...when` implicitly skips non-matches (no nulls in result)\n2. No need for `none =\u003e skip` boilerplate\n3. The one-liner form `for @x when @cond =\u003e expr` works naturally since bare `when` already supports it\n\n**Current behavior (to be changed):**\n```mlld\n/var @arr = for @x in @xs [\n  when [ @x \u003e 0 =\u003e @x ]  \n]\n\u003e\u003e Returns [1, null, 2, null, 3] - nulls for non-matches\n\n/var @arr = for @x in @xs [\n  when [ @x \u003e 0 =\u003e @x; none =\u003e skip ]\n]\n\u003e\u003e Returns [1, 2, 3] - requires explicit skip\n```\n\n**New behavior:**\n```mlld\n/var @arr = for @x in @xs when [ @x \u003e 0 =\u003e @x ]\n\u003e\u003e Returns [1, 2, 3] - implicit skip, no nulls\n```\n\nThis is the common case - nobody wants nulls in their collected array.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T21:10:55.463436-08:00","updated_at":"2025-12-10T23:02:10.11598-08:00","closed_at":"2025-12-10T23:02:10.11598-08:00"}
{"id":"mlld-tfb","title":"Tests: strict mode fixtures and regressions","description":"**Summary:**\nAdd comprehensive test coverage for strict mode parsing and execution.\n\n**New fixtures needed:**\n\n1. **Strict mode success cases** (`tests/cases/valid/strict/`):\n   - `bare-directives.mld` - directives without `/` prefix\n   - `optional-slash.mld` - directives WITH `/` prefix (backward compat)\n   - `mixed-slash.mld` - some with, some without `/`\n   - `blank-lines.mld` - blank lines as formatting (should be ignored)\n   - `all-directives.mld` - every directive type without slash\n\n2. **Strict mode error cases** (`tests/cases/invalid/strict/`):\n   - `text-line.mld` - plain text should error\n   - `prose-content.mld` - markdown prose should error\n   - `comment-looking-text.mld` - `# heading` (not a directive) should error\n\n3. **Markdown mode regressions** (`tests/cases/valid/markdown/`):\n   - Existing tests renamed to `.mld.md` to confirm they still work\n   - Or keep as `.mld` with explicit mode override for backward compat testing\n\n4. **Cross-mode imports** (`tests/cases/valid/imports/`):\n   - `strict-imports-markdown.mld` imports `helper.mld.md`\n   - `markdown-imports-strict.mld.md` imports `helper.mld`\n\n**Fixture structure:**\n```\ntests/cases/valid/strict/\n  bare-directives/\n    example.mld      # bare var, exe, show, etc.\n    expected.md      # output\ntests/cases/invalid/strict/\n  text-line/\n    example.mld      # \"This is text\"\n    error.md         # expected error pattern\n```\n\n**Testing approach:**\n- Run `npm run build:fixtures` to generate fixture JSON\n- Verify strict mode fixtures parse/execute correctly\n- Verify invalid strict cases produce clear errors","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:17.200221-08:00","updated_at":"2025-12-15T20:50:09.184514-08:00","closed_at":"2025-12-11T17:53:11.499329-08:00","dependencies":[{"issue_id":"mlld-tfb","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.543036-08:00","created_by":"daemon"},{"issue_id":"mlld-tfb","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.870957-08:00","created_by":"daemon"}]}
{"id":"mlld-tiq","title":"Directory imports: exported variables missing, only __meta__ (frontmatter) visible","description":"When using directory imports, child modules' exported variables are not accessible. Only the frontmatter __meta__ property is visible.\n\nReproduction:\n- File agents/party/index.mld exports @meta, @tldr\n- /import \"./agents\" as @registry\n- @registry.party only shows __meta__ (frontmatter), not the exported variables\n\nThe issue appears to be in ModuleContentProcessor.ts where files without populated moduleObjects fallback to template mode even though they have valid exports.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T11:50:32.738424-08:00","updated_at":"2025-12-18T16:15:50.628326-08:00","closed_at":"2025-12-18T16:15:50.628326-08:00","close_reason":"Fixed by agent. Added .mx.key accessor for iteration and fixed directory import exports. Tests pass.","labels":["devrel","user-blocking"]}
{"id":"mlld-u8r","title":"Types: Extend RunValues/RunRaw/RunMeta for workingDir","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task adds TypeScript type definitions for the new `workingDir` field in run directive AST nodes.\n\n## Prerequisites\nNone - this can be done independently, but grammar tasks (mlld-b0e, mlld-zgb, mlld-rn5) will reference these types.\n\n## Task\nExtend the run directive type definitions to include working directory fields.\n\n## Implementation\n\nLocation: `core/types/run.ts`\n\n### 1. Extend RunValues interface\n\nFind the `RunValues` interface and add:\n```typescript\nexport interface RunValues {\n  command?: ContentNodeArray;\n  lang?: TextNodeArray;\n  args?: VariableNodeArray;\n  code?: ContentNodeArray;\n  identifier?: VariableNodeArray;\n  withClause?: WithClause;\n  securityLabels?: DataLabel[];\n  workingDir?: ContentNodeArray;  // NEW: Working directory path parts\n}\n```\n\n### 2. Extend RunRaw interface\n\n```typescript\nexport interface RunRaw {\n  command?: string;\n  lang?: string;\n  args?: string[];\n  code?: string;\n  identifier?: string;\n  withClause?: WithClause;\n  securityLabels?: string;\n  workingDir?: string;  // NEW: Raw working directory string\n}\n```\n\n### 3. Extend RunMeta interface\n\n```typescript\nexport interface RunMeta {\n  isMultiLine?: boolean;\n  argumentCount?: number;\n  language?: string;\n  hasVariables?: boolean;\n  withClause?: WithClause;\n  securityLabels?: DataLabel[];\n  hasWorkingDir?: boolean;      // NEW: Flag indicating working dir is set\n  workingDirMeta?: PathMeta;    // NEW: Path metadata for working dir\n}\n```\n\n### 4. Check PathMeta import\n\nEnsure `PathMeta` is imported if not already:\n```typescript\nimport type { PathMeta } from './path'; // or wherever PathMeta is defined\n```\n\n## What These Fields Mean\n\n- `workingDir` in RunValues: Array of AST nodes (Text nodes and VariableReference nodes) that make up the path\n- `workingDir` in RunRaw: The raw string representation like \"/tmp\" or \"@base/scripts\"\n- `hasWorkingDir` in RunMeta: Boolean flag to quickly check if workingDir was specified\n- `workingDirMeta` in RunMeta: Metadata like `hasVariables: true`, `isAbsolute: true`, etc.\n\n## Testing\n\nAfter implementation:\n```bash\nnpm run build\n```\n\nShould compile without errors. The grammar implementation will use these types.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:23.658146-08:00","updated_at":"2025-12-08T20:24:10.118584-08:00","closed_at":"2025-12-08T20:24:10.118584-08:00"}
{"id":"mlld-vlw","title":"Docs: update for strict mode","description":"**Summary:**\nUpdate all documentation to reflect the two-mode system.\n\n**Files to update:**\n\n1. **llms.txt:**\n   - Add mode explanation at top\n   - Note that examples use strict mode (no `/` prefix)\n   - Reference `.mld.md` for prose-embedded scripts\n\n2. **docs/user/ files:**\n   - Add \"Execution Modes\" section to getting-started or new page\n   - Update examples to show both styles where relevant\n   - Clarify file extension semantics\n\n3. **docs/dev/GRAMMAR.md:**\n   - Document mode flag in parser options\n   - Explain optional slash parsing\n   - Document top-level line handling per mode\n\n4. **README.md:**\n   - Quick mention of file extensions and modes\n\n**Key messaging:**\n\n- `.mld` = code file, LLM-friendly, no implicit content\n- `.mld.md` = documentation file, prose becomes output\n- Optional `/` in strict mode for gradual migration\n- SDK raw strings default to strict\n\n**Example documentation:**\n\n```markdown\n## File Extensions\n\n| Extension | Mode     | Behavior |\n|-----------|----------|----------|\n| `.mld`    | strict   | Every line is a directive or blank. Text lines error. |\n| `.mld.md` | markdown | `/` required for directives. Text becomes content. |\n\n### Strict Mode (.mld)\n```mlld\nvar @name = \"World\"\nshow `Hello @name`\n```\n\n### Markdown Mode (.mld.md)\n```mlld\n# Welcome Script\n\nThis text becomes output.\n\n/var @name = \"World\"\n/show `Hello @name`\n```\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:40.507851-08:00","updated_at":"2025-12-08T19:58:40.507851-08:00","dependencies":[{"issue_id":"mlld-vlw","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.647573-08:00","created_by":"daemon"},{"issue_id":"mlld-vlw","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T19:59:14.957772-08:00","created_by":"daemon"}]}
{"id":"mlld-w2u","title":"Language labels (js/py/sh/cmd) should use 'type' semantic token","description":"Language identifiers in /run blocks should be tokenized as 'type'. Currently using 'label'. Affects: js, node, sh, py, cmd language identifiers.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-14T07:55:54.841815-08:00","updated_at":"2025-12-14T08:52:08.552434-08:00","closed_at":"2025-12-14T08:52:08.552434-08:00"}
{"id":"mlld-wrb","title":"Phase 1.3: Grammar - Simplify when oneliner syntax","description":"## Summary\n\nSimplify when oneliner syntax to not require brackets around the condition.\n\n## Current vs New Syntax\n\n```mlld\n# CURRENT (brackets around condition)\nwhen [@condition] =\u003e action\n\n# NEW (no brackets needed for oneliner)\nwhen @condition =\u003e action\n\n# Block form (unchanged)\nwhen [\n  @cond1 =\u003e action1\n  @cond2 =\u003e action2\n]\n```\n\n## Breaking Change\n\nThis simplifies the oneliner by removing unnecessary brackets. The block form remains unchanged.\n\n## Files to Modify\n\n- `grammar/directives/when.peggy` - Update oneliner pattern\n\n## Implementation\n\nThe oneliner should parse as:\n\n```peggy\nWhenOneliner \"when oneliner\"\n  = \"when\" _ condition:WhenCondition _ \"=\u003e\" _ action:WhenAction {\n      return {\n        type: 'WhenExpression',\n        subtype: 'oneliner',\n        values: {\n          conditions: [condition],\n          actions: [action]\n        },\n        // ... \n      };\n    }\n```\n\nKeep the block form parsing as-is.\n\n## Rationale\n\n- More concise syntax for simple conditionals\n- Consistent with other oneliners in the language\n- Block form still available for multi-condition cases\n\n## Testing\n\n```bash\nnpm run ast -- 'when @x \u003e 5 =\u003e \"big\"'      # oneliner (new)\nnpm run ast -- 'when [@x \u003e 5 =\u003e \"big\"]'    # block form (unchanged)\n```\n\n## Validation\n\n- [ ] Oneliner parses without brackets\n- [ ] Block form still works\n- [ ] Both forms produce correct AST","notes":"Simplified when simple form to accept bracketless oneliner. Grammar rebuild ok; block forms untouched.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:15:41.385926-08:00","updated_at":"2025-12-15T20:50:09.184806-08:00","closed_at":"2025-12-10T07:09:09.589956-08:00","dependencies":[{"issue_id":"mlld-wrb","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.1699-08:00","created_by":"daemon"}]}
{"id":"mlld-wsm","title":"Resolvers: propagate mode through imports","description":"**Summary:**\nWhen resolving imports, ensure the imported module is parsed with the correct mode based on its extension.\n\n**Changes required:**\n\n1. **Import resolution** (resolvers, likely `LocalResolver`, `RegistryResolver`, etc.):\n   - When resolving a module path, determine mode from resolved filepath extension\n   - Pass mode to parser when loading the imported module\n\n2. **Mode inheritance rules:**\n   - `.mld` imports ‚Üí strict mode\n   - `.mld.md` imports ‚Üí markdown mode\n   - The importing file's mode does NOT affect the imported file's mode\n   - Each file's extension determines its own mode\n\n3. **Dynamic modules:**\n   - String dynamic modules: default to `'strict'` (or accept mode option)\n   - Object dynamic modules: N/A (no parsing)\n\n4. **Edge cases:**\n   - Circular imports: mode still derived from extension\n   - Re-exports: mode of original source file applies\n\n**Testing:**\n- `.mld` file imports `.mld.md` file - each parses in correct mode\n- `.mld.md` file imports `.mld` file - each parses in correct mode\n- Dynamic module string defaults to strict","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:02.459003-08:00","updated_at":"2025-12-15T20:50:09.185103-08:00","closed_at":"2025-12-11T17:45:16.657612-08:00","dependencies":[{"issue_id":"mlld-wsm","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.504019-08:00","created_by":"daemon"},{"issue_id":"mlld-wsm","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.8354-08:00","created_by":"daemon"}]}
{"id":"mlld-wzb","title":"Grammar bug: Second bare directive parsed as text in strict mode","description":"In strict mode, when two directives appear on consecutive lines, the second directive is incorrectly parsed as text content and triggers 'Text content not allowed in strict mode' error.\n\n## Reproduction\n```mlld\nrun {echo \"A\"}\nrun {echo \"B\"}\n```\n\nParse this with `{mode: 'strict'}` and it fails with:\n```\nParse error: Text content not allowed in strict mode (.mld). Use .mld.md for prose. at line 2, column 4\n```\n\n## Expected\nBoth directives should be parsed and executed.\n\n## Actual  \nSecond directive is treated as text and triggers strict mode error.\n\n## Root Cause\nThe Directive rule predicate checks `isLogicalLineStart()` which requires the previous character (skipping whitespace) to be a newline. After the first directive's newline is consumed, the second directive starts at a position where the previous character is `\\n`, which should satisfy `isLogicalLineStart()`. However, something in the parsing order causes the second directive to not match.\n\nHappens even with simple directives, no blank lines needed - just any two bare directives on consecutive lines.\n\n## Impact\n- ~80 new strict mode test fixtures cannot be used until this is fixed\n- Strict mode is essentially unusable for multi-line scripts\n- BLOCKING: Cannot enable strict mode as default until fixed\n\n## Workaround\nFor now, using slash prefix (`/run`, `/var`, etc.) works in strict mode since the Directive rule checks both `isStrictMode || hasSlash`.\n\n## Files\n- `grammar/mlld.peggy` - Directive rule line 216-246\n- `grammar/deps/grammar-core.ts` - isLogicalLineStart helper line 146-151\n- `grammar/base/whitespace.peggy` - may be related to newline handling","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-11T19:55:48.93822-08:00","updated_at":"2025-12-11T20:16:29.988601-08:00","closed_at":"2025-12-11T20:16:29.988601-08:00"}
{"id":"mlld-x41","title":"Field access on JS-returned objects fails in for-loop source","description":"## Reproduction\n\n```mlld\n/exe @getData() = js { return { all: ['a','b','c'] } }\n/var @result = @getData()\n/show \"All: @result.all\"           # Works: [\"a\",\"b\",\"c\"]\n/for @item in @result.all =\u003e show @item  # FAILS: undefined\n```\n\n## Issue\n\nField access `@result.all` works in string interpolation but returns `undefined` when used as a /for loop source.\n\n## Expected\n\n`@result.all` should return the array `['a','b','c']` consistently in all contexts.\n\n## Context\n\nJS function returns object, gets stored as StructuredValue. Field access works for display but not for iteration.\n\nReported by: partydev.1","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-09T17:09:42.728504-08:00","updated_at":"2025-12-15T20:50:09.185408-08:00","closed_at":"2025-12-10T19:22:41.178321-08:00"}
{"id":"mlld-xiw","title":"LSP: Fix array/object mlld value highlighting (GH#332)","description":"## Summary\nArrays and objects with mlld values have inconsistent highlighting.\n\nGitHub: https://github.com/mlld-lang/mlld/issues/332\n\n## Problem\n```mlld\n/var @data = {\n  name: @userName,      \u003c\u003c @userName not highlighted\n  items: [@a, @b, @c]   \u003c\u003c Variables not highlighted\n}\n```\n\n## Root Cause\nThe StructureVisitor handling objects and arrays doesn't recursively visit mlld value nodes.\n\n## Investigation\n```bash\nnpm run ast -- '/var @data = { name: @userName }'\n# Check if @userName is a VariableReference node with location\n```\n\n## Implementation\n\n### Check StructureVisitor\nIn `services/lsp/visitors/StructureVisitor.ts`:\n\n```typescript\nvisitObjectExpression(node: any, context: VisitorContext): void {\n  // Tokenize opening brace\n  // ...\n  \n  // Process properties\n  if (node.properties) {\n    for (const prop of node.properties) {\n      this.visitProperty(prop, context);\n    }\n  }\n  \n  // Tokenize closing brace\n}\n\nvisitProperty(node: any, context: VisitorContext): void {\n  // Tokenize property key\n  if (node.key) {\n    this.tokenBuilder.addToken({\n      line: node.key.location.start.line - 1,\n      char: node.key.location.start.column - 1,\n      length: node.key.name.length,\n      tokenType: 'property',\n      modifiers: []\n    });\n  }\n  \n  // Tokenize colon\n  // ...\n  \n  // IMPORTANT: Recursively visit the value\n  if (node.value) {\n    this.mainVisitor.visitNode(node.value, context);\n  }\n}\n\nvisitArrayExpression(node: any, context: VisitorContext): void {\n  // Tokenize opening bracket\n  // ...\n  \n  // IMPORTANT: Recursively visit elements\n  if (node.elements) {\n    for (const element of node.elements) {\n      this.mainVisitor.visitNode(element, context);\n    }\n  }\n  \n  // Tokenize closing bracket\n}\n```\n\nThe key is ensuring `mainVisitor.visitNode()` is called for values/elements so VariableReferences get proper tokens.\n\n## Testing\n```typescript\nit('highlights variables in object values', async () =\u003e {\n  const tokens = await getSemanticTokens('/var @x = { name: @value }');\n  expect(tokens).toContainToken({ type: 'variable', text: '@value' });\n});\n\nit('highlights variables in array elements', async () =\u003e {\n  const tokens = await getSemanticTokens('/var @x = [@a, @b]');\n  expect(tokens).toContainToken({ type: 'variable', text: '@a' });\n  expect(tokens).toContainToken({ type: 'variable', text: '@b' });\n});\n```\n\n## Files to Modify\n- `services/lsp/visitors/StructureVisitor.ts`\n\n## Size\nSmall - ensure recursive visitation of values/elements","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:36.61009-08:00","updated_at":"2025-12-11T22:05:24.367951-08:00","closed_at":"2025-12-11T22:05:24.367951-08:00","dependencies":[{"issue_id":"mlld-xiw","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.182947-08:00","created_by":"daemon"}]}
{"id":"mlld-xju","title":"Refactor: Consolidate expression.ts and expressions.ts","description":"## Summary\n\nConsolidate duplicate expression evaluator files to eliminate confusion and technical debt.\n\n## Context\n\nWe have TWO files with overlapping functionality:\n1. `interpreter/eval/expression.ts` (OLD) - 347 lines\n2. `interpreter/eval/expressions.ts` (NEW) - ~350 lines\n\nThe OLD file contains useful helpers (isTruthy, isEqual, toNumber) but also a broken `evaluateExpression()` that doesn't support arithmetic operators. The NEW file has the working evaluator but imports helpers from the OLD file.\n\n**Current fix:** interpreter.ts now uses the NEW evaluator (mlld-a2x fix), but we should consolidate the files.\n\n## Current Usage\n\n**expression.ts (OLD):**\n- Exports: isTruthy, isEqual, toNumber, evaluateExpression\n- Used by: expressions.ts (helpers), value-combine.ts (toNumber)\n- evaluateExpression: UNUSED (was broken, replaced by evaluateUnifiedExpression)\n\n**expressions.ts (NEW):**\n- Exports: evaluateUnifiedExpression\n- Imports: isTruthy, isEqual, toNumber from expression.ts\n- Used by: interpreter.ts (as of mlld-a2x fix)\n\n## Consolidation Options\n\n### Option 1: Merge into expressions.ts (Recommended)\n\n**Steps:**\n1. Copy isTruthy, isEqual, toNumber into expressions.ts\n2. Remove import from expressions.ts\n3. Export helpers from expressions.ts\n4. Update value-combine.ts to import from expressions.ts\n5. Delete expression.ts entirely\n\n**Result:** Single file with all expression logic\n\n**Pros:** Clean, single source of truth\n**Cons:** Larger file (~650 lines)\n\n### Option 2: Rename to expression-helpers.ts\n\n**Steps:**\n1. Rename expression.ts ‚Üí expression-helpers.ts\n2. Remove evaluateExpression() from helpers file (keep only isTruthy, isEqual, toNumber)\n3. Update imports in expressions.ts and value-combine.ts\n\n**Result:** Clear separation (helpers vs evaluators)\n\n**Pros:** Explicit naming, smaller files\n**Cons:** Extra file\n\n## Files to Modify\n\nOption 1 (Merge):\n- interpreter/eval/expressions.ts (add helpers)\n- interpreter/utils/value-combine.ts (update import)\n- Delete interpreter/eval/expression.ts\n\nOption 2 (Rename):\n- Rename interpreter/eval/expression.ts ‚Üí expression-helpers.ts\n- Update interpreter/eval/expressions.ts import\n- Update interpreter/utils/value-combine.ts import\n- Remove evaluateExpression() from helpers\n\n## Validation\n\n- [ ] All tests pass after consolidation\n- [ ] No imports from expression.ts remain\n- [ ] Helpers (isTruthy, isEqual, toNumber) still work\n- [ ] evaluateUnifiedExpression still works\n- [ ] value-combine.ts still works\n\n## Effort\n\n**Option 1 (Merge):** 30-45 minutes\n**Option 2 (Rename):** 20-30 minutes\n\n## References\n\n- Fixed in: mlld-a2x (interpreter.ts now uses NEW evaluator)\n- Analysis: tmp/expression-consolidation-plan.md","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T18:32:55.307628-08:00","updated_at":"2025-12-10T19:09:19.073389-08:00","labels":["chore"]}
{"id":"mlld-yd9","title":"VERIFY FIXED: Function declaration position with datatype labels","description":"Function declarations like exe @evaluateAgent(agent, msg, turnP) have multiple issues:\n1. Function name highlighting starts 2 characters late\n2. Opening/closing parentheses not highlighted\n3. Function arguments not tokenized/highlighted\n\nExample: exe @evaluateAgent(agent, msg, turnP) = [...]\n- @evaluateAgent highlighting offset by 2 chars\n- ( and ) not highlighted\n- agent, msg, turnP not highlighted as parameters","notes":"Fixed handleVariableDeclaration to search for @ position instead of calculating offset. Now handles 'exe datatype @func()' correctly. Need to verify in editor.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-13T05:32:41.102029-08:00","updated_at":"2025-12-14T13:10:42.954637-08:00","closed_at":"2025-12-14T13:10:42.954637-08:00","dependencies":[{"issue_id":"mlld-yd9","depends_on_id":"mlld-76c","type":"blocks","created_at":"2025-12-13T05:32:41.102487-08:00","created_by":"daemon"}]}
{"id":"mlld-ytz","title":"Dynamic modules: mode selection for injected content","description":"**Summary:**\nEnsure dynamically injected modules respect mode settings.\n\n**Changes required:**\n\n1. **String dynamic modules**:\n   - `dynamicModules: { '@foo': 'var @x = 1' }` - needs to parse\n   - Default: `'strict'` mode (programmatic injection = code, not docs)\n   - Add option: `dynamicModuleMode?: 'strict' | 'markdown'`\n\n2. **Object dynamic modules**:\n   - `dynamicModules: { '@state': { count: 0 } }` - no parsing, N/A\n   - These become direct value exports, mode irrelevant\n\n3. **Per-module mode** (optional enhancement):\n   - Could support: `dynamicModules: { '@foo': { source: '...', mode: 'markdown' } }`\n   - Lower priority, probably not needed\n\n4. **Documentation**:\n   - Document that string dynamic modules parse in strict mode by default\n   - Explain how to opt into markdown mode if needed\n\n**Testing:**\n- String dynamic module with bare directives - parses in strict\n- String dynamic module with text content - errors (strict default)\n- String dynamic module with explicit markdown mode - text becomes content","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:56:53.299196-08:00","updated_at":"2025-12-15T20:50:09.185691-08:00","closed_at":"2025-12-11T17:46:10.688649-08:00","dependencies":[{"issue_id":"mlld-ytz","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.446397-08:00","created_by":"daemon"},{"issue_id":"mlld-ytz","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.25244-08:00","created_by":"daemon"}]}
{"id":"mlld-zce","title":"E2E smoke tests for Claude Code integration","description":"## Goal\n\nCreate E2E smoke tests that verify mlld works correctly when piping/passing data to Claude Code CLI, especially with complex escaping scenarios.\n\n## Requirements\n\n**Test location:** `tests/claude/` (separate from regular tests)\n**Run command:** `npm run test:claude` (NOT included in `npm test`)\n**Test type:** E2E using mlld SDK's `execute()` function (NOT unit tests with manual ExecInvocation construction)\n\n## Test Patterns to Cover\n\nFrom your list of escaping/piping scenarios:\n\n1. `/exe @func(value) = @value | cmd { claude -p --model haiku }`\n2. `/exe @func(value) = cmd { @value | claude -p --model haiku }`\n3. `/exe @func(value) = @other(value) | cmd { claude -p --model haiku }`\n4. `/exe @func(value) = js { return \"hi\" } | cmd { claude -p --model haiku }`\n5. `/exe @func(value) = cmd { echo \"hello\" } | cmd { claude -p --model haiku }`\n6. `/exe @func(value) = @value | cmd { claude -p } | cmd { claude -p \"wdyt?\" }`\n\n## Test Structure (E2E with SDK)\n\nWrite actual mlld files + TypeScript tests using SDK `execute()`:\n\n**tests/claude/scripts/pipe-value.mld:**\n```mlld\n/exe @claude(prompt) = @prompt | cmd { claude -p --model haiku }\n/var @response = @claude(\"Say only OK\")\n/show @response\n```\n\n**tests/claude/integration.test.ts:**\n```typescript\nimport { execute } from '@sdk/execute';\nimport path from 'node:path';\n\nconst shouldRun = process.env.MLLD_RUN_CLAUDE_TESTS === '1';\nconst describeTest = shouldRun ? describe : describe.skip;\n\ndescribeTest('Claude integration', () =\u003e {\n  it('pipes value through claude', async () =\u003e {\n    const script = path.join(__dirname, 'scripts/pipe-value.mld');\n    const result = await execute(script, {});\n    \n    expect(result.output.trim().length).toBeGreaterThan(0);\n    expect(result.output.toUpperCase()).toContain('OK');\n  }, 30000);\n});\n```\n\n## What gpt5.1 Got Wrong\n\nCreated unit tests with manual ExecInvocation construction instead of E2E tests using actual mlld files + SDK execute().","notes":"## Test Coverage\n\nCreated comprehensive E2E tests for Claude Code integration covering all 6 escaping/piping patterns:\n\n1. Pattern 1: @value | cmd { claude -p } - Pipes value through claude\n2. Pattern 2: cmd { claude -p \"@value\" } - Uses value inside cmd body\n3. Pattern 3: @other(value) | cmd { claude -p } - Pipes result from another function\n4. Pattern 4: js { return \"prompt\" } | cmd { claude -p } - Pipes js result through claude\n5. Pattern 5: cmd { echo \"prompt\" } | cmd { claude -p } - Pipes cmd result through claude\n6. Pattern 6: @value | cmd { claude -p } | cmd { claude -p \"followup\" } - Double pipe through claude\n\nAll tests use SDK execute() function (NOT manual ExecInvocation construction).\nAll 9 tests passing across 3 test files.\n\n## Files Created\n\n- tests/claude/escaping-patterns.test.ts (6 tests)\n- tmp/claude-test-*.mld (6 test scripts)\n- Fixed: tests/claude/exe-claude-pipeline.test.ts (corrected syntax)\n- Fixed: tests/claude/claude-sdk-smoke.mld (corrected model name)\n\n## Alias Resolution Behavior\n\nmlld resolves shell aliases for commands in cmd { } blocks via interpreter/utils/alias-resolver.ts.\n\nKey behavior:\n- ‚úÖ cmd { claude -p \"prompt\" } - Alias resolves (command at start of block)\n- ‚ùå cmd { echo \"x\" | claude -p } - Alias does NOT resolve (pipe INSIDE block)\n- ‚úÖ @value | cmd { claude -p } - Alias resolves (pipe OUTSIDE block)\n\nThe alias resolver runs on the top-level command of a cmd block, but not on commands after pipes within shell scripts. This is why pattern 2 uses cmd { claude -p \"@value\" } instead of cmd { echo \"@value\" | claude -p }.\n\n## Run Tests\n\nnpm run test:claude\nMLLD_RUN_CLAUDE_TESTS=1 CLAUDE_MODEL=haiku vitest run tests/claude","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-09T18:43:47.625059-08:00","updated_at":"2025-12-09T19:25:44.599803-08:00","closed_at":"2025-12-09T19:17:24.767804-08:00"}
{"id":"mlld-zeo","title":"Phase 2.1: Interpreter - Export let functions from when.ts","description":"## Summary\n\nExport the existing let/augmented assignment evaluation functions from when.ts so they can be reused by exe and for block evaluators.\n\n## üìö Required Reading\n\nBefore starting Phase 2 interpreter work:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Return values should preserve wrappers\n\n## Why This Matters\n\nThe plan identifies that exe blocks are ~80% the same as exe..when. The let/augmented assignment logic already exists and works - we just need to export it for reuse.\n\n## Files to Modify\n\n- `interpreter/eval/when.ts` - Export helper functions\n\n## Implementation\n\nChange from private to exported functions (around lines 31 and 66):\n\n```typescript\n// Change: async function evaluateLetAssignment(...)\n// To: export async function evaluateLetAssignment(...)\n\nexport async function evaluateLetAssignment(\n  entry: LetAssignmentNode,\n  env: Environment\n): Promise\u003cEnvironment\u003e {\n  // ... existing implementation unchanged\n}\n\nexport async function evaluateAugmentedAssignment(\n  entry: AugmentedAssignmentNode,\n  env: Environment\n): Promise\u003cEnvironment\u003e {\n  // ... existing implementation unchanged\n}\n```\n\n## Key Implementation Details\n\nFrom when.ts (lines 31-112):\n- `evaluateLetAssignment()` creates child environment with new binding\n- `evaluateAugmentedAssignment()` finds existing let variable and mutates\n- Both return new Environment (immutable pattern)\n\n## Augmented Assignment Semantics (lines 66-112)\n\n- Arrays: concat (`[1, 2] += 3` ‚Üí `[1, 2, 3]`, `[1] += [2, 3]` ‚Üí `[1, 2, 3]`)\n- Strings: append (`\"hello\" += \" world\"` ‚Üí `\"hello world\"`)\n- Objects: shallow merge (`{a: 1} += {b: 2}` ‚Üí `{a: 1, b: 2}`)\n- Only works with local `let` bindings (not global variables)\n\n## Testing\n\nAfter export, verify imports work:\n\n```typescript\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n```\n\n## Validation\n\n- [ ] Functions exported without breaking existing when evaluation\n- [ ] Type signatures remain unchanged\n- [ ] All existing when tests still pass","notes":"‚úÖ PREREQUISITE UPDATE: Type enums completed in mlld-b4f. DirectiveKind now includes 'while' and 'for'. DirectiveSubtype now includes 'exeBlock', 'while', and 'for'. All types compile successfully. Ready to proceed with exporting let functions.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:54.131728-08:00","updated_at":"2025-12-15T20:50:09.18621-08:00","closed_at":"2025-12-10T14:00:43.452905-08:00","dependencies":[{"issue_id":"mlld-zeo","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:51.792231-08:00","created_by":"daemon"},{"issue_id":"mlld-zeo","depends_on_id":"mlld-b4f","type":"blocks","created_at":"2025-12-10T11:27:19.185199-08:00","created_by":"daemon"}]}
{"id":"mlld-zgb","title":"Grammar: Extend CmdCommandBrackets to support optional :path","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task extends the `CmdCommandBrackets` pattern to accept the optional `:path` suffix.\n\n## Prerequisites\n- mlld-b0e must be complete (WorkingDirPath pattern exists)\n\n## Task\nModify `CmdCommandBrackets` to optionally parse and include working directory path.\n\n## Implementation\n\nLocation: `grammar/patterns/unified-run-content.peggy`\n\nCurrent code (around line 84-87):\n```peggy\nCmdCommandBrackets \"cmd command brackets\"\n  = \"cmd\" _ content:UnifiedCommandBrackets {\n      return content;\n    }\n```\n\nChange to:\n```peggy\nCmdCommandBrackets \"cmd command brackets\"\n  = \"cmd\" workingDir:WorkingDirPath? _ content:UnifiedCommandBrackets {\n      const result = content;\n      if (workingDir) {\n        result.values.workingDir = workingDir.parts;\n        result.raw.workingDir = workingDir.raw;\n        result.meta.hasWorkingDir = true;\n        result.meta.workingDirMeta = workingDir.meta;\n      }\n      return result;\n    }\n```\n\n## What This Does\n\n1. Optionally matches `WorkingDirPath` after `cmd` keyword\n2. If present, adds to the result node:\n   - `values.workingDir` - AST node array for interpreter\n   - `raw.workingDir` - raw string for debugging/display\n   - `meta.hasWorkingDir` - boolean flag\n   - `meta.workingDirMeta` - path metadata (hasVariables, etc)\n\n## Testing\n\nAfter implementation:\n```bash\nnpm run ast -- '/run cmd:/tmp {ls}'\nnpm run ast -- '/run cmd:@mypath {pwd}'\nnpm run ast -- '/run cmd {ls}'  # without path still works\n```\n\nCheck the AST output has `workingDir` field in values/raw/meta when path is present.","notes":"Cmd :path grammar uses WorkingDirPath pattern; accepts absolute Unix paths only ('/' ok); no Windows or '~'.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:13.204118-08:00","updated_at":"2025-12-08T20:23:39.467487-08:00","closed_at":"2025-12-08T20:23:39.467487-08:00"}
