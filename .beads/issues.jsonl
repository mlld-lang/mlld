{"id":"mlld-04k","title":"Docs: alternative syntax guide","description":"Document alternative syntax forms in a new docs/user/alternative-syntax.md. Cover:\\n- Backtick + @var templates and .att template file style as primary patterns.\\n- Alternative cases for markdown mode templates and other interpolation styles.\\n- Guidance on when to use markdown mode vs strict.\\n- Cross-link from main docs without promoting alternates as defaults.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:29:23.17602-08:00","updated_at":"2025-12-09T08:29:23.17602-08:00"}
{"id":"mlld-0gd","title":"Phase 1.5: Verify grammar with AST tool","description":"## Summary\n\nValidate all grammar changes by running the AST tool on representative examples.\n\n## ‚ö° Incremental Unblocking\n\nThis verification task can unblock Phase 2 work **incrementally**:\n\n- Once exe block grammar is verified ‚Üí mlld-9id (exe interpreter) can start\n- Once for block grammar is verified ‚Üí mlld-0ic (for interpreter) can start  \n- Once while grammar is verified ‚Üí mlld-ait (while interpreter) can start\n\nDon't wait for all constructs to be verified before starting interpreter work on verified constructs.\n\n## Prereq\n\nAll Phase 1 grammar issues must be complete:\n- mlld-9pl (block patterns)\n- mlld-1sh (while patterns)  \n- mlld-wrb (when syntax)\n- mlld-8d6 (types)\n- mlld-1iz (error recovery)\n\n## Build First\n\n```bash\nnpm run build:grammar\n```\n\n## Test Cases\n\n### Exe Block\n```bash\nnpm run ast -- 'exe @f() = [let @x = 1 =\u003e @x]'\n```\n\nExpected: ExeBlock node with statements array and return value.\n\n### For Block\n```bash\nnpm run ast -- 'for @x in @xs =\u003e [show @x]'\n```\n\nExpected: ForDirective with meta.actionType = 'block'.\n\n### When Oneliner (new syntax)\n```bash\nnpm run ast -- 'when @x \u003e 5 =\u003e \"big\"'\n```\n\nExpected: WhenExpression with oneliner subtype.\n\n### When Block (unchanged)\n```bash\nnpm run ast -- 'when [@x \u003e 5 =\u003e \"big\"]'\n```\n\nExpected: WhenExpression with block subtype.\n\n### While Pipeline Stage\n```bash\nnpm run ast -- 'var @x = @y | while(10) @process'\n```\n\nExpected: Pipeline with WhileStage node.\n\n### Done/Continue Literals\n```bash\nnpm run ast -- 'exe @p(s) = when [@s.done =\u003e done @s.result * =\u003e continue @newState]'\n```\n\nExpected: ControlLiteral nodes with done/continue subtypes.\n\n## Common Errors to Debug\n\n- \"Expected token but...\" - Usually JavaScript in action block has unsupported syntax\n- Type mismatches - Check core/types/ alignment\n- Backtracking errors - Check rule ordering, more specific first\n\n## Debug Mode\n\n```bash\nDEBUG_MLLD_GRAMMAR=1 npm run ast -- '/var @test = \"value\"'\n```\n\n## Validation Checklist\n\n- [ ] Exe block parses correctly ‚Üí **unblocks mlld-9id**\n- [ ] For block parses correctly ‚Üí **unblocks mlld-0ic**\n- [ ] When oneliner parses correctly\n- [ ] When block still works\n- [ ] While stage parses correctly ‚Üí **unblocks mlld-ait**\n- [ ] Done literal parses correctly\n- [ ] Continue literal parses correctly\n- [ ] All AST output matches type definitions","notes":"Ran AST validation after grammar build: /exe block with block+return, /for block action, when simple and block forms, while pipeline stage, and done/continue in when-expression inside /exe; all parsed as expected.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:16.299919-08:00","updated_at":"2025-12-10T07:11:46.151058-08:00","closed_at":"2025-12-10T07:11:46.151059-08:00","dependencies":[{"issue_id":"mlld-0gd","depends_on_id":"mlld-9pl","type":"blocks","created_at":"2025-12-09T22:16:36.27996-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-1sh","type":"blocks","created_at":"2025-12-09T22:16:36.317874-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-wrb","type":"blocks","created_at":"2025-12-09T22:16:36.35831-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-8d6","type":"blocks","created_at":"2025-12-09T22:16:36.432164-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-1iz","type":"blocks","created_at":"2025-12-09T22:27:45.137162-08:00","created_by":"daemon"}]}
{"id":"mlld-0ic","title":"Phase 2.3: Interpreter - Modify for.ts for block action support","description":"## Summary\n\nModify the for loop evaluator to detect block vs single action mode and evaluate blocks with let support.\n\n## Key Insight\n\nForSingleAction already supports everything for blocks need. The change is minimal - detect action type and call the right evaluator.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Iterator values preserve wrappers through loop body\n\n## ‚ùå DON'T DO (Explicit Restrictions)\n\nThese combinations are **NOT supported** in this epic:\n\n1. **Parallel for with blocks**: `for parallel() @x in @xs =\u003e [...]`\n   - Error: \"Parallel for loops not supported with block bodies. Use exe wrapper pattern.\"\n   - Workaround: Create an exe that contains the block logic, use parallel for with that exe.\n\n2. **Batch pipelines with blocks**: `for @x in @xs =\u003e [...] =\u003e || @batch()`\n   - Error: \"Batch pipelines not supported with block bodies. Use simple for-expression.\"\n   - Workaround: Use simple for-expression if batch pipeline needed.\n\n3. **Field access mutation in +=**: `let @data[-1].field += value`\n   - Error: \"ETOOCOMPLEX: Augmented assignment only supports simple variables.\"\n   - Only support: `let @variable += value` (simple variable names)\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n- mlld-zeo (Export let functions)\n\n## Files to Modify\n\n- `interpreter/eval/for.ts` - Modify runOne() function\n\n## Implementation\n\nUpdate runOne() function (around line 168):\n\n```typescript\nimport { isLetAssignment, isAugmentedAssignment } from '@core/types/when';\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n\nconst runOne = async (entry: [any, any], idx: number) =\u003e {\n  // ... existing setup code for childEnv, iterationVar, etc.\n\n  const actionNodes = directive.values.action;\n  const retry = new RateLimitRetry();\n\n  while (true) {\n    try {\n      // Handle block vs single action mode\n      if (directive.meta.actionType === 'block') {\n        // Block mode: sequential evaluation with let support\n        let blockEnv = childEnv;\n        for (const stmt of actionNodes) {\n          if (isLetAssignment(stmt)) {\n            blockEnv = await evaluateLetAssignment(stmt, blockEnv);\n          } else if (isAugmentedAssignment(stmt)) {\n            blockEnv = await evaluateAugmentedAssignment(stmt, blockEnv);\n          } else {\n            const result = await evaluate(stmt, blockEnv);\n            blockEnv = result.env || blockEnv;\n          }\n        }\n        childEnv = blockEnv;\n      } else {\n        // Single action mode (existing behavior - unchanged)\n        // ... existing code\n      }\n\n      retry.reset();\n      break;\n    } catch (err: any) {\n      // ... existing retry logic unchanged\n    }\n  }\n  return;\n};\n```\n\n## Scoping Rules\n\n- Each iteration gets fresh child environment\n- Let variables scoped to block (not visible across iterations)\n- `var` mutations affect outer scope (existing behavior)\n- Parallel execution unchanged (blocks run sequentially within each parallel iteration)\n\n## Validation\n\n- [ ] Block mode detected via meta.actionType\n- [ ] Let assignments create scoped variables per iteration (as StructuredValue)\n- [ ] Augmented assignments work within iteration\n- [ ] Parallel execution still works for single actions\n- [ ] Error messages for unsupported combinations (parallel+block, batch+block)","notes":"ForDirective meta.actionType now 'single' | 'block'; values.action may be block statements. Block actions should run sequentially and respect control literals: skip/retry, plus done/continue literals with valueType and possible array payloads (Literal.value can be array). Ensure StructuredValue wrapping and early-return semantics are defined.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T22:18:12.164593-08:00","updated_at":"2025-12-10T03:02:31.391785-08:00","dependencies":[{"issue_id":"mlld-0ic","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:52.106015-08:00","created_by":"daemon"},{"issue_id":"mlld-0ic","depends_on_id":"mlld-zeo","type":"blocks","created_at":"2025-12-09T22:18:52.193244-08:00","created_by":"daemon"}]}
{"id":"mlld-0rz","title":"Global `@debug` object stopped working at some point","description":"I'm not sure when .... this used to get us most of whatever was in Environment for the purposes of debugging/inspection. It only redacted any env var values but did list the ones it could see.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T14:48:45.092969-08:00","updated_at":"2025-12-09T14:48:45.092969-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-1iz","title":"Phase 1.6: Grammar Error Recovery Infrastructure","description":"Implement sophisticated error recovery for block syntax to provide accurate error locations and helpful messages.\n\n## Scope\nMake Peggy parse errors inside [...] blocks point to the actual bad token instead of the opening bracket. Apply to exe blocks, for blocks, and while constructs.\n\n## Implementation Details\n\n### 1. Structured Block Rules (No Catch-Alls)\n- Define explicit statement lists without generic fallbacks\n- ExeBlockStatement enumerates: LetAssignment | AugmentedAssignment | EffectAction | WhenRHSVarAssignment | ReturnStatement\n- ForBlockStatement uses ForSingleAction directly\n- Reorder alternatives: specific statements before generic expression fallbacks\n\n### 2. Inline Error Recovery Branches\n- Unterminated block: lookahead for ], error at EOF if missing\n- Return placement: branch for =\u003e not last, error 'Return must be last'\n- Comma separator: match ',' in statement lists, error 'Use whitespace not commas'\n- Missing = after let @id: recovery in let-assignment.peggy\n- Multiple returns: detect second =\u003e in block\n\n### 3. Reparse-on-Failure Helper\nAdd helper in grammar/deps/grammar-core.ts:\nreparseInner(innerText, startRule, offset) - calls peg$parse with startRule, offsets location() by block start, rethrows via mlldError\n\n### 4. Unclosed Delimiter Scanners\n- Add bracket-aware scanner (like existing) honoring strings\n- Use in ExeBlock/ForBlock rules\n- Catch unclosed [ with helpful error\n\n### 5. Baseline Fixtures\nCreate failing fixtures capturing current bad diagnostics for regression guard\n\n## References\n- Source: todo/plan-grammar-errors.md","notes":"Added block grammar recovery: explicit ExeBlockAction surface (effects/assignments/special literals), ensured return must be last with mlldError, and block separators already reject commas. For/Exe blocks enumerate statements (no catch-alls) and reuse unclosed-[ check. Grammar build core passed.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:26:53.223759-08:00","updated_at":"2025-12-10T02:39:33.609622-08:00","closed_at":"2025-12-10T02:39:33.609624-08:00","labels":["enhancement","grammar"],"dependencies":[{"issue_id":"mlld-1iz","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:26:53.224915-08:00","created_by":"daemon"}]}
{"id":"mlld-1sh","title":"Phase 1.2: Grammar - Add While loop patterns with done/continue keywords","description":"## Summary\n\nAdd while loop construct for bounded iteration with `done`/`continue` control keywords.\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) first.\n\n## Syntax\n\n```mlld\n# Pipeline stage\nvar @result = @initial | while(100) @processor\n\n# Directive form\nwhile (100, 1s) @processor\n\n# Processor with done/continue\nexe @processor(state) = when [\n  @state.done =\u003e done @state.result\n  * =\u003e continue @newState\n]\n```\n\n## Files to Modify\n\n- `grammar/base/literals.peggy` - Add DoneLiteral and ContinueLiteral\n- `grammar/patterns/pipeline.peggy` - Add WhilePipelineStage\n- `grammar/directives/while.peggy` (new file) - Add WhileDirective\n\n## Implementation\n\n### DoneLiteral and ContinueLiteral (in literals.peggy)\n\nFollow exact pattern from `retry`, `skip`, `allow`, `denied` (lines 50-74):\n\n```peggy\nDoneLiteral \"done literal\"\n  = \"done\" _ value:WhenRHSValue {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'done',\n        values: { value: [value] },\n        raw: { value: text() },\n        meta: { hasValue: true }\n      };\n    }\n  / \"done\" {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'done',\n        values: { value: [] },\n        raw: { value: 'done' },\n        meta: { hasValue: false }\n      };\n    }\n\nContinueLiteral \"continue literal\"\n  = \"continue\" _ value:WhenRHSValue {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'continue',\n        values: { value: [value] },\n        raw: { value: text() },\n        meta: { hasValue: true }\n      };\n    }\n  / \"continue\" {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'continue',\n        values: { value: [] },\n        raw: { value: 'continue' },\n        meta: { hasValue: false }\n      };\n    }\n```\n\n### WhilePipelineStage\n\n```peggy\nWhilePipelineStage \"while pipeline stage\"\n  = \"while\" _ \"(\" _ cap:Integer _ (\",\" _ rate:Duration)? _ \")\" _ processor:ExeReference {\n      return {\n        type: 'WhileStage',\n        values: {\n          cap: cap,\n          rate: rate || null,\n          processor: processor\n        },\n        meta: {\n          hasCap: true,\n          hasRate: !!rate\n        }\n      };\n    }\n```\n\n## Error Recovery\n\n- Missing cap: \"while() requires a maximum iteration count\"\n- Invalid processor: \"while expects an executable reference like @processor\"\n\n## Context Object\n\nWhile loops provide `@ctx.while.*`:\n- `@ctx.while.iteration` - current iteration number (0-indexed)\n- `@ctx.while.cap` - maximum iterations allowed\n\n## Testing\n\n```bash\nnpm run ast -- 'var @x = @y | while(10) @process'\nnpm run ast -- 'exe @p(s) = when [@s.done =\u003e done @s.result]'\n```\n\n## Validation\n\n- [ ] DoneLiteral parses correctly\n- [ ] ContinueLiteral parses correctly  \n- [ ] WhilePipelineStage parses correctly\n- [ ] Error messages are helpful","notes":"Added while directive grammar, while pipeline stage, and done/continue literals. Directive list now includes /while; pipeline stage supports while(\u003ccap\u003e[,\u003crate\u003e]) @processor with errors; done/continue literals parse via Literal valueType. Grammar build passes.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:15:24.186936-08:00","updated_at":"2025-12-10T00:00:33.554781-08:00","closed_at":"2025-12-10T00:00:33.554783-08:00","dependencies":[{"issue_id":"mlld-1sh","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.094575-08:00","created_by":"daemon"}]}
{"id":"mlld-1x2","title":"Interpreter: Create cwd-resolver utility for path validation","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task creates a utility function to resolve and validate working directory paths before command execution.\n\n## Prerequisites\n- Grammar tasks complete (workingDir is in AST)\n- Type tasks complete (workingDir types defined)\n\n## Task\nCreate `interpreter/utils/cwd-resolver.ts` to handle path interpolation and validation.\n\n## Requirements\n\nThe resolver must:\n1. Interpolate variables in the path (`@mypath`, `/home/@user/dev`)\n2. Validate path is rooted (starts with `/`)\n3. Check directory exists\n4. Check path is actually a directory (not a file)\n5. Return absolute path or throw clear errors\n\n## Implementation\n\nCreate new file: `interpreter/utils/cwd-resolver.ts`\n\n```typescript\nimport * as fs from 'fs';\nimport type { ContentNodeArray } from '@core/types';\nimport type { Environment } from '../env/Environment';\nimport { interpolate, InterpolationContext } from '../core/interpreter';\nimport { MlldCommandExecutionError } from '@core/errors';\n\nexport async function resolveCwd(\n  workingDirNodes: ContentNodeArray,\n  env: Environment,\n  sourceLocation?: any\n): Promise\u003cstring\u003e {\n  // Step 1: Interpolate variables\n  const interpolatedPath = await interpolate(\n    workingDirNodes,\n    env,\n    undefined,\n    { context: InterpolationContext.FilePath }\n  );\n  \n  // Step 2: Validate rooted (absolute) path\n  if (!interpolatedPath.startsWith('/')) {\n    throw new MlldCommandExecutionError(\n      `Working directory must be an absolute path (start with /): ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  // Step 3: Check directory exists\n  if (!fs.existsSync(interpolatedPath)) {\n    throw new MlldCommandExecutionError(\n      `Working directory does not exist: ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  // Step 4: Check is directory\n  const stats = fs.statSync(interpolatedPath);\n  if (!stats.isDirectory()) {\n    throw new MlldCommandExecutionError(\n      `Working directory path is not a directory: ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  return interpolatedPath;\n}\n```\n\n## Error Messages\n\nProvide clear errors for common issues:\n- Undefined variable: \"Cannot resolve working directory: variable @username is not defined\"\n- Not rooted: \"Working directory must be an absolute path (start with /): ./relative\"\n- Doesn't exist: \"Working directory does not exist: /nonexistent/path\"\n- Not a directory: \"Working directory path is not a directory: /etc/hosts\"\n\n## Testing\n\nCreate unit tests in `interpreter/utils/cwd-resolver.test.ts`:\n```typescript\ndescribe('resolveCwd', () =\u003e {\n  it('should resolve absolute path', async () =\u003e {\n    // Test with /tmp\n  });\n  \n  it('should interpolate variables', async () =\u003e {\n    // Test with @mypath variable\n  });\n  \n  it('should error on non-rooted path', async () =\u003e {\n    // Test ./relative fails\n  });\n  \n  it('should error on non-existent path', async () =\u003e {\n    // Test /does/not/exist fails\n  });\n  \n  it('should error on file path', async () =\u003e {\n    // Test /etc/hosts fails (is file not dir)\n  });\n});\n```","notes":"Validation rules: absolute Unix paths only (/ ok); no Windows or '~'; reuse existing path error pattern on missing/non-dir; supports variable interpolation before validation.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:30.564083-08:00","updated_at":"2025-12-08T20:24:26.808179-08:00","closed_at":"2025-12-08T20:24:26.808179-08:00"}
{"id":"mlld-1zd","title":"Analyzer: mode-aware parsing and cache keys","description":"**Summary:**\nEnsure `analyzeModule` respects file extension mode and caches correctly.\n\n**Changes required:**\n\n1. **Mode inference**:\n   - `analyzeModule(filepath)` should infer mode from extension\n   - Add optional `mode` parameter to override\n\n2. **Parser call**:\n   - Pass inferred/explicit mode to parser\n   - Analyzer should parse `.mld` in strict mode, `.mld.md` in markdown mode\n\n3. **Cache keys**:\n   - Include mode in analyzer cache key (if analyzer has its own cache)\n   - Or ensure it uses the shared AST cache which already includes mode (per mlld-ah5)\n\n4. **Analysis results**:\n   - No change to ModuleAnalysis structure needed\n   - Mode affects parsing only, not analysis output\n\n**Testing:**\n- Analyze `.mld` file with bare directives - succeeds\n- Analyze `.mld` file with text content - reports parse error\n- Analyze `.mld.md` file with prose - succeeds","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T20:56:43.129243-08:00","updated_at":"2025-12-08T20:56:43.129243-08:00","dependencies":[{"issue_id":"mlld-1zd","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.407032-08:00","created_by":"daemon"},{"issue_id":"mlld-1zd","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.213788-08:00","created_by":"daemon"}]}
{"id":"mlld-3bl","title":"Grammar: when-expressions fail with 3+ conditions (comparison + 2 method calls)","description":"Detailed investigation of grammar parsing bug where when-expressions with specific condition combinations fail to parse","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-06T12:16:03.302262-08:00","updated_at":"2025-12-06T18:47:29.68001-08:00","closed_at":"2025-12-06T18:47:29.68001-08:00"}
{"id":"mlld-3gm","title":"Grammar: template path should support variable interpolation","description":"**Reported by:** partydev during SDK dogfooding\n\n**Current behavior:**\n`template \"../agents/@agent.att\"` treats the path as a literal string - @agent is NOT interpolated.\n\n**Expected behavior:**\nVariables in the template path should be interpolated, same as in backticks or angle brackets.\n\n**Current workarounds:**\n1. Use a variable for the full path:\n```mlld\n/var @templatePath = \\`../agents/@agent.att\\`\n/exe @buildPrompt(message) = template @templatePath\n```\n\n2. Use angle brackets + inline template:\n```mlld\n/var @tpl = \u003c../agents/@agent.att\u003e\n/exe @buildPrompt(message) = ::@tpl::\n```\n\n**Root cause:**\n`QuotedStringPath` in `grammar/patterns/path-expression.peggy` uses `$([^\"]*)` which captures content as-is without parsing for variable references.\n\n**Fix needed:**\nUpdate `QuotedStringPath` to parse variable references similar to how `AlligatorPath` does, or create a new `InterpolatedQuotedPath` pattern for template paths.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-09T08:38:03.216807-08:00","updated_at":"2025-12-09T08:51:14.335259-08:00","closed_at":"2025-12-09T08:51:14.335259-08:00"}
{"id":"mlld-3jk","title":"MJS bundle: Dynamic require of fs error in Node 24 ESM projects","description":"**Reported by:** partydev during SDK dogfooding\n\n**Environment:**\n- Node 24\n- ESM project (type: module in package.json)\n- Using `import { execute } from 'mlld'`\n\n**Error:**\n`Dynamic require of fs is not supported` when importing from the MJS bundle.\n\n**Workaround:**\nRemove `type: module` from package.json and let tsx handle ESM imports, or use createRequire with the CJS bundle.\n\n**Root cause (suspected):**\nThe MJS bundle is pulling in a CJS-only dependency that uses `require('fs')` or similar. Our tsup build generates both .mjs and .cjs outputs but the MJS bundle may not be fully tree-shaken or may include CJS-style imports.\n\n**To investigate:**\n1. Check tsup build config for ESM externals\n2. Look for dynamic requires in dependencies\n3. Test with Node 24 ESM project","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-09T04:53:12.510232-08:00","updated_at":"2025-12-09T04:53:12.510232-08:00"}
{"id":"mlld-3ma","title":"Migration: lint warning for prose in .mld files","description":"**Summary:**\nHelp users migrate by warning when `.mld` files contain prose that will error in strict mode.\n\n**Changes required:**\n\n1. **Lint rule / diagnostic**:\n   - Scan `.mld` files for lines that would be text content\n   - Emit warning: \"This file contains prose on line X. Rename to .mld.md or remove text.\"\n\n2. **CLI flag**:\n   - `mlld lint --check-mode` or similar\n   - Could be part of `mlld check` if that exists\n\n3. **Error message enhancement**:\n   - When strict mode parser errors on text, include helpful message:\n   - \"Text content not allowed in .mld files. Either:\\n  1. Rename to .mld.md to embed prose\\n  2. Remove or comment out text lines\"\n\n4. **Migration script** (optional):\n   - `mlld migrate --to-strict` - rename files and report issues\n   - Low priority, users can do this manually\n\n**Testing:**\n- Lint `.mld` file with prose - warns with line numbers\n- Lint clean `.mld` file - no warnings\n- Error message on strict parse failure includes migration hint","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T20:57:14.29758-08:00","updated_at":"2025-12-08T20:57:14.29758-08:00","dependencies":[{"issue_id":"mlld-3ma","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.522074-08:00","created_by":"daemon"},{"issue_id":"mlld-3ma","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T20:59:32.324654-08:00","created_by":"daemon"}]}
{"id":"mlld-4cs","title":"Short urls for every beads task","description":"`/bd/proj-id` should jump straight to a project's card.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T15:15:37.642987-08:00","updated_at":"2025-12-07T19:33:09.48891-08:00","closed_at":"2025-12-07T19:33:09.48891-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-4cw","title":"Docs: restructure llms.txt into modules","description":"Restructure llms.txt into modular sections using existing XML structure: a concise getting","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:29:52.689432-08:00","updated_at":"2025-12-09T08:29:52.689432-08:00"}
{"id":"mlld-4xm","title":"When expressions returning numbers produce empty output","description":"## Summary\n\nUser partydev.3 reported that `/exe` with `when first` returning numeric values produces empty output instead of the number.\n\n## Root Cause\n\nGrammar was inconsistent about primitive handling:\n- Some patterns returned raw primitives (`42`)\n- Some returned Literal AST nodes (`{type: 'Literal', value: 42}`)\n- Interpreter had gaps in Literal node handling\n\nThis violated the fundamental principle: **Grammar should always return AST nodes, interpreter extracts values.**\n\n## Policy Decision (Documented in DATA.md)\n\n**Primitives are NEVER StructuredValues:**\n1. Grammar returns Literal AST nodes: `{type: 'Literal', value: 42}`\n2. Interpreter extracts native values: `42`\n3. Variables wrap primitives: `PrimitiveVariable{value: 42, ctx: {...}}`\n4. StructuredValue is ONLY for dual representations (loaded content, pipeline results)\n\n**Rationale:**\n- Primitives have no dual representation (`42` is just `42`)\n- No provenance for literals in code\n- Variables already provide metadata layer\n- Performance - no wasteful wrapping\n\n## Fixes Applied\n\n1. **Grammar (`var-rhs.peggy`)**: `PrimitiveValue` now wraps all primitives in Literal nodes\n2. **When evaluator (`when-expression.ts`)**: `normalizeActionValue()` extracts values from Literal nodes\n3. **Data evaluator (`PrimitiveEvaluator.ts`)**: Added Literal node handling\n4. **Object processing (`var.ts`)**: `evaluateArrayItem()` extracts values from Literal nodes\n\n## Testing\n\n- ‚úÖ All 2367 tests pass\n- ‚úÖ Numeric returns in when expressions work\n- ‚úÖ Object serialization preserves types: `{\"count\":42}` not `{\"count\":\"42\"}`\n- ‚úÖ Array methods with numeric args work: `@arr.includes(3)`\n\n## Follow-up\n\nCreated mlld-62p for full codebase audit to ensure all primitive handling is consistent.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T11:59:53.332409-08:00","updated_at":"2025-12-09T12:31:20.38644-08:00","closed_at":"2025-12-09T12:31:20.38644-08:00"}
{"id":"mlld-4zy","title":"Formatter: mode-aware slash prefix handling","description":"**Summary:**\nFormatter should emit appropriate slash prefix based on mode.\n\n**Changes required:**\n\n1. **Mode detection**:\n   - Formatter receives mode from file extension or explicit option\n   - Track mode throughout formatting pass\n\n2. **Directive formatting**:\n   - Markdown mode: always emit `/` prefix on directives\n   - Strict mode: configurable behavior:\n     - Option A: emit bare directives (no `/`)\n     - Option B: preserve input style (if had `/`, keep it)\n     - Option C: always emit `/` for compatibility\n   - Recommend Option A as default, Option B for `--preserve-style`\n\n3. **Blank line handling**:\n   - Strict mode: blank lines are formatting whitespace, preserve for readability\n   - Markdown mode: blank lines may be content, preserve carefully\n\n4. **Config option**:\n   - `strictModeSlash: 'omit' | 'preserve' | 'include'`\n   - Or simpler: `--bare-directives` flag for strict mode\n\n**Testing:**\n- Format `.mld` file - outputs bare directives (if Option A)\n- Format `.mld.md` file - outputs `/` prefixed directives\n- Format `.mld` with mixed slash usage - normalizes per config","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T20:57:03.568773-08:00","updated_at":"2025-12-08T20:57:03.568773-08:00","dependencies":[{"issue_id":"mlld-4zy","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.486165-08:00","created_by":"daemon"},{"issue_id":"mlld-4zy","depends_on_id":"mlld-gj7","type":"blocks","created_at":"2025-12-08T20:59:32.287836-08:00","created_by":"daemon"}]}
{"id":"mlld-5ik","title":"Phase 4: Integration Tests and Polish (Optional)","description":"## Summary\n\nExtended test suite and polish after core features work. This phase is optional but recommended for production readiness.\n\n## Prereq\n\nPhase 3 core tests (mlld-jw7) must pass first.\n\n## Comprehensive Test Cases\n\n### Test A: Exe Block with Nested For and When\n\n```mlld\n/exe @summarize(projects) = [\n  let @out = []\n  let @errors = []\n\n  for @project in @projects =\u003e [\n    let @rows = []\n\n    for @task in @project.tasks =\u003e [\n      when [\n        @task.state == \"done\" =\u003e let @rows += { id: @task.id, pts: @task.points }\n        @task.state == \"blocked\" =\u003e let @errors += { id: @task.id, reason: @task.blocker }\n      ]\n    ]\n\n    let @out += {\n      name: @project.name,\n      total: @rows.length,\n      tasks: @rows\n    }\n  ]\n\n  show \"Projects: @out.length, errors: @errors.length\"\n  =\u003e { results: @out, errors: @errors }\n]\n```\n\n### Test B: For Block with Nested Loop\n\n```mlld\n/for @user in @users [\n  let @active = []\n\n  for @msg in @user.inbox [\n    when [\n      @msg.status == \"unread\" =\u003e let @active += @msg\n    ]\n  ]\n\n  show `User @user.name: @active.length unread`\n]\n```\n\n### Test C: Simple Accumulation Pattern\n\n```mlld\n/var @results = []\n\n/for @row in @rows [\n  let @acc = { id: @row.id, tags: [] }\n\n  for @tag in @row.tags [\n    let @acc.tags += @tag\n  ]\n\n  var @results += @acc\n]\n\n/show @results | @json\n```\n\n### Test D: Strict Mode (No Slashes)\n\n```mlld\nexe @process(items) = [\n  let @results = []\n\n  for @item in @items [\n    let @results += @item.value\n    show \"Processed: @item.id\"\n  ]\n\n  =\u003e @results\n]\n\nvar @output = @process([{ id: 1, value: \"a\" }])\nshow @output\n```\n\n### Test E: Loose Mode (Top-Level Slashes Only)\n\n```mlld\n/exe @process(items) = [\n  let @results = []\n\n  for @item in @items [\n    let @results += @item.value\n    show \"Processed: @item.id\"\n  ]\n\n  =\u003e @results\n]\n\n/var @output = @process([{ id: 1, value: \"a\" }])\n/show @output\n```\n\n## Error Cases\n\n### Error F: Multiple Returns\n\n```mlld\n/exe @bad() = [\n  let @x = 1\n  =\u003e @x\n  let @y = 2\n  =\u003e @y\n]\n```\nError: \"Multiple return statements in exe block. Only one return allowed as last statement.\"\n\n### Error G: Field Access Mutation (ETOOCOMPLEX)\n\n```mlld\n/exe @bad() = [\n  let @data = []\n  let @data += { values: [] }\n  let @data[0].values += \"x\"\n]\n```\nError: \"ETOOCOMPLEX: Augmented assignment only supports simple variables.\"\n\n### Error H: Unterminated Block\n\n```mlld\n/for @item in @items [\n  let @x = 1\n  show @x\n```\nError: \"Unterminated block. Expected ']' to close block.\"\n\n## Edge Cases\n\n- [ ] Empty blocks: `[ ]` should be valid, returns undefined\n- [ ] Return without value: `=\u003e` alone should error\n- [ ] Let without value: Should error at parse time\n- [ ] Nested parallel: Verify parallel specs stack correctly\n- [ ] Error mid-block: Should preserve completed let assignments\n\n## Documentation Updates\n\n- [ ] User docs: Block syntax for exe and for\n- [ ] Grammar docs: New patterns added\n- [ ] Examples: Update with block syntax where beneficial\n- [ ] Migration guide: When to use blocks vs single actions\n\n## Validation\n\n- [ ] All integration tests pass\n- [ ] Error messages are clear and actionable\n- [ ] Documentation updated\n- [ ] No regressions in existing functionality","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T22:20:01.49389-08:00","updated_at":"2025-12-09T22:20:01.49389-08:00","dependencies":[{"issue_id":"mlld-5ik","depends_on_id":"mlld-jw7","type":"blocks","created_at":"2025-12-09T22:20:07.023716-08:00","created_by":"daemon"}]}
{"id":"mlld-5jz","title":"CLI: add --loose/--strict mode flags","description":"Expose explicit CLI flags for parser mode selection. Requirements:\\n- Add --strict flag to force strict mode.\\n- Add --loose flag (aliases: --markdown, --md, --prose) to force markdown mode.\\n- Flags override extension inference and existing --mode handling.\\n- Update help/usage text and wire through option processing to parser invocation.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T08:28:19.903908-08:00","updated_at":"2025-12-09T08:28:19.903908-08:00"}
{"id":"mlld-5n7","title":"Interpreter: thread mode through parser invocation","description":"**Summary:**\nWire the mode flag from entry points through to the parser, with extension-based defaults.\n\n**Changes required:**\n\n1. **Extension ‚Üí mode mapping** (likely in `services/PathService.ts` or new utility):\n   ```typescript\n   function getModeFromPath(filepath: string): 'strict' | 'markdown' {\n     if (filepath.endsWith('.mld.md') || filepath.endsWith('.md')) return 'markdown';\n     if (filepath.endsWith('.mld')) return 'strict';\n     return 'markdown'; // fallback for unknown\n   }\n   ```\n\n2. **Entry points to update:**\n   - `processMlld(script, options)` - add `mode` option, default `'strict'` for raw strings\n   - `interpret(script, options)` - thread mode to parser\n   - `execute(filepath, payload, options)` - derive mode from extension\n   - CLI entry point - derive mode from input file extension\n\n3. **Parser invocation** (wherever `parse()` is called):\n   ```typescript\n   const ast = parse(source, { \n     ...existingOptions,\n     mode: options.mode ?? getModeFromPath(options.filePath) \n   });\n   ```\n\n4. **Options types** (`types/` or relevant interface files):\n   - Add `mode?: 'strict' | 'markdown'` to ProcessOptions, InterpretOptions, ExecuteOptions\n\n**Testing:**\n- Unit test: `.mld` file parses in strict mode\n- Unit test: `.mld.md` file parses in markdown mode\n- Unit test: raw string defaults to strict\n- Unit test: explicit mode option overrides extension inference","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-08T19:57:44.878318-08:00","updated_at":"2025-12-08T19:57:44.878318-08:00","dependencies":[{"issue_id":"mlld-5n7","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.431674-08:00","created_by":"daemon"},{"issue_id":"mlld-5n7","depends_on_id":"mlld-gj7","type":"blocks","created_at":"2025-12-08T19:59:14.754308-08:00","created_by":"daemon"}]}
{"id":"mlld-5p8","title":"Grammar: extend VariableBoundary escape to all interpolation contexts","description":"**Reported by:** partydev during SDK dogfooding\n\n**Problem:**\nWhen parsing `@agent.att` in paths/strings, the grammar greedily consumes `.att` as field access. Users need a way to say \"stop here, `.att` is literal text (a file extension).\"\n\n**Example:**\n```mlld\n/exe @buildPrompt(msg) = template \"../agents/@agent.att\"\n\u003e\u003e Currently: @agent with field access .att\n\u003e\u003e Wanted: @agent variable + literal .att extension\n```\n\n**Current state:**\n- `VariableBoundary` mechanism exists in `unified-variables.peggy`\n- Syntax: `@var\\` terminates variable, `@var\\\\` produces literal backslash\n- BUT: only used in `UnifiedTemplateVariableReference` (template contexts)\n- AND: boundary check happens AFTER greedy field consumption (wrong order)\n\n**Fix needed:**\n1. Reorder grammar so boundary check happens BEFORE field access consumption\n2. Apply `VariableBoundary` pattern to ALL variable interpolation contexts:\n   - Double-quoted strings\n   - Path contexts (angle brackets)\n   - Template paths in /exe\n   - Any other interpolation context\n\n**User syntax after fix:**\n```mlld\n/exe @buildPrompt(msg) = template \"../agents/@agent\\.att\"\n\u003e\u003e @agent\\ = terminate variable here\n\u003e\u003e .att = literal file extension\n```\n\n**Files to modify:**\n- grammar/base/unified-variables.peggy - fix ordering, ensure boundary works\n- Verify all variable-consuming patterns use the unified pattern\n\n**Future enhancement:**\nConsider adding `@{var}` braced syntax as a more intuitive alternative (separate issue).","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T08:00:13.723859-08:00","updated_at":"2025-12-09T08:06:28.583781-08:00","closed_at":"2025-12-09T08:06:28.583781-08:00"}
{"id":"mlld-5qm","title":"Make @mlld/stream-claude-agent-sdk module work with single-quoted templates","description":"The published module @mlld/stream-claude-agent-sdk uses double-quoted templates which get interpolated as mlld variables during import. Need to republish with single-quoted templates and test.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T20:50:05.396861-08:00","updated_at":"2025-12-08T02:53:01.835237-08:00","closed_at":"2025-12-08T02:53:01.835237-08:00"}
{"id":"mlld-5x5","title":"SDK/CLI: expose mode option and set defaults","description":"**Summary:**\nExpose `mode` option in SDK APIs and CLI, with sensible defaults.\n\n**SDK changes:**\n\n1. **processMlld(script, options)**:\n   - Add `mode?: 'strict' | 'markdown'` to options\n   - Default: `'strict'` when no `filePath` provided (raw strings)\n   - Default: infer from extension when `filePath` provided\n\n2. **interpret(script, options)**:\n   - Add `mode` option, same defaults as processMlld\n\n3. **execute(filepath, payload, options)**:\n   - Add `mode` option\n   - Default: infer from filepath extension\n   - Explicit option overrides inference\n\n4. **Type exports**:\n   - Export `MlldMode = 'strict' | 'markdown'` type\n\n**CLI changes:**\n\n1. **Flag**: `--mode \u003cstrict|markdown\u003e`\n   - Overrides extension-based inference\n   - Useful for testing or unusual file extensions\n\n2. **Extension inference**:\n   - `.mld` ‚Üí strict\n   - `.mld.md` / `.md` ‚Üí markdown\n   - stdin without `--mode` ‚Üí strict (matches SDK raw string default)\n\n3. **Help text**:\n   - Document mode flag and extension defaults\n\n**Testing:**\n- SDK: raw string without filePath uses strict\n- SDK: `.mld` file uses strict\n- SDK: `.mld.md` file uses markdown\n- SDK: explicit mode overrides extension\n- CLI: `--mode markdown` on `.mld` file uses markdown\n- CLI: stdin defaults to strict","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-08T20:56:33.43397-08:00","updated_at":"2025-12-08T20:56:33.43397-08:00","dependencies":[{"issue_id":"mlld-5x5","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.360437-08:00","created_by":"daemon"},{"issue_id":"mlld-5x5","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.172773-08:00","created_by":"daemon"}]}
{"id":"mlld-5y6","title":"Docs: clarify pipeline data shape vs parallel stage output","description":"Docs promise StructuredValue pipeline stages, but still mention parallel groups handing JSON array strings to next stage. Validate actual behavior and update docs to reflect structured pipeline inputs/outputs (including parallel aggregation semantics) once aligned with executor/state machine.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:40:56.370878-08:00","updated_at":"2025-12-08T19:40:56.370878-08:00"}
{"id":"mlld-62p","title":"Audit: Ensure universal StructuredValue compliance","description":"## Goal\n\nAudit and fix the codebase to ensure **universal StructuredValue compliance**:\n\n**All runtime values are StructuredValues** - primitives, strings, arrays, objects, loaded content.\n\n## Policy (now in DATA.md)\n\n**Universal StructuredValue flow:**\n1. **Grammar**: Returns AST Literal nodes `{type: 'Literal', value: 42}`\n2. **Interpreter**: Wraps ALL values in StructuredValue `{type: 'number', text: '42', data: 42, ctx: {...}}`\n3. **Variables**: Wrap StructuredValues (StructuredValueVariable)\n4. **Boundaries**: Use `asData()` for computation, `asText()` for display\n\n## Rationale\n\nWe tried making primitives exceptions but the system fights that. The evidence:\n- `wrapExecResult`, `ensureStructuredValue`, pipelines already wrap primitives\n- Dual representation IS useful: `.text` for templates, `.data` for comparisons, `.ctx` for guards\n- Consistency wins: one model is simpler than special cases\n- We were adding unwrapping hacks everywhere - fighting the design\n\n## Audit Strategy\n\n### Find places that DON'T use asData()/asText()\n\n**Computation boundaries that need `asData()`:**\n- ‚úÖ Comparisons (`toNumber`, `isEqual`) - FIXED\n- Array methods (`.includes()`, `.indexOf()`, `.join()`, etc.)\n- String methods (`.startsWith()`, `.substring()`, etc.)\n- Arithmetic operations\n- Boolean operations\n- Object property access\n- Array indexing\n\n**Display boundaries that need `asText()`:**\n- Template interpolation\n- Shell command arguments  \n- `/show` output\n- Log messages\n- JSON.stringify contexts\n\n### Find places trying to unwrap primitives\n\nSearch for patterns like:\n- Checking `typeof value === 'number'` without extracting first\n- Creating PrimitiveVariable instead of StructuredValueVariable for exec results\n- Avoiding wrapping in `ensureStructuredValue`\n\n### Implementation\n\nUse mlld to parallelize:\n1. Spawn haiku agents for each file category\n2. Each outputs JSON: `{file, needsAsData: [...], needsAsText: [...], wrongUnwrap: [...]}`\n3. Aggregate to `audit-results.jsonl`\n4. Generate fix plan\n5. Apply fixes (parallelized if many)\n\n## Current Status\n\n**Fixed:**\n- ‚úÖ `toNumber()` extracts `.data` from StructuredValue\n- ‚úÖ `extractValue()` in expression.ts handles StructuredValue\n- ‚úÖ Grammar returns Literal nodes consistently\n- ‚úÖ PrimitiveEvaluator extracts Literal values\n- ‚úÖ Object property evaluation handles Literal nodes\n\n**Likely still broken:**\n- ‚ùì Array/string method arg processing\n- ‚ùì Arithmetic expression evaluation\n- ‚ùì Direct property access on StructuredValues\n\n## Next Steps\n\n1. Run the audit script to find all missing `asData()`/`asText()` calls\n2. Prioritize by user impact (comparison operators were P1)\n3. Fix systematically","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T12:26:52.590565-08:00","updated_at":"2025-12-09T15:21:29.593082-08:00"}
{"id":"mlld-75e","title":"Allow escaping `@` everywhere with `@@` ","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T08:30:56.452213-08:00","updated_at":"2025-12-09T08:51:20.348654-08:00","closed_at":"2025-12-09T08:51:20.348654-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-7e7","title":"Executors: Add cwd support to CommandExecutionOptions and executors","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task adds `cwd` support to the command executor options and modifies all executors to use it.\n\n## Prerequisites\n- mlld-e0b in progress or complete (run evaluator passing cwd)\n\n## Task\n1. Add `cwd?: string` to `CommandExecutionOptions` interface\n2. Modify all executors to use `options.cwd` when provided\n\n## Implementation\n\n### Step 1: Update CommandExecutionOptions interface\n\nLocation: `interpreter/env/executors/BaseCommandExecutor.ts` (or wherever CommandExecutionOptions is defined)\n\nFind the interface (likely around line 10-20):\n```typescript\nexport interface CommandExecutionOptions {\n  env?: Record\u003cstring, string\u003e;\n  timeout?: number;\n  captureOutput?: boolean;\n  // ... other options\n  cwd?: string;  // NEW: Optional working directory\n}\n```\n\n### Step 2: Modify ShellCommandExecutor\n\nLocation: `interpreter/env/executors/ShellCommandExecutor.ts`\n\nFind where `spawn` is called (likely around line 340):\n\n**Before:**\n```typescript\nconst child = spawn(safeCommand, {\n  cwd: this.workingDirectory,\n  env,\n  shell: true,\n  // ...\n});\n```\n\n**After:**\n```typescript\nconst child = spawn(safeCommand, {\n  cwd: options?.cwd || this.workingDirectory,  // Use options.cwd if provided\n  env,\n  shell: true,\n  // ...\n});\n```\n\nAlso find the `execAsync` call (around line 297) and update similarly:\n```typescript\nconst { stdout, stderr } = await execAsync(finalCommand, {\n  encoding: 'utf8',\n  cwd: options?.cwd || this.workingDirectory,  // Use options.cwd if provided\n  env: { ...process.env, ...(options?.env || {}) },\n  maxBuffer: 10 * 1024 * 1024\n});\n```\n\n### Step 3: Modify BashExecutor\n\nLocation: `interpreter/env/executors/BashExecutor.ts`\n\nApply the same pattern - find spawn calls and update cwd:\n```typescript\ncwd: options?.cwd || this.workingDirectory\n```\n\n### Step 4: Modify other executors\n\nCheck and update these if they execute processes:\n- `NodeExecutor.ts` - for `/run js {}`\n- `PythonExecutor.ts` - for `/run python {}`\n- `JavaScriptExecutor.ts` - if separate from NodeExecutor\n\nFor each, find where child processes are spawned and apply:\n```typescript\ncwd: options?.cwd || this.workingDirectory\n```\n\n## Pattern\n\nThe pattern is consistent across all executors:\n1. Check if `options?.cwd` is provided\n2. If yes, use it\n3. If no, fall back to `this.workingDirectory` (existing behavior)\n\n## Testing\n\nAfter implementation, test that cwd is actually used:\n\n```bash\necho '/run cmd:/tmp {pwd}' | ./dist/cli.cjs\n# Should output: /tmp\n\necho '/run sh:/home {pwd}' | ./dist/cli.cjs  \n# Should output: /home (if exists)\n```\n\nCheck that commands without cwd still work:\n```bash\necho '/run cmd {pwd}' | ./dist/cli.cjs\n# Should output: current working directory\n```","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:42.69404-08:00","updated_at":"2025-12-08T20:24:57.116324-08:00","closed_at":"2025-12-08T20:24:57.116324-08:00"}
{"id":"mlld-7fa","title":"Tests: add balanced loose/strict coverage post-rollout","description":"Follow-up after fixing current failures: ensure test suites include both strict (.mld) and markdown (.mld.md/raw) coverage, add explicit mode flags where appropriate, and document the defaults. Blocked by mlld-7ng.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T05:16:39.824334-08:00","updated_at":"2025-12-09T05:16:39.824334-08:00","dependencies":[{"issue_id":"mlld-7fa","depends_on_id":"mlld-7ng","type":"blocks","created_at":"2025-12-09T05:16:54.846728-08:00","created_by":"adam"}]}
{"id":"mlld-7j7","title":"Exe RHS pipeline syntax broken: value | cmd and cmd | cmd patterns fail","description":"## Summary\n\nMultiple  RHS pipeline patterns are failing to parse or execute correctly in strict mode.\n\n## Expected Working Patterns\n\nAll of these should work:\n\n```mlld\n/exe @func(value) = @value | cmd { claude -p --model haiku }\n/exe @func(value) = cmd { @value | claude -p --model haiku }\n/exe @func(value) = @other(value) | cmd { claude -p --model haiku }\n/exe @func(value) = js { return \"hi\" } | cmd { claude -p --model haiku }\n/exe @func(value) = cmd { echo \"hello\" } | cmd { claude -p --model haiku }\n/exe @func(value) = @value | cmd { claude -p } | cmd { claude -p \"wdyt?\" }\n```\n\nBonus (if we can handle escaping):\n```mlld\n/exe @func(value) = cmd { claude -p \"@prompt\" --model haiku }\n```\n\n## Current Behavior\n\n- `@value | cmd {...}` fails with \"Invalid /exe syntax\" parse error\n- `run @value | cmd {...}` also fails\n- User changed to `cmd { @value | claude... }` which should work but returns null/empty\n\n## Why This Matters\n\n**Piping is critical for large/complex content:**\n- Escaping multi-line prompts with special chars is fragile\n- Stdin piping is robust and standard Unix pattern\n- Current audit script (audit-primitive-handling.mld) blocked by this\n\n## Context\n\nWe use this pattern extensively:\n- `scripts/mlld/audit-pathcontext-flow.mld` has `/exe @claude(prompt) = run @prompt | {claude -p}`\n- But it's unclear if this actually works or silently fails\n- We may have tests but they might be too simple (not testing large complex file content)\n\n## Investigation Needed\n\n1. Check grammar for exe RHS pipeline syntax - what's actually supported?\n2. Test with real Claude calls and large file content\n3. Verify existing tests actually cover this (not just toy examples)\n4. Consider deprecating `run` in RHS position (accept but mark deprecated in grammar/CHANGELOG)\n\n## Workaround\n\nUnknown - need to investigate what actually works.\n\n## Impact\n\nBlocks parallel audit script and potentially other mlld-scripting-mlld patterns.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-09T14:20:38.374747-08:00","updated_at":"2025-12-09T14:20:38.374747-08:00"}
{"id":"mlld-7ng","title":"Tests: fix failing suites for strict-mode rollout","description":"Failing test files after strict mode changes:\n- cli/commands/mcp.test.ts\n- interpreter/index.structured.test.ts\n- interpreter/interpreter.fixture.test.ts\n- interpreter/output-formats.test.ts\n- interpreter/output-management.test.ts\n- tests/heredoc.e2e.test.ts\n- tests/integration/imports/basic-patterns.test.ts\n- tests/integration/node-shadow-cleanup.test.ts\n- tests/pipeline/parallel-runtime.test.ts\n\n## interpreter.fixture.test.ts tests/cases\n\n\n  - effects: append-jsonl-basic; append-pipeline-basic; exe-for-effects; exe-for-nested-\n    effects; exe-for-pipeline-retry-effects; exe-when-basic; for-basic-effects; nested-\n    contexts; output-directive-effects; pipeline-function-effects; pipeline-inline-log;\n    pipeline-inline-output-file; pipeline-inline-output-stderr; pipeline-inline-output-\n    stdout; pipeline-inline-retry-replay; pipeline-inline-show; pipeline-retry-effects;\n    var-for-immediate-effects\n  - exe: command-ref-array-preserve\n  - alligator: alligator-glob-concat; ast-name-list-all/class/fn/glob/var; ast-selection;\n    ast-selector-variable; ast-type-filter-all/class/fn/var; ast-wildcard-contains/\n    prefix/single/suffix; edge-cases-boundary; file-references-legitimate; function-args-\n    operators; glob-as-transform; json-autoparse; keep-in-loops; keep-metadata-access;\n    metadata-file/json/url; pipe-transformations; pipeline-contexts; section-extraction;\n    section-list-all/glob/h2/h3; security-labels-files; unified-json-file; unified-text-\n    file; url-markdown-conversion; xml-html-literal\n  - array-operations: slice-basic; slice-negative; slice-variable-indices\n  - augmented-assignment\n  - bash: heredoc-prevents-e2big; large-variable-heredoc\n  - bracket-notation-comprehensive\n  - builtin: typeof-function; builtin-methods-array/string/variables; builtin-type-\n    checking\n  - command-substitution-tty\n  - comments/inline\n  - exe: command-ref-arg-interpolation-basic; function-call-syntax; param-shadowing\n  - expressions-operators; expressions-operators-parsing\n  - file-reference-interpolation\n  - for: directive-actions; exe-template-params; nested-basic/function-calls/output/\n    triple; pipeline-multiple/single; run-command; template-interpolation; when-with-none\n  - frontmatter: alias; basic\n  - html-conversion: basic-article; complex-elements; edge-cases; heading-hierarchy;\n    metadata-extraction; readability-extraction; url-section-extraction\n  - input: env-vars-allowed; input-new-syntax\n  - issue-fixes/issue-459-run-json-field-access\n  - json-backslash-n-preserved\n  - keep-structured\n  - literals-in-function-args\n  - load-content: js-edge-cases; js-unwrap; node-unwrap\n  - method-chain-after-array-access\n  - module-system: command-ref-imports; directive-guard; security-exe-roundtrip;\n    template-interpolation\n  - native-object: github-pattern; node-return; property-access\n  - object-property-access in exec args/functions\n  - object-spread\n  - optional-slash-comprehensive\n  - pipeline: chained-multiple; exe-command-ref-pipeline; exe-reusable-pipes; foreach-\n    structured-value; inline-log-suppressed; inline-output-file; inline-show-basic/retry-\n    replay; interpolation-contexts; native-json-stages; parallel-syntax-parity; pipeline-\n    alias-p-negative-index; pipeline-array-indexing; pipeline-context-basic/edge-cases/\n    preservation; pipeline-multi-stage-retry; pipeline-ordering-integrity; pipes-with-\n    arguments; retry-attempt-tracking; retry-basic/best-of-n/complex-logic/conditional-\n    fallback/hint-function-value/hint-interpolated/hint-object/hint-reception/when-\n    expression/with-none; show-invocation-inline-retry; show-vs-with-basic/retry;\n    vertical-stacked-pipes; when-actions-pipes; when-all-any-pipes; with-clause-pipes\n  - policy: import-policy; union; wants-basic\n  - reserved: input-variable; now-variable; now-variable-lowercase; projectpath-variable\n  - resolver-contexts\n  - run: command-escape-newline-in-quoted\n  - security: guard-after-allow/deny-handled/transform/transform-chain; guard-allow;\n    guard-always; guard-before-after-compose; guard-deny-handled; guard-multiple-\n    handlers; guard-retry; expression-tracking; pipeline-taint; after-guard-retry\n    variants (nonpipeline hints/success/transform; pipeline effects/success); before-\n    guard-retry-success; guard-context-inside-guards; guard-overrides-disable-all/except/\n    only; guard-structured-equality\n  - shell-interpolation: array-from-js-function; array-of-mixed-types/objects-command/\n    objects-stdin; array-with-nulls; booleans-in-objects; deeply-nested-structures;\n    empty-array-command; exec-stdin-complex-array/object; exec-with-complex-param;\n    foreach-complex-elements; jq-with-complex-stdin; json-transformer-output; loader-to-\n    command; mixed-complex-array; mixed-wrapped-simple; multiple-complex-params; nested-\n    arrays-command/stdin; numbers-in-nested-array; object-array-in-template; object-\n    in-command; object-nested-properties; object-via-stdin; object-with-array-property;\n    pipe-sugar-complex-array; pipeline-complex-data; simple-array-expansion/stdin;\n    single-quoted-complex/+apostrophe; special-chars-in-object; structured-value-wrapped;\n    three-level-nesting; undefined-variable-interpolation; user-full-scenario-435; user-\n    scenario-435\n  - template-inline: for-backtick; for-double-colon; inline-show-double-bracket; inline-\n    show-triple; triple-alligator-literal\n  - template-syntax-migration\n  - transformers: chain; csv-basic; json-basic/fromlist/llm-extract-array/generic-fence/\n    inline-prose/invalid/nested/no-json/with-comments; json-llm-extract; json-loose-\n    syntax; json-strict-basic; md-basic; xml-basic\n  - variable-methods: direct-rhs-indexing; method-chaining\n  - when: when-preserve-type-through-pipeline; expression-none-with-vars\n  - with: combined; needs-node; pipeline-basic/input/termination\n  - integration: exe-invocation-module; exe-sh-module; modules/auto-export/explicit-\n    export/metadata; pipeline/ctx-hint-flow-basic/ctx-hint-multistage-mixed-hints/ctx-\n    hint-object/ctx-hint-template-code; executable-transform; formatted-input; hint-\n    command-ref-interpolation; triple-colon-exec\n  - regression: alligator-for-expressions; angle-bracket-literals\n  - slash/exe: code-brackets; command-substitution-interactive/sh; double-colon-\n    content; exe-node-console-log-capture; exe-node-gray-matter-access; exe-node-mlld-\n    dependencies; exe-node-shadow-env-always-created; exe-parameterized-command; js-\n    shadow-env-test; nested-executable-field-access/-var; node-shadow-env; node-\n    undefined-params; optional-slash-run; param-at-syntax; param-interpolation; run-\n    template-exec; shadow-env-undefined-params; shadow-environment/+simple\n  - slash/for: exe-for-expression/nested; for-basic; var-for-function-composition\n  - slash/import: alias; explicit-export-success/wildcard; import-triple-colon-template;\n    imported-array-behavior; mixed; namespace-json/nested/shorthand/special-chars; stdin-\n    json/live/shorthand/text/deprecated; type-static/type-static-inferred; url\n  - slash/output: alligator-content; blank-line-normalization; command; document;\n    file; literal; quoted-path; resolver; security-imported-exec; template-invocation;\n    variable; when-action\n  - slash/path: url; variable-assignment\n  - slash/run: bash-env-vars/multiline/parameters/bash/bash-array-at-syntax; code-with-\n    variables; command-bases-npm-run/ operators/special-patterns; file-content-escaping;\n    no-reinterpret; pipe-operator; quoted-special-chars; run-cmd-syntax-consistency; run-\n    command-bracket-nesting; run-node-console-log-no-capture; shell-escaping; stdin-\n    support\n  - slash/show: all-template-types; alligator-section-as-substring; backtick-template;\n    backtick-with-colon\n  - slash/var: data-array-ast-fix/data-array-path-disambiguation/data-array-valid-\n    patterns/data-object-literals-in-arrays/data-primitive-values; exe-invocation-direct-\n    data/direct-text; foreach-bash-env/foreach-text-template; now-basic-compat; text-\n    assignment-run-slash; text-url; text-variable-copy\n  - slash/when: add-variable-in-action; all-block-action; all-individual-actions; any-\n    block-action; bare-block-action; bare-individual-actions; block-all; exe-conditions;\n    exe-invocation-add/run/tail; exe-when-all-matches; exe-when-expressions/+operators;\n    exe-wildcard-default; first-individual-actions; implicit-actions; let-local-\n    var; negation/+bare-when/+block; none-vs-wildcard; operators-chained; operators-\n    comparison; optional-slash-combined/output/run/show; simple-none; truthiness-edge-\n    cases; var-complex-types; var-function-calls; when-literal-condition; when-negation-\n    switch; when-switch; wildcard-always-true\n  - warnings: bare-variable-reference; directive-in-text-line; template-syntax-in-text\n\nUpdate fixtures/expectations as needed, prioritizing non-strict-text errors first.","notes":"Plan for strict-mode test migration:\n- Default most feature/integration fixtures to strict (.mld, optional slash), unless they assert prose/blank-line semantics.\n- Keep markdown (.mld.md) only where prose behavior matters (content/blank lines/formatter/doc-style output).\n- Duplicate or parametrize only when mode changes behavior: prose handling, bare directives vs text, formatter/prose outputs, LSP/token sensitivity.\n- Use explicit mode in raw-string tests; SDK/CLI defaults stay strict unless prose is expected.\n- Keep LOOSE_TESTMODE=1 as default for stability; add targeted strict runs/subsets to catch regressions.\n- Migration order: 1) convert generic fixtures to strict; 2) add strict variants only for prose-sensitive cases; 3) wire a small strict subset run; 4) align docs/examples mode with intent.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T05:16:23.953965-08:00","updated_at":"2025-12-09T08:19:37.645687-08:00"}
{"id":"mlld-8d6","title":"Phase 1.4: Types - Define AST node types for blocks and while","description":"## Summary\n\nAdd TypeScript type definitions for the new AST nodes introduced by the grammar changes.\n\n## ‚ö†Ô∏è CRITICAL: Types Must Match Grammar Output\n\nThe type definitions below are **starting points**. After grammar is implemented:\n\n1. Run `npm run ast -- '\u003csyntax\u003e'` on each construct\n2. Compare actual grammar output to type definitions\n3. Adjust types to match grammar output exactly\n4. Pay special attention to:\n   - `values` vs direct properties\n   - `with`/pipeline metadata flow\n   - Array wrapping conventions\n\n**DO NOT assume these types are correct** - verify against actual grammar output!\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) to understand existing type hierarchy.\n\n## Files to Modify\n\n- `core/types/index.ts` - Add ExeBlockNode\n- `core/types/for.ts` - Extend ForDirective with actionType\n- `core/types/while.ts` (new) - WhilePipelineStage, WhileDirective types\n- `core/types/control.ts` (new or existing) - DoneLiteral, ContinueLiteral types\n\n## Type Definitions (Starting Points)\n\n### ExeBlockNode\n\n```typescript\nexport interface ExeBlockNode extends BaseMlldNode {\n  type: 'ExeBlock';\n  subtype: 'exeBlock';\n  values: {\n    statements: BaseMlldNode[];\n    return?: BaseMlldNode[];\n  };\n  raw: {\n    statements: string;\n    hasReturn: boolean;\n  };\n  meta: {\n    statementCount: number;\n    hasReturn: boolean;\n  };\n}\n\nexport function isExeBlockNode(node: BaseMlldNode): node is ExeBlockNode {\n  return node.type === 'ExeBlock';\n}\n```\n\n### ForDirective Extension\n\n```typescript\nexport interface ForDirective extends DirectiveNode {\n  kind: 'for';\n  subtype: 'for';\n  values: {\n    variable: VariableReferenceNode[];\n    source: BaseMlldNode[];\n    action: BaseMlldNode[];\n    forOptions?: {\n      parallel?: boolean;\n      cap?: number;\n      rateMs?: number;\n    };\n  };\n  meta: {\n    hasVariables: true;\n    actionType: 'single' | 'block';  // NEW FIELD\n  };\n}\n```\n\n### While Types\n\n```typescript\nexport interface WhilePipelineStage extends BaseMlldNode {\n  type: 'WhileStage';\n  values: {\n    cap: number;\n    rate: number | null;\n    processor: ExeReferenceNode;\n  };\n  meta: {\n    hasCap: true;\n    hasRate: boolean;\n  };\n}\n\nexport interface DoneLiteral extends BaseMlldNode {\n  type: 'ControlLiteral';\n  subtype: 'done';\n  values: {\n    value: BaseMlldNode[];\n  };\n  meta: {\n    hasValue: boolean;\n  };\n}\n\nexport interface ContinueLiteral extends BaseMlldNode {\n  type: 'ControlLiteral';\n  subtype: 'continue';\n  values: {\n    value: BaseMlldNode[];\n  };\n  meta: {\n    hasValue: boolean;\n  };\n}\n\nexport function isDoneLiteral(node: BaseMlldNode): node is DoneLiteral {\n  return node.type === 'ControlLiteral' \u0026\u0026 node.subtype === 'done';\n}\n\nexport function isContinueLiteral(node: BaseMlldNode): node is ContinueLiteral {\n  return node.type === 'ControlLiteral' \u0026\u0026 node.subtype === 'continue';\n}\n```\n\n## Validation\n\n- [ ] All new types extend BaseMlldNode correctly\n- [ ] Type guards are implemented\n- [ ] **Types verified against actual grammar output**\n- [ ] No circular dependencies introduced\n- [ ] Pipeline/with metadata flows correctly","notes":"Added types for exe blocks, while directive/stage, and control literals. Updated pipeline stage union, ForDirective meta actionType union, LiteralNode to allow done/continue payload arrays, and added control type guards. Build passes.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:00.189932-08:00","updated_at":"2025-12-10T00:06:55.847506-08:00","closed_at":"2025-12-10T00:06:55.847508-08:00","dependencies":[{"issue_id":"mlld-8d6","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.241807-08:00","created_by":"daemon"}]}
{"id":"mlld-8ml","title":"Pipeline state machine uses text channel instead of structured values","description":"PipelineExecutor loops state machine transitions on the .text string while stage inputs/outputs are StructuredValue. State machine START/STAGE_RESULT transitions only see text, so metadata/provenance/security are invisible to control flow and retries. Align state machine payloads with structured values (or dual channel) so pipeline retries and downstream guards use full data.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-08T19:40:41.102258-08:00","updated_at":"2025-12-08T19:40:41.102258-08:00"}
{"id":"mlld-8zi","title":"Grammar: @ in method string arguments incorrectly parsed as variable reference","description":"In when-expressions, method calls with double-quoted string arguments containing @ like `.startsWith(\"@\")` fail to parse because the @ is being interpreted as a variable reference instead of a literal character in the string.\n\nReproduction:\n```\n/exe @fn(msg) = when first [\n  @msg.body.startsWith(\"@\") =\u003e \"yes\"\n  * =\u003e \"no\"\n]\n```\n\nThis should parse successfully but fails with 'Invalid /exe syntax'.\n\nWorkaround: Use single quotes instead: `.startsWith('@')`","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T11:35:40.40568-08:00","updated_at":"2025-12-09T11:42:04.332574-08:00","closed_at":"2025-12-09T11:42:04.332574-08:00"}
{"id":"mlld-9id","title":"Phase 2.2: Interpreter - Add evaluateExeBlock() to exe.ts","description":"## Summary\n\nAdd exe block evaluation to the interpreter, reusing the exported let/augmented assignment functions from when.ts.\n\n## Key Insight\n\nExe blocks are ~80% the same as exe..when! An exe block is just a when expression without conditions (or with implicit `* =\u003e`). Massive reuse opportunity.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Return values should preserve wrappers\n\n## ‚ùå DON'T DO (Explicit Restrictions)\n\n1. **Field access mutation in +=**: `let @data[-1].field += value`\n   - Error: \"ETOOCOMPLEX: Augmented assignment only supports simple variables.\"\n   - Only support: `let @variable += value` (simple variable names)\n\n2. **Multiple return statements**: `=\u003e @x ... =\u003e @y`\n   - Error at parse time: \"Return statement must be last in exe block\"\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n- mlld-zeo (Export let functions)\n\n## Files to Modify\n\n- `interpreter/eval/exe.ts` - Add evaluateExeBlock() function\n\n## Implementation\n\nAdd after existing exe evaluation code (around line 50):\n\n```typescript\nimport { isLetAssignment, isAugmentedAssignment } from '@core/types/when';\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n\nasync function evaluateExeBlock(\n  block: ExeBlockNode,\n  env: Environment,\n  args: Record\u003cstring, unknown\u003e\n): Promise\u003cunknown\u003e {\n  // Create child environment for block scope\n  let blockEnv = env.createChild();\n\n  // Bind parameters to arguments\n  for (const [param, value] of Object.entries(args)) {\n    const importer = new VariableImporter();\n    const variable = importer.createVariableFromValue(\n      param, \n      value, \n      'exe-param', \n      undefined, \n      { env: blockEnv }\n    );\n    blockEnv.setVariable(param, variable);\n  }\n\n  // Execute statements sequentially\n  for (const stmt of block.values.statements) {\n    if (isLetAssignment(stmt)) {\n      blockEnv = await evaluateLetAssignment(stmt, blockEnv);\n    } else if (isAugmentedAssignment(stmt)) {\n      blockEnv = await evaluateAugmentedAssignment(stmt, blockEnv);\n    } else {\n      const result = await evaluate(stmt, blockEnv);\n      blockEnv = result.env || blockEnv;\n    }\n  }\n\n  // Handle return statement (required, must be last)\n  if (block.values.return) {\n    const returnResult = await evaluate(block.values.return, blockEnv);\n    return returnResult.value;\n  }\n\n  return undefined;\n}\n```\n\n## Wire into evaluateExe()\n\nUpdate around line 500 to detect and handle ExeBlock:\n\n```typescript\n// After checking for when expressions, add:\nif (content \u0026\u0026 content.type === 'ExeBlock') {\n  return await evaluateExeBlock(content, env, boundArgs);\n}\n```\n\n## Validation\n\n- [ ] Block creates child environment\n- [ ] Parameters bound correctly\n- [ ] Let assignments create scoped variables (as StructuredValue)\n- [ ] Augmented assignments work on arrays/strings/objects\n- [ ] Return statement evaluates and returns value (preserving wrapper)\n- [ ] Environment chaining preserved\n- [ ] Field access mutation throws helpful error","notes":"Interpreter should handle exeBlock subtype: values.statements array with optional return; return is last-only per grammar. Literal.value may be array for done/continue payloads (valueType done/continue). Ensure evaluation supports early return and StructuredValue handling for literal payload arrays.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T22:17:46.580094-08:00","updated_at":"2025-12-10T03:02:25.743333-08:00","dependencies":[{"issue_id":"mlld-9id","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:51.917186-08:00","created_by":"daemon"},{"issue_id":"mlld-9id","depends_on_id":"mlld-zeo","type":"blocks","created_at":"2025-12-09T22:18:52.011176-08:00","created_by":"daemon"}]}
{"id":"mlld-9o7","title":"alias @base -\u003e @root, make @root default everywhere","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T13:18:31.724492-08:00","updated_at":"2025-12-09T13:18:31.724492-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-9pl","title":"Phase 1.1: Grammar - Add ExeStatementBlock and ForActionBlock patterns","description":"## Summary\n\nAdd `[...]` block patterns to exe and for directives, reusing existing when-block infrastructure.\n\n## üîë Critical Design Decision: `[...]` Not `{...}`\n\n**Why blocks use `[...]` instead of `{...}`:**\n- `{...}` is already used for code/commands/data objects\n- `[...]` is consistent with when blocks (already use this)\n- Zero ambiguity, no lookahead needed\n- LLM-friendly: clear visual separation from JS/shell\n\n**Array vs Block Disambiguation:**\n- In exe/for context, `[...]` is **ALWAYS** a block\n- Array literals only valid in `var` context\n- Context determines meaning - no grammar tricks needed\n\n**Examples:**\n```mlld\nexe @func() = [let @x = 1 =\u003e @x]    # Block (statements)\nexe @func() = [1, 2, 3]              # Also block (3 expressions - likely error)\nexe @arr() = {[1, 2, 3]}             # Escape hatch: object containing array\nvar @arr = [1, 2, 3]                 # Array literal (var context)\n```\n\n## ‚ö†Ô∏è IMPORTANT: Grammar Snippets Are Starting Points\n\nThe grammar snippets below are **starting points pending abstraction discovery findings** (mlld-cw9). The discovery phase may reveal better patterns to reuse. Don't copy these verbatim - use them as inspiration after understanding what already exists.\n\n## Strict vs Loose Mode Clarification\n\n- **Strict mode**: No slashes on directives (pure mlld)\n- **Loose mode**: Requires `/` on top-level directives (markdown-friendly)\n- **Inner statements**: Slashless in BOTH modes (inside blocks)\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) first to understand what can be reused.\n\n## Files to Modify\n\n- `grammar/patterns/exe-rhs.peggy` - Add ExeBlockPattern\n- `grammar/directives/for.peggy` - Add ForActionVariant\n- `grammar/patterns/iteration.peggy` - Add ForBlockAction pattern\n\n## Grammar Implementation (Starting Points)\n\n### ExeBlockPattern (in exe-rhs.peggy)\n\nBased on discovery, likely reuses `WhenExpressionEntry` + return statement:\n\n```peggy\nExeStatementBlock \"exe statement block\"\n  = \"[\" _ statements:ExeBlockStatementList _ returnStmt:ExeReturnStatement? _ \"]\" {\n      return {\n        type: 'ExeBlock',\n        subtype: 'exeBlock',\n        source: 'block',\n        values: {\n          statements: statements,\n          ...(returnStmt ? { return: returnStmt } : {})\n        },\n        raw: {\n          statements: helpers.reconstructRawString(statements),\n          hasReturn: !!returnStmt\n        },\n        meta: {\n          statementCount: statements.length,\n          hasReturn: !!returnStmt\n        }\n      };\n    }\n```\n\n### ExeBlockStatementList\n\nLikely reuses existing patterns:\n\n```peggy\nExeBlockStatementList\n  = first:ExeBlockStatement rest:(_ stmt:ExeBlockStatement { return stmt; })* {\n      return [first, ...rest];\n    }\n\nExeBlockStatement \"exe block statement\"\n  = LetAssignment              // let @x = value\n  / AugmentedAssignment        // @x += value\n  / EffectAction               // show, log, output, append\n  / WhenRHSVarAssignment       // var @x = value (outer scope)\n  / WhenRHSCommandAction       // cmd {...}\n  / WhenRHSFunctionCall        // @func()\n  / VarRHSContent              // Any expression\n```\n\n### ForActionVariant\n\n```peggy\nForActionVariant\n  = \"=\u003e\" _ action:ForSingleAction {\n      return { type: 'single', action: Array.isArray(action) ? action : [action] };\n    }\n  / \"[\" _ statements:ForBlockStatementList _ \"]\" {\n      return { type: 'block', statements };\n    }\n```\n\n### Update ExeRHSContent ordering\n\n```peggy\nExeRHSContent \"exe assignment value\"\n  = WhenExpression              # when [...]\n  / ForExpressionExe            # for =\u003e [...]\n  / ExeCodePattern              # js {...}\n  / ExeCommandPattern           # cmd {...}\n  / ExeDataPattern              # {key: value}\n  / ExeStatementBlock           # NEW - [statements] (after data)\n  / ... rest\n```\n\n## Error Recovery\n\nAdd helpful error messages for:\n- Unterminated `[` - \"Unterminated block. Expected ']' to close block.\"\n- Comma separators - \"Use newlines between statements, not commas\"\n- Multiple returns - \"Only one return allowed as last statement\"\n\n## Statement Separator Rules\n\nUse whitespace separation like when blocks:\n- When.peggy lines 440-457 show the pattern\n- Error helpfully on commas\n\n## Testing\n\nAfter building grammar:\n```bash\nnpm run build:grammar\nnpm run ast -- 'exe @f() = [let @x = 1 =\u003e @x]'\nnpm run ast -- 'for @x in @xs =\u003e [show @x]'\n```\n\n## Validation\n\n- [ ] ExeStatementBlock parses correctly\n- [ ] ForActionBlock parses correctly  \n- [ ] Error recovery works for common mistakes\n- [ ] AST output matches type definitions\n- [ ] Strict mode works (no leading /)\n- [ ] Loose mode works (requires leading /)","notes":"Grammar: added exe statement blocks and for block actions with block separators, return handling, and error recovery; ForActionVariant handles block vs single; ExeRHSContent routes to blocks. build:grammar/build passed.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:14:45.573522-08:00","updated_at":"2025-12-10T02:36:55.739253-08:00","closed_at":"2025-12-10T02:36:55.739254-08:00","dependencies":[{"issue_id":"mlld-9pl","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.021026-08:00","created_by":"daemon"}]}
{"id":"mlld-9pv","title":"Epic: Block error reparse helper","description":"Add reparse-on-failure helper to surface inner-line parse errors for all [..] block constructs (exe blocks, for blocks, when blocks/match, guard blocks, foreach if applicable). Deliver: grammar-core helper + per-block wiring to reparse inner text with correct offsets, plus fixtures for improved diagnostics.","notes":"Block reparse helper landed across exe/for/when/guard, docs updated, changelog noted, targeted test added; grammar build passes.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T02:50:58.903344-08:00","updated_at":"2025-12-10T07:06:03.718621-08:00","closed_at":"2025-12-10T07:06:03.718623-08:00"}
{"id":"mlld-9pv.1","title":"Grammar-core: add reparseInner helper","description":"Add helpers.reparseInner(innerText, startRule, offset) in grammar/deps/grammar-core.ts to reparse block contents and rethrow mlldError with corrected locations. Should offset location() by block start and be safe for block contexts only.","notes":"Reparse helper implemented and wired; tests added.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:04.553133-08:00","updated_at":"2025-12-10T07:05:42.428859-08:00","closed_at":"2025-12-10T07:05:42.428861-08:00","dependencies":[{"issue_id":"mlld-9pv.1","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:04.553578-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.2","title":"Wire reparse helper for exe blocks","description":"Use grammar-core reparse helper in exe statement block parsing to re-run inner text on failure and surface inner-line errors; include unterminated block and return-last checks.","notes":"Exe block reparse wiring done; regression test covers block errors.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:11.017812-08:00","updated_at":"2025-12-10T07:05:48.053412-08:00","closed_at":"2025-12-10T07:05:48.053413-08:00","dependencies":[{"issue_id":"mlld-9pv.2","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:11.018285-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.3","title":"Wire reparse helper for for blocks","description":"Apply reparse helper to for block actions so inner errors point to the failing statement; handle unterminated block and comma/return diagnostics.","notes":"For block reparse wiring complete; included in shared block error test.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:15.726975-08:00","updated_at":"2025-12-10T07:05:53.976319-08:00","closed_at":"2025-12-10T07:05:53.97632-08:00","dependencies":[{"issue_id":"mlld-9pv.3","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:15.727462-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.4","title":"Wire reparse helper for when/guard blocks","description":"Integrate reparse helper for when block/match and guard block parsing so inner condition/action errors report precise locations; ensure comma/unterminated handling remains.","notes":"When/guard block reparsing wired; block error test covers when/guard.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:22.663089-08:00","updated_at":"2025-12-10T07:05:59.402809-08:00","closed_at":"2025-12-10T07:05:59.40281-08:00","dependencies":[{"issue_id":"mlld-9pv.4","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:22.663541-08:00","created_by":"adam"}]}
{"id":"mlld-9qq","title":"Docs: audit strict vs markdown defaults","description":"Audit user/dev docs and examples to align with strict vs markdown modes. Scope:\\n- Default examples to strict unless prose semantics are needed.\\n- Identify docs needing mode updates and open individual cards per doc for edits.\\n- Ensure flags/CLI/SDK mode defaults are documented, with strict for modules and markdown for prose.\\n- Recommend keeping LOOSE_TESTMODE noted for test guidance.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:28:51.672034-08:00","updated_at":"2025-12-09T08:28:51.672034-08:00"}
{"id":"mlld-a2x","title":"mlld needs simple math operators and logic","description":"`*` `+` `/` `-` ... maybe that's all? idk what other languages have","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T16:37:38.005938-08:00","updated_at":"2025-12-09T16:37:38.005938-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-ah5","title":"Cache: include mode in AST cache keys","description":"**Summary:**\nEnsure AST cache doesn't return wrong-mode cached AST.\n\n**Changes required:**\n\n1. **Locate AST cache** (likely in interpreter or execute flow):\n   - Find where parsed ASTs are cached by filepath\n\n2. **Update cache key**:\n   ```typescript\n   // Before\n   const cacheKey = filepath;\n   \n   // After\n   const cacheKey = `${filepath}:${mode}`;\n   ```\n   \n   Or use a composite key object if the cache supports it.\n\n3. **Cache invalidation**:\n   - Same file parsed with different mode = different cache entries\n   - mtime-based invalidation still applies per entry\n\n**Testing:**\n- Parse same file in strict mode, cache hit\n- Parse same file in markdown mode, cache miss (different key)\n- Modify file, both cache entries invalidate","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:57:52.664361-08:00","updated_at":"2025-12-08T19:57:52.664361-08:00","dependencies":[{"issue_id":"mlld-ah5","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.46839-08:00","created_by":"daemon"},{"issue_id":"mlld-ah5","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.797125-08:00","created_by":"daemon"}]}
{"id":"mlld-ait","title":"Phase 2.4: Interpreter - Add while loop evaluator","description":"## Summary\n\nAdd while loop evaluation for bounded iteration with done/continue control flow.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- Pipeline stages receive/return StructuredValue\n- State passed between iterations preserves wrappers\n- done/continue values should preserve wrappers\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n\n## Files to Create/Modify\n\n- `interpreter/eval/while.ts` (new file)\n- `interpreter/eval/pipeline/executor.ts` - Wire in while stage\n\n## Context Variables (@ctx.while.*)\n\nProcessors have access to iteration context:\n\n- `@ctx.while.iteration` (number) - Current iteration, **1-based**\n- `@ctx.while.limit` (number) - Configured cap\n- `@ctx.while.active` (boolean) - true when inside while loop\n\n```mlld\nexe @processor(state) = when [\n  @ctx.while.iteration \u003e 5 =\u003e done @state\n  @ctx.while.iteration == @ctx.while.limit =\u003e done \"hit cap\"\n  * =\u003e continue @state\n]\n```\n\n## Pacing Semantics\n\n- Parameter: `(cap, pacing)` e.g., `while(100, 1s)`\n- Pacing is minimum delay BETWEEN iterations\n- Applied after each iteration (except last)\n- Uses same TimeDuration format as other mlld features (ms, s, m, h)\n\n## Retry Interaction Rules (CRITICAL)\n\n- Processors **CANNOT** use `retry` keyword (use `continue` instead)\n- If processor returns `retry`, throw error: \"Use 'continue' instead of 'retry' in while processors\"\n- Downstream stages CAN retry the entire while stage\n- Example: `@initial | while(100) @iterate | @validate` (validate can retry the whole while)\n\n## Implementation\n\n### New File: while.ts\n\n```typescript\nimport { Environment } from '@interpreter/env/Environment';\nimport { isDoneLiteral, isContinueLiteral, isRetryLiteral, WhilePipelineStage } from '@core/types';\nimport { MlldWhileError } from '@core/errors';\nimport { evaluate } from '../evaluate';\n\ninterface WhileContext {\n  iteration: number;  // 1-based\n  limit: number;\n  active: boolean;\n}\n\nexport async function evaluateWhileStage(\n  stage: WhilePipelineStage,\n  input: unknown,\n  env: Environment\n): Promise\u003cunknown\u003e {\n  const cap = stage.values.cap;\n  const rate = stage.values.rate;\n  const processorRef = stage.values.processor;\n  \n  let state = input;\n  \n  for (let iteration = 1; iteration \u003c= cap; iteration++) {\n    // Create context for this iteration\n    const whileCtx: WhileContext = { \n      iteration,  // 1-based\n      limit: cap,\n      active: true \n    };\n    \n    // Set up iteration environment with @ctx.while\n    const iterEnv = env.createChild();\n    iterEnv.setContextValue('while', whileCtx);\n    \n    // Invoke processor with current state\n    const result = await invokeProcessor(processorRef, state, iterEnv);\n    \n    // Check for forbidden retry\n    if (isRetryLiteral(result)) {\n      throw new MlldWhileError(\n        \"Use 'continue' instead of 'retry' in while processors\",\n        { iteration, limit: cap }\n      );\n    }\n    \n    // Handle control flow\n    if (isDoneLiteral(result)) {\n      // Terminal - return the done value\n      return result.values.value.length \u003e 0 \n        ? await evaluate(result.values.value[0], iterEnv)\n        : state;\n    }\n    \n    if (isContinueLiteral(result)) {\n      // Continue with new state\n      state = result.values.value.length \u003e 0\n        ? await evaluate(result.values.value[0], iterEnv)\n        : state;\n    } else {\n      // Implicit continue with result as new state\n      state = result;\n    }\n    \n    // Apply pacing if specified (except on last iteration)\n    if (rate \u0026\u0026 iteration \u003c cap) {\n      await delay(rate);\n    }\n  }\n  \n  // Reached cap without done - throw error with hint\n  throw new MlldWhileError(\n    `While loop reached cap (${cap}) without 'done'. Consider increasing cap or check termination logic.`,\n    { iteration: cap, limit: cap }\n  );\n}\n```\n\n### Wire into Pipeline Executor\n\nIn `interpreter/eval/pipeline/executor.ts`, add handling for WhileStage:\n\n```typescript\nimport { evaluateWhileStage } from '../while';\n\n// In stage execution logic:\nif (stage.type === 'WhileStage') {\n  return await evaluateWhileStage(stage, input, env);\n}\n```\n\n## Control Flow Semantics\n\n- `done @value` - Terminate iteration, return value\n- `done` (no value) - Terminate, return current state\n- `continue @value` - Next iteration with value as new state\n- `continue` (no value) - Next iteration with current state\n- Implicit return - Treated as continue with result\n\n## Error Handling\n\n- **Cap exceeded**: `MlldWhileError` with hint to increase cap or check logic\n- **Retry used**: Error telling to use `continue` instead\n- **Invalid return**: Must return done/continue, error if neither recognized\n- **Processor errors**: Propagate normally with iteration number in stack\n\n## Validation\n\n- [ ] While stage executes bounded iterations\n- [ ] Done terminates and returns value (preserving StructuredValue)\n- [ ] Continue advances to next iteration (preserving StructuredValue)\n- [ ] Cap limit enforced with helpful error\n- [ ] Rate limiting (pacing) works\n- [ ] Context (@ctx.while.*) available in processor\n- [ ] Retry throws helpful error message\n- [ ] Iteration is 1-based (not 0-based)","notes":"While stage grammar outputs type 'whileStage' with cap, optional rateMs, and processor (VariableReference). Control literals done/continue now parse as Literal.valueType with payload arrays; pipeline/while evaluator must define control flow: done should short-circuit with result, continue feeds next state. Ensure StructuredValue wrapping and ctx preservation when iterating.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T22:18:37.290469-08:00","updated_at":"2025-12-10T03:02:37.449494-08:00","dependencies":[{"issue_id":"mlld-ait","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:52.279935-08:00","created_by":"daemon"}]}
{"id":"mlld-b0e","title":"Grammar: Add WorkingDirPath pattern for :path suffix parsing","description":"## Context\nPart of implementing cmd:path/sh:path feature to allow setting working directory for command execution.\n\nExample syntax:\n```mlld\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n/run sh:@mypath {echo \"hello world\"}\n/run cmd:@base/scripts {./build.sh}\n/run sh:/Users/@username/dev/@dir {somecommand}\n```\n\n## Task\nCreate a new grammar pattern `WorkingDirPath` to parse the `:path` suffix that appears after `cmd` or language keywords (`sh`, `bash`, etc).\n\n## Requirements\n\n1. Path must be rooted (absolute) - starts with `/` or `@`\n2. Support variable interpolation: `@mypath`, `@base/subdir`, `/home/@user/dev`\n3. No relative paths allowed (no `./` or bare names)\n\n## Implementation\n\nLocation: `grammar/patterns/unified-run-content.peggy`\n\nAdd these patterns:\n\n```peggy\n// Working directory path suffix for cmd and sh\nWorkingDirPath \"working directory path\"\n  = \":\" path:WorkingDirPathContent {\n      return path;\n    }\n\n// Path content with variable interpolation\nWorkingDirPathContent\n  = parts:WorkingDirPathPart+ {\n      const flatParts = parts.flat();\n      const raw = helpers.reconstructRawString(flatParts);\n      \n      return {\n        type: 'workingDir',\n        parts: flatParts,\n        raw: raw,\n        meta: helpers.createPathMetadata(raw, flatParts)\n      };\n    }\n\n// Individual path parts - variables or literal path segments\nWorkingDirPathPart\n  = UnifiedVariableNoTail       // @mypath or @base etc.\n  / WorkingDirPathLiteral       // /path/segments\n\n// Literal path segments (no whitespace, not braces)\nWorkingDirPathLiteral\n  = chars:WorkingDirPathChar+ {\n      return helpers.createNode(NodeType.Text, { \n        content: chars.join(''), \n        location: location() \n      });\n    }\n\nWorkingDirPathChar\n  = [^\\s\\t\\n\\r\\{\\}@]  // Any char except whitespace, braces, @\n```\n\n## Key Points\n\n- Reuse `UnifiedVariableNoTail` for variable parsing (already exists)\n- Return structure with `parts` (AST nodes) and `raw` (string)\n- Use `helpers.createPathMetadata()` to create metadata\n- Must stop at whitespace or `{` (command block start)\n\n## Testing\n\nAfter implementation, test with `npm run ast`:\n```bash\nnpm run ast -- 'cmd:/absolute/path {ls}'\nnpm run ast -- 'cmd:@variable {ls}'\nnpm run ast -- 'cmd:@base/subdir {ls}'\n```","notes":"Grammar pattern should parse :path suffix for cmd/sh etc; path content allows absolute Unix paths only; no Windows or '~'; '/' valid.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:06.303866-08:00","updated_at":"2025-12-08T20:23:24.305345-08:00","closed_at":"2025-12-08T20:23:24.305345-08:00"}
{"id":"mlld-bgl","title":"Security: Policy-based working directory path restrictions","description":"Add security policy support for restricting working directory paths in cmd:path/sh:path syntax.\n\n## Background\nCurrently cmd:path and sh:path allow any absolute path the user has filesystem access to. We need policy-based restrictions to:\n- Define allowed path prefixes (e.g., only /Users/adam/dev/)\n- Prevent access to sensitive directories (/etc, /root, etc.)\n- Support guards that test path compliance before execution\n\n## Requirements\n1. Extend security policy to include working directory constraints\n2. Add path validation against policy in cwd-resolver\n3. Create guards that can inspect and approve/deny workingDir\n4. Clear error messages when path violates policy\n\n## Examples\nPolicy:\n```\n/needs cmd.cwd:/Users/adam/dev/**\n```\n\nGuard:\n```\n/guard [cmd.cwd =\u003e {\n  # Validate working directory is within allowed paths\n}]\n```\n\nThis issue should be tackled after the basic cmd:path/sh:path feature is implemented and working.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T12:53:10.831611-08:00","updated_at":"2025-12-08T12:53:10.831611-08:00","labels":["future","security"]}
{"id":"mlld-cgb","title":"LSP: update highlighting for strict and markdown modes","description":"Audit and update LSP semantic tokens and visitors to handle strict vs markdown modes. Ensure directive detection, template handling, and mode-sensitive tokenization stay accurate in both modes; add tests for each mode.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:30:21.961653-08:00","updated_at":"2025-12-09T08:30:21.961653-08:00"}
{"id":"mlld-cw9","title":"Phase 0: Abstraction Discovery for Block Syntax Epic","description":"**CRITICAL: This must be done FIRST before any implementation!**\n\n## Purpose\n\nBefore writing any new grammar, systematically identify what already exists. The plan was created with \"late-context chaotic planning energy\" - a fresh implementer's brain will see patterns we missed.\n\n## Time Budget\n\n60-90 minutes of reading before writing code.\n\n## Required Reading\n\n### 1. Grammar Files to Review\n\n**`grammar/patterns/exe-rhs.peggy`**\n- What can `WhenExpression` currently contain? (lines 438-517)\n- What's in `WhenExpressionEntry`? (line 502-505)\n- What's `WhenRHSAction`? (references when-rhs-action.peggy)\n- Can we reuse `WhenExpressionConditionList` for exe blocks?\n\n**`grammar/patterns/when-rhs-action.peggy`**\n- What actions are supported? (line 8-17)\n- What directives can appear in when RHS?\n- Which of these should work in exe blocks?\n\n**`grammar/patterns/iteration.peggy`**\n- What's in `ForSingleAction`? (lines 55-101)\n- Does it already support everything for blocks need?\n- What's `WhenRHSAction` reused here?\n\n**`grammar/base/literals.peggy`**\n- How are `retry`, `skip`, `allow`, `denied` defined? (lines 50-74)\n- Follow exact same pattern for `done` and `continue`\n\n**`grammar/patterns/let-assignment.peggy`**\n- How do `LetAssignment` and `AugmentedAssignment` work?\n- Can we reuse directly or need exe-specific variants?\n\n### 2. Type Files to Review\n\n**`core/types/` for exe/for/when**\n- Understand `ExecutableDefinition` variants\n- How does dispatch work?\n- Where does `ExeBlockNode` fit in hierarchy?\n\n### 3. Data Handling (CRITICAL!)\n\n**`docs/dev/DATA.md`** - Required reading!\n- StructuredValue system (.text, .data, .ctx)\n- When to use asData() vs asText()\n- Boundary rules for unwrapping\n\n### 4. Files to AVOID\n\n**`grammar/directives/for-template.peggy`** - NOT reusable (text substitution)\n\n## Key Insight from Plan\n\nExe blocks are ~80% the same as exe..when! An exe block is just when expression without conditions (or with implicit `* =\u003e`). Massive reuse opportunity.\n\n## Critical Disambiguation (SOLVED in plan)\n\nIn exe/for contexts, `[...]` is **always a block**:\n```mlld\nexe @func() = [1, 2, 3]           # Block with 3 expressions (likely error)\nexe @func() = {[1, 2, 3]}         # Escape hatch: object with array\nexe @func() = @identity([1, 2, 3]) # Or use function\n\nfor @x in @xs =\u003e [statements]     # Always block\n```\n\n**No lookahead needed** - Context determines meaning.\n\n## Deliverable\n\nCreate `tmp/abstraction-reuse-findings.md` documenting:\n1. What patterns exist and can be reused (with line numbers)\n2. What needs creating (minimal list)\n3. Gap analysis: exe..when vs exe blocks\n4. Solution for array literal disambiguation\n5. Type hierarchy understanding\n6. StructuredValue usage patterns\n\n## Validation\n\n- [ ] Read all listed files\n- [ ] Created findings document\n- [ ] Identified reuse opportunities\n- [ ] Ready to start Phase 1\n\n## Warning\n\nThe plan shows test examples with BOTH `{...}` and `[...]` syntax due to iteration during planning. **The final decision is `[...]` for all mlld blocks**. When implementing, convert all block examples to use `[...]` brackets, not `{...}` curly braces.","notes":"Phase 0 reading done; documented reuse/gaps in tmp/abstraction-reuse-findings.md; ready to proceed to block grammar/AST work.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-09T22:14:05.424356-08:00","updated_at":"2025-12-09T23:42:33.072751-08:00","closed_at":"2025-12-09T23:42:33.072751-08:00"}
{"id":"mlld-d0p","title":"Use the SDK's analyze module function to extract the required base-level `/needs` and check them against the user's module when publishing","description":"If the user doesn't have required items listed, we should suggest `/needs` and suggest they break it up into `/wants` tiers if there is a requirement hierarchy.\n\nThis issue needs to be thought through in more depth.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-07T13:50:42.30443-08:00","updated_at":"2025-12-08T12:20:15.296359-08:00","labels":["creator:adamavenir@hey.com"]}
{"id":"mlld-e0b","title":"Interpreter: Modify run evaluator to resolve and pass cwd","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task modifies the run evaluator to check for workingDir in the AST, resolve it, and pass it to command executors.\n\n## Prerequisites\n- mlld-1x2 complete (cwd-resolver exists)\n- mlld-u8r complete (workingDir types defined)\n- Grammar tasks complete (workingDir in AST)\n\n## Task\nModify `interpreter/eval/run.ts` to handle the optional `workingDir` field from the AST.\n\n## Implementation\n\nLocation: `interpreter/eval/run.ts`\n\n### Step 1: Import the resolver\n\nAdd import at top of file:\n```typescript\nimport { resolveCwd } from '../utils/cwd-resolver';\n```\n\n### Step 2: Find command execution locations\n\nLook for calls to:\n- `env.executeCommand()`\n- `env.executeCode()`\n\nThese are likely in functions like:\n- `evaluateRunCommand()` - for `cmd {...}`\n- `evaluateRunCode()` - for `sh {...}`, `bash {...}`, etc.\n\n### Step 3: Add cwd resolution before execution\n\nFor each execution point, add cwd resolution:\n\n```typescript\n// Check if workingDir is present in AST\nlet resolvedCwd: string | undefined;\nif (node.values?.workingDir) {\n  resolvedCwd = await resolveCwd(\n    node.values.workingDir,\n    env,\n    node.location\n  );\n}\n\n// Pass to executor\nconst result = await env.executeCommand(command, {\n  ...existingOptions,\n  cwd: resolvedCwd\n});\n```\n\n### Step 4: Handle both cmd and code execution\n\nMake sure both paths are covered:\n\n**For cmd execution:**\n```typescript\nconst result = await env.executeCommand(command, {\n  env: envVars,\n  cwd: resolvedCwd,  // NEW\n  // ... other options\n});\n```\n\n**For code execution (sh, bash, js, python):**\n```typescript\nconst result = await env.executeCode(language, code, {\n  args: resolvedArgs,\n  cwd: resolvedCwd,  // NEW\n  // ... other options\n});\n```\n\n## Edge Cases\n\n1. **workingDir is optional**: Only resolve if present in AST\n2. **Error propagation**: Let `resolveCwd` errors bubble up naturally\n3. **Pipeline context**: Each command gets its own cwd resolution\n\n## Testing\n\nAfter implementation, test with actual mlld scripts:\n\n```bash\necho '/var @mypath = \"/tmp\"\n/run cmd:@mypath {pwd}' | ./dist/cli.cjs\n\n# Should output: /tmp\n```\n\n```bash\necho '/run cmd:/nonexistent {ls}' | ./dist/cli.cjs\n\n# Should error: Working directory does not exist\n```","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:35.93044-08:00","updated_at":"2025-12-08T20:24:42.061534-08:00","closed_at":"2025-12-08T20:24:42.061534-08:00"}
{"id":"mlld-emu","title":"CLI: add --payload alias for --inject flag","description":"**Reported by:** partydev during SDK dogfooding\n\n**Request:**\nAdd `--payload` as an alias for `--inject` in the CLI for consistency with the SDK.\n\n**Rationale:**\n- SDK uses `execute(file, payload)`\n- CLI uses `--inject`\n- For consistency, `mlld file.mld --payload '{...}'` would be more intuitive\n\n**Implementation:**\nAdd alias in ArgumentParser - straightforward change.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-09T07:50:59.202687-08:00","updated_at":"2025-12-09T08:06:20.371517-08:00","closed_at":"2025-12-09T08:06:20.371517-08:00"}
{"id":"mlld-fln","title":"Epic: Block Syntax, While Loops, and Grammar Error Handling","description":"A unified grammar epic that adds three major features to mlld:\n\n1. **Block syntax `[...]`** for exe/for directives with `let`/`+=` support\n2. **While loops** with `done`/`continue` keywords for bounded iteration\n3. **Unified when syntax** - one form: `when [condition =\u003e action]`\n4. **Improved error handling** - proper location tracking in blocks\n\n## Key Insight\n\nAll three features use `[...]` delimiter for mlld constructs, creating clear visual separation from JS/shell `{...}` syntax. This helps LLMs distinguish mlld from embedded languages.\n\n## Why Together\n\nSame files, same patterns, shared error infrastructure. More efficient as one epic than three separate PRs.\n\n## Delimiter Rules (CRITICAL)\n\n- `{...}` ‚Üí code/command/data (requires prefix or property syntax)\n- `[...]` ‚Üí mlld blocks in exe/for/when contexts\n- `[...]` ‚Üí array literals in var/argument contexts\n- **Context determines meaning** - No ambiguity!\n\n## New Keywords\n\n- `done` and `continue` (for while loops)\n- `let` already exists for when blocks\n\n## Scope Restrictions (Pragmatic)\n\n**NOT Implementing:**\n- Field access mutation: `let @data[-1].field += value` ‚Üí ETOOCOMPLEX\n- Parallel for with blocks: `for parallel() @x =\u003e [...]` ‚Üí Use exe wrapper\n- Batch pipelines with blocks: `for =\u003e [...] =\u003e ||` ‚Üí Use simple expressions\n- When match form: `when @var: [...]` ‚Üí Use `when [@var == value =\u003e ...]`\n\n**ARE Implementing:**\n- Block syntax `[...]` for multi-statement bodies (exe, for)\n- Simple let/+=: `let @var = value` (variable name only, no field access)\n- Nested control flow: for/when inside blocks\n- While loops: Bounded iteration with done/continue\n- Explicit returns: `=\u003e @value` (required in exe blocks, must be last)\n- Proper error handling: Location tracking, helpful messages\n- Strict/loose mode: No slashes in strict, top-level only in loose\n\n## Implementation Phases\n\n1. **Phase 0**: Abstraction Discovery (60-90 min reading before code)\n2. **Phase 1**: Grammar + Types (all features, parse-only focus)\n3. **Phase 2**: Interpreter (one construct at a time)\n4. **Phase 3**: Core Tests (minimal golden set - 5 tests)\n5. **Phase 4**: Integration \u0026 Polish (optional)\n\n## Success Criteria\n\n1. All core test cases pass\n2. Exe blocks can have sequential statements with let/+=\n3. For blocks can have nested control flow\n4. Let variables properly scoped to blocks\n5. Augmented assignment works on arrays, strings, objects\n6. Return statements work in exe blocks\n7. Error messages clear and actionable\n8. Nested blocks maintain separate scopes\n\n## Estimate\n\n3-5 Claude sessions (grammar-first approach, abstraction reuse focus)\n\n## Reference\n\nSee `todo/plan-grammar-next.md` for full implementation details.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-09T22:13:32.943942-08:00","updated_at":"2025-12-09T22:13:32.943942-08:00","dependencies":[{"issue_id":"mlld-fln","depends_on_id":"mlld-cw9","type":"parent-child","created_at":"2025-12-09T22:14:11.122384-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-9pl","type":"parent-child","created_at":"2025-12-09T22:16:29.283436-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-1sh","type":"parent-child","created_at":"2025-12-09T22:16:29.35034-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-wrb","type":"parent-child","created_at":"2025-12-09T22:16:29.417501-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-8d6","type":"parent-child","created_at":"2025-12-09T22:16:29.524287-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-0gd","type":"parent-child","created_at":"2025-12-09T22:16:29.592885-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-zeo","type":"parent-child","created_at":"2025-12-09T22:18:43.391952-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-9id","type":"parent-child","created_at":"2025-12-09T22:18:43.463166-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-0ic","type":"parent-child","created_at":"2025-12-09T22:18:43.545022-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-ait","type":"parent-child","created_at":"2025-12-09T22:18:43.615165-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-jw7","type":"parent-child","created_at":"2025-12-09T22:19:32.661253-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-5ik","type":"parent-child","created_at":"2025-12-09T22:20:06.935882-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-1iz","type":"parent-child","created_at":"2025-12-09T22:27:45.067721-08:00","created_by":"daemon"}]}
{"id":"mlld-fzr","title":"init incorrectly names files `.mlld.md` instead of `.mld.md`","description":"We don't want `.mlld` or `.mlld.md` to become standard -- just `.mld` and `.mld.md` ","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T05:17:57.376218-08:00","updated_at":"2025-12-08T12:18:32.986333-08:00","closed_at":"2025-12-08T12:18:32.986333-08:00","labels":["creator:adamavenir@hey.com"]}
{"id":"mlld-gj7","title":"Grammar: add mode flag and optional slash prefix","description":"**Summary:**\nAdd a `mode: 'strict' | 'markdown'` option to the parser and make the leading `/` optional on directives.\n\n**Changes required:**\n\n1. **Parser options** (`grammar/parser/index.ts` or entry point):\n   - Accept `mode` option, default to `'markdown'` for backward compat during transition\n   - Thread mode into grammar context\n\n2. **Grammar helper** (`grammar/deps/grammar-core.ts`):\n   - Replace `isSlashDirectiveContext` with `isDirectiveContext`\n   - In both modes, match optional `/` followed by directive keyword at line start\n   - The difference is handled at top-level line classification, not here\n\n3. **Directive rules** (`grammar/mlld.peggy` or modular files):\n   - Change directive prefix from `\"/\"` to `\"/\"?`\n   - All directives: var, exe, run, show, for, when, import, export, guard, output, log, append, stream, needs, wants\n   - Keep semantic actions unchanged\n\n4. **Top-level line rule**:\n   ```peggy\n   Line \n     = Directive\n     / BlankLine\n     / \u0026{ return options.mode === 'markdown' } TextLine\n     / \u0026{ return options.mode === 'strict' } StrictModeTextError\n   \n   StrictModeTextError = (!Directive .)+ { \n     error(\"Text content not allowed in strict mode (.mld). Use .mld.md for prose.\") \n   }\n   ```\n\n5. **Blank line handling**:\n   - Strict mode: blank lines are whitespace, produce no AST node\n   - Markdown mode: blank lines may become content nodes (current behavior)\n\n**Testing:**\n- Add grammar unit tests for optional slash parsing\n- Verify existing tests pass with mode='markdown'","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-08T19:57:33.602447-08:00","updated_at":"2025-12-08T19:57:33.602447-08:00","dependencies":[{"issue_id":"mlld-gj7","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.389438-08:00","created_by":"daemon"}]}
{"id":"mlld-jw7","title":"Phase 3: Core Tests - Minimal golden set for block syntax epic","description":"## Summary\n\nCreate 5 core test cases that validate each feature works in isolation. These are the minimal golden set before moving to integration tests.\n\n## Prereq\n\nAll Phase 2 interpreter issues must be complete:\n- mlld-zeo (Export let functions)\n- mlld-9id (Exe blocks)\n- mlld-0ic (For blocks)\n- mlld-ait (While loops)\n\n## Test Structure\n\n```\ntests/cases/feat/\n‚îú‚îÄ‚îÄ exe-block/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ for-block/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ when-unified/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ while/\n‚îÇ   ‚îî‚îÄ‚îÄ basic-done-continue/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\ntests/cases/exceptions/\n‚îî‚îÄ‚îÄ augmented-assignment/\n    ‚îî‚îÄ‚îÄ undefined-variable/\n        ‚îú‚îÄ‚îÄ example.md\n        ‚îî‚îÄ‚îÄ error.md\n```\n\n## Test 1: Exe Block Happy Path\n\nFile: `tests/cases/feat/exe-block/basic/example.md`\n```mlld\n/exe @greet(name) = [\n  let @greeting = \"Hello\"\n  let @punctuation = \"!\"\n  =\u003e \"@greeting @name@punctuation\"\n]\n\n/show @greet(\"World\")\n```\n\nExpected: `expected.md`\n```\nHello World!\n```\n\n**Purpose**: Exe block with let assignments and explicit return.\n\n---\n\n## Test 2: For Block Happy Path\n\nFile: `tests/cases/feat/for-block/basic/example.md`\n```mlld\n/var @count = 0\n\n/for @item in [\"a\", \"b\", \"c\"] =\u003e [\n  show \"Item: @item\"\n  var @count += 1\n]\n\n/show \"Total: @count\"\n```\n\nExpected: `expected.md`\n```\nItem: a\nItem: b\nItem: c\nTotal: 3\n```\n\n**Purpose**: For block with local let and outer var mutation.\n\n---\n\n## Test 3: When Unified Syntax\n\nFile: `tests/cases/feat/when-unified/basic/example.md`\n```mlld\n/exe @classify(x) = when [\n  @x \u003e 100 =\u003e \"large\"\n  @x \u003e 10 =\u003e \"medium\"\n  * =\u003e \"small\"\n]\n\n/show @classify(150)\n/show @classify(50)\n/show @classify(5)\n```\n\nExpected: `expected.md`\n```\nlarge\nmedium\nsmall\n```\n\n**Purpose**: When expression with unified `[condition =\u003e action]` syntax.\n\n---\n\n## Test 4: While Loop Happy Path\n\nFile: `tests/cases/feat/while/basic-done-continue/example.md`\n```mlld\n/exe @countdown(n) = when [\n  @n \u003c= 0 =\u003e done \"finished\"\n  * =\u003e continue (@n - 1)\n]\n\n/var @result = 5 | while(10) @countdown\n/show @result\n```\n\nExpected: `expected.md`\n```\nfinished\n```\n\n**Purpose**: While loop with done/continue keywords.\n\n---\n\n## Test 5: Error - Augmented Assignment Without Let\n\nFile: `tests/cases/exceptions/augmented-assignment/undefined-variable/example.md`\n```mlld\n/var @items = [1, 2, 3]\n/for @item in @items =\u003e [\n  let @count += 1\n]\n```\n\nExpected: `error.md`\n```\nCannot use += on undefined variable @count. Use \"let @count = ...\" first.\n```\n\n**Purpose**: Runtime error for += without prior let.\n\n---\n\n## Running Tests\n\n```bash\n# Build fixtures first\nnpm run build:fixtures\n\n# Run all block syntax tests\nnpm run test:case -- feat/exe-block\nnpm run test:case -- feat/for-block\nnpm run test:case -- feat/when-unified\nnpm run test:case -- feat/while\n\n# Run exception tests\nnpm run test:case -- exceptions/augmented-assignment\n```\n\n## Validation\n\n- [ ] All 5 test cases created\n- [ ] Fixtures generated without errors\n- [ ] All tests pass\n- [ ] Edge cases identified for Phase 4","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T22:19:25.090487-08:00","updated_at":"2025-12-09T22:19:25.090487-08:00","dependencies":[{"issue_id":"mlld-jw7","depends_on_id":"mlld-9id","type":"blocks","created_at":"2025-12-09T22:19:32.747661-08:00","created_by":"daemon"},{"issue_id":"mlld-jw7","depends_on_id":"mlld-0ic","type":"blocks","created_at":"2025-12-09T22:19:32.834833-08:00","created_by":"daemon"},{"issue_id":"mlld-jw7","depends_on_id":"mlld-ait","type":"blocks","created_at":"2025-12-09T22:19:32.960034-08:00","created_by":"daemon"}]}
{"id":"mlld-k4k","title":"Strict mode for .mld files","description":"Implement a strict execution mode for .mld files that eliminates LLM-unfriendly ambiguities:\n\n**Problem:**\n- Current mlld requires `/` prefix on directive lines, which creates ambiguity\n- Non-directive lines become implicit content output, which LLMs can accidentally trigger\n- This makes mlld harder for LLMs to generate correctly\n\n**Solution:**\nTwo modes based on file extension:\n- `.mld` ‚Üí strict mode: bare directives, text lines error, blank lines ignored\n- `.mld.md` ‚Üí markdown mode: `/` required, text becomes content (current behavior)\n\n**Key decisions:**\n- Optional `/` prefix in strict mode for backward compatibility\n- Blank lines are no-ops in strict mode (formatting whitespace)\n- Raw strings in SDK default to strict mode\n- Mode included in AST cache keys\n\n**Line handling by mode:**\n\n| Line Type          | Strict Mode   | Markdown Mode   |\n|--------------------|---------------|-----------------|\n| `/directive`       | ‚úì Execute     | ‚úì Execute       |\n| `directive` (bare) | ‚úì Execute     | Text content    |\n| Blank              | ‚úì Ignore      | Content         |\n| Text               | ‚úó Error       | Content         |\n\nSee child issues for implementation breakdown.\n\nIMPORTANT: Ensure compatibility with \n1. current .mld.md module format which mixes ```mlld``` and ```mlld-run``` in markdown + frontmatter files‚Äîthis should be valid.\n2. `/for`...`/end` loops in templates","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-08T19:57:11.921576-08:00","updated_at":"2025-12-09T04:14:39.694319-08:00","dependencies":[{"issue_id":"mlld-k4k","depends_on_id":"mlld-5jz","type":"blocks","created_at":"2025-12-09T08:28:34.440584-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-9qq","type":"blocks","created_at":"2025-12-09T08:29:07.286149-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-04k","type":"blocks","created_at":"2025-12-09T08:29:37.475238-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-4cw","type":"blocks","created_at":"2025-12-09T08:30:06.896625-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-cgb","type":"blocks","created_at":"2025-12-09T08:30:38.780886-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-o2u","type":"blocks","created_at":"2025-12-09T08:31:10.514377-08:00","created_by":"adam"}]}
{"id":"mlld-k69","title":"Tests: Add comprehensive test coverage for cmd:path/sh:path","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task creates comprehensive test coverage for the new syntax.\n\n## Prerequisites\n- All implementation tasks complete (grammar, types, interpreter, executors)\n\n## Task\nCreate test cases covering valid syntax, invalid syntax, runtime exceptions, and edge cases.\n\n## Test Structure\n\nmlld uses a fixture-based test system:\n- `tests/cases/` - valid test cases\n- `tests/cases/invalid/` - syntax/parse errors\n- `tests/cases/exceptions/` - runtime errors\n- `tests/fixtures/` - generated fixture files (gitignored)\n\n### Test File Naming\n\n**CRITICAL**: Test names must be unique across ALL tests. Use prefixes like:\n- `cmd-path-absolute.md` \n- `cmd-path-variable.md`\n- `sh-path-interpolation.md`\n\nNOT just `path.md` or `test.md`!\n\n## Valid Test Cases\n\nLocation: `tests/cases/cmd-path/` (create new directory)\n\n### 1. cmd-path-absolute.md\n```markdown\n/run cmd:/tmp {pwd}\n```\n\nexpected.md:\n```\n/tmp\n```\n\n### 2. cmd-path-variable.md\n```markdown\n/var @mypath = \"/tmp\"\n/run cmd:@mypath {pwd}\n```\n\nexpected.md:\n```\n/tmp\n```\n\n### 3. cmd-path-interpolation.md\n```markdown\n/var @base = \"/tmp\"\n/var @subdir = \"test\"\n/run cmd:@base/@subdir {pwd}\n```\n\nexpected.md:\n```\n/tmp/test\n```\n\n### 4. sh-path-absolute.md\n```markdown\n/run sh:/tmp {pwd}\n```\n\n### 5. bash-path-variable.md\n```markdown\n/var @dir = \"/tmp\"\n/run bash:@dir {pwd}\n```\n\n### 6. cmd-path-loop-iteration.md\n```markdown\n/var @dirs = [\"/tmp\", \"/home\"]\n/for @dir in @dirs {\n  /run cmd:@dir {pwd}\n}\n```\n\nexpected.md:\n```\n/tmp\n/home\n```\n\n### 7. cmd-no-path-still-works.md\nTest that existing cmd without :path still works:\n```markdown\n/run cmd {pwd}\n```\n\n## Invalid Test Cases (Parse Errors)\n\nLocation: `tests/cases/invalid/cmd-path/`\n\n### 1. cmd-path-invalid-relative.md\n```markdown\n/run cmd:./relative {ls}\n```\n\nerror.md:\n```\nParse error: working directory must start with / or @\n```\n\n### 2. cmd-path-invalid-bare.md\n```markdown\n/run cmd:relative {ls}\n```\n\nNote: This might parse successfully but fail at runtime if it doesn't start with `/` or `@`. Adjust test category as needed.\n\n## Exception Test Cases (Runtime Errors)\n\nLocation: `tests/cases/exceptions/cmd-path/`\n\n### 1. cmd-path-exception-undefined-var.md\n```markdown\n/run cmd:@undefined {pwd}\n```\n\nerror.md:\n```\nVariable @undefined is not defined\n```\n\n### 2. cmd-path-exception-not-rooted.md\n```markdown\n/var @rel = \"relative\"\n/run cmd:@rel {pwd}\n```\n\nerror.md:\n```\nWorking directory must be an absolute path\n```\n\n### 3. cmd-path-exception-not-exists.md\n```markdown\n/run cmd:/does/not/exist/path {ls}\n```\n\nerror.md:\n```\nWorking directory does not exist\n```\n\n### 4. cmd-path-exception-not-directory.md\n```markdown\n/run cmd:/etc/hosts {ls}\n```\n\nerror.md:\n```\nWorking directory path is not a directory\n```\n\n## Grammar Tests\n\nLocation: `grammar/tests/run.test.ts`\n\nAdd test cases to verify AST structure:\n\n```typescript\ndescribe('cmd:path syntax', () =\u003e {\n  it('should parse cmd with absolute path', () =\u003e {\n    const result = parse('/run cmd:/tmp {ls}');\n    expect(result.values.workingDir).toBeDefined();\n    expect(result.raw.workingDir).toBe('/tmp');\n  });\n  \n  it('should parse cmd with variable path', () =\u003e {\n    const result = parse('/run cmd:@mypath {ls}');\n    expect(result.values.workingDir).toHaveLength(1);\n    expect(result.values.workingDir[0].type).toBe('VariableReference');\n  });\n  \n  it('should parse sh with interpolated path', () =\u003e {\n    const result = parse('/run sh:@base/subdir {pwd}');\n    expect(result.values.workingDir).toHaveLength(2); // variable + text\n    expect(result.meta.hasWorkingDir).toBe(true);\n  });\n});\n```\n\n## Running Tests\n\n```bash\n# Generate fixtures\nnpm run build:fixtures\n\n# Run specific test directory\nnpm run test:case -- cmd-path\n\n# Run all tests\nnpm test\n```\n\n## Acceptance Criteria\n\n- [ ] All valid syntax parses and executes correctly\n- [ ] Undefined variables produce clear errors\n- [ ] Non-rooted paths are rejected\n- [ ] Non-existent directories are detected\n- [ ] File paths (not directories) are rejected  \n- [ ] Loop iterations work with different paths\n- [ ] Existing cmd/sh without :path still works\n- [ ] Grammar tests verify AST structure","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:49.842606-08:00","updated_at":"2025-12-08T20:25:12.829395-08:00","closed_at":"2025-12-08T20:25:12.829395-08:00"}
{"id":"mlld-nwu","title":"sh/bash executor not emitting CHUNK events to StreamBus for format adapters","description":"When using 'stream sh { ... }' the FormatAdapterSink doesn't receive CHUNK events. Works with 'stream cmd { ... }'. FormatAdapterSink.handle never called for sh/bash executors.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-07T20:51:28.696466-08:00","updated_at":"2025-12-07T20:51:28.696466-08:00"}
{"id":"mlld-o2u","title":"Regex syntax highlighting: strict vs markdown","description":"Review and update regex/textmate/grammar-based highlighting to handle strict and markdown modes consistently. Validate directive detection, template delimiters, and optional slashes in both modes.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:30:53.814723-08:00","updated_at":"2025-12-09T08:30:53.814723-08:00"}
{"id":"mlld-om1","title":"LSP: mode-aware syntax highlighting and errors","description":"**Summary:**\nUpdate LSP/language server to handle both modes correctly.\n\n**Changes required:**\n\n1. **File extension detection:**\n   - `.mld` ‚Üí strict mode tokenization\n   - `.mld.md` ‚Üí markdown mode tokenization\n\n2. **Syntax highlighting:**\n   - Strict mode: directive keywords without `/` are highlighted as keywords\n   - Markdown mode: only `/keyword` highlighted as directives\n   - Both: `/keyword` highlighted as directive\n\n3. **Error diagnostics:**\n   - Strict mode: text lines get error squiggles with message\n   - Strict mode: suggest \"rename to .mld.md if you want prose content\"\n   - Markdown mode: no change from current behavior\n\n4. **Hover/completion:**\n   - Directive completions in strict mode don't require `/` prefix\n   - Both modes accept `/` prefix in completions\n\n5. **Formatter:**\n   - Strict mode: optionally normalize to bare directives (no `/`)\n   - Markdown mode: preserve `/` prefix\n   - Config option for strict mode preference (with or without slash)\n\n**Files likely affected:**\n- `lsp/` directory\n- VS Code extension if separate\n- TextMate grammar files for syntax highlighting\n\n**Testing:**\n- Open `.mld` file, verify bare directives highlighted\n- Open `.mld.md` file, verify only `/` directives highlighted\n- Verify error squiggles on text in strict mode","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T19:58:27.625577-08:00","updated_at":"2025-12-08T19:58:27.625577-08:00","dependencies":[{"issue_id":"mlld-om1","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.595916-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T19:59:14.906243-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-ah5","type":"blocks","created_at":"2025-12-08T20:59:32.37355-08:00","created_by":"daemon"}]}
{"id":"mlld-qxb","title":"cmd:path / sh:path for rooted commands","description":"One thing that both `cmd` and `sh` often need is to set the path for their operation. \n\n`cmd` intentionally disallows chaining which makes it impossible to just do `cd /some/dir \u0026\u0026 mycommand`\n\nBut given this is a common use case‚Äîand one which enforces security and clarity‚Äîwe should allow a way to set the path for `cmd` and `sh`\n\n```\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n/run sh:@mypath {echo \"hello world\"}\n/run cmd:@base/path/to/file {mycommand param}\n/run sh:/Users/@username/dev/@dir {somecommand --flag}\n```\n\nthe `:path` would be an option everywhere `sh` and `cmd` are used; if not set the path would be set to whatever the system defaults to currently (which has its own rules)","design":"## Design Overview\n\nThis feature adds `:path` syntax to `cmd` and language executors (`sh`, `bash`, `js`, `python`, etc.) to set the working directory for command execution.\n\n## Motivation\n\nCurrently, `cmd` intentionally disallows chaining (no `\u0026\u0026` inside `cmd {...}`), which makes it impossible to do:\n```\n/run cmd {cd /some/dir \u0026\u0026 mycommand}  # NOT ALLOWED\n```\n\nThe `:path` syntax provides a clean, explicit alternative that:\n1. Enforces security through validation\n2. Makes working directory changes explicit in the syntax\n3. Supports variable interpolation\n4. Maintains cmd's no-chaining principle\n\n## Syntax Examples\n\n```mlld\n# Absolute path\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n\n# Variable path\n/var @mypath = \"/tmp\"\n/run sh:@mypath {echo \"hello world\"}\n\n# Interpolated path\n/var @base = \"/Users/adam\"\n/run cmd:@base/dev/mlld {git status}\n\n# With multiple variables\n/run sh:/Users/@username/dev/@project {make test}\n\n# Works with all language executors\n/run bash:/tmp {pwd}\n/run js:/home/user/scripts {console.log(process.cwd())}\n/run python:@workspace {import os; print(os.getcwd())}\n```\n\n## Design Decisions\n\n### 1. Rooted Paths Only\n\nPaths MUST be rooted (absolute):\n- ‚úÖ `/tmp` - absolute path\n- ‚úÖ `@mypath` - variable (must resolve to absolute)\n- ‚úÖ `@base/subdir` - variable + path (variable must be absolute)\n- ‚ùå `./relative` - REJECTED\n- ‚ùå `relative` - REJECTED\n\n**Rationale**: Relative paths are ambiguous (relative to what?). Rooted paths are explicit and secure.\n\n### 2. Variable Interpolation\n\nVariables in paths are interpolated at runtime using existing `interpolate()` infrastructure:\n```mlld\n/var @user = \"alice\"\n/run cmd:/home/@user/work {ls}  # Resolves to /home/alice/work\n```\n\n**Rationale**: Consistent with how variables work elsewhere in mlld.\n\n### 3. Fail Fast Validation\n\nPath validation happens BEFORE command execution:\n1. Interpolate variables (error if undefined)\n2. Check path starts with `/` (error if not)\n3. Check directory exists (error if not)\n4. Check is directory not file (error if file)\n\n**Rationale**: Better error messages, prevents confusing command failures.\n\n### 4. No Security Policy (Yet)\n\nInitial implementation allows ANY absolute path the user has filesystem access to. Security policy integration is deferred to mlld-bgl.\n\n**Future**: Policy will allow restricting to specific path prefixes:\n```mlld\n/needs cmd.cwd:/Users/adam/dev/**  # Only allow paths under this\n```\n\n### 5. Scope is Per-Command\n\nThe `:path` only affects the specific command it's attached to, not global state:\n```mlld\n/run cmd:/tmp {pwd}        # runs in /tmp\n/run cmd {pwd}             # runs in default cwd\n/run @data | cmd:/app {process.sh}  # only process.sh runs in /app\n```\n\n**Rationale**: Explicit scope prevents action-at-a-distance bugs.\n\n## Implementation Order\n\nThe subtasks have dependencies:\n\n**Phase 1: Foundation (can be parallel)**\n1. mlld-u8r - Types (no dependencies)\n2. mlld-b0e - Grammar: WorkingDirPath pattern\n\n**Phase 2: Grammar Integration (depends on phase 1)**\n3. mlld-zgb - Grammar: cmd support (depends on mlld-b0e)\n4. mlld-rn5 - Grammar: sh/bash support (depends on mlld-b0e)\n\n**Phase 3: Runtime (depends on phase 1-2)**\n5. mlld-1x2 - cwd-resolver utility (depends on mlld-u8r)\n6. mlld-e0b - run evaluator (depends on mlld-1x2, mlld-u8r)\n7. mlld-7e7 - executors (depends on mlld-e0b)\n\n**Phase 4: Testing (depends on all)**\n8. mlld-k69 - comprehensive tests\n\n## Technical Architecture\n\n```\nGrammar Layer:\n  WorkingDirPath pattern ‚Üí parses :path syntax\n  ‚Üì\n  CmdCommandBrackets / RunLanguageCodeCore ‚Üí includes workingDir in AST\n  ‚Üì\nAST:\n  values.workingDir: ContentNodeArray (nodes with variables)\n  raw.workingDir: string (raw text)\n  meta.hasWorkingDir: boolean\n  meta.workingDirMeta: PathMeta\n  ‚Üì\nInterpreter:\n  run evaluator ‚Üí checks for workingDir in AST\n  ‚Üì\n  cwd-resolver ‚Üí interpolates variables, validates path\n  ‚Üì\n  executeCommand/executeCode ‚Üí passes cwd in options\n  ‚Üì\nExecutors:\n  ShellCommandExecutor / BashExecutor / etc ‚Üí use options.cwd || this.workingDirectory\n```\n\n## Error Handling\n\nClear, actionable error messages:\n\n```\nError: Cannot resolve working directory path\n  Path: /home/@username/dev\n  Reason: Variable @username is not defined\n  Location: example.mld:5:10\n```\n\n```\nError: Working directory must be an absolute path (start with /)\n  Provided: ./relative\n  Location: example.mld:8:15\n```\n\n```\nError: Working directory does not exist\n  Path: /nonexistent/directory\n  Location: example.mld:12:10\n```\n\n## Testing Strategy\n\n1. **Grammar tests**: Verify AST structure for various syntax forms\n2. **Valid cases**: Test execution with different path types\n3. **Invalid cases**: Test parse errors for unsupported syntax\n4. **Exception cases**: Test runtime errors for undefined vars, bad paths\n5. **Integration**: Test with loops, pipelines, different executors","notes":"Decisions: '/' allowed; paths must be absolute Unix; no Windows or '~'; reuse existing missing/non-dir path errors at runtime; :path applies to cmd/sh/etc including /exe forms like /exe @run(path, foo) = cmd:@path {...}.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T11:49:05.80685-08:00","updated_at":"2025-12-08T20:25:28.959279-08:00","closed_at":"2025-12-08T20:25:28.959279-08:00","labels":["creator:adamavenir@hey.com","epic","feature"],"dependencies":[{"issue_id":"mlld-qxb","depends_on_id":"mlld-b0e","type":"blocks","created_at":"2025-12-08T12:54:49.696952-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-zgb","type":"blocks","created_at":"2025-12-08T12:54:49.737084-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-rn5","type":"blocks","created_at":"2025-12-08T12:54:49.774931-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-u8r","type":"blocks","created_at":"2025-12-08T12:54:49.809626-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-1x2","type":"blocks","created_at":"2025-12-08T12:54:49.842686-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-e0b","type":"blocks","created_at":"2025-12-08T12:54:49.878847-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-7e7","type":"blocks","created_at":"2025-12-08T12:54:49.913983-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-k69","type":"blocks","created_at":"2025-12-08T12:54:49.949208-08:00","created_by":"daemon"}]}
{"id":"mlld-rn5","title":"Grammar: Extend RunLanguageCodeCore to support :path for sh/bash","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task extends language code execution (`sh`, `bash`, `js`, `python`, etc.) to support the `:path` suffix.\n\n## Prerequisites\n- mlld-b0e must be complete (WorkingDirPath pattern exists)\n\n## Task\nModify `RunLanguageCodeCore` to optionally parse and include working directory path for language executors.\n\n## Implementation\n\nLocation: `grammar/core/code.peggy`\n\n### Step 1: Add language with path pattern\n\n```peggy\n// Shared working directory pattern for language codes\nLanguageWorkingDirPath \"language working directory path\"\n  = \":\" path:WorkingDirPathContent {\n      return path;\n    }\n\n// Run language with optional working directory\nRunCodeLanguageWithPath\n  = language:RunCodeLanguage workingDir:LanguageWorkingDirPath? {\n      return {\n        language: language,\n        workingDir: workingDir || null\n      };\n    }\n```\n\n### Step 2: Modify RunLanguageCodeCore\n\nFind `RunLanguageCodeCore` pattern (around line 208) and update it to:\n1. Use `RunCodeLanguageWithPath` instead of `RunCodeLanguage`\n2. Extract `workingDir` from `langInfo`\n3. Add workingDir to values/raw/meta when present\n\n```peggy\nRunLanguageCodeCore\n  = streamPrefix:StreamKeyword? _ langInfo:RunCodeLanguageWithPath _ code:UnifiedCodeBrackets {\n      const language = langInfo.language;\n      const workingDir = langInfo.workingDir;\n      \n      // ... existing code to process language and code ...\n      \n      const values = {\n        lang: [langNode],\n        args: [],\n        code: [codeNode]\n      };\n      \n      if (workingDir) {\n        values.workingDir = workingDir.parts;\n      }\n      \n      const raw = {\n        lang: language,\n        args: [],\n        code: codeContent\n      };\n      \n      if (workingDir) {\n        raw.workingDir = workingDir.raw;\n      }\n      \n      const meta = {\n        isMultiLine: code.isMultiLine || codeContent.includes('\\n'),\n        language: language,\n        hasVariables: false,\n        hasWorkingDir: \\!\\!workingDir\n      };\n      \n      if (workingDir) {\n        meta.workingDirMeta = workingDir.meta;\n      }\n      \n      // ... rest of existing code ...\n    }\n```\n\n## Examples\n\n```mlld\n/run sh:/tmp {echo \"hello\"}\n/run bash:@mypath {pwd}\n/run js:/home/@user/scripts {console.log(process.cwd())}\n```\n\n## Testing\n\n```bash\nnpm run ast -- '/run sh:/tmp {echo hello}'\nnpm run ast -- '/run bash:@base {pwd}'\nnpm run ast -- '/run python:/scripts {print(1)}'\n```","notes":"RunLanguageCodeCore needs :path using WorkingDirPath; absolute Unix paths only ('/' ok); no Windows or '~'.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:18.829051-08:00","updated_at":"2025-12-08T20:23:54.14086-08:00","closed_at":"2025-12-08T20:23:54.14086-08:00"}
{"id":"mlld-sqt","title":"`log` folder should only be created if user sets a flag ","description":"Need to think about what the design for this is, but the current approach isn't great, and it's not even clear what is supposed to be going in `log` I just see them littering things whenever I run mlld files ‚Äî and the output that I've seen is empty!! ","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-07T13:44:47.291457-08:00","updated_at":"2025-12-08T12:17:37.089103-08:00","labels":["bug","creator:adamavenir@hey.com"]}
{"id":"mlld-tfb","title":"Tests: strict mode fixtures and regressions","description":"**Summary:**\nAdd comprehensive test coverage for strict mode parsing and execution.\n\n**New fixtures needed:**\n\n1. **Strict mode success cases** (`tests/cases/valid/strict/`):\n   - `bare-directives.mld` - directives without `/` prefix\n   - `optional-slash.mld` - directives WITH `/` prefix (backward compat)\n   - `mixed-slash.mld` - some with, some without `/`\n   - `blank-lines.mld` - blank lines as formatting (should be ignored)\n   - `all-directives.mld` - every directive type without slash\n\n2. **Strict mode error cases** (`tests/cases/invalid/strict/`):\n   - `text-line.mld` - plain text should error\n   - `prose-content.mld` - markdown prose should error\n   - `comment-looking-text.mld` - `# heading` (not a directive) should error\n\n3. **Markdown mode regressions** (`tests/cases/valid/markdown/`):\n   - Existing tests renamed to `.mld.md` to confirm they still work\n   - Or keep as `.mld` with explicit mode override for backward compat testing\n\n4. **Cross-mode imports** (`tests/cases/valid/imports/`):\n   - `strict-imports-markdown.mld` imports `helper.mld.md`\n   - `markdown-imports-strict.mld.md` imports `helper.mld`\n\n**Fixture structure:**\n```\ntests/cases/valid/strict/\n  bare-directives/\n    example.mld      # bare var, exe, show, etc.\n    expected.md      # output\ntests/cases/invalid/strict/\n  text-line/\n    example.mld      # \"This is text\"\n    error.md         # expected error pattern\n```\n\n**Testing approach:**\n- Run `npm run build:fixtures` to generate fixture JSON\n- Verify strict mode fixtures parse/execute correctly\n- Verify invalid strict cases produce clear errors","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:17.200221-08:00","updated_at":"2025-12-08T19:58:17.200221-08:00","dependencies":[{"issue_id":"mlld-tfb","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.543036-08:00","created_by":"daemon"},{"issue_id":"mlld-tfb","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.870957-08:00","created_by":"daemon"}]}
{"id":"mlld-u8r","title":"Types: Extend RunValues/RunRaw/RunMeta for workingDir","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task adds TypeScript type definitions for the new `workingDir` field in run directive AST nodes.\n\n## Prerequisites\nNone - this can be done independently, but grammar tasks (mlld-b0e, mlld-zgb, mlld-rn5) will reference these types.\n\n## Task\nExtend the run directive type definitions to include working directory fields.\n\n## Implementation\n\nLocation: `core/types/run.ts`\n\n### 1. Extend RunValues interface\n\nFind the `RunValues` interface and add:\n```typescript\nexport interface RunValues {\n  command?: ContentNodeArray;\n  lang?: TextNodeArray;\n  args?: VariableNodeArray;\n  code?: ContentNodeArray;\n  identifier?: VariableNodeArray;\n  withClause?: WithClause;\n  securityLabels?: DataLabel[];\n  workingDir?: ContentNodeArray;  // NEW: Working directory path parts\n}\n```\n\n### 2. Extend RunRaw interface\n\n```typescript\nexport interface RunRaw {\n  command?: string;\n  lang?: string;\n  args?: string[];\n  code?: string;\n  identifier?: string;\n  withClause?: WithClause;\n  securityLabels?: string;\n  workingDir?: string;  // NEW: Raw working directory string\n}\n```\n\n### 3. Extend RunMeta interface\n\n```typescript\nexport interface RunMeta {\n  isMultiLine?: boolean;\n  argumentCount?: number;\n  language?: string;\n  hasVariables?: boolean;\n  withClause?: WithClause;\n  securityLabels?: DataLabel[];\n  hasWorkingDir?: boolean;      // NEW: Flag indicating working dir is set\n  workingDirMeta?: PathMeta;    // NEW: Path metadata for working dir\n}\n```\n\n### 4. Check PathMeta import\n\nEnsure `PathMeta` is imported if not already:\n```typescript\nimport type { PathMeta } from './path'; // or wherever PathMeta is defined\n```\n\n## What These Fields Mean\n\n- `workingDir` in RunValues: Array of AST nodes (Text nodes and VariableReference nodes) that make up the path\n- `workingDir` in RunRaw: The raw string representation like \"/tmp\" or \"@base/scripts\"\n- `hasWorkingDir` in RunMeta: Boolean flag to quickly check if workingDir was specified\n- `workingDirMeta` in RunMeta: Metadata like `hasVariables: true`, `isAbsolute: true`, etc.\n\n## Testing\n\nAfter implementation:\n```bash\nnpm run build\n```\n\nShould compile without errors. The grammar implementation will use these types.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:23.658146-08:00","updated_at":"2025-12-08T20:24:10.118584-08:00","closed_at":"2025-12-08T20:24:10.118584-08:00"}
{"id":"mlld-vlw","title":"Docs: update for strict mode","description":"**Summary:**\nUpdate all documentation to reflect the two-mode system.\n\n**Files to update:**\n\n1. **llms.txt:**\n   - Add mode explanation at top\n   - Note that examples use strict mode (no `/` prefix)\n   - Reference `.mld.md` for prose-embedded scripts\n\n2. **docs/user/ files:**\n   - Add \"Execution Modes\" section to getting-started or new page\n   - Update examples to show both styles where relevant\n   - Clarify file extension semantics\n\n3. **docs/dev/GRAMMAR.md:**\n   - Document mode flag in parser options\n   - Explain optional slash parsing\n   - Document top-level line handling per mode\n\n4. **README.md:**\n   - Quick mention of file extensions and modes\n\n**Key messaging:**\n\n- `.mld` = code file, LLM-friendly, no implicit content\n- `.mld.md` = documentation file, prose becomes output\n- Optional `/` in strict mode for gradual migration\n- SDK raw strings default to strict\n\n**Example documentation:**\n\n```markdown\n## File Extensions\n\n| Extension | Mode     | Behavior |\n|-----------|----------|----------|\n| `.mld`    | strict   | Every line is a directive or blank. Text lines error. |\n| `.mld.md` | markdown | `/` required for directives. Text becomes content. |\n\n### Strict Mode (.mld)\n```mlld\nvar @name = \"World\"\nshow `Hello @name`\n```\n\n### Markdown Mode (.mld.md)\n```mlld\n# Welcome Script\n\nThis text becomes output.\n\n/var @name = \"World\"\n/show `Hello @name`\n```\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:40.507851-08:00","updated_at":"2025-12-08T19:58:40.507851-08:00","dependencies":[{"issue_id":"mlld-vlw","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.647573-08:00","created_by":"daemon"},{"issue_id":"mlld-vlw","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T19:59:14.957772-08:00","created_by":"daemon"}]}
{"id":"mlld-wrb","title":"Phase 1.3: Grammar - Simplify when oneliner syntax","description":"## Summary\n\nSimplify when oneliner syntax to not require brackets around the condition.\n\n## Current vs New Syntax\n\n```mlld\n# CURRENT (brackets around condition)\nwhen [@condition] =\u003e action\n\n# NEW (no brackets needed for oneliner)\nwhen @condition =\u003e action\n\n# Block form (unchanged)\nwhen [\n  @cond1 =\u003e action1\n  @cond2 =\u003e action2\n]\n```\n\n## Breaking Change\n\nThis simplifies the oneliner by removing unnecessary brackets. The block form remains unchanged.\n\n## Files to Modify\n\n- `grammar/directives/when.peggy` - Update oneliner pattern\n\n## Implementation\n\nThe oneliner should parse as:\n\n```peggy\nWhenOneliner \"when oneliner\"\n  = \"when\" _ condition:WhenCondition _ \"=\u003e\" _ action:WhenAction {\n      return {\n        type: 'WhenExpression',\n        subtype: 'oneliner',\n        values: {\n          conditions: [condition],\n          actions: [action]\n        },\n        // ... \n      };\n    }\n```\n\nKeep the block form parsing as-is.\n\n## Rationale\n\n- More concise syntax for simple conditionals\n- Consistent with other oneliners in the language\n- Block form still available for multi-condition cases\n\n## Testing\n\n```bash\nnpm run ast -- 'when @x \u003e 5 =\u003e \"big\"'      # oneliner (new)\nnpm run ast -- 'when [@x \u003e 5 =\u003e \"big\"]'    # block form (unchanged)\n```\n\n## Validation\n\n- [ ] Oneliner parses without brackets\n- [ ] Block form still works\n- [ ] Both forms produce correct AST","notes":"Simplified when simple form to accept bracketless oneliner. Grammar rebuild ok; block forms untouched.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:15:41.385926-08:00","updated_at":"2025-12-10T07:09:09.589955-08:00","closed_at":"2025-12-10T07:09:09.589956-08:00","dependencies":[{"issue_id":"mlld-wrb","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.1699-08:00","created_by":"daemon"}]}
{"id":"mlld-wsm","title":"Resolvers: propagate mode through imports","description":"**Summary:**\nWhen resolving imports, ensure the imported module is parsed with the correct mode based on its extension.\n\n**Changes required:**\n\n1. **Import resolution** (resolvers, likely `LocalResolver`, `RegistryResolver`, etc.):\n   - When resolving a module path, determine mode from resolved filepath extension\n   - Pass mode to parser when loading the imported module\n\n2. **Mode inheritance rules:**\n   - `.mld` imports ‚Üí strict mode\n   - `.mld.md` imports ‚Üí markdown mode\n   - The importing file's mode does NOT affect the imported file's mode\n   - Each file's extension determines its own mode\n\n3. **Dynamic modules:**\n   - String dynamic modules: default to `'strict'` (or accept mode option)\n   - Object dynamic modules: N/A (no parsing)\n\n4. **Edge cases:**\n   - Circular imports: mode still derived from extension\n   - Re-exports: mode of original source file applies\n\n**Testing:**\n- `.mld` file imports `.mld.md` file - each parses in correct mode\n- `.mld.md` file imports `.mld` file - each parses in correct mode\n- Dynamic module string defaults to strict","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:02.459003-08:00","updated_at":"2025-12-08T19:58:02.459003-08:00","dependencies":[{"issue_id":"mlld-wsm","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.504019-08:00","created_by":"daemon"},{"issue_id":"mlld-wsm","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.8354-08:00","created_by":"daemon"}]}
{"id":"mlld-x41","title":"Field access on JS-returned objects fails in for-loop source","description":"## Reproduction\n\n```mlld\n/exe @getData() = js { return { all: ['a','b','c'] } }\n/var @result = @getData()\n/show \"All: @result.all\"           # Works: [\"a\",\"b\",\"c\"]\n/for @item in @result.all =\u003e show @item  # FAILS: undefined\n```\n\n## Issue\n\nField access `@result.all` works in string interpolation but returns `undefined` when used as a /for loop source.\n\n## Expected\n\n`@result.all` should return the array `['a','b','c']` consistently in all contexts.\n\n## Context\n\nJS function returns object, gets stored as StructuredValue. Field access works for display but not for iteration.\n\nReported by: partydev.1","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-09T17:09:42.728504-08:00","updated_at":"2025-12-09T17:09:42.728504-08:00"}
{"id":"mlld-ytz","title":"Dynamic modules: mode selection for injected content","description":"**Summary:**\nEnsure dynamically injected modules respect mode settings.\n\n**Changes required:**\n\n1. **String dynamic modules**:\n   - `dynamicModules: { '@foo': 'var @x = 1' }` - needs to parse\n   - Default: `'strict'` mode (programmatic injection = code, not docs)\n   - Add option: `dynamicModuleMode?: 'strict' | 'markdown'`\n\n2. **Object dynamic modules**:\n   - `dynamicModules: { '@state': { count: 0 } }` - no parsing, N/A\n   - These become direct value exports, mode irrelevant\n\n3. **Per-module mode** (optional enhancement):\n   - Could support: `dynamicModules: { '@foo': { source: '...', mode: 'markdown' } }`\n   - Lower priority, probably not needed\n\n4. **Documentation**:\n   - Document that string dynamic modules parse in strict mode by default\n   - Explain how to opt into markdown mode if needed\n\n**Testing:**\n- String dynamic module with bare directives - parses in strict\n- String dynamic module with text content - errors (strict default)\n- String dynamic module with explicit markdown mode - text becomes content","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T20:56:53.299196-08:00","updated_at":"2025-12-08T20:56:53.299196-08:00","dependencies":[{"issue_id":"mlld-ytz","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.446397-08:00","created_by":"daemon"},{"issue_id":"mlld-ytz","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.25244-08:00","created_by":"daemon"}]}
{"id":"mlld-zce","title":"E2E smoke tests for Claude Code integration","description":"## Goal\n\nCreate E2E smoke tests that verify mlld works correctly when piping/passing data to Claude Code CLI, especially with complex escaping scenarios.\n\n## Requirements\n\n**Test location:** `tests/claude/` (separate from regular tests)\n**Run command:** `npm run test:claude` (NOT included in `npm test`)\n**Test type:** E2E using mlld SDK's `execute()` function (NOT unit tests with manual ExecInvocation construction)\n\n## Test Patterns to Cover\n\nFrom your list of escaping/piping scenarios:\n\n1. `/exe @func(value) = @value | cmd { claude -p --model haiku }`\n2. `/exe @func(value) = cmd { @value | claude -p --model haiku }`\n3. `/exe @func(value) = @other(value) | cmd { claude -p --model haiku }`\n4. `/exe @func(value) = js { return \"hi\" } | cmd { claude -p --model haiku }`\n5. `/exe @func(value) = cmd { echo \"hello\" } | cmd { claude -p --model haiku }`\n6. `/exe @func(value) = @value | cmd { claude -p } | cmd { claude -p \"wdyt?\" }`\n\n## Test Structure (E2E with SDK)\n\nWrite actual mlld files + TypeScript tests using SDK `execute()`:\n\n**tests/claude/scripts/pipe-value.mld:**\n```mlld\n/exe @claude(prompt) = @prompt | cmd { claude -p --model haiku }\n/var @response = @claude(\"Say only OK\")\n/show @response\n```\n\n**tests/claude/integration.test.ts:**\n```typescript\nimport { execute } from '@sdk/execute';\nimport path from 'node:path';\n\nconst shouldRun = process.env.MLLD_RUN_CLAUDE_TESTS === '1';\nconst describeTest = shouldRun ? describe : describe.skip;\n\ndescribeTest('Claude integration', () =\u003e {\n  it('pipes value through claude', async () =\u003e {\n    const script = path.join(__dirname, 'scripts/pipe-value.mld');\n    const result = await execute(script, {});\n    \n    expect(result.output.trim().length).toBeGreaterThan(0);\n    expect(result.output.toUpperCase()).toContain('OK');\n  }, 30000);\n});\n```\n\n## What gpt5.1 Got Wrong\n\nCreated unit tests with manual ExecInvocation construction instead of E2E tests using actual mlld files + SDK execute().","notes":"## Test Coverage\n\nCreated comprehensive E2E tests for Claude Code integration covering all 6 escaping/piping patterns:\n\n1. Pattern 1: @value | cmd { claude -p } - Pipes value through claude\n2. Pattern 2: cmd { claude -p \"@value\" } - Uses value inside cmd body\n3. Pattern 3: @other(value) | cmd { claude -p } - Pipes result from another function\n4. Pattern 4: js { return \"prompt\" } | cmd { claude -p } - Pipes js result through claude\n5. Pattern 5: cmd { echo \"prompt\" } | cmd { claude -p } - Pipes cmd result through claude\n6. Pattern 6: @value | cmd { claude -p } | cmd { claude -p \"followup\" } - Double pipe through claude\n\nAll tests use SDK execute() function (NOT manual ExecInvocation construction).\nAll 9 tests passing across 3 test files.\n\n## Files Created\n\n- tests/claude/escaping-patterns.test.ts (6 tests)\n- tmp/claude-test-*.mld (6 test scripts)\n- Fixed: tests/claude/exe-claude-pipeline.test.ts (corrected syntax)\n- Fixed: tests/claude/claude-sdk-smoke.mld (corrected model name)\n\n## Alias Resolution Behavior\n\nmlld resolves shell aliases for commands in cmd { } blocks via interpreter/utils/alias-resolver.ts.\n\nKey behavior:\n- ‚úÖ cmd { claude -p \"prompt\" } - Alias resolves (command at start of block)\n- ‚ùå cmd { echo \"x\" | claude -p } - Alias does NOT resolve (pipe INSIDE block)\n- ‚úÖ @value | cmd { claude -p } - Alias resolves (pipe OUTSIDE block)\n\nThe alias resolver runs on the top-level command of a cmd block, but not on commands after pipes within shell scripts. This is why pattern 2 uses cmd { claude -p \"@value\" } instead of cmd { echo \"@value\" | claude -p }.\n\n## Run Tests\n\nnpm run test:claude\nMLLD_RUN_CLAUDE_TESTS=1 CLAUDE_MODEL=haiku vitest run tests/claude","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-09T18:43:47.625059-08:00","updated_at":"2025-12-09T19:25:44.599803-08:00","closed_at":"2025-12-09T19:17:24.767804-08:00"}
{"id":"mlld-zeo","title":"Phase 2.1: Interpreter - Export let functions from when.ts","description":"## Summary\n\nExport the existing let/augmented assignment evaluation functions from when.ts so they can be reused by exe and for block evaluators.\n\n## üìö Required Reading\n\nBefore starting Phase 2 interpreter work:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Return values should preserve wrappers\n\n## Why This Matters\n\nThe plan identifies that exe blocks are ~80% the same as exe..when. The let/augmented assignment logic already exists and works - we just need to export it for reuse.\n\n## Files to Modify\n\n- `interpreter/eval/when.ts` - Export helper functions\n\n## Implementation\n\nChange from private to exported functions (around lines 31 and 66):\n\n```typescript\n// Change: async function evaluateLetAssignment(...)\n// To: export async function evaluateLetAssignment(...)\n\nexport async function evaluateLetAssignment(\n  entry: LetAssignmentNode,\n  env: Environment\n): Promise\u003cEnvironment\u003e {\n  // ... existing implementation unchanged\n}\n\nexport async function evaluateAugmentedAssignment(\n  entry: AugmentedAssignmentNode,\n  env: Environment\n): Promise\u003cEnvironment\u003e {\n  // ... existing implementation unchanged\n}\n```\n\n## Key Implementation Details\n\nFrom when.ts (lines 31-112):\n- `evaluateLetAssignment()` creates child environment with new binding\n- `evaluateAugmentedAssignment()` finds existing let variable and mutates\n- Both return new Environment (immutable pattern)\n\n## Augmented Assignment Semantics (lines 66-112)\n\n- Arrays: concat (`[1, 2] += 3` ‚Üí `[1, 2, 3]`, `[1] += [2, 3]` ‚Üí `[1, 2, 3]`)\n- Strings: append (`\"hello\" += \" world\"` ‚Üí `\"hello world\"`)\n- Objects: shallow merge (`{a: 1} += {b: 2}` ‚Üí `{a: 1, b: 2}`)\n- Only works with local `let` bindings (not global variables)\n\n## Testing\n\nAfter export, verify imports work:\n\n```typescript\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n```\n\n## Validation\n\n- [ ] Functions exported without breaking existing when evaluation\n- [ ] Type signatures remain unchanged\n- [ ] All existing when tests still pass","notes":"Export let/augmented assignment helpers for reuse by exe/for block evaluators; ensure local block lets/augments can be created and resolved during block execution.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:54.131728-08:00","updated_at":"2025-12-10T03:02:43.222899-08:00","dependencies":[{"issue_id":"mlld-zeo","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:51.792231-08:00","created_by":"daemon"}]}
{"id":"mlld-zgb","title":"Grammar: Extend CmdCommandBrackets to support optional :path","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task extends the `CmdCommandBrackets` pattern to accept the optional `:path` suffix.\n\n## Prerequisites\n- mlld-b0e must be complete (WorkingDirPath pattern exists)\n\n## Task\nModify `CmdCommandBrackets` to optionally parse and include working directory path.\n\n## Implementation\n\nLocation: `grammar/patterns/unified-run-content.peggy`\n\nCurrent code (around line 84-87):\n```peggy\nCmdCommandBrackets \"cmd command brackets\"\n  = \"cmd\" _ content:UnifiedCommandBrackets {\n      return content;\n    }\n```\n\nChange to:\n```peggy\nCmdCommandBrackets \"cmd command brackets\"\n  = \"cmd\" workingDir:WorkingDirPath? _ content:UnifiedCommandBrackets {\n      const result = content;\n      if (workingDir) {\n        result.values.workingDir = workingDir.parts;\n        result.raw.workingDir = workingDir.raw;\n        result.meta.hasWorkingDir = true;\n        result.meta.workingDirMeta = workingDir.meta;\n      }\n      return result;\n    }\n```\n\n## What This Does\n\n1. Optionally matches `WorkingDirPath` after `cmd` keyword\n2. If present, adds to the result node:\n   - `values.workingDir` - AST node array for interpreter\n   - `raw.workingDir` - raw string for debugging/display\n   - `meta.hasWorkingDir` - boolean flag\n   - `meta.workingDirMeta` - path metadata (hasVariables, etc)\n\n## Testing\n\nAfter implementation:\n```bash\nnpm run ast -- '/run cmd:/tmp {ls}'\nnpm run ast -- '/run cmd:@mypath {pwd}'\nnpm run ast -- '/run cmd {ls}'  # without path still works\n```\n\nCheck the AST output has `workingDir` field in values/raw/meta when path is present.","notes":"Cmd :path grammar uses WorkingDirPath pattern; accepts absolute Unix paths only ('/' ok); no Windows or '~'.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:13.204118-08:00","updated_at":"2025-12-08T20:23:39.467487-08:00","closed_at":"2025-12-08T20:23:39.467487-08:00"}
