{"id":"mlld-1x2","title":"Interpreter: Create cwd-resolver utility for path validation","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task creates a utility function to resolve and validate working directory paths before command execution.\n\n## Prerequisites\n- Grammar tasks complete (workingDir is in AST)\n- Type tasks complete (workingDir types defined)\n\n## Task\nCreate `interpreter/utils/cwd-resolver.ts` to handle path interpolation and validation.\n\n## Requirements\n\nThe resolver must:\n1. Interpolate variables in the path (`@mypath`, `/home/@user/dev`)\n2. Validate path is rooted (starts with `/`)\n3. Check directory exists\n4. Check path is actually a directory (not a file)\n5. Return absolute path or throw clear errors\n\n## Implementation\n\nCreate new file: `interpreter/utils/cwd-resolver.ts`\n\n```typescript\nimport * as fs from 'fs';\nimport type { ContentNodeArray } from '@core/types';\nimport type { Environment } from '../env/Environment';\nimport { interpolate, InterpolationContext } from '../core/interpreter';\nimport { MlldCommandExecutionError } from '@core/errors';\n\nexport async function resolveCwd(\n  workingDirNodes: ContentNodeArray,\n  env: Environment,\n  sourceLocation?: any\n): Promise\u003cstring\u003e {\n  // Step 1: Interpolate variables\n  const interpolatedPath = await interpolate(\n    workingDirNodes,\n    env,\n    undefined,\n    { context: InterpolationContext.FilePath }\n  );\n  \n  // Step 2: Validate rooted (absolute) path\n  if (!interpolatedPath.startsWith('/')) {\n    throw new MlldCommandExecutionError(\n      `Working directory must be an absolute path (start with /): ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  // Step 3: Check directory exists\n  if (!fs.existsSync(interpolatedPath)) {\n    throw new MlldCommandExecutionError(\n      `Working directory does not exist: ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  // Step 4: Check is directory\n  const stats = fs.statSync(interpolatedPath);\n  if (!stats.isDirectory()) {\n    throw new MlldCommandExecutionError(\n      `Working directory path is not a directory: ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  return interpolatedPath;\n}\n```\n\n## Error Messages\n\nProvide clear errors for common issues:\n- Undefined variable: \"Cannot resolve working directory: variable @username is not defined\"\n- Not rooted: \"Working directory must be an absolute path (start with /): ./relative\"\n- Doesn't exist: \"Working directory does not exist: /nonexistent/path\"\n- Not a directory: \"Working directory path is not a directory: /etc/hosts\"\n\n## Testing\n\nCreate unit tests in `interpreter/utils/cwd-resolver.test.ts`:\n```typescript\ndescribe('resolveCwd', () =\u003e {\n  it('should resolve absolute path', async () =\u003e {\n    // Test with /tmp\n  });\n  \n  it('should interpolate variables', async () =\u003e {\n    // Test with @mypath variable\n  });\n  \n  it('should error on non-rooted path', async () =\u003e {\n    // Test ./relative fails\n  });\n  \n  it('should error on non-existent path', async () =\u003e {\n    // Test /does/not/exist fails\n  });\n  \n  it('should error on file path', async () =\u003e {\n    // Test /etc/hosts fails (is file not dir)\n  });\n});\n```","notes":"Validation rules: absolute Unix paths only (/ ok); no Windows or '~'; reuse existing path error pattern on missing/non-dir; supports variable interpolation before validation.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:30.564083-08:00","updated_at":"2025-12-08T20:24:26.808179-08:00","closed_at":"2025-12-08T20:24:26.808179-08:00"}
{"id":"mlld-1zd","title":"Analyzer: mode-aware parsing and cache keys","description":"**Summary:**\nEnsure `analyzeModule` respects file extension mode and caches correctly.\n\n**Changes required:**\n\n1. **Mode inference**:\n   - `analyzeModule(filepath)` should infer mode from extension\n   - Add optional `mode` parameter to override\n\n2. **Parser call**:\n   - Pass inferred/explicit mode to parser\n   - Analyzer should parse `.mld` in strict mode, `.mld.md` in markdown mode\n\n3. **Cache keys**:\n   - Include mode in analyzer cache key (if analyzer has its own cache)\n   - Or ensure it uses the shared AST cache which already includes mode (per mlld-ah5)\n\n4. **Analysis results**:\n   - No change to ModuleAnalysis structure needed\n   - Mode affects parsing only, not analysis output\n\n**Testing:**\n- Analyze `.mld` file with bare directives - succeeds\n- Analyze `.mld` file with text content - reports parse error\n- Analyze `.mld.md` file with prose - succeeds","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T20:56:43.129243-08:00","updated_at":"2025-12-08T20:56:43.129243-08:00","dependencies":[{"issue_id":"mlld-1zd","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.407032-08:00","created_by":"daemon"},{"issue_id":"mlld-1zd","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.213788-08:00","created_by":"daemon"}]}
{"id":"mlld-3bl","title":"Grammar: when-expressions fail with 3+ conditions (comparison + 2 method calls)","description":"Detailed investigation of grammar parsing bug where when-expressions with specific condition combinations fail to parse","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-06T12:16:03.302262-08:00","updated_at":"2025-12-06T18:47:29.68001-08:00","closed_at":"2025-12-06T18:47:29.68001-08:00"}
{"id":"mlld-3ma","title":"Migration: lint warning for prose in .mld files","description":"**Summary:**\nHelp users migrate by warning when `.mld` files contain prose that will error in strict mode.\n\n**Changes required:**\n\n1. **Lint rule / diagnostic**:\n   - Scan `.mld` files for lines that would be text content\n   - Emit warning: \"This file contains prose on line X. Rename to .mld.md or remove text.\"\n\n2. **CLI flag**:\n   - `mlld lint --check-mode` or similar\n   - Could be part of `mlld check` if that exists\n\n3. **Error message enhancement**:\n   - When strict mode parser errors on text, include helpful message:\n   - \"Text content not allowed in .mld files. Either:\\n  1. Rename to .mld.md to embed prose\\n  2. Remove or comment out text lines\"\n\n4. **Migration script** (optional):\n   - `mlld migrate --to-strict` - rename files and report issues\n   - Low priority, users can do this manually\n\n**Testing:**\n- Lint `.mld` file with prose - warns with line numbers\n- Lint clean `.mld` file - no warnings\n- Error message on strict parse failure includes migration hint","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T20:57:14.29758-08:00","updated_at":"2025-12-08T20:57:14.29758-08:00","dependencies":[{"issue_id":"mlld-3ma","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.522074-08:00","created_by":"daemon"},{"issue_id":"mlld-3ma","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T20:59:32.324654-08:00","created_by":"daemon"}]}
{"id":"mlld-4cs","title":"Short urls for every beads task","description":"`/bd/proj-id` should jump straight to a project's card.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T15:15:37.642987-08:00","updated_at":"2025-12-07T19:33:09.48891-08:00","closed_at":"2025-12-07T19:33:09.48891-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-4zy","title":"Formatter: mode-aware slash prefix handling","description":"**Summary:**\nFormatter should emit appropriate slash prefix based on mode.\n\n**Changes required:**\n\n1. **Mode detection**:\n   - Formatter receives mode from file extension or explicit option\n   - Track mode throughout formatting pass\n\n2. **Directive formatting**:\n   - Markdown mode: always emit `/` prefix on directives\n   - Strict mode: configurable behavior:\n     - Option A: emit bare directives (no `/`)\n     - Option B: preserve input style (if had `/`, keep it)\n     - Option C: always emit `/` for compatibility\n   - Recommend Option A as default, Option B for `--preserve-style`\n\n3. **Blank line handling**:\n   - Strict mode: blank lines are formatting whitespace, preserve for readability\n   - Markdown mode: blank lines may be content, preserve carefully\n\n4. **Config option**:\n   - `strictModeSlash: 'omit' | 'preserve' | 'include'`\n   - Or simpler: `--bare-directives` flag for strict mode\n\n**Testing:**\n- Format `.mld` file - outputs bare directives (if Option A)\n- Format `.mld.md` file - outputs `/` prefixed directives\n- Format `.mld` with mixed slash usage - normalizes per config","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T20:57:03.568773-08:00","updated_at":"2025-12-08T20:57:03.568773-08:00","dependencies":[{"issue_id":"mlld-4zy","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.486165-08:00","created_by":"daemon"},{"issue_id":"mlld-4zy","depends_on_id":"mlld-gj7","type":"blocks","created_at":"2025-12-08T20:59:32.287836-08:00","created_by":"daemon"}]}
{"id":"mlld-5n7","title":"Interpreter: thread mode through parser invocation","description":"**Summary:**\nWire the mode flag from entry points through to the parser, with extension-based defaults.\n\n**Changes required:**\n\n1. **Extension → mode mapping** (likely in `services/PathService.ts` or new utility):\n   ```typescript\n   function getModeFromPath(filepath: string): 'strict' | 'markdown' {\n     if (filepath.endsWith('.mld.md') || filepath.endsWith('.md')) return 'markdown';\n     if (filepath.endsWith('.mld')) return 'strict';\n     return 'markdown'; // fallback for unknown\n   }\n   ```\n\n2. **Entry points to update:**\n   - `processMlld(script, options)` - add `mode` option, default `'strict'` for raw strings\n   - `interpret(script, options)` - thread mode to parser\n   - `execute(filepath, payload, options)` - derive mode from extension\n   - CLI entry point - derive mode from input file extension\n\n3. **Parser invocation** (wherever `parse()` is called):\n   ```typescript\n   const ast = parse(source, { \n     ...existingOptions,\n     mode: options.mode ?? getModeFromPath(options.filePath) \n   });\n   ```\n\n4. **Options types** (`types/` or relevant interface files):\n   - Add `mode?: 'strict' | 'markdown'` to ProcessOptions, InterpretOptions, ExecuteOptions\n\n**Testing:**\n- Unit test: `.mld` file parses in strict mode\n- Unit test: `.mld.md` file parses in markdown mode\n- Unit test: raw string defaults to strict\n- Unit test: explicit mode option overrides extension inference","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-08T19:57:44.878318-08:00","updated_at":"2025-12-08T19:57:44.878318-08:00","dependencies":[{"issue_id":"mlld-5n7","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.431674-08:00","created_by":"daemon"},{"issue_id":"mlld-5n7","depends_on_id":"mlld-gj7","type":"blocks","created_at":"2025-12-08T19:59:14.754308-08:00","created_by":"daemon"}]}
{"id":"mlld-5qm","title":"Make @mlld/stream-claude-agent-sdk module work with single-quoted templates","description":"The published module @mlld/stream-claude-agent-sdk uses double-quoted templates which get interpolated as mlld variables during import. Need to republish with single-quoted templates and test.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T20:50:05.396861-08:00","updated_at":"2025-12-08T02:53:01.835237-08:00","closed_at":"2025-12-08T02:53:01.835237-08:00"}
{"id":"mlld-5x5","title":"SDK/CLI: expose mode option and set defaults","description":"**Summary:**\nExpose `mode` option in SDK APIs and CLI, with sensible defaults.\n\n**SDK changes:**\n\n1. **processMlld(script, options)**:\n   - Add `mode?: 'strict' | 'markdown'` to options\n   - Default: `'strict'` when no `filePath` provided (raw strings)\n   - Default: infer from extension when `filePath` provided\n\n2. **interpret(script, options)**:\n   - Add `mode` option, same defaults as processMlld\n\n3. **execute(filepath, payload, options)**:\n   - Add `mode` option\n   - Default: infer from filepath extension\n   - Explicit option overrides inference\n\n4. **Type exports**:\n   - Export `MlldMode = 'strict' | 'markdown'` type\n\n**CLI changes:**\n\n1. **Flag**: `--mode \u003cstrict|markdown\u003e`\n   - Overrides extension-based inference\n   - Useful for testing or unusual file extensions\n\n2. **Extension inference**:\n   - `.mld` → strict\n   - `.mld.md` / `.md` → markdown\n   - stdin without `--mode` → strict (matches SDK raw string default)\n\n3. **Help text**:\n   - Document mode flag and extension defaults\n\n**Testing:**\n- SDK: raw string without filePath uses strict\n- SDK: `.mld` file uses strict\n- SDK: `.mld.md` file uses markdown\n- SDK: explicit mode overrides extension\n- CLI: `--mode markdown` on `.mld` file uses markdown\n- CLI: stdin defaults to strict","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-08T20:56:33.43397-08:00","updated_at":"2025-12-08T20:56:33.43397-08:00","dependencies":[{"issue_id":"mlld-5x5","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.360437-08:00","created_by":"daemon"},{"issue_id":"mlld-5x5","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.172773-08:00","created_by":"daemon"}]}
{"id":"mlld-5y6","title":"Docs: clarify pipeline data shape vs parallel stage output","description":"Docs promise StructuredValue pipeline stages, but still mention parallel groups handing JSON array strings to next stage. Validate actual behavior and update docs to reflect structured pipeline inputs/outputs (including parallel aggregation semantics) once aligned with executor/state machine.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:40:56.370878-08:00","updated_at":"2025-12-08T19:40:56.370878-08:00"}
{"id":"mlld-7e7","title":"Executors: Add cwd support to CommandExecutionOptions and executors","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task adds `cwd` support to the command executor options and modifies all executors to use it.\n\n## Prerequisites\n- mlld-e0b in progress or complete (run evaluator passing cwd)\n\n## Task\n1. Add `cwd?: string` to `CommandExecutionOptions` interface\n2. Modify all executors to use `options.cwd` when provided\n\n## Implementation\n\n### Step 1: Update CommandExecutionOptions interface\n\nLocation: `interpreter/env/executors/BaseCommandExecutor.ts` (or wherever CommandExecutionOptions is defined)\n\nFind the interface (likely around line 10-20):\n```typescript\nexport interface CommandExecutionOptions {\n  env?: Record\u003cstring, string\u003e;\n  timeout?: number;\n  captureOutput?: boolean;\n  // ... other options\n  cwd?: string;  // NEW: Optional working directory\n}\n```\n\n### Step 2: Modify ShellCommandExecutor\n\nLocation: `interpreter/env/executors/ShellCommandExecutor.ts`\n\nFind where `spawn` is called (likely around line 340):\n\n**Before:**\n```typescript\nconst child = spawn(safeCommand, {\n  cwd: this.workingDirectory,\n  env,\n  shell: true,\n  // ...\n});\n```\n\n**After:**\n```typescript\nconst child = spawn(safeCommand, {\n  cwd: options?.cwd || this.workingDirectory,  // Use options.cwd if provided\n  env,\n  shell: true,\n  // ...\n});\n```\n\nAlso find the `execAsync` call (around line 297) and update similarly:\n```typescript\nconst { stdout, stderr } = await execAsync(finalCommand, {\n  encoding: 'utf8',\n  cwd: options?.cwd || this.workingDirectory,  // Use options.cwd if provided\n  env: { ...process.env, ...(options?.env || {}) },\n  maxBuffer: 10 * 1024 * 1024\n});\n```\n\n### Step 3: Modify BashExecutor\n\nLocation: `interpreter/env/executors/BashExecutor.ts`\n\nApply the same pattern - find spawn calls and update cwd:\n```typescript\ncwd: options?.cwd || this.workingDirectory\n```\n\n### Step 4: Modify other executors\n\nCheck and update these if they execute processes:\n- `NodeExecutor.ts` - for `/run js {}`\n- `PythonExecutor.ts` - for `/run python {}`\n- `JavaScriptExecutor.ts` - if separate from NodeExecutor\n\nFor each, find where child processes are spawned and apply:\n```typescript\ncwd: options?.cwd || this.workingDirectory\n```\n\n## Pattern\n\nThe pattern is consistent across all executors:\n1. Check if `options?.cwd` is provided\n2. If yes, use it\n3. If no, fall back to `this.workingDirectory` (existing behavior)\n\n## Testing\n\nAfter implementation, test that cwd is actually used:\n\n```bash\necho '/run cmd:/tmp {pwd}' | ./dist/cli.cjs\n# Should output: /tmp\n\necho '/run sh:/home {pwd}' | ./dist/cli.cjs  \n# Should output: /home (if exists)\n```\n\nCheck that commands without cwd still work:\n```bash\necho '/run cmd {pwd}' | ./dist/cli.cjs\n# Should output: current working directory\n```","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:42.69404-08:00","updated_at":"2025-12-08T20:24:57.116324-08:00","closed_at":"2025-12-08T20:24:57.116324-08:00"}
{"id":"mlld-8ml","title":"Pipeline state machine uses text channel instead of structured values","description":"PipelineExecutor loops state machine transitions on the .text string while stage inputs/outputs are StructuredValue. State machine START/STAGE_RESULT transitions only see text, so metadata/provenance/security are invisible to control flow and retries. Align state machine payloads with structured values (or dual channel) so pipeline retries and downstream guards use full data.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-08T19:40:41.102258-08:00","updated_at":"2025-12-08T19:40:41.102258-08:00"}
{"id":"mlld-ah5","title":"Cache: include mode in AST cache keys","description":"**Summary:**\nEnsure AST cache doesn't return wrong-mode cached AST.\n\n**Changes required:**\n\n1. **Locate AST cache** (likely in interpreter or execute flow):\n   - Find where parsed ASTs are cached by filepath\n\n2. **Update cache key**:\n   ```typescript\n   // Before\n   const cacheKey = filepath;\n   \n   // After\n   const cacheKey = `${filepath}:${mode}`;\n   ```\n   \n   Or use a composite key object if the cache supports it.\n\n3. **Cache invalidation**:\n   - Same file parsed with different mode = different cache entries\n   - mtime-based invalidation still applies per entry\n\n**Testing:**\n- Parse same file in strict mode, cache hit\n- Parse same file in markdown mode, cache miss (different key)\n- Modify file, both cache entries invalidate","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:57:52.664361-08:00","updated_at":"2025-12-08T19:57:52.664361-08:00","dependencies":[{"issue_id":"mlld-ah5","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.46839-08:00","created_by":"daemon"},{"issue_id":"mlld-ah5","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.797125-08:00","created_by":"daemon"}]}
{"id":"mlld-b0e","title":"Grammar: Add WorkingDirPath pattern for :path suffix parsing","description":"## Context\nPart of implementing cmd:path/sh:path feature to allow setting working directory for command execution.\n\nExample syntax:\n```mlld\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n/run sh:@mypath {echo \"hello world\"}\n/run cmd:@base/scripts {./build.sh}\n/run sh:/Users/@username/dev/@dir {somecommand}\n```\n\n## Task\nCreate a new grammar pattern `WorkingDirPath` to parse the `:path` suffix that appears after `cmd` or language keywords (`sh`, `bash`, etc).\n\n## Requirements\n\n1. Path must be rooted (absolute) - starts with `/` or `@`\n2. Support variable interpolation: `@mypath`, `@base/subdir`, `/home/@user/dev`\n3. No relative paths allowed (no `./` or bare names)\n\n## Implementation\n\nLocation: `grammar/patterns/unified-run-content.peggy`\n\nAdd these patterns:\n\n```peggy\n// Working directory path suffix for cmd and sh\nWorkingDirPath \"working directory path\"\n  = \":\" path:WorkingDirPathContent {\n      return path;\n    }\n\n// Path content with variable interpolation\nWorkingDirPathContent\n  = parts:WorkingDirPathPart+ {\n      const flatParts = parts.flat();\n      const raw = helpers.reconstructRawString(flatParts);\n      \n      return {\n        type: 'workingDir',\n        parts: flatParts,\n        raw: raw,\n        meta: helpers.createPathMetadata(raw, flatParts)\n      };\n    }\n\n// Individual path parts - variables or literal path segments\nWorkingDirPathPart\n  = UnifiedVariableNoTail       // @mypath or @base etc.\n  / WorkingDirPathLiteral       // /path/segments\n\n// Literal path segments (no whitespace, not braces)\nWorkingDirPathLiteral\n  = chars:WorkingDirPathChar+ {\n      return helpers.createNode(NodeType.Text, { \n        content: chars.join(''), \n        location: location() \n      });\n    }\n\nWorkingDirPathChar\n  = [^\\s\\t\\n\\r\\{\\}@]  // Any char except whitespace, braces, @\n```\n\n## Key Points\n\n- Reuse `UnifiedVariableNoTail` for variable parsing (already exists)\n- Return structure with `parts` (AST nodes) and `raw` (string)\n- Use `helpers.createPathMetadata()` to create metadata\n- Must stop at whitespace or `{` (command block start)\n\n## Testing\n\nAfter implementation, test with `npm run ast`:\n```bash\nnpm run ast -- 'cmd:/absolute/path {ls}'\nnpm run ast -- 'cmd:@variable {ls}'\nnpm run ast -- 'cmd:@base/subdir {ls}'\n```","notes":"Grammar pattern should parse :path suffix for cmd/sh etc; path content allows absolute Unix paths only; no Windows or '~'; '/' valid.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:06.303866-08:00","updated_at":"2025-12-08T20:23:24.305345-08:00","closed_at":"2025-12-08T20:23:24.305345-08:00"}
{"id":"mlld-bgl","title":"Security: Policy-based working directory path restrictions","description":"Add security policy support for restricting working directory paths in cmd:path/sh:path syntax.\n\n## Background\nCurrently cmd:path and sh:path allow any absolute path the user has filesystem access to. We need policy-based restrictions to:\n- Define allowed path prefixes (e.g., only /Users/adam/dev/)\n- Prevent access to sensitive directories (/etc, /root, etc.)\n- Support guards that test path compliance before execution\n\n## Requirements\n1. Extend security policy to include working directory constraints\n2. Add path validation against policy in cwd-resolver\n3. Create guards that can inspect and approve/deny workingDir\n4. Clear error messages when path violates policy\n\n## Examples\nPolicy:\n```\n/needs cmd.cwd:/Users/adam/dev/**\n```\n\nGuard:\n```\n/guard [cmd.cwd =\u003e {\n  # Validate working directory is within allowed paths\n}]\n```\n\nThis issue should be tackled after the basic cmd:path/sh:path feature is implemented and working.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T12:53:10.831611-08:00","updated_at":"2025-12-08T12:53:10.831611-08:00","labels":["future","security"]}
{"id":"mlld-d0p","title":"Use the SDK's analyze module function to extract the required base-level `/needs` and check them against the user's module when publishing","description":"If the user doesn't have required items listed, we should suggest `/needs` and suggest they break it up into `/wants` tiers if there is a requirement hierarchy.\n\nThis issue needs to be thought through in more depth.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-07T13:50:42.30443-08:00","updated_at":"2025-12-08T12:20:15.296359-08:00","labels":["creator:adamavenir@hey.com"]}
{"id":"mlld-e0b","title":"Interpreter: Modify run evaluator to resolve and pass cwd","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task modifies the run evaluator to check for workingDir in the AST, resolve it, and pass it to command executors.\n\n## Prerequisites\n- mlld-1x2 complete (cwd-resolver exists)\n- mlld-u8r complete (workingDir types defined)\n- Grammar tasks complete (workingDir in AST)\n\n## Task\nModify `interpreter/eval/run.ts` to handle the optional `workingDir` field from the AST.\n\n## Implementation\n\nLocation: `interpreter/eval/run.ts`\n\n### Step 1: Import the resolver\n\nAdd import at top of file:\n```typescript\nimport { resolveCwd } from '../utils/cwd-resolver';\n```\n\n### Step 2: Find command execution locations\n\nLook for calls to:\n- `env.executeCommand()`\n- `env.executeCode()`\n\nThese are likely in functions like:\n- `evaluateRunCommand()` - for `cmd {...}`\n- `evaluateRunCode()` - for `sh {...}`, `bash {...}`, etc.\n\n### Step 3: Add cwd resolution before execution\n\nFor each execution point, add cwd resolution:\n\n```typescript\n// Check if workingDir is present in AST\nlet resolvedCwd: string | undefined;\nif (node.values?.workingDir) {\n  resolvedCwd = await resolveCwd(\n    node.values.workingDir,\n    env,\n    node.location\n  );\n}\n\n// Pass to executor\nconst result = await env.executeCommand(command, {\n  ...existingOptions,\n  cwd: resolvedCwd\n});\n```\n\n### Step 4: Handle both cmd and code execution\n\nMake sure both paths are covered:\n\n**For cmd execution:**\n```typescript\nconst result = await env.executeCommand(command, {\n  env: envVars,\n  cwd: resolvedCwd,  // NEW\n  // ... other options\n});\n```\n\n**For code execution (sh, bash, js, python):**\n```typescript\nconst result = await env.executeCode(language, code, {\n  args: resolvedArgs,\n  cwd: resolvedCwd,  // NEW\n  // ... other options\n});\n```\n\n## Edge Cases\n\n1. **workingDir is optional**: Only resolve if present in AST\n2. **Error propagation**: Let `resolveCwd` errors bubble up naturally\n3. **Pipeline context**: Each command gets its own cwd resolution\n\n## Testing\n\nAfter implementation, test with actual mlld scripts:\n\n```bash\necho '/var @mypath = \"/tmp\"\n/run cmd:@mypath {pwd}' | ./dist/cli.cjs\n\n# Should output: /tmp\n```\n\n```bash\necho '/run cmd:/nonexistent {ls}' | ./dist/cli.cjs\n\n# Should error: Working directory does not exist\n```","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:35.93044-08:00","updated_at":"2025-12-08T20:24:42.061534-08:00","closed_at":"2025-12-08T20:24:42.061534-08:00"}
{"id":"mlld-fzr","title":"init incorrectly names files `.mlld.md` instead of `.mld.md`","description":"We don't want `.mlld` or `.mlld.md` to become standard -- just `.mld` and `.mld.md` ","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T05:17:57.376218-08:00","updated_at":"2025-12-08T12:18:32.986333-08:00","closed_at":"2025-12-08T12:18:32.986333-08:00","labels":["creator:adamavenir@hey.com"]}
{"id":"mlld-gj7","title":"Grammar: add mode flag and optional slash prefix","description":"**Summary:**\nAdd a `mode: 'strict' | 'markdown'` option to the parser and make the leading `/` optional on directives.\n\n**Changes required:**\n\n1. **Parser options** (`grammar/parser/index.ts` or entry point):\n   - Accept `mode` option, default to `'markdown'` for backward compat during transition\n   - Thread mode into grammar context\n\n2. **Grammar helper** (`grammar/deps/grammar-core.ts`):\n   - Replace `isSlashDirectiveContext` with `isDirectiveContext`\n   - In both modes, match optional `/` followed by directive keyword at line start\n   - The difference is handled at top-level line classification, not here\n\n3. **Directive rules** (`grammar/mlld.peggy` or modular files):\n   - Change directive prefix from `\"/\"` to `\"/\"?`\n   - All directives: var, exe, run, show, for, when, import, export, guard, output, log, append, stream, needs, wants\n   - Keep semantic actions unchanged\n\n4. **Top-level line rule**:\n   ```peggy\n   Line \n     = Directive\n     / BlankLine\n     / \u0026{ return options.mode === 'markdown' } TextLine\n     / \u0026{ return options.mode === 'strict' } StrictModeTextError\n   \n   StrictModeTextError = (!Directive .)+ { \n     error(\"Text content not allowed in strict mode (.mld). Use .mld.md for prose.\") \n   }\n   ```\n\n5. **Blank line handling**:\n   - Strict mode: blank lines are whitespace, produce no AST node\n   - Markdown mode: blank lines may become content nodes (current behavior)\n\n**Testing:**\n- Add grammar unit tests for optional slash parsing\n- Verify existing tests pass with mode='markdown'","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-08T19:57:33.602447-08:00","updated_at":"2025-12-08T19:57:33.602447-08:00","dependencies":[{"issue_id":"mlld-gj7","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.389438-08:00","created_by":"daemon"}]}
{"id":"mlld-k4k","title":"Strict mode for .mld files","description":"Implement a strict execution mode for .mld files that eliminates LLM-unfriendly ambiguities:\n\n**Problem:**\n- Current mlld requires `/` prefix on directive lines, which creates ambiguity\n- Non-directive lines become implicit content output, which LLMs can accidentally trigger\n- This makes mlld harder for LLMs to generate correctly\n\n**Solution:**\nTwo modes based on file extension:\n- `.mld` → strict mode: bare directives, text lines error, blank lines ignored\n- `.mld.md` → markdown mode: `/` required, text becomes content (current behavior)\n\n**Key decisions:**\n- Optional `/` prefix in strict mode for backward compatibility\n- Blank lines are no-ops in strict mode (formatting whitespace)\n- Raw strings in SDK default to strict mode\n- Mode included in AST cache keys\n\n**Line handling by mode:**\n\n| Line Type          | Strict Mode   | Markdown Mode   |\n|--------------------|---------------|-----------------|\n| `/directive`       | ✓ Execute     | ✓ Execute       |\n| `directive` (bare) | ✓ Execute     | Text content    |\n| Blank              | ✓ Ignore      | Content         |\n| Text               | ✗ Error       | Content         |\n\nSee child issues for implementation breakdown.\n\nNeed to investigate and ensure compatibility with current module format which mixes \n```mlld``` and ```mlld-run``` in a markdown+frontmatter file.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-08T19:57:11.921576-08:00","updated_at":"2025-12-08T21:06:59.614521-08:00"}
{"id":"mlld-k69","title":"Tests: Add comprehensive test coverage for cmd:path/sh:path","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task creates comprehensive test coverage for the new syntax.\n\n## Prerequisites\n- All implementation tasks complete (grammar, types, interpreter, executors)\n\n## Task\nCreate test cases covering valid syntax, invalid syntax, runtime exceptions, and edge cases.\n\n## Test Structure\n\nmlld uses a fixture-based test system:\n- `tests/cases/` - valid test cases\n- `tests/cases/invalid/` - syntax/parse errors\n- `tests/cases/exceptions/` - runtime errors\n- `tests/fixtures/` - generated fixture files (gitignored)\n\n### Test File Naming\n\n**CRITICAL**: Test names must be unique across ALL tests. Use prefixes like:\n- `cmd-path-absolute.md` \n- `cmd-path-variable.md`\n- `sh-path-interpolation.md`\n\nNOT just `path.md` or `test.md`!\n\n## Valid Test Cases\n\nLocation: `tests/cases/cmd-path/` (create new directory)\n\n### 1. cmd-path-absolute.md\n```markdown\n/run cmd:/tmp {pwd}\n```\n\nexpected.md:\n```\n/tmp\n```\n\n### 2. cmd-path-variable.md\n```markdown\n/var @mypath = \"/tmp\"\n/run cmd:@mypath {pwd}\n```\n\nexpected.md:\n```\n/tmp\n```\n\n### 3. cmd-path-interpolation.md\n```markdown\n/var @base = \"/tmp\"\n/var @subdir = \"test\"\n/run cmd:@base/@subdir {pwd}\n```\n\nexpected.md:\n```\n/tmp/test\n```\n\n### 4. sh-path-absolute.md\n```markdown\n/run sh:/tmp {pwd}\n```\n\n### 5. bash-path-variable.md\n```markdown\n/var @dir = \"/tmp\"\n/run bash:@dir {pwd}\n```\n\n### 6. cmd-path-loop-iteration.md\n```markdown\n/var @dirs = [\"/tmp\", \"/home\"]\n/for @dir in @dirs {\n  /run cmd:@dir {pwd}\n}\n```\n\nexpected.md:\n```\n/tmp\n/home\n```\n\n### 7. cmd-no-path-still-works.md\nTest that existing cmd without :path still works:\n```markdown\n/run cmd {pwd}\n```\n\n## Invalid Test Cases (Parse Errors)\n\nLocation: `tests/cases/invalid/cmd-path/`\n\n### 1. cmd-path-invalid-relative.md\n```markdown\n/run cmd:./relative {ls}\n```\n\nerror.md:\n```\nParse error: working directory must start with / or @\n```\n\n### 2. cmd-path-invalid-bare.md\n```markdown\n/run cmd:relative {ls}\n```\n\nNote: This might parse successfully but fail at runtime if it doesn't start with `/` or `@`. Adjust test category as needed.\n\n## Exception Test Cases (Runtime Errors)\n\nLocation: `tests/cases/exceptions/cmd-path/`\n\n### 1. cmd-path-exception-undefined-var.md\n```markdown\n/run cmd:@undefined {pwd}\n```\n\nerror.md:\n```\nVariable @undefined is not defined\n```\n\n### 2. cmd-path-exception-not-rooted.md\n```markdown\n/var @rel = \"relative\"\n/run cmd:@rel {pwd}\n```\n\nerror.md:\n```\nWorking directory must be an absolute path\n```\n\n### 3. cmd-path-exception-not-exists.md\n```markdown\n/run cmd:/does/not/exist/path {ls}\n```\n\nerror.md:\n```\nWorking directory does not exist\n```\n\n### 4. cmd-path-exception-not-directory.md\n```markdown\n/run cmd:/etc/hosts {ls}\n```\n\nerror.md:\n```\nWorking directory path is not a directory\n```\n\n## Grammar Tests\n\nLocation: `grammar/tests/run.test.ts`\n\nAdd test cases to verify AST structure:\n\n```typescript\ndescribe('cmd:path syntax', () =\u003e {\n  it('should parse cmd with absolute path', () =\u003e {\n    const result = parse('/run cmd:/tmp {ls}');\n    expect(result.values.workingDir).toBeDefined();\n    expect(result.raw.workingDir).toBe('/tmp');\n  });\n  \n  it('should parse cmd with variable path', () =\u003e {\n    const result = parse('/run cmd:@mypath {ls}');\n    expect(result.values.workingDir).toHaveLength(1);\n    expect(result.values.workingDir[0].type).toBe('VariableReference');\n  });\n  \n  it('should parse sh with interpolated path', () =\u003e {\n    const result = parse('/run sh:@base/subdir {pwd}');\n    expect(result.values.workingDir).toHaveLength(2); // variable + text\n    expect(result.meta.hasWorkingDir).toBe(true);\n  });\n});\n```\n\n## Running Tests\n\n```bash\n# Generate fixtures\nnpm run build:fixtures\n\n# Run specific test directory\nnpm run test:case -- cmd-path\n\n# Run all tests\nnpm test\n```\n\n## Acceptance Criteria\n\n- [ ] All valid syntax parses and executes correctly\n- [ ] Undefined variables produce clear errors\n- [ ] Non-rooted paths are rejected\n- [ ] Non-existent directories are detected\n- [ ] File paths (not directories) are rejected  \n- [ ] Loop iterations work with different paths\n- [ ] Existing cmd/sh without :path still works\n- [ ] Grammar tests verify AST structure","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:49.842606-08:00","updated_at":"2025-12-08T20:25:12.829395-08:00","closed_at":"2025-12-08T20:25:12.829395-08:00"}
{"id":"mlld-nwu","title":"sh/bash executor not emitting CHUNK events to StreamBus for format adapters","description":"When using 'stream sh { ... }' the FormatAdapterSink doesn't receive CHUNK events. Works with 'stream cmd { ... }'. FormatAdapterSink.handle never called for sh/bash executors.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-07T20:51:28.696466-08:00","updated_at":"2025-12-07T20:51:28.696466-08:00"}
{"id":"mlld-om1","title":"LSP: mode-aware syntax highlighting and errors","description":"**Summary:**\nUpdate LSP/language server to handle both modes correctly.\n\n**Changes required:**\n\n1. **File extension detection:**\n   - `.mld` → strict mode tokenization\n   - `.mld.md` → markdown mode tokenization\n\n2. **Syntax highlighting:**\n   - Strict mode: directive keywords without `/` are highlighted as keywords\n   - Markdown mode: only `/keyword` highlighted as directives\n   - Both: `/keyword` highlighted as directive\n\n3. **Error diagnostics:**\n   - Strict mode: text lines get error squiggles with message\n   - Strict mode: suggest \"rename to .mld.md if you want prose content\"\n   - Markdown mode: no change from current behavior\n\n4. **Hover/completion:**\n   - Directive completions in strict mode don't require `/` prefix\n   - Both modes accept `/` prefix in completions\n\n5. **Formatter:**\n   - Strict mode: optionally normalize to bare directives (no `/`)\n   - Markdown mode: preserve `/` prefix\n   - Config option for strict mode preference (with or without slash)\n\n**Files likely affected:**\n- `lsp/` directory\n- VS Code extension if separate\n- TextMate grammar files for syntax highlighting\n\n**Testing:**\n- Open `.mld` file, verify bare directives highlighted\n- Open `.mld.md` file, verify only `/` directives highlighted\n- Verify error squiggles on text in strict mode","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T19:58:27.625577-08:00","updated_at":"2025-12-08T19:58:27.625577-08:00","dependencies":[{"issue_id":"mlld-om1","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.595916-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T19:59:14.906243-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-ah5","type":"blocks","created_at":"2025-12-08T20:59:32.37355-08:00","created_by":"daemon"}]}
{"id":"mlld-qxb","title":"cmd:path / sh:path for rooted commands","description":"One thing that both `cmd` and `sh` often need is to set the path for their operation. \n\n`cmd` intentionally disallows chaining which makes it impossible to just do `cd /some/dir \u0026\u0026 mycommand`\n\nBut given this is a common use case—and one which enforces security and clarity—we should allow a way to set the path for `cmd` and `sh`\n\n```\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n/run sh:@mypath {echo \"hello world\"}\n/run cmd:@base/path/to/file {mycommand param}\n/run sh:/Users/@username/dev/@dir {somecommand --flag}\n```\n\nthe `:path` would be an option everywhere `sh` and `cmd` are used; if not set the path would be set to whatever the system defaults to currently (which has its own rules)","design":"## Design Overview\n\nThis feature adds `:path` syntax to `cmd` and language executors (`sh`, `bash`, `js`, `python`, etc.) to set the working directory for command execution.\n\n## Motivation\n\nCurrently, `cmd` intentionally disallows chaining (no `\u0026\u0026` inside `cmd {...}`), which makes it impossible to do:\n```\n/run cmd {cd /some/dir \u0026\u0026 mycommand}  # NOT ALLOWED\n```\n\nThe `:path` syntax provides a clean, explicit alternative that:\n1. Enforces security through validation\n2. Makes working directory changes explicit in the syntax\n3. Supports variable interpolation\n4. Maintains cmd's no-chaining principle\n\n## Syntax Examples\n\n```mlld\n# Absolute path\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n\n# Variable path\n/var @mypath = \"/tmp\"\n/run sh:@mypath {echo \"hello world\"}\n\n# Interpolated path\n/var @base = \"/Users/adam\"\n/run cmd:@base/dev/mlld {git status}\n\n# With multiple variables\n/run sh:/Users/@username/dev/@project {make test}\n\n# Works with all language executors\n/run bash:/tmp {pwd}\n/run js:/home/user/scripts {console.log(process.cwd())}\n/run python:@workspace {import os; print(os.getcwd())}\n```\n\n## Design Decisions\n\n### 1. Rooted Paths Only\n\nPaths MUST be rooted (absolute):\n- ✅ `/tmp` - absolute path\n- ✅ `@mypath` - variable (must resolve to absolute)\n- ✅ `@base/subdir` - variable + path (variable must be absolute)\n- ❌ `./relative` - REJECTED\n- ❌ `relative` - REJECTED\n\n**Rationale**: Relative paths are ambiguous (relative to what?). Rooted paths are explicit and secure.\n\n### 2. Variable Interpolation\n\nVariables in paths are interpolated at runtime using existing `interpolate()` infrastructure:\n```mlld\n/var @user = \"alice\"\n/run cmd:/home/@user/work {ls}  # Resolves to /home/alice/work\n```\n\n**Rationale**: Consistent with how variables work elsewhere in mlld.\n\n### 3. Fail Fast Validation\n\nPath validation happens BEFORE command execution:\n1. Interpolate variables (error if undefined)\n2. Check path starts with `/` (error if not)\n3. Check directory exists (error if not)\n4. Check is directory not file (error if file)\n\n**Rationale**: Better error messages, prevents confusing command failures.\n\n### 4. No Security Policy (Yet)\n\nInitial implementation allows ANY absolute path the user has filesystem access to. Security policy integration is deferred to mlld-bgl.\n\n**Future**: Policy will allow restricting to specific path prefixes:\n```mlld\n/needs cmd.cwd:/Users/adam/dev/**  # Only allow paths under this\n```\n\n### 5. Scope is Per-Command\n\nThe `:path` only affects the specific command it's attached to, not global state:\n```mlld\n/run cmd:/tmp {pwd}        # runs in /tmp\n/run cmd {pwd}             # runs in default cwd\n/run @data | cmd:/app {process.sh}  # only process.sh runs in /app\n```\n\n**Rationale**: Explicit scope prevents action-at-a-distance bugs.\n\n## Implementation Order\n\nThe subtasks have dependencies:\n\n**Phase 1: Foundation (can be parallel)**\n1. mlld-u8r - Types (no dependencies)\n2. mlld-b0e - Grammar: WorkingDirPath pattern\n\n**Phase 2: Grammar Integration (depends on phase 1)**\n3. mlld-zgb - Grammar: cmd support (depends on mlld-b0e)\n4. mlld-rn5 - Grammar: sh/bash support (depends on mlld-b0e)\n\n**Phase 3: Runtime (depends on phase 1-2)**\n5. mlld-1x2 - cwd-resolver utility (depends on mlld-u8r)\n6. mlld-e0b - run evaluator (depends on mlld-1x2, mlld-u8r)\n7. mlld-7e7 - executors (depends on mlld-e0b)\n\n**Phase 4: Testing (depends on all)**\n8. mlld-k69 - comprehensive tests\n\n## Technical Architecture\n\n```\nGrammar Layer:\n  WorkingDirPath pattern → parses :path syntax\n  ↓\n  CmdCommandBrackets / RunLanguageCodeCore → includes workingDir in AST\n  ↓\nAST:\n  values.workingDir: ContentNodeArray (nodes with variables)\n  raw.workingDir: string (raw text)\n  meta.hasWorkingDir: boolean\n  meta.workingDirMeta: PathMeta\n  ↓\nInterpreter:\n  run evaluator → checks for workingDir in AST\n  ↓\n  cwd-resolver → interpolates variables, validates path\n  ↓\n  executeCommand/executeCode → passes cwd in options\n  ↓\nExecutors:\n  ShellCommandExecutor / BashExecutor / etc → use options.cwd || this.workingDirectory\n```\n\n## Error Handling\n\nClear, actionable error messages:\n\n```\nError: Cannot resolve working directory path\n  Path: /home/@username/dev\n  Reason: Variable @username is not defined\n  Location: example.mld:5:10\n```\n\n```\nError: Working directory must be an absolute path (start with /)\n  Provided: ./relative\n  Location: example.mld:8:15\n```\n\n```\nError: Working directory does not exist\n  Path: /nonexistent/directory\n  Location: example.mld:12:10\n```\n\n## Testing Strategy\n\n1. **Grammar tests**: Verify AST structure for various syntax forms\n2. **Valid cases**: Test execution with different path types\n3. **Invalid cases**: Test parse errors for unsupported syntax\n4. **Exception cases**: Test runtime errors for undefined vars, bad paths\n5. **Integration**: Test with loops, pipelines, different executors","notes":"Decisions: '/' allowed; paths must be absolute Unix; no Windows or '~'; reuse existing missing/non-dir path errors at runtime; :path applies to cmd/sh/etc including /exe forms like /exe @run(path, foo) = cmd:@path {...}.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T11:49:05.80685-08:00","updated_at":"2025-12-08T20:25:28.959279-08:00","closed_at":"2025-12-08T20:25:28.959279-08:00","labels":["creator:adamavenir@hey.com","epic","feature"],"dependencies":[{"issue_id":"mlld-qxb","depends_on_id":"mlld-b0e","type":"blocks","created_at":"2025-12-08T12:54:49.696952-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-zgb","type":"blocks","created_at":"2025-12-08T12:54:49.737084-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-rn5","type":"blocks","created_at":"2025-12-08T12:54:49.774931-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-u8r","type":"blocks","created_at":"2025-12-08T12:54:49.809626-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-1x2","type":"blocks","created_at":"2025-12-08T12:54:49.842686-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-e0b","type":"blocks","created_at":"2025-12-08T12:54:49.878847-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-7e7","type":"blocks","created_at":"2025-12-08T12:54:49.913983-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-k69","type":"blocks","created_at":"2025-12-08T12:54:49.949208-08:00","created_by":"daemon"}]}
{"id":"mlld-rn5","title":"Grammar: Extend RunLanguageCodeCore to support :path for sh/bash","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task extends language code execution (`sh`, `bash`, `js`, `python`, etc.) to support the `:path` suffix.\n\n## Prerequisites\n- mlld-b0e must be complete (WorkingDirPath pattern exists)\n\n## Task\nModify `RunLanguageCodeCore` to optionally parse and include working directory path for language executors.\n\n## Implementation\n\nLocation: `grammar/core/code.peggy`\n\n### Step 1: Add language with path pattern\n\n```peggy\n// Shared working directory pattern for language codes\nLanguageWorkingDirPath \"language working directory path\"\n  = \":\" path:WorkingDirPathContent {\n      return path;\n    }\n\n// Run language with optional working directory\nRunCodeLanguageWithPath\n  = language:RunCodeLanguage workingDir:LanguageWorkingDirPath? {\n      return {\n        language: language,\n        workingDir: workingDir || null\n      };\n    }\n```\n\n### Step 2: Modify RunLanguageCodeCore\n\nFind `RunLanguageCodeCore` pattern (around line 208) and update it to:\n1. Use `RunCodeLanguageWithPath` instead of `RunCodeLanguage`\n2. Extract `workingDir` from `langInfo`\n3. Add workingDir to values/raw/meta when present\n\n```peggy\nRunLanguageCodeCore\n  = streamPrefix:StreamKeyword? _ langInfo:RunCodeLanguageWithPath _ code:UnifiedCodeBrackets {\n      const language = langInfo.language;\n      const workingDir = langInfo.workingDir;\n      \n      // ... existing code to process language and code ...\n      \n      const values = {\n        lang: [langNode],\n        args: [],\n        code: [codeNode]\n      };\n      \n      if (workingDir) {\n        values.workingDir = workingDir.parts;\n      }\n      \n      const raw = {\n        lang: language,\n        args: [],\n        code: codeContent\n      };\n      \n      if (workingDir) {\n        raw.workingDir = workingDir.raw;\n      }\n      \n      const meta = {\n        isMultiLine: code.isMultiLine || codeContent.includes('\\n'),\n        language: language,\n        hasVariables: false,\n        hasWorkingDir: \\!\\!workingDir\n      };\n      \n      if (workingDir) {\n        meta.workingDirMeta = workingDir.meta;\n      }\n      \n      // ... rest of existing code ...\n    }\n```\n\n## Examples\n\n```mlld\n/run sh:/tmp {echo \"hello\"}\n/run bash:@mypath {pwd}\n/run js:/home/@user/scripts {console.log(process.cwd())}\n```\n\n## Testing\n\n```bash\nnpm run ast -- '/run sh:/tmp {echo hello}'\nnpm run ast -- '/run bash:@base {pwd}'\nnpm run ast -- '/run python:/scripts {print(1)}'\n```","notes":"RunLanguageCodeCore needs :path using WorkingDirPath; absolute Unix paths only ('/' ok); no Windows or '~'.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:18.829051-08:00","updated_at":"2025-12-08T20:23:54.14086-08:00","closed_at":"2025-12-08T20:23:54.14086-08:00"}
{"id":"mlld-sqt","title":"`log` folder should only be created if user sets a flag ","description":"Need to think about what the design for this is, but the current approach isn't great, and it's not even clear what is supposed to be going in `log` I just see them littering things whenever I run mlld files — and the output that I've seen is empty!! ","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-07T13:44:47.291457-08:00","updated_at":"2025-12-08T12:17:37.089103-08:00","labels":["bug","creator:adamavenir@hey.com"]}
{"id":"mlld-tfb","title":"Tests: strict mode fixtures and regressions","description":"**Summary:**\nAdd comprehensive test coverage for strict mode parsing and execution.\n\n**New fixtures needed:**\n\n1. **Strict mode success cases** (`tests/cases/valid/strict/`):\n   - `bare-directives.mld` - directives without `/` prefix\n   - `optional-slash.mld` - directives WITH `/` prefix (backward compat)\n   - `mixed-slash.mld` - some with, some without `/`\n   - `blank-lines.mld` - blank lines as formatting (should be ignored)\n   - `all-directives.mld` - every directive type without slash\n\n2. **Strict mode error cases** (`tests/cases/invalid/strict/`):\n   - `text-line.mld` - plain text should error\n   - `prose-content.mld` - markdown prose should error\n   - `comment-looking-text.mld` - `# heading` (not a directive) should error\n\n3. **Markdown mode regressions** (`tests/cases/valid/markdown/`):\n   - Existing tests renamed to `.mld.md` to confirm they still work\n   - Or keep as `.mld` with explicit mode override for backward compat testing\n\n4. **Cross-mode imports** (`tests/cases/valid/imports/`):\n   - `strict-imports-markdown.mld` imports `helper.mld.md`\n   - `markdown-imports-strict.mld.md` imports `helper.mld`\n\n**Fixture structure:**\n```\ntests/cases/valid/strict/\n  bare-directives/\n    example.mld      # bare var, exe, show, etc.\n    expected.md      # output\ntests/cases/invalid/strict/\n  text-line/\n    example.mld      # \"This is text\"\n    error.md         # expected error pattern\n```\n\n**Testing approach:**\n- Run `npm run build:fixtures` to generate fixture JSON\n- Verify strict mode fixtures parse/execute correctly\n- Verify invalid strict cases produce clear errors","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:17.200221-08:00","updated_at":"2025-12-08T19:58:17.200221-08:00","dependencies":[{"issue_id":"mlld-tfb","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.543036-08:00","created_by":"daemon"},{"issue_id":"mlld-tfb","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.870957-08:00","created_by":"daemon"}]}
{"id":"mlld-u8r","title":"Types: Extend RunValues/RunRaw/RunMeta for workingDir","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task adds TypeScript type definitions for the new `workingDir` field in run directive AST nodes.\n\n## Prerequisites\nNone - this can be done independently, but grammar tasks (mlld-b0e, mlld-zgb, mlld-rn5) will reference these types.\n\n## Task\nExtend the run directive type definitions to include working directory fields.\n\n## Implementation\n\nLocation: `core/types/run.ts`\n\n### 1. Extend RunValues interface\n\nFind the `RunValues` interface and add:\n```typescript\nexport interface RunValues {\n  command?: ContentNodeArray;\n  lang?: TextNodeArray;\n  args?: VariableNodeArray;\n  code?: ContentNodeArray;\n  identifier?: VariableNodeArray;\n  withClause?: WithClause;\n  securityLabels?: DataLabel[];\n  workingDir?: ContentNodeArray;  // NEW: Working directory path parts\n}\n```\n\n### 2. Extend RunRaw interface\n\n```typescript\nexport interface RunRaw {\n  command?: string;\n  lang?: string;\n  args?: string[];\n  code?: string;\n  identifier?: string;\n  withClause?: WithClause;\n  securityLabels?: string;\n  workingDir?: string;  // NEW: Raw working directory string\n}\n```\n\n### 3. Extend RunMeta interface\n\n```typescript\nexport interface RunMeta {\n  isMultiLine?: boolean;\n  argumentCount?: number;\n  language?: string;\n  hasVariables?: boolean;\n  withClause?: WithClause;\n  securityLabels?: DataLabel[];\n  hasWorkingDir?: boolean;      // NEW: Flag indicating working dir is set\n  workingDirMeta?: PathMeta;    // NEW: Path metadata for working dir\n}\n```\n\n### 4. Check PathMeta import\n\nEnsure `PathMeta` is imported if not already:\n```typescript\nimport type { PathMeta } from './path'; // or wherever PathMeta is defined\n```\n\n## What These Fields Mean\n\n- `workingDir` in RunValues: Array of AST nodes (Text nodes and VariableReference nodes) that make up the path\n- `workingDir` in RunRaw: The raw string representation like \"/tmp\" or \"@base/scripts\"\n- `hasWorkingDir` in RunMeta: Boolean flag to quickly check if workingDir was specified\n- `workingDirMeta` in RunMeta: Metadata like `hasVariables: true`, `isAbsolute: true`, etc.\n\n## Testing\n\nAfter implementation:\n```bash\nnpm run build\n```\n\nShould compile without errors. The grammar implementation will use these types.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:23.658146-08:00","updated_at":"2025-12-08T20:24:10.118584-08:00","closed_at":"2025-12-08T20:24:10.118584-08:00"}
{"id":"mlld-vlw","title":"Docs: update for strict mode","description":"**Summary:**\nUpdate all documentation to reflect the two-mode system.\n\n**Files to update:**\n\n1. **llms.txt:**\n   - Add mode explanation at top\n   - Note that examples use strict mode (no `/` prefix)\n   - Reference `.mld.md` for prose-embedded scripts\n\n2. **docs/user/ files:**\n   - Add \"Execution Modes\" section to getting-started or new page\n   - Update examples to show both styles where relevant\n   - Clarify file extension semantics\n\n3. **docs/dev/GRAMMAR.md:**\n   - Document mode flag in parser options\n   - Explain optional slash parsing\n   - Document top-level line handling per mode\n\n4. **README.md:**\n   - Quick mention of file extensions and modes\n\n**Key messaging:**\n\n- `.mld` = code file, LLM-friendly, no implicit content\n- `.mld.md` = documentation file, prose becomes output\n- Optional `/` in strict mode for gradual migration\n- SDK raw strings default to strict\n\n**Example documentation:**\n\n```markdown\n## File Extensions\n\n| Extension | Mode     | Behavior |\n|-----------|----------|----------|\n| `.mld`    | strict   | Every line is a directive or blank. Text lines error. |\n| `.mld.md` | markdown | `/` required for directives. Text becomes content. |\n\n### Strict Mode (.mld)\n```mlld\nvar @name = \"World\"\nshow `Hello @name`\n```\n\n### Markdown Mode (.mld.md)\n```mlld\n# Welcome Script\n\nThis text becomes output.\n\n/var @name = \"World\"\n/show `Hello @name`\n```\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:40.507851-08:00","updated_at":"2025-12-08T19:58:40.507851-08:00","dependencies":[{"issue_id":"mlld-vlw","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.647573-08:00","created_by":"daemon"},{"issue_id":"mlld-vlw","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T19:59:14.957772-08:00","created_by":"daemon"}]}
{"id":"mlld-wsm","title":"Resolvers: propagate mode through imports","description":"**Summary:**\nWhen resolving imports, ensure the imported module is parsed with the correct mode based on its extension.\n\n**Changes required:**\n\n1. **Import resolution** (resolvers, likely `LocalResolver`, `RegistryResolver`, etc.):\n   - When resolving a module path, determine mode from resolved filepath extension\n   - Pass mode to parser when loading the imported module\n\n2. **Mode inheritance rules:**\n   - `.mld` imports → strict mode\n   - `.mld.md` imports → markdown mode\n   - The importing file's mode does NOT affect the imported file's mode\n   - Each file's extension determines its own mode\n\n3. **Dynamic modules:**\n   - String dynamic modules: default to `'strict'` (or accept mode option)\n   - Object dynamic modules: N/A (no parsing)\n\n4. **Edge cases:**\n   - Circular imports: mode still derived from extension\n   - Re-exports: mode of original source file applies\n\n**Testing:**\n- `.mld` file imports `.mld.md` file - each parses in correct mode\n- `.mld.md` file imports `.mld` file - each parses in correct mode\n- Dynamic module string defaults to strict","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:02.459003-08:00","updated_at":"2025-12-08T19:58:02.459003-08:00","dependencies":[{"issue_id":"mlld-wsm","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.504019-08:00","created_by":"daemon"},{"issue_id":"mlld-wsm","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.8354-08:00","created_by":"daemon"}]}
{"id":"mlld-ytz","title":"Dynamic modules: mode selection for injected content","description":"**Summary:**\nEnsure dynamically injected modules respect mode settings.\n\n**Changes required:**\n\n1. **String dynamic modules**:\n   - `dynamicModules: { '@foo': 'var @x = 1' }` - needs to parse\n   - Default: `'strict'` mode (programmatic injection = code, not docs)\n   - Add option: `dynamicModuleMode?: 'strict' | 'markdown'`\n\n2. **Object dynamic modules**:\n   - `dynamicModules: { '@state': { count: 0 } }` - no parsing, N/A\n   - These become direct value exports, mode irrelevant\n\n3. **Per-module mode** (optional enhancement):\n   - Could support: `dynamicModules: { '@foo': { source: '...', mode: 'markdown' } }`\n   - Lower priority, probably not needed\n\n4. **Documentation**:\n   - Document that string dynamic modules parse in strict mode by default\n   - Explain how to opt into markdown mode if needed\n\n**Testing:**\n- String dynamic module with bare directives - parses in strict\n- String dynamic module with text content - errors (strict default)\n- String dynamic module with explicit markdown mode - text becomes content","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T20:56:53.299196-08:00","updated_at":"2025-12-08T20:56:53.299196-08:00","dependencies":[{"issue_id":"mlld-ytz","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.446397-08:00","created_by":"daemon"},{"issue_id":"mlld-ytz","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.25244-08:00","created_by":"daemon"}]}
{"id":"mlld-zgb","title":"Grammar: Extend CmdCommandBrackets to support optional :path","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task extends the `CmdCommandBrackets` pattern to accept the optional `:path` suffix.\n\n## Prerequisites\n- mlld-b0e must be complete (WorkingDirPath pattern exists)\n\n## Task\nModify `CmdCommandBrackets` to optionally parse and include working directory path.\n\n## Implementation\n\nLocation: `grammar/patterns/unified-run-content.peggy`\n\nCurrent code (around line 84-87):\n```peggy\nCmdCommandBrackets \"cmd command brackets\"\n  = \"cmd\" _ content:UnifiedCommandBrackets {\n      return content;\n    }\n```\n\nChange to:\n```peggy\nCmdCommandBrackets \"cmd command brackets\"\n  = \"cmd\" workingDir:WorkingDirPath? _ content:UnifiedCommandBrackets {\n      const result = content;\n      if (workingDir) {\n        result.values.workingDir = workingDir.parts;\n        result.raw.workingDir = workingDir.raw;\n        result.meta.hasWorkingDir = true;\n        result.meta.workingDirMeta = workingDir.meta;\n      }\n      return result;\n    }\n```\n\n## What This Does\n\n1. Optionally matches `WorkingDirPath` after `cmd` keyword\n2. If present, adds to the result node:\n   - `values.workingDir` - AST node array for interpreter\n   - `raw.workingDir` - raw string for debugging/display\n   - `meta.hasWorkingDir` - boolean flag\n   - `meta.workingDirMeta` - path metadata (hasVariables, etc)\n\n## Testing\n\nAfter implementation:\n```bash\nnpm run ast -- '/run cmd:/tmp {ls}'\nnpm run ast -- '/run cmd:@mypath {pwd}'\nnpm run ast -- '/run cmd {ls}'  # without path still works\n```\n\nCheck the AST output has `workingDir` field in values/raw/meta when path is present.","notes":"Cmd :path grammar uses WorkingDirPath pattern; accepts absolute Unix paths only ('/' ok); no Windows or '~'.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:13.204118-08:00","updated_at":"2025-12-08T20:23:39.467487-08:00","closed_at":"2025-12-08T20:23:39.467487-08:00"}
