{"id":"mlld-04k","title":"Docs: alternative syntax guide","description":"Document alternative syntax forms in a new docs/user/alternative-syntax.md. Cover:\\n- Backtick + @var templates and .att template file style as primary patterns.\\n- Alternative cases for markdown mode templates and other interpolation styles.\\n- Guidance on when to use markdown mode vs strict.\\n- Cross-link from main docs without promoting alternates as defaults.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:29:23.17602-08:00","updated_at":"2025-12-09T08:29:23.17602-08:00"}
{"id":"mlld-0gd","title":"Phase 1.5: Verify grammar with AST tool","description":"## Summary\n\nValidate all grammar changes by running the AST tool on representative examples.\n\n## ‚ö° Incremental Unblocking\n\nThis verification task can unblock Phase 2 work **incrementally**:\n\n- Once exe block grammar is verified ‚Üí mlld-9id (exe interpreter) can start\n- Once for block grammar is verified ‚Üí mlld-0ic (for interpreter) can start  \n- Once while grammar is verified ‚Üí mlld-ait (while interpreter) can start\n\nDon't wait for all constructs to be verified before starting interpreter work on verified constructs.\n\n## Prereq\n\nAll Phase 1 grammar issues must be complete:\n- mlld-9pl (block patterns)\n- mlld-1sh (while patterns)  \n- mlld-wrb (when syntax)\n- mlld-8d6 (types)\n- mlld-1iz (error recovery)\n\n## Build First\n\n```bash\nnpm run build:grammar\n```\n\n## Test Cases\n\n### Exe Block\n```bash\nnpm run ast -- 'exe @f() = [let @x = 1 =\u003e @x]'\n```\n\nExpected: ExeBlock node with statements array and return value.\n\n### For Block\n```bash\nnpm run ast -- 'for @x in @xs =\u003e [show @x]'\n```\n\nExpected: ForDirective with meta.actionType = 'block'.\n\n### When Oneliner (new syntax)\n```bash\nnpm run ast -- 'when @x \u003e 5 =\u003e \"big\"'\n```\n\nExpected: WhenExpression with oneliner subtype.\n\n### When Block (unchanged)\n```bash\nnpm run ast -- 'when [@x \u003e 5 =\u003e \"big\"]'\n```\n\nExpected: WhenExpression with block subtype.\n\n### While Pipeline Stage\n```bash\nnpm run ast -- 'var @x = @y | while(10) @process'\n```\n\nExpected: Pipeline with WhileStage node.\n\n### Done/Continue Literals\n```bash\nnpm run ast -- 'exe @p(s) = when [@s.done =\u003e done @s.result * =\u003e continue @newState]'\n```\n\nExpected: ControlLiteral nodes with done/continue subtypes.\n\n## Common Errors to Debug\n\n- \"Expected token but...\" - Usually JavaScript in action block has unsupported syntax\n- Type mismatches - Check core/types/ alignment\n- Backtracking errors - Check rule ordering, more specific first\n\n## Debug Mode\n\n```bash\nDEBUG_MLLD_GRAMMAR=1 npm run ast -- '/var @test = \"value\"'\n```\n\n## Validation Checklist\n\n- [ ] Exe block parses correctly ‚Üí **unblocks mlld-9id**\n- [ ] For block parses correctly ‚Üí **unblocks mlld-0ic**\n- [ ] When oneliner parses correctly\n- [ ] When block still works\n- [ ] While stage parses correctly ‚Üí **unblocks mlld-ait**\n- [ ] Done literal parses correctly\n- [ ] Continue literal parses correctly\n- [ ] All AST output matches type definitions","notes":"Ran AST validation after grammar build: /exe block with block+return, /for block action, when simple and block forms, while pipeline stage, and done/continue in when-expression inside /exe; all parsed as expected.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:16.299919-08:00","updated_at":"2025-12-10T07:11:46.151058-08:00","closed_at":"2025-12-10T07:11:46.151059-08:00","dependencies":[{"issue_id":"mlld-0gd","depends_on_id":"mlld-9pl","type":"blocks","created_at":"2025-12-09T22:16:36.27996-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-1sh","type":"blocks","created_at":"2025-12-09T22:16:36.317874-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-wrb","type":"blocks","created_at":"2025-12-09T22:16:36.35831-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-8d6","type":"blocks","created_at":"2025-12-09T22:16:36.432164-08:00","created_by":"daemon"},{"issue_id":"mlld-0gd","depends_on_id":"mlld-1iz","type":"blocks","created_at":"2025-12-09T22:27:45.137162-08:00","created_by":"daemon"}]}
{"id":"mlld-0ic","title":"Phase 2.3: Interpreter - Modify for.ts for block action support","description":"## Summary\n\nModify the for loop evaluator to detect block vs single action mode and evaluate blocks with let support.\n\n## Key Insight\n\nForSingleAction already supports everything for blocks need. The change is minimal - detect action type and call the right evaluator.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Iterator values preserve wrappers through loop body\n\n## ‚ùå DON'T DO (Explicit Restrictions)\n\nThese combinations are **NOT supported** in this epic:\n\n1. **Parallel for with blocks**: `for parallel() @x in @xs [...]]`\n   - Error: \"Parallel for loops not supported with block bodies. Use exe wrapper pattern.\"\n   - Workaround: Create an exe that contains the block logic, use parallel for with that exe.\n\n2. **Batch pipelines with blocks**: `for @x in @xs =\u003e [...] =\u003e || @batch()`\n   - Error: \"Batch pipelines not supported with block bodies. Use simple for-expression.\"\n   - Workaround: Use simple for-expression if batch pipeline needed.\n\n3. **Field access mutation in +=**: `let @data[-1].field += value`\n   - Error: \"ETOOCOMPLEX: Augmented assignment only supports simple variables.\"\n   - Only support: `let @variable += value` (simple variable names)\n\n4. **var +=**: There is no `var +=` syntax. Use `let` for accumulation within blocks.\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n- mlld-zeo (Export let functions)\n\n## Files to Modify\n\n- `interpreter/eval/for.ts` - Modify runOne() function\n\n## Implementation\n\nUpdate runOne() function (around line 168):\n\n```typescript\nimport { isLetAssignment, isAugmentedAssignment } from '@core/types/when';\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n\nconst runOne = async (entry: [any, any], idx: number) =\u003e {\n  // ... existing setup code for childEnv, iterationVar, etc.\n\n  const actionNodes = directive.values.action;\n  const retry = new RateLimitRetry();\n\n  while (true) {\n    try {\n      // Handle block vs single action mode\n      if (directive.meta.actionType === 'block') {\n        // Block mode: sequential evaluation with let support\n        let blockEnv = childEnv;\n        for (const stmt of actionNodes) {\n          if (isLetAssignment(stmt)) {\n            blockEnv = await evaluateLetAssignment(stmt, blockEnv);\n          } else if (isAugmentedAssignment(stmt)) {\n            blockEnv = await evaluateAugmentedAssignment(stmt, blockEnv);\n          } else {\n            const result = await evaluate(stmt, blockEnv);\n            blockEnv = result.env || blockEnv;\n          }\n        }\n        childEnv = blockEnv;\n      } else {\n        // Single action mode (existing behavior - unchanged)\n        // ... existing code\n      }\n\n      retry.reset();\n      break;\n    } catch (err: any) {\n      // ... existing retry logic unchanged\n    }\n  }\n  return;\n};\n```\n\n## Scoping Rules\n\n- Each iteration gets fresh child environment\n- Let variables scoped to block (not visible across iterations)\n- `let` in outer exe block CAN be mutated from inner for block (lexical scoping)\n- Parallel execution unchanged (blocks run sequentially within each parallel iteration)\n\n## Validation\n\n- [ ] Block mode detected via meta.actionType\n- [ ] Let assignments create scoped variables per iteration (as StructuredValue)\n- [ ] Augmented assignments work within iteration\n- [ ] Parallel execution still works for single actions\n- [ ] Error messages for unsupported combinations (parallel+block, batch+block)","notes":"‚úÖ PREREQUISITE UPDATE: Type enums completed in mlld-b4f. ForDirective.meta.actionType discriminator ('single' | 'block') verified in AST. ForDirective.meta.block.statementCount field validated. DirectiveSubtype includes 'for'. All regression tests pass. Ready for interpreter implementation once mlld-zeo (export let functions) is complete.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:18:12.164593-08:00","updated_at":"2025-12-10T14:00:53.77735-08:00","closed_at":"2025-12-10T14:00:53.77735-08:00","dependencies":[{"issue_id":"mlld-0ic","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:52.106015-08:00","created_by":"daemon"},{"issue_id":"mlld-0ic","depends_on_id":"mlld-zeo","type":"blocks","created_at":"2025-12-09T22:18:52.193244-08:00","created_by":"daemon"}]}
{"id":"mlld-0rz","title":"Global `@debug` object stopped working at some point","description":"I'm not sure when .... this used to get us most of whatever was in Environment for the purposes of debugging/inspection. It only redacted any env var values but did list the ones it could see.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T14:48:45.092969-08:00","updated_at":"2025-12-09T14:48:45.092969-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-1iz","title":"Phase 1.6: Grammar Error Recovery Infrastructure","description":"Implement sophisticated error recovery for block syntax to provide accurate error locations and helpful messages.\n\n## Scope\nMake Peggy parse errors inside [...] blocks point to the actual bad token instead of the opening bracket. Apply to exe blocks, for blocks, and while constructs.\n\n## Implementation Details\n\n### 1. Structured Block Rules (No Catch-Alls)\n- Define explicit statement lists without generic fallbacks\n- ExeBlockStatement enumerates: LetAssignment | AugmentedAssignment | EffectAction | WhenRHSVarAssignment | ReturnStatement\n- ForBlockStatement uses ForSingleAction directly\n- Reorder alternatives: specific statements before generic expression fallbacks\n\n### 2. Inline Error Recovery Branches\n- Unterminated block: lookahead for ], error at EOF if missing\n- Return placement: branch for =\u003e not last, error 'Return must be last'\n- Comma separator: match ',' in statement lists, error 'Use whitespace not commas'\n- Missing = after let @id: recovery in let-assignment.peggy\n- Multiple returns: detect second =\u003e in block\n\n### 3. Reparse-on-Failure Helper\nAdd helper in grammar/deps/grammar-core.ts:\nreparseInner(innerText, startRule, offset) - calls peg$parse with startRule, offsets location() by block start, rethrows via mlldError\n\n### 4. Unclosed Delimiter Scanners\n- Add bracket-aware scanner (like existing) honoring strings\n- Use in ExeBlock/ForBlock rules\n- Catch unclosed [ with helpful error\n\n### 5. Baseline Fixtures\nCreate failing fixtures capturing current bad diagnostics for regression guard\n\n## References\n- Source: todo/plan-grammar-errors.md","notes":"Added block grammar recovery: explicit ExeBlockAction surface (effects/assignments/special literals), ensured return must be last with mlldError, and block separators already reject commas. For/Exe blocks enumerate statements (no catch-alls) and reuse unclosed-[ check. Grammar build core passed.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:26:53.223759-08:00","updated_at":"2025-12-10T02:39:33.609622-08:00","closed_at":"2025-12-10T02:39:33.609624-08:00","labels":["enhancement","grammar"],"dependencies":[{"issue_id":"mlld-1iz","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:26:53.224915-08:00","created_by":"daemon"}]}
{"id":"mlld-1sh","title":"Phase 1.2: Grammar - Add While loop patterns with done/continue keywords","description":"## Summary\n\nAdd while loop construct for bounded iteration with `done`/`continue` control keywords.\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) first.\n\n## Syntax\n\n```mlld\n# Pipeline stage\nvar @result = @initial | while(100) @processor\n\n# Directive form\nwhile (100, 1s) @processor\n\n# Processor with done/continue\nexe @processor(state) = when [\n  @state.done =\u003e done @state.result\n  * =\u003e continue @newState\n]\n```\n\n## Files to Modify\n\n- `grammar/base/literals.peggy` - Add DoneLiteral and ContinueLiteral\n- `grammar/patterns/pipeline.peggy` - Add WhilePipelineStage\n- `grammar/directives/while.peggy` (new file) - Add WhileDirective\n\n## Implementation\n\n### DoneLiteral and ContinueLiteral (in literals.peggy)\n\nFollow exact pattern from `retry`, `skip`, `allow`, `denied` (lines 50-74):\n\n```peggy\nDoneLiteral \"done literal\"\n  = \"done\" _ value:WhenRHSValue {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'done',\n        values: { value: [value] },\n        raw: { value: text() },\n        meta: { hasValue: true }\n      };\n    }\n  / \"done\" {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'done',\n        values: { value: [] },\n        raw: { value: 'done' },\n        meta: { hasValue: false }\n      };\n    }\n\nContinueLiteral \"continue literal\"\n  = \"continue\" _ value:WhenRHSValue {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'continue',\n        values: { value: [value] },\n        raw: { value: text() },\n        meta: { hasValue: true }\n      };\n    }\n  / \"continue\" {\n      return {\n        type: 'ControlLiteral',\n        subtype: 'continue',\n        values: { value: [] },\n        raw: { value: 'continue' },\n        meta: { hasValue: false }\n      };\n    }\n```\n\n### WhilePipelineStage\n\n```peggy\nWhilePipelineStage \"while pipeline stage\"\n  = \"while\" _ \"(\" _ cap:Integer _ (\",\" _ rate:Duration)? _ \")\" _ processor:ExeReference {\n      return {\n        type: 'WhileStage',\n        values: {\n          cap: cap,\n          rate: rate || null,\n          processor: processor\n        },\n        meta: {\n          hasCap: true,\n          hasRate: !!rate\n        }\n      };\n    }\n```\n\n## Error Recovery\n\n- Missing cap: \"while() requires a maximum iteration count\"\n- Invalid processor: \"while expects an executable reference like @processor\"\n\n## Context Object\n\nWhile loops provide `@ctx.while.*`:\n- `@ctx.while.iteration` - current iteration number (0-indexed)\n- `@ctx.while.cap` - maximum iterations allowed\n\n## Testing\n\n```bash\nnpm run ast -- 'var @x = @y | while(10) @process'\nnpm run ast -- 'exe @p(s) = when [@s.done =\u003e done @s.result]'\n```\n\n## Validation\n\n- [ ] DoneLiteral parses correctly\n- [ ] ContinueLiteral parses correctly  \n- [ ] WhilePipelineStage parses correctly\n- [ ] Error messages are helpful","notes":"Added while directive grammar, while pipeline stage, and done/continue literals. Directive list now includes /while; pipeline stage supports while(\u003ccap\u003e[,\u003crate\u003e]) @processor with errors; done/continue literals parse via Literal valueType. Grammar build passes.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:15:24.186936-08:00","updated_at":"2025-12-10T00:00:33.554781-08:00","closed_at":"2025-12-10T00:00:33.554783-08:00","dependencies":[{"issue_id":"mlld-1sh","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.094575-08:00","created_by":"daemon"}]}
{"id":"mlld-1x2","title":"Interpreter: Create cwd-resolver utility for path validation","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task creates a utility function to resolve and validate working directory paths before command execution.\n\n## Prerequisites\n- Grammar tasks complete (workingDir is in AST)\n- Type tasks complete (workingDir types defined)\n\n## Task\nCreate `interpreter/utils/cwd-resolver.ts` to handle path interpolation and validation.\n\n## Requirements\n\nThe resolver must:\n1. Interpolate variables in the path (`@mypath`, `/home/@user/dev`)\n2. Validate path is rooted (starts with `/`)\n3. Check directory exists\n4. Check path is actually a directory (not a file)\n5. Return absolute path or throw clear errors\n\n## Implementation\n\nCreate new file: `interpreter/utils/cwd-resolver.ts`\n\n```typescript\nimport * as fs from 'fs';\nimport type { ContentNodeArray } from '@core/types';\nimport type { Environment } from '../env/Environment';\nimport { interpolate, InterpolationContext } from '../core/interpreter';\nimport { MlldCommandExecutionError } from '@core/errors';\n\nexport async function resolveCwd(\n  workingDirNodes: ContentNodeArray,\n  env: Environment,\n  sourceLocation?: any\n): Promise\u003cstring\u003e {\n  // Step 1: Interpolate variables\n  const interpolatedPath = await interpolate(\n    workingDirNodes,\n    env,\n    undefined,\n    { context: InterpolationContext.FilePath }\n  );\n  \n  // Step 2: Validate rooted (absolute) path\n  if (!interpolatedPath.startsWith('/')) {\n    throw new MlldCommandExecutionError(\n      `Working directory must be an absolute path (start with /): ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  // Step 3: Check directory exists\n  if (!fs.existsSync(interpolatedPath)) {\n    throw new MlldCommandExecutionError(\n      `Working directory does not exist: ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  // Step 4: Check is directory\n  const stats = fs.statSync(interpolatedPath);\n  if (!stats.isDirectory()) {\n    throw new MlldCommandExecutionError(\n      `Working directory path is not a directory: ${interpolatedPath}`,\n      { location: sourceLocation }\n    );\n  }\n  \n  return interpolatedPath;\n}\n```\n\n## Error Messages\n\nProvide clear errors for common issues:\n- Undefined variable: \"Cannot resolve working directory: variable @username is not defined\"\n- Not rooted: \"Working directory must be an absolute path (start with /): ./relative\"\n- Doesn't exist: \"Working directory does not exist: /nonexistent/path\"\n- Not a directory: \"Working directory path is not a directory: /etc/hosts\"\n\n## Testing\n\nCreate unit tests in `interpreter/utils/cwd-resolver.test.ts`:\n```typescript\ndescribe('resolveCwd', () =\u003e {\n  it('should resolve absolute path', async () =\u003e {\n    // Test with /tmp\n  });\n  \n  it('should interpolate variables', async () =\u003e {\n    // Test with @mypath variable\n  });\n  \n  it('should error on non-rooted path', async () =\u003e {\n    // Test ./relative fails\n  });\n  \n  it('should error on non-existent path', async () =\u003e {\n    // Test /does/not/exist fails\n  });\n  \n  it('should error on file path', async () =\u003e {\n    // Test /etc/hosts fails (is file not dir)\n  });\n});\n```","notes":"Validation rules: absolute Unix paths only (/ ok); no Windows or '~'; reuse existing path error pattern on missing/non-dir; supports variable interpolation before validation.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:30.564083-08:00","updated_at":"2025-12-08T20:24:26.808179-08:00","closed_at":"2025-12-08T20:24:26.808179-08:00"}
{"id":"mlld-1zd","title":"Analyzer: mode-aware parsing and cache keys","description":"**Summary:**\nEnsure `analyzeModule` respects file extension mode and caches correctly.\n\n**Changes required:**\n\n1. **Mode inference**:\n   - `analyzeModule(filepath)` should infer mode from extension\n   - Add optional `mode` parameter to override\n\n2. **Parser call**:\n   - Pass inferred/explicit mode to parser\n   - Analyzer should parse `.mld` in strict mode, `.mld.md` in markdown mode\n\n3. **Cache keys**:\n   - Include mode in analyzer cache key (if analyzer has its own cache)\n   - Or ensure it uses the shared AST cache which already includes mode (per mlld-ah5)\n\n4. **Analysis results**:\n   - No change to ModuleAnalysis structure needed\n   - Mode affects parsing only, not analysis output\n\n**Testing:**\n- Analyze `.mld` file with bare directives - succeeds\n- Analyze `.mld` file with text content - reports parse error\n- Analyze `.mld.md` file with prose - succeeds","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:56:43.129243-08:00","updated_at":"2025-12-11T17:37:39.186076-08:00","closed_at":"2025-12-11T17:37:39.186076-08:00","dependencies":[{"issue_id":"mlld-1zd","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.407032-08:00","created_by":"daemon"},{"issue_id":"mlld-1zd","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.213788-08:00","created_by":"daemon"}]}
{"id":"mlld-3bl","title":"Grammar: when-expressions fail with 3+ conditions (comparison + 2 method calls)","description":"Detailed investigation of grammar parsing bug where when-expressions with specific condition combinations fail to parse","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-06T12:16:03.302262-08:00","updated_at":"2025-12-06T18:47:29.68001-08:00","closed_at":"2025-12-06T18:47:29.68001-08:00"}
{"id":"mlld-3e6","title":"Docs: Update for block syntax, while loops, and done/continue keywords","description":"## Summary\n\nUpdate mlld documentation to reflect the new block syntax features, while loops, and done/continue control flow keywords implemented in the block syntax epic.\n\n## Context\n\nEpic mlld-fln introduced three major features:\n1. Block syntax `[...]` for exe/for directives with let/+= support\n2. While loops with done/continue keywords\n3. Unified when syntax\n\nThese features are now implemented and all tests pass (Phase 2 complete, Phase 3 core tests passing). Documentation needs to be updated to reflect:\n- New syntax forms\n- New keywords (done, continue)\n- Let/+= semantics in blocks\n- Scope restrictions (what's NOT supported)\n\n## Documentation Files to Update\n\nBased on typical mlld docs structure, likely need updates in:\n\n### User-Facing Docs\n- `docs/flow-control.md` - Add exe blocks, for blocks, while loops\n- `docs/reference.md` - Add block syntax reference\n- `docs/quickstart.md` - Show simple block examples\n- `docs/introduction.md` - Mention blocks if appropriate\n\n### Developer Docs  \n- `docs/dev/AST.md` - Update with new node types (ExeBlockNode, control literals)\n- `docs/dev/GRAMMAR.md` - Already current, may need minor updates\n- `docs/dev/DATA.md` - Verify numeric value handling documented\n\n## What to Document\n\n### 1. Exe Block Syntax\n\n```mlld\n/exe @greet(name) = [\n  let @greeting = \"Hello\"\n  let @punctuation = \"!\"\n  =\u003e \"@greeting @name@punctuation\"\n]\n```\n\n**Key points:**\n- Multi-statement bodies with `[...]`\n- `let @var = value` for local variables\n- `let @var += value` for accumulation\n- `=\u003e value` for explicit returns (required, must be last)\n- Nested for/when allowed\n\n### 2. For Block Syntax\n\n```mlld\n/for @item in @items [\n  show \"Item: @item\"\n  let @count += 1\n]\n```\n\n**Key points:**\n- Multi-statement iteration bodies\n- Let/+= support\n- Nested control flow\n- Arrow syntax deprecated but still works: `for @x in @xs =\u003e [...]`\n\n### 3. While Loops\n\n```mlld\n/exe @countdown(n) = when [\n  @n \u003c= 0 =\u003e done \"finished\"\n  * =\u003e continue (@n - 1)\n]\n\n/var @result = 5 | while(10) @countdown\n```\n\n**Key points:**\n- Bounded iteration: `while(cap) @processor`\n- Optional pacing: `while(cap, 1s) @processor`\n- Control keywords: `done @value`, `continue @value`\n- Context: `@ctx.while.iteration`, `@ctx.while.limit`, `@ctx.while.active`\n- Retry prohibited (use continue instead)\n\n### 4. Done/Continue Keywords\n\n```mlld\ndone @value      # Terminate with value\ndone             # Terminate with current state\ncontinue @value  # Next iteration with value\ncontinue         # Next iteration with current state\n```\n\n**Key points:**\n- Used in while processors\n- Work in when expression actions\n- Can be used in exe block returns\n- Values are evaluated in current environment\n\n### 5. Scope Restrictions (Important!)\n\nDocument what's NOT supported:\n- ‚ùå Field access mutation: `let @data[-1].field += value` ‚Üí ETOOCOMPLEX\n- ‚ùå Parallel for with blocks: `for parallel() @x [...]` ‚Üí Use exe wrapper\n- ‚ùå Batch pipelines with blocks: `for [...] =\u003e ||` ‚Üí Use simple expressions\n- ‚ùå var +=: Only `let` supports +=, not `var`\n\n### 6. Let vs Var Semantics\n\nClarify the difference:\n- `let` - Block-scoped, supports +=, used in exe/for blocks\n- `var` - File/module-scoped, no +=, used for state\n\n## Validation\n\n- [ ] All examples in docs parse correctly\n- [ ] Examples match test fixtures where possible\n- [ ] Restrictions clearly documented\n- [ ] Migration guidance for existing patterns\n- [ ] AST.md updated with new node types\n\n## References\n\n- Implementation: mlld-zeo, mlld-9id, mlld-0ic, mlld-ait\n- Test fixtures: tests/cases/feat/exe-block, for-block, while\n- Verification: tmp/phase2-implementation-verification.md, tmp/while-loop-verification.md\n- Grammar docs: docs/dev/GRAMMAR.md (already current)","notes":"Documentation updated for block syntax, while loops, and done/continue keywords.\n\nFiles updated:\n- docs/user/flow-control.md: Added exe blocks, for blocks, while loops sections\n- docs/user/reference.md: Added syntax references for blocks and while\n- llms.txt: Added block syntax and while loops to ITERATION/EXE_EXECUTABLES sections\n- docs/dev/AST.md: Added new node types (ExeBlock, For block metadata, While stages, Control literals)\n\nAll examples tested and verified working. No hallucinations - every code example runs successfully.\n\nTest verification:\n- Exe block examples ‚úÖ\n- For block examples ‚úÖ  \n- While loop examples ‚úÖ\n- Control keywords (done/continue) ‚úÖ","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T17:31:20.61021-08:00","updated_at":"2025-12-10T17:56:30.868255-08:00","closed_at":"2025-12-10T17:56:30.868258-08:00","dependencies":[{"issue_id":"mlld-3e6","depends_on_id":"mlld-jw7","type":"blocks","created_at":"2025-12-10T17:31:27.672242-08:00","created_by":"daemon"}]}
{"id":"mlld-3gm","title":"Grammar: template path should support variable interpolation","description":"**Reported by:** partydev during SDK dogfooding\n\n**Current behavior:**\n`template \"../agents/@agent.att\"` treats the path as a literal string - @agent is NOT interpolated.\n\n**Expected behavior:**\nVariables in the template path should be interpolated, same as in backticks or angle brackets.\n\n**Current workarounds:**\n1. Use a variable for the full path:\n```mlld\n/var @templatePath = \\`../agents/@agent.att\\`\n/exe @buildPrompt(message) = template @templatePath\n```\n\n2. Use angle brackets + inline template:\n```mlld\n/var @tpl = \u003c../agents/@agent.att\u003e\n/exe @buildPrompt(message) = ::@tpl::\n```\n\n**Root cause:**\n`QuotedStringPath` in `grammar/patterns/path-expression.peggy` uses `$([^\"]*)` which captures content as-is without parsing for variable references.\n\n**Fix needed:**\nUpdate `QuotedStringPath` to parse variable references similar to how `AlligatorPath` does, or create a new `InterpolatedQuotedPath` pattern for template paths.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-09T08:38:03.216807-08:00","updated_at":"2025-12-09T08:51:14.335259-08:00","closed_at":"2025-12-09T08:51:14.335259-08:00"}
{"id":"mlld-3h3","title":"Dynamic bracket access fails with field access expressions","description":"**Repro:**\n```mlld\n/import templates from \"./agents\" as @agents(msg)\n/var @agentObj = {\"agent\": \"alice\"}\n\n/show @agents[@agentObj.agent](@msg)\n```\n\n**Expected:** Resolves `@agentObj.agent` to `\"alice\"`, then invokes `@agents[\"alice\"](@msg)`\n\n**Actual:** Outputs literal text without executing:\n```\n[@agentObj.agent](@msg)\n```\n\n**Works:**\n```mlld\n/var @name = \"alice\"\n/show @agents[@name](@msg)  # ‚úì works\n```\n\n**Doesn't work:**\n```mlld\n/show @agents[@obj.field](@msg)  # ‚úó literal output\n```\n\nThe bracket expression isn't being evaluated before indexing into the template collection.\n\nReported by @partydev.1 in chat - blocking their orchestration use case.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-11T04:51:24.958764-08:00","updated_at":"2025-12-11T09:43:36.846002-08:00","closed_at":"2025-12-11T09:43:36.846002-08:00"}
{"id":"mlld-3ha","title":"Add error accumulation for parallel execution (for blocks + pipeline groups)","description":"**Scope:** Error accumulation for parallel execution - both for loops and pipeline groups.\n\n**1. Parallel for blocks**\n\n**Current:** Block bodies blocked:\n```mlld\n‚úÖ /for parallel @x in @xs =\u003e show @x\n‚ùå /for parallel @x in @xs [ show @x; let @count += 1 ]\n```\n\n**Desired:**\n```mlld\n/for parallel(3) @agent in @respondingAgents [\n  let @prompt = @agents[@agent.agent](@messageBody)\n  let @response = cmd { claude -p \"@prompt\" }\n  run { bdm post --as @agent.agent\\.1 \"@response\" }\n]\n```\n\n**2. Parallel pipeline groups**\n\n**Current:** `|| @a || @b || @c` fails entire pipeline if one fails\n\n**Desired:** Best-effort with error accumulation:\n```mlld\n/var @data = || @fetchA() || @fetchB() || @fetchC() | @combine\n\n/exe @combine(results) = when [\n  @ctx.errors.length == 0 =\u003e @merge(@results)\n  * =\u003e @handlePartial(@results, @ctx.errors)  # 2/3 succeeded\n]\n```\n\n**Use cases:**\n- Multi-agent orchestration (invoke 5 agents, proceed if 3 respond)\n- Best-of-N with fallback (try multiple LLMs, use what works)\n- Multi-source aggregation (fetch 3 APIs, ok if 2/3 succeed)\n- Validation pipeline (run multiple validators, collect all failures)\n\n**Unified design:**\n\n**Error handling:**\n- Errors accumulate in `@ctx.errors` array instead of throwing\n- Results array contains error markers for failed operations (index-aligned)\n- Error marker: `{ index, key?, message, error, value? }`\n  - `index`: position in input\n  - `key`: for object iteration\n  - `message`: human-readable\n  - `error`: stringified detail\n  - `value`: original input (for retry logic)\n- `@ctx.errors` clears per parallel operation (no state leakage)\n- Caller decides repair via `when @ctx.errors.length \u003e 0`\n\n**Isolation (parallel for only):**\n- Block-scoped `let` only\n- Error on writes to outer variables (race prevention)\n\n**Ordering:**\n- Directive form: streams unordered (fast)\n- Expression form: preserves input order\n\n**Sequential blocks keep current behavior:**\n- Fail fast (no benefit to continuing)\n- Outer writes allowed (no races)\n- No error accumulation\n\n**Pattern:**\n```mlld\n/exe @invokeAll(agents, msg) = [\n  let @results = for parallel @a in @agents =\u003e @invoke(@a, @msg)\n  =\u003e when [\n    @ctx.errors.length == 0 =\u003e @results\n    * =\u003e @repair(@results, @ctx.errors, @msg)  # AI-driven repair\n  ]\n]\n\n/exe @aggregate(sources) = [\n  let @data = || @fetch(@sources[0]) || @fetch(@sources[1]) || @fetch(@sources[2])\n  =\u003e when [\n    @ctx.errors.length == 0 =\u003e @data\n    @data.length \u003e= 2 =\u003e @data  # 2/3 is good enough\n    * =\u003e retry \"Need at least 2 sources\"\n  ]\n]\n```\n\nDesign from @partydev.1, implementation by gpt5.1.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-11T05:04:30.901599-08:00","updated_at":"2025-12-11T09:43:55.079981-08:00","closed_at":"2025-12-11T09:43:55.079981-08:00"}
{"id":"mlld-3jk","title":"MJS bundle: Dynamic require of fs error in Node 24 ESM projects","description":"**Reported by:** partydev during SDK dogfooding\n\n**Environment:**\n- Node 24\n- ESM project (type: module in package.json)\n- Using `import { execute } from 'mlld'`\n\n**Error:**\n`Dynamic require of fs is not supported` when importing from the MJS bundle.\n\n**Workaround:**\nRemove `type: module` from package.json and let tsx handle ESM imports, or use createRequire with the CJS bundle.\n\n**Root cause (suspected):**\nThe MJS bundle is pulling in a CJS-only dependency that uses `require('fs')` or similar. Our tsup build generates both .mjs and .cjs outputs but the MJS bundle may not be fully tree-shaken or may include CJS-style imports.\n\n**To investigate:**\n1. Check tsup build config for ESM externals\n2. Look for dynamic requires in dependencies\n3. Test with Node 24 ESM project","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-09T04:53:12.510232-08:00","updated_at":"2025-12-11T17:06:38.3971-08:00"}
{"id":"mlld-3ma","title":"Migration: lint warning for prose in .mld files","description":"**Summary:**\nHelp users migrate by warning when `.mld` files contain prose that will error in strict mode.\n\n**Changes required:**\n\n1. **Lint rule / diagnostic**:\n   - Scan `.mld` files for lines that would be text content\n   - Emit warning: \"This file contains prose on line X. Rename to .mld.md or remove text.\"\n\n2. **CLI flag**:\n   - `mlld lint --check-mode` or similar\n   - Could be part of `mlld check` if that exists\n\n3. **Error message enhancement**:\n   - When strict mode parser errors on text, include helpful message:\n   - \"Text content not allowed in .mld files. Either:\\n  1. Rename to .mld.md to embed prose\\n  2. Remove or comment out text lines\"\n\n4. **Migration script** (optional):\n   - `mlld migrate --to-strict` - rename files and report issues\n   - Low priority, users can do this manually\n\n**Testing:**\n- Lint `.mld` file with prose - warns with line numbers\n- Lint clean `.mld` file - no warnings\n- Error message on strict parse failure includes migration hint","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T20:57:14.29758-08:00","updated_at":"2025-12-08T20:57:14.29758-08:00","dependencies":[{"issue_id":"mlld-3ma","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.522074-08:00","created_by":"daemon"},{"issue_id":"mlld-3ma","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T20:59:32.324654-08:00","created_by":"daemon"}]}
{"id":"mlld-4bf","title":"LSP: Highlight function execution in /run directive (GH#331)","description":"Function execution in /run directive not highlighted.\n\nSee: https://github.com/mlld-lang/mlld/issues/331\n\nSize: Small","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:36.760769-08:00","updated_at":"2025-12-11T20:12:36.760769-08:00","dependencies":[{"issue_id":"mlld-4bf","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.226226-08:00","created_by":"daemon"}]}
{"id":"mlld-4cs","title":"Short urls for every beads task","description":"`/bd/proj-id` should jump straight to a project's card.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T15:15:37.642987-08:00","updated_at":"2025-12-07T19:33:09.48891-08:00","closed_at":"2025-12-07T19:33:09.48891-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-4cw","title":"Docs: restructure llms.txt into modules","description":"Restructure llms.txt into modular sections using existing XML structure: a concise getting","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-09T08:29:52.689432-08:00","updated_at":"2025-12-10T18:40:48.417163-08:00"}
{"id":"mlld-4p5","title":"LSP: Highlight end-of-line comments in when expressions (GH#329)","description":"End-of-line comments not highlighted in when expressions.\n\nSee: https://github.com/mlld-lang/mlld/issues/329\n\nSize: Small","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:37.063973-08:00","updated_at":"2025-12-11T20:12:37.063973-08:00","dependencies":[{"issue_id":"mlld-4p5","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.309833-08:00","created_by":"daemon"}]}
{"id":"mlld-4xm","title":"When expressions returning numbers produce empty output","description":"## Summary\n\nUser partydev.3 reported that `/exe` with `when first` returning numeric values produces empty output instead of the number.\n\n## Root Cause\n\nGrammar was inconsistent about primitive handling:\n- Some patterns returned raw primitives (`42`)\n- Some returned Literal AST nodes (`{type: 'Literal', value: 42}`)\n- Interpreter had gaps in Literal node handling\n\nThis violated the fundamental principle: **Grammar should always return AST nodes, interpreter extracts values.**\n\n## Policy Decision (Documented in DATA.md)\n\n**Primitives are NEVER StructuredValues:**\n1. Grammar returns Literal AST nodes: `{type: 'Literal', value: 42}`\n2. Interpreter extracts native values: `42`\n3. Variables wrap primitives: `PrimitiveVariable{value: 42, ctx: {...}}`\n4. StructuredValue is ONLY for dual representations (loaded content, pipeline results)\n\n**Rationale:**\n- Primitives have no dual representation (`42` is just `42`)\n- No provenance for literals in code\n- Variables already provide metadata layer\n- Performance - no wasteful wrapping\n\n## Fixes Applied\n\n1. **Grammar (`var-rhs.peggy`)**: `PrimitiveValue` now wraps all primitives in Literal nodes\n2. **When evaluator (`when-expression.ts`)**: `normalizeActionValue()` extracts values from Literal nodes\n3. **Data evaluator (`PrimitiveEvaluator.ts`)**: Added Literal node handling\n4. **Object processing (`var.ts`)**: `evaluateArrayItem()` extracts values from Literal nodes\n\n## Testing\n\n- ‚úÖ All 2367 tests pass\n- ‚úÖ Numeric returns in when expressions work\n- ‚úÖ Object serialization preserves types: `{\"count\":42}` not `{\"count\":\"42\"}`\n- ‚úÖ Array methods with numeric args work: `@arr.includes(3)`\n\n## Follow-up\n\nCreated mlld-62p for full codebase audit to ensure all primitive handling is consistent.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T11:59:53.332409-08:00","updated_at":"2025-12-09T12:31:20.38644-08:00","closed_at":"2025-12-09T12:31:20.38644-08:00"}
{"id":"mlld-4zy","title":"Formatter: mode-aware slash prefix handling","description":"**Summary:**\nFormatter should emit appropriate slash prefix based on mode.\n\n**Changes required:**\n\n1. **Mode detection**:\n   - Formatter receives mode from file extension or explicit option\n   - Track mode throughout formatting pass\n\n2. **Directive formatting**:\n   - Markdown mode: always emit `/` prefix on directives\n   - Strict mode: configurable behavior:\n     - Option A: emit bare directives (no `/`)\n     - Option B: preserve input style (if had `/`, keep it)\n     - Option C: always emit `/` for compatibility\n   - Recommend Option A as default, Option B for `--preserve-style`\n\n3. **Blank line handling**:\n   - Strict mode: blank lines are formatting whitespace, preserve for readability\n   - Markdown mode: blank lines may be content, preserve carefully\n\n4. **Config option**:\n   - `strictModeSlash: 'omit' | 'preserve' | 'include'`\n   - Or simpler: `--bare-directives` flag for strict mode\n\n**Testing:**\n- Format `.mld` file - outputs bare directives (if Option A)\n- Format `.mld.md` file - outputs `/` prefixed directives\n- Format `.mld` with mixed slash usage - normalizes per config","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T20:57:03.568773-08:00","updated_at":"2025-12-08T20:57:03.568773-08:00","dependencies":[{"issue_id":"mlld-4zy","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.486165-08:00","created_by":"daemon"},{"issue_id":"mlld-4zy","depends_on_id":"mlld-gj7","type":"blocks","created_at":"2025-12-08T20:59:32.287836-08:00","created_by":"daemon"}]}
{"id":"mlld-5ik","title":"Phase 4: Integration Tests and Polish (Optional)","description":"## Summary\n\nExtended integration tests and polish after core features work. Optional but recommended for production readiness.\n\n## Prereq\n\nPhase 3 core tests (mlld-jw7) must pass first.\n\n## Comprehensive Test Cases\n\n### Test A: Exe Block with Nested For and When\n\n```\n/exe @summarize(projects) = [\n  let @out = []\n  let @errors = []\n\n  for @project in @projects [\n    let @rows = []\n\n    for @task in @project.tasks [\n      when [\n        @task.state == \"done\" =\u003e let @rows += { id: @task.id, pts: @task.points }\n        @task.state == \"blocked\" =\u003e let @errors += { id: @task.id, reason: @task.blocker }\n      ]\n    ]\n\n    let @out += {\n      name: @project.name,\n      total: @rows.length,\n      tasks: @rows\n    }\n  ]\n\n  show \"Projects: @out.length, errors: @errors.length\"\n  =\u003e { results: @out, errors: @errors }\n]\n```\n\n### Test B: For Block with Nested Loop (wrapped in exe)\n\n```\n/exe @processUsers(users) = [\n  for @user in @users [\n    let @active = []\n\n    for @msg in @user.inbox [\n      when [\n        @msg.status == \"unread\" =\u003e let @active += @msg\n      ]\n    ]\n\n    show `User @user.name: @active.length unread`\n  ]\n  =\u003e \"done\"\n]\n\n/show @processUsers(@users)\n```\n\n### Test C: Simple Accumulation Pattern (no var +=)\n\n```\n/exe @buildResults(rows) = [\n  let @results = []\n\n  for @row in @rows [\n    let @acc = { id: @row.id, tags: [] }\n\n    for @tag in @row.tags [\n      let @acc.tags += @tag\n    ]\n\n    let @results += @acc\n  ]\n\n  =\u003e @results\n]\n\n/show @buildResults(@rows) | @json\n```\n\n**Note**: Accumulation uses `let` within exe block scope. No `var +=` syntax exists.\n\n### Test D: Strict Mode (No Slashes)\n\n```\nexe @process(items) = [\n  let @results = []\n\n  for @item in @items [\n    let @results += @item.value\n    show \"Processed: @item.id\"\n  ]\n\n  =\u003e @results\n]\n\nvar @output = @process([{ id: 1, value: \"a\" }])\nshow @output\n```\n\n### Test E: Loose Mode (Top-Level Slashes Only)\n\n```\n/exe @process(items) = [\n  let @results = []\n\n  for @item in @items [\n    let @results += @item.value\n    show \"Processed: @item.id\"\n  ]\n\n  =\u003e @results\n]\n\n/var @output = @process([{ id: 1, value: \"a\" }])\n/show @output\n```\n\n## Edge Cases\n\n- [ ] Empty blocks: `[ ]` should be valid, returns undefined\n- [ ] Return without value: `=\u003e` alone should error\n- [ ] Let without value: Should error at parse time\n- [ ] Nested parallel: Verify parallel specs stack correctly\n- [ ] Error mid-block: Should preserve completed let assignments\n\n## Validation\n\n- [ ] All integration tests pass\n- [ ] Edge cases covered\n- [ ] No regressions in existing functionality\n\n## Notes\n\nScope tightened: no standalone error fixtures; docs handled in mlld-3e6.","notes":"Scope tightened: drop error fixtures; focus on integration/edge tests. Docs handled in mlld-3e6.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T22:20:01.49389-08:00","updated_at":"2025-12-10T18:34:10.913029-08:00","closed_at":"2025-12-10T18:34:10.913029-08:00","dependencies":[{"issue_id":"mlld-5ik","depends_on_id":"mlld-jw7","type":"blocks","created_at":"2025-12-09T22:20:07.023716-08:00","created_by":"daemon"}]}
{"id":"mlld-5jz","title":"CLI: add --loose/--strict mode flags","description":"Partially done: --mode and --strict flags exist. Still need: --loose flag (aliases: --markdown, --md, --prose) to force markdown mode.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T08:28:19.903908-08:00","updated_at":"2025-12-11T17:36:42.617941-08:00","closed_at":"2025-12-11T17:36:42.617941-08:00"}
{"id":"mlld-5n7","title":"Interpreter: thread mode through parser invocation","description":"**Summary:**\nWire the mode flag from entry points through to the parser, with extension-based defaults.\n\n**Changes required:**\n\n1. **Extension ‚Üí mode mapping** (likely in `services/PathService.ts` or new utility):\n   ```typescript\n   function getModeFromPath(filepath: string): 'strict' | 'markdown' {\n     if (filepath.endsWith('.mld.md') || filepath.endsWith('.md')) return 'markdown';\n     if (filepath.endsWith('.mld')) return 'strict';\n     return 'markdown'; // fallback for unknown\n   }\n   ```\n\n2. **Entry points to update:**\n   - `processMlld(script, options)` - add `mode` option, default `'strict'` for raw strings\n   - `interpret(script, options)` - thread mode to parser\n   - `execute(filepath, payload, options)` - derive mode from extension\n   - CLI entry point - derive mode from input file extension\n\n3. **Parser invocation** (wherever `parse()` is called):\n   ```typescript\n   const ast = parse(source, { \n     ...existingOptions,\n     mode: options.mode ?? getModeFromPath(options.filePath) \n   });\n   ```\n\n4. **Options types** (`types/` or relevant interface files):\n   - Add `mode?: 'strict' | 'markdown'` to ProcessOptions, InterpretOptions, ExecuteOptions\n\n**Testing:**\n- Unit test: `.mld` file parses in strict mode\n- Unit test: `.mld.md` file parses in markdown mode\n- Unit test: raw string defaults to strict\n- Unit test: explicit mode option overrides extension inference","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:57:44.878318-08:00","updated_at":"2025-12-11T17:17:58.529905-08:00","closed_at":"2025-12-11T17:17:58.529905-08:00","dependencies":[{"issue_id":"mlld-5n7","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.431674-08:00","created_by":"daemon"},{"issue_id":"mlld-5n7","depends_on_id":"mlld-gj7","type":"blocks","created_at":"2025-12-08T19:59:14.754308-08:00","created_by":"daemon"}]}
{"id":"mlld-5p8","title":"Grammar: extend VariableBoundary escape to all interpolation contexts","description":"**Reported by:** partydev during SDK dogfooding\n\n**Problem:**\nWhen parsing `@agent.att` in paths/strings, the grammar greedily consumes `.att` as field access. Users need a way to say \"stop here, `.att` is literal text (a file extension).\"\n\n**Example:**\n```mlld\n/exe @buildPrompt(msg) = template \"../agents/@agent.att\"\n\u003e\u003e Currently: @agent with field access .att\n\u003e\u003e Wanted: @agent variable + literal .att extension\n```\n\n**Current state:**\n- `VariableBoundary` mechanism exists in `unified-variables.peggy`\n- Syntax: `@var\\` terminates variable, `@var\\\\` produces literal backslash\n- BUT: only used in `UnifiedTemplateVariableReference` (template contexts)\n- AND: boundary check happens AFTER greedy field consumption (wrong order)\n\n**Fix needed:**\n1. Reorder grammar so boundary check happens BEFORE field access consumption\n2. Apply `VariableBoundary` pattern to ALL variable interpolation contexts:\n   - Double-quoted strings\n   - Path contexts (angle brackets)\n   - Template paths in /exe\n   - Any other interpolation context\n\n**User syntax after fix:**\n```mlld\n/exe @buildPrompt(msg) = template \"../agents/@agent\\.att\"\n\u003e\u003e @agent\\ = terminate variable here\n\u003e\u003e .att = literal file extension\n```\n\n**Files to modify:**\n- grammar/base/unified-variables.peggy - fix ordering, ensure boundary works\n- Verify all variable-consuming patterns use the unified pattern\n\n**Future enhancement:**\nConsider adding `@{var}` braced syntax as a more intuitive alternative (separate issue).","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T08:00:13.723859-08:00","updated_at":"2025-12-09T08:06:28.583781-08:00","closed_at":"2025-12-09T08:06:28.583781-08:00"}
{"id":"mlld-5qm","title":"Make @mlld/stream-claude-agent-sdk module work with single-quoted templates","description":"The published module @mlld/stream-claude-agent-sdk uses double-quoted templates which get interpolated as mlld variables during import. Need to republish with single-quoted templates and test.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T20:50:05.396861-08:00","updated_at":"2025-12-08T02:53:01.835237-08:00","closed_at":"2025-12-08T02:53:01.835237-08:00"}
{"id":"mlld-5x5","title":"SDK/CLI: expose mode option and set defaults","description":"**Summary:**\nExpose `mode` option in SDK APIs and CLI, with sensible defaults.\n\n**SDK changes:**\n\n1. **processMlld(script, options)**:\n   - Add `mode?: 'strict' | 'markdown'` to options\n   - Default: `'strict'` when no `filePath` provided (raw strings)\n   - Default: infer from extension when `filePath` provided\n\n2. **interpret(script, options)**:\n   - Add `mode` option, same defaults as processMlld\n\n3. **execute(filepath, payload, options)**:\n   - Add `mode` option\n   - Default: infer from filepath extension\n   - Explicit option overrides inference\n\n4. **Type exports**:\n   - Export `MlldMode = 'strict' | 'markdown'` type\n\n**CLI changes:**\n\n1. **Flag**: `--mode \u003cstrict|markdown\u003e`\n   - Overrides extension-based inference\n   - Useful for testing or unusual file extensions\n\n2. **Extension inference**:\n   - `.mld` ‚Üí strict\n   - `.mld.md` / `.md` ‚Üí markdown\n   - stdin without `--mode` ‚Üí strict (matches SDK raw string default)\n\n3. **Help text**:\n   - Document mode flag and extension defaults\n\n**Testing:**\n- SDK: raw string without filePath uses strict\n- SDK: `.mld` file uses strict\n- SDK: `.mld.md` file uses markdown\n- SDK: explicit mode overrides extension\n- CLI: `--mode markdown` on `.mld` file uses markdown\n- CLI: stdin defaults to strict","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T20:56:33.43397-08:00","updated_at":"2025-12-11T17:18:10.75636-08:00","closed_at":"2025-12-11T17:18:10.75636-08:00","dependencies":[{"issue_id":"mlld-5x5","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.360437-08:00","created_by":"daemon"},{"issue_id":"mlld-5x5","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.172773-08:00","created_by":"daemon"}]}
{"id":"mlld-5y6","title":"Docs: clarify pipeline data shape vs parallel stage output","description":"Docs promise StructuredValue pipeline stages, but still mention parallel groups handing JSON array strings to next stage. Validate actual behavior and update docs to reflect structured pipeline inputs/outputs (including parallel aggregation semantics) once aligned with executor/state machine.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:40:56.370878-08:00","updated_at":"2025-12-08T19:40:56.370878-08:00"}
{"id":"mlld-62p","title":"Audit: Ensure universal StructuredValue compliance","description":"## Goal\n\nAudit and fix the codebase to ensure **universal StructuredValue compliance**:\n\n**All runtime values are StructuredValues** - primitives, strings, arrays, objects, loaded content.\n\n## Policy (now in DATA.md)\n\n**Universal StructuredValue flow:**\n1. **Grammar**: Returns AST Literal nodes `{type: 'Literal', value: 42}`\n2. **Interpreter**: Wraps ALL values in StructuredValue `{type: 'number', text: '42', data: 42, ctx: {...}}`\n3. **Variables**: Wrap StructuredValues (StructuredValueVariable)\n4. **Boundaries**: Use `asData()` for computation, `asText()` for display\n\n## Rationale\n\nWe tried making primitives exceptions but the system fights that. The evidence:\n- `wrapExecResult`, `ensureStructuredValue`, pipelines already wrap primitives\n- Dual representation IS useful: `.text` for templates, `.data` for comparisons, `.ctx` for guards\n- Consistency wins: one model is simpler than special cases\n- We were adding unwrapping hacks everywhere - fighting the design\n\n## Audit Strategy\n\n### Find places that DON'T use asData()/asText()\n\n**Computation boundaries that need `asData()`:**\n- ‚úÖ Comparisons (`toNumber`, `isEqual`) - FIXED\n- Array methods (`.includes()`, `.indexOf()`, `.join()`, etc.)\n- String methods (`.startsWith()`, `.substring()`, etc.)\n- Arithmetic operations\n- Boolean operations\n- Object property access\n- Array indexing\n\n**Display boundaries that need `asText()`:**\n- Template interpolation\n- Shell command arguments  \n- `/show` output\n- Log messages\n- JSON.stringify contexts\n\n### Find places trying to unwrap primitives\n\nSearch for patterns like:\n- Checking `typeof value === 'number'` without extracting first\n- Creating PrimitiveVariable instead of StructuredValueVariable for exec results\n- Avoiding wrapping in `ensureStructuredValue`\n\n### Implementation\n\nUse mlld to parallelize:\n1. Spawn haiku agents for each file category\n2. Each outputs JSON: `{file, needsAsData: [...], needsAsText: [...], wrongUnwrap: [...]}`\n3. Aggregate to `audit-results.jsonl`\n4. Generate fix plan\n5. Apply fixes (parallelized if many)\n\n## Current Status\n\n**Fixed:**\n- ‚úÖ `toNumber()` extracts `.data` from StructuredValue\n- ‚úÖ `extractValue()` in expression.ts handles StructuredValue\n- ‚úÖ Grammar returns Literal nodes consistently\n- ‚úÖ PrimitiveEvaluator extracts Literal values\n- ‚úÖ Object property evaluation handles Literal nodes\n\n**Likely still broken:**\n- ‚ùì Array/string method arg processing\n- ‚ùì Arithmetic expression evaluation\n- ‚ùì Direct property access on StructuredValues\n\n## Next Steps\n\n1. Run the audit script to find all missing `asData()`/`asText()` calls\n2. Prioritize by user impact (comparison operators were P1)\n3. Fix systematically","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T12:26:52.590565-08:00","updated_at":"2025-12-09T15:21:29.593082-08:00"}
{"id":"mlld-75e","title":"Allow escaping `@` everywhere with `@@` ","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T08:30:56.452213-08:00","updated_at":"2025-12-09T08:51:20.348654-08:00","closed_at":"2025-12-09T08:51:20.348654-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-7e7","title":"Executors: Add cwd support to CommandExecutionOptions and executors","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task adds `cwd` support to the command executor options and modifies all executors to use it.\n\n## Prerequisites\n- mlld-e0b in progress or complete (run evaluator passing cwd)\n\n## Task\n1. Add `cwd?: string` to `CommandExecutionOptions` interface\n2. Modify all executors to use `options.cwd` when provided\n\n## Implementation\n\n### Step 1: Update CommandExecutionOptions interface\n\nLocation: `interpreter/env/executors/BaseCommandExecutor.ts` (or wherever CommandExecutionOptions is defined)\n\nFind the interface (likely around line 10-20):\n```typescript\nexport interface CommandExecutionOptions {\n  env?: Record\u003cstring, string\u003e;\n  timeout?: number;\n  captureOutput?: boolean;\n  // ... other options\n  cwd?: string;  // NEW: Optional working directory\n}\n```\n\n### Step 2: Modify ShellCommandExecutor\n\nLocation: `interpreter/env/executors/ShellCommandExecutor.ts`\n\nFind where `spawn` is called (likely around line 340):\n\n**Before:**\n```typescript\nconst child = spawn(safeCommand, {\n  cwd: this.workingDirectory,\n  env,\n  shell: true,\n  // ...\n});\n```\n\n**After:**\n```typescript\nconst child = spawn(safeCommand, {\n  cwd: options?.cwd || this.workingDirectory,  // Use options.cwd if provided\n  env,\n  shell: true,\n  // ...\n});\n```\n\nAlso find the `execAsync` call (around line 297) and update similarly:\n```typescript\nconst { stdout, stderr } = await execAsync(finalCommand, {\n  encoding: 'utf8',\n  cwd: options?.cwd || this.workingDirectory,  // Use options.cwd if provided\n  env: { ...process.env, ...(options?.env || {}) },\n  maxBuffer: 10 * 1024 * 1024\n});\n```\n\n### Step 3: Modify BashExecutor\n\nLocation: `interpreter/env/executors/BashExecutor.ts`\n\nApply the same pattern - find spawn calls and update cwd:\n```typescript\ncwd: options?.cwd || this.workingDirectory\n```\n\n### Step 4: Modify other executors\n\nCheck and update these if they execute processes:\n- `NodeExecutor.ts` - for `/run js {}`\n- `PythonExecutor.ts` - for `/run python {}`\n- `JavaScriptExecutor.ts` - if separate from NodeExecutor\n\nFor each, find where child processes are spawned and apply:\n```typescript\ncwd: options?.cwd || this.workingDirectory\n```\n\n## Pattern\n\nThe pattern is consistent across all executors:\n1. Check if `options?.cwd` is provided\n2. If yes, use it\n3. If no, fall back to `this.workingDirectory` (existing behavior)\n\n## Testing\n\nAfter implementation, test that cwd is actually used:\n\n```bash\necho '/run cmd:/tmp {pwd}' | ./dist/cli.cjs\n# Should output: /tmp\n\necho '/run sh:/home {pwd}' | ./dist/cli.cjs  \n# Should output: /home (if exists)\n```\n\nCheck that commands without cwd still work:\n```bash\necho '/run cmd {pwd}' | ./dist/cli.cjs\n# Should output: current working directory\n```","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:42.69404-08:00","updated_at":"2025-12-08T20:24:57.116324-08:00","closed_at":"2025-12-08T20:24:57.116324-08:00"}
{"id":"mlld-7fa","title":"Tests: add balanced loose/strict coverage post-rollout","description":"Follow-up after fixing current failures: ensure test suites include both strict (.mld) and markdown (.mld.md/raw) coverage, add explicit mode flags where appropriate, and document the defaults. Blocked by mlld-7ng.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T05:16:39.824334-08:00","updated_at":"2025-12-11T17:53:35.147288-08:00","closed_at":"2025-12-11T17:53:35.147288-08:00","dependencies":[{"issue_id":"mlld-7fa","depends_on_id":"mlld-7ng","type":"blocks","created_at":"2025-12-09T05:16:54.846728-08:00","created_by":"adam"}]}
{"id":"mlld-7j7","title":"Exe RHS pipeline syntax broken: value | cmd and cmd | cmd patterns fail","description":"## Summary\n\nMultiple  RHS pipeline patterns are failing to parse or execute correctly in strict mode.\n\n## Expected Working Patterns\n\nAll of these should work:\n\n```mlld\n/exe @func(value) = @value | cmd { claude -p --model haiku }\n/exe @func(value) = cmd { @value | claude -p --model haiku }\n/exe @func(value) = @other(value) | cmd { claude -p --model haiku }\n/exe @func(value) = js { return \"hi\" } | cmd { claude -p --model haiku }\n/exe @func(value) = cmd { echo \"hello\" } | cmd { claude -p --model haiku }\n/exe @func(value) = @value | cmd { claude -p } | cmd { claude -p \"wdyt?\" }\n```\n\nBonus (if we can handle escaping):\n```mlld\n/exe @func(value) = cmd { claude -p \"@prompt\" --model haiku }\n```\n\n## Current Behavior\n\n- `@value | cmd {...}` fails with \"Invalid /exe syntax\" parse error\n- `run @value | cmd {...}` also fails\n- User changed to `cmd { @value | claude... }` which should work but returns null/empty\n\n## Why This Matters\n\n**Piping is critical for large/complex content:**\n- Escaping multi-line prompts with special chars is fragile\n- Stdin piping is robust and standard Unix pattern\n- Current audit script (audit-primitive-handling.mld) blocked by this\n\n## Context\n\nWe use this pattern extensively:\n- `scripts/mlld/audit-pathcontext-flow.mld` has `/exe @claude(prompt) = run @prompt | {claude -p}`\n- But it's unclear if this actually works or silently fails\n- We may have tests but they might be too simple (not testing large complex file content)\n\n## Investigation Needed\n\n1. Check grammar for exe RHS pipeline syntax - what's actually supported?\n2. Test with real Claude calls and large file content\n3. Verify existing tests actually cover this (not just toy examples)\n4. Consider deprecating `run` in RHS position (accept but mark deprecated in grammar/CHANGELOG)\n\n## Workaround\n\nUnknown - need to investigate what actually works.\n\n## Impact\n\nBlocks parallel audit script and potentially other mlld-scripting-mlld patterns.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T14:20:38.374747-08:00","updated_at":"2025-12-10T19:08:40.540628-08:00","closed_at":"2025-12-10T19:08:40.540628-08:00"}
{"id":"mlld-7ng","title":"Tests: fix failing suites for strict-mode rollout","description":"Failing test files after strict mode changes:\n- cli/commands/mcp.test.ts\n- interpreter/index.structured.test.ts\n- interpreter/interpreter.fixture.test.ts\n- interpreter/output-formats.test.ts\n- interpreter/output-management.test.ts\n- tests/heredoc.e2e.test.ts\n- tests/integration/imports/basic-patterns.test.ts\n- tests/integration/node-shadow-cleanup.test.ts\n- tests/pipeline/parallel-runtime.test.ts\n\n## interpreter.fixture.test.ts tests/cases\n\n\n  - effects: append-jsonl-basic; append-pipeline-basic; exe-for-effects; exe-for-nested-\n    effects; exe-for-pipeline-retry-effects; exe-when-basic; for-basic-effects; nested-\n    contexts; output-directive-effects; pipeline-function-effects; pipeline-inline-log;\n    pipeline-inline-output-file; pipeline-inline-output-stderr; pipeline-inline-output-\n    stdout; pipeline-inline-retry-replay; pipeline-inline-show; pipeline-retry-effects;\n    var-for-immediate-effects\n  - exe: command-ref-array-preserve\n  - alligator: alligator-glob-concat; ast-name-list-all/class/fn/glob/var; ast-selection;\n    ast-selector-variable; ast-type-filter-all/class/fn/var; ast-wildcard-contains/\n    prefix/single/suffix; edge-cases-boundary; file-references-legitimate; function-args-\n    operators; glob-as-transform; json-autoparse; keep-in-loops; keep-metadata-access;\n    metadata-file/json/url; pipe-transformations; pipeline-contexts; section-extraction;\n    section-list-all/glob/h2/h3; security-labels-files; unified-json-file; unified-text-\n    file; url-markdown-conversion; xml-html-literal\n  - array-operations: slice-basic; slice-negative; slice-variable-indices\n  - augmented-assignment\n  - bash: heredoc-prevents-e2big; large-variable-heredoc\n  - bracket-notation-comprehensive\n  - builtin: typeof-function; builtin-methods-array/string/variables; builtin-type-\n    checking\n  - command-substitution-tty\n  - comments/inline\n  - exe: command-ref-arg-interpolation-basic; function-call-syntax; param-shadowing\n  - expressions-operators; expressions-operators-parsing\n  - file-reference-interpolation\n  - for: directive-actions; exe-template-params; nested-basic/function-calls/output/\n    triple; pipeline-multiple/single; run-command; template-interpolation; when-with-none\n  - frontmatter: alias; basic\n  - html-conversion: basic-article; complex-elements; edge-cases; heading-hierarchy;\n    metadata-extraction; readability-extraction; url-section-extraction\n  - input: env-vars-allowed; input-new-syntax\n  - issue-fixes/issue-459-run-json-field-access\n  - json-backslash-n-preserved\n  - keep-structured\n  - literals-in-function-args\n  - load-content: js-edge-cases; js-unwrap; node-unwrap\n  - method-chain-after-array-access\n  - module-system: command-ref-imports; directive-guard; security-exe-roundtrip;\n    template-interpolation\n  - native-object: github-pattern; node-return; property-access\n  - object-property-access in exec args/functions\n  - object-spread\n  - optional-slash-comprehensive\n  - pipeline: chained-multiple; exe-command-ref-pipeline; exe-reusable-pipes; foreach-\n    structured-value; inline-log-suppressed; inline-output-file; inline-show-basic/retry-\n    replay; interpolation-contexts; native-json-stages; parallel-syntax-parity; pipeline-\n    alias-p-negative-index; pipeline-array-indexing; pipeline-context-basic/edge-cases/\n    preservation; pipeline-multi-stage-retry; pipeline-ordering-integrity; pipes-with-\n    arguments; retry-attempt-tracking; retry-basic/best-of-n/complex-logic/conditional-\n    fallback/hint-function-value/hint-interpolated/hint-object/hint-reception/when-\n    expression/with-none; show-invocation-inline-retry; show-vs-with-basic/retry;\n    vertical-stacked-pipes; when-actions-pipes; when-all-any-pipes; with-clause-pipes\n  - policy: import-policy; union; wants-basic\n  - reserved: input-variable; now-variable; now-variable-lowercase; projectpath-variable\n  - resolver-contexts\n  - run: command-escape-newline-in-quoted\n  - security: guard-after-allow/deny-handled/transform/transform-chain; guard-allow;\n    guard-always; guard-before-after-compose; guard-deny-handled; guard-multiple-\n    handlers; guard-retry; expression-tracking; pipeline-taint; after-guard-retry\n    variants (nonpipeline hints/success/transform; pipeline effects/success); before-\n    guard-retry-success; guard-context-inside-guards; guard-overrides-disable-all/except/\n    only; guard-structured-equality\n  - shell-interpolation: array-from-js-function; array-of-mixed-types/objects-command/\n    objects-stdin; array-with-nulls; booleans-in-objects; deeply-nested-structures;\n    empty-array-command; exec-stdin-complex-array/object; exec-with-complex-param;\n    foreach-complex-elements; jq-with-complex-stdin; json-transformer-output; loader-to-\n    command; mixed-complex-array; mixed-wrapped-simple; multiple-complex-params; nested-\n    arrays-command/stdin; numbers-in-nested-array; object-array-in-template; object-\n    in-command; object-nested-properties; object-via-stdin; object-with-array-property;\n    pipe-sugar-complex-array; pipeline-complex-data; simple-array-expansion/stdin;\n    single-quoted-complex/+apostrophe; special-chars-in-object; structured-value-wrapped;\n    three-level-nesting; undefined-variable-interpolation; user-full-scenario-435; user-\n    scenario-435\n  - template-inline: for-backtick; for-double-colon; inline-show-double-bracket; inline-\n    show-triple; triple-alligator-literal\n  - template-syntax-migration\n  - transformers: chain; csv-basic; json-basic/fromlist/llm-extract-array/generic-fence/\n    inline-prose/invalid/nested/no-json/with-comments; json-llm-extract; json-loose-\n    syntax; json-strict-basic; md-basic; xml-basic\n  - variable-methods: direct-rhs-indexing; method-chaining\n  - when: when-preserve-type-through-pipeline; expression-none-with-vars\n  - with: combined; needs-node; pipeline-basic/input/termination\n  - integration: exe-invocation-module; exe-sh-module; modules/auto-export/explicit-\n    export/metadata; pipeline/ctx-hint-flow-basic/ctx-hint-multistage-mixed-hints/ctx-\n    hint-object/ctx-hint-template-code; executable-transform; formatted-input; hint-\n    command-ref-interpolation; triple-colon-exec\n  - regression: alligator-for-expressions; angle-bracket-literals\n  - slash/exe: code-brackets; command-substitution-interactive/sh; double-colon-\n    content; exe-node-console-log-capture; exe-node-gray-matter-access; exe-node-mlld-\n    dependencies; exe-node-shadow-env-always-created; exe-parameterized-command; js-\n    shadow-env-test; nested-executable-field-access/-var; node-shadow-env; node-\n    undefined-params; optional-slash-run; param-at-syntax; param-interpolation; run-\n    template-exec; shadow-env-undefined-params; shadow-environment/+simple\n  - slash/for: exe-for-expression/nested; for-basic; var-for-function-composition\n  - slash/import: alias; explicit-export-success/wildcard; import-triple-colon-template;\n    imported-array-behavior; mixed; namespace-json/nested/shorthand/special-chars; stdin-\n    json/live/shorthand/text/deprecated; type-static/type-static-inferred; url\n  - slash/output: alligator-content; blank-line-normalization; command; document;\n    file; literal; quoted-path; resolver; security-imported-exec; template-invocation;\n    variable; when-action\n  - slash/path: url; variable-assignment\n  - slash/run: bash-env-vars/multiline/parameters/bash/bash-array-at-syntax; code-with-\n    variables; command-bases-npm-run/ operators/special-patterns; file-content-escaping;\n    no-reinterpret; pipe-operator; quoted-special-chars; run-cmd-syntax-consistency; run-\n    command-bracket-nesting; run-node-console-log-no-capture; shell-escaping; stdin-\n    support\n  - slash/show: all-template-types; alligator-section-as-substring; backtick-template;\n    backtick-with-colon\n  - slash/var: data-array-ast-fix/data-array-path-disambiguation/data-array-valid-\n    patterns/data-object-literals-in-arrays/data-primitive-values; exe-invocation-direct-\n    data/direct-text; foreach-bash-env/foreach-text-template; now-basic-compat; text-\n    assignment-run-slash; text-url; text-variable-copy\n  - slash/when: add-variable-in-action; all-block-action; all-individual-actions; any-\n    block-action; bare-block-action; bare-individual-actions; block-all; exe-conditions;\n    exe-invocation-add/run/tail; exe-when-all-matches; exe-when-expressions/+operators;\n    exe-wildcard-default; first-individual-actions; implicit-actions; let-local-\n    var; negation/+bare-when/+block; none-vs-wildcard; operators-chained; operators-\n    comparison; optional-slash-combined/output/run/show; simple-none; truthiness-edge-\n    cases; var-complex-types; var-function-calls; when-literal-condition; when-negation-\n    switch; when-switch; wildcard-always-true\n  - warnings: bare-variable-reference; directive-in-text-line; template-syntax-in-text\n\nUpdate fixtures/expectations as needed, prioritizing non-strict-text errors first.","notes":"Plan for strict-mode test migration:\n- Default most feature/integration fixtures to strict (.mld, optional slash), unless they assert prose/blank-line semantics.\n- Keep markdown (.mld.md) only where prose behavior matters (content/blank lines/formatter/doc-style output).\n- Duplicate or parametrize only when mode changes behavior: prose handling, bare directives vs text, formatter/prose outputs, LSP/token sensitivity.\n- Use explicit mode in raw-string tests; SDK/CLI defaults stay strict unless prose is expected.\n- Keep LOOSE_TESTMODE=1 as default for stability; add targeted strict runs/subsets to catch regressions.\n- Migration order: 1) convert generic fixtures to strict; 2) add strict variants only for prose-sensitive cases; 3) wire a small strict subset run; 4) align docs/examples mode with intent.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T05:16:23.953965-08:00","updated_at":"2025-12-11T17:53:05.285765-08:00","closed_at":"2025-12-11T17:53:05.285765-08:00"}
{"id":"mlld-8d6","title":"Phase 1.4: Types - Define AST node types for blocks and while","description":"## Summary\n\nAdd TypeScript type definitions for the new AST nodes introduced by the grammar changes.\n\n## ‚ö†Ô∏è CRITICAL: Types Must Match Grammar Output\n\nThe type definitions below are **starting points**. After grammar is implemented:\n\n1. Run `npm run ast -- '\u003csyntax\u003e'` on each construct\n2. Compare actual grammar output to type definitions\n3. Adjust types to match grammar output exactly\n4. Pay special attention to:\n   - `values` vs direct properties\n   - `with`/pipeline metadata flow\n   - Array wrapping conventions\n\n**DO NOT assume these types are correct** - verify against actual grammar output!\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) to understand existing type hierarchy.\n\n## Files to Modify\n\n- `core/types/index.ts` - Add ExeBlockNode\n- `core/types/for.ts` - Extend ForDirective with actionType\n- `core/types/while.ts` (new) - WhilePipelineStage, WhileDirective types\n- `core/types/control.ts` (new or existing) - DoneLiteral, ContinueLiteral types\n\n## Type Definitions (Starting Points)\n\n### ExeBlockNode\n\n```typescript\nexport interface ExeBlockNode extends BaseMlldNode {\n  type: 'ExeBlock';\n  subtype: 'exeBlock';\n  values: {\n    statements: BaseMlldNode[];\n    return?: BaseMlldNode[];\n  };\n  raw: {\n    statements: string;\n    hasReturn: boolean;\n  };\n  meta: {\n    statementCount: number;\n    hasReturn: boolean;\n  };\n}\n\nexport function isExeBlockNode(node: BaseMlldNode): node is ExeBlockNode {\n  return node.type === 'ExeBlock';\n}\n```\n\n### ForDirective Extension\n\n```typescript\nexport interface ForDirective extends DirectiveNode {\n  kind: 'for';\n  subtype: 'for';\n  values: {\n    variable: VariableReferenceNode[];\n    source: BaseMlldNode[];\n    action: BaseMlldNode[];\n    forOptions?: {\n      parallel?: boolean;\n      cap?: number;\n      rateMs?: number;\n    };\n  };\n  meta: {\n    hasVariables: true;\n    actionType: 'single' | 'block';  // NEW FIELD\n  };\n}\n```\n\n### While Types\n\n```typescript\nexport interface WhilePipelineStage extends BaseMlldNode {\n  type: 'WhileStage';\n  values: {\n    cap: number;\n    rate: number | null;\n    processor: ExeReferenceNode;\n  };\n  meta: {\n    hasCap: true;\n    hasRate: boolean;\n  };\n}\n\nexport interface DoneLiteral extends BaseMlldNode {\n  type: 'ControlLiteral';\n  subtype: 'done';\n  values: {\n    value: BaseMlldNode[];\n  };\n  meta: {\n    hasValue: boolean;\n  };\n}\n\nexport interface ContinueLiteral extends BaseMlldNode {\n  type: 'ControlLiteral';\n  subtype: 'continue';\n  values: {\n    value: BaseMlldNode[];\n  };\n  meta: {\n    hasValue: boolean;\n  };\n}\n\nexport function isDoneLiteral(node: BaseMlldNode): node is DoneLiteral {\n  return node.type === 'ControlLiteral' \u0026\u0026 node.subtype === 'done';\n}\n\nexport function isContinueLiteral(node: BaseMlldNode): node is ContinueLiteral {\n  return node.type === 'ControlLiteral' \u0026\u0026 node.subtype === 'continue';\n}\n```\n\n## Validation\n\n- [ ] All new types extend BaseMlldNode correctly\n- [ ] Type guards are implemented\n- [ ] **Types verified against actual grammar output**\n- [ ] No circular dependencies introduced\n- [ ] Pipeline/with metadata flows correctly","notes":"Added types for exe blocks, while directive/stage, and control literals. Updated pipeline stage union, ForDirective meta actionType union, LiteralNode to allow done/continue payload arrays, and added control type guards. Build passes.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:00.189932-08:00","updated_at":"2025-12-10T00:06:55.847506-08:00","closed_at":"2025-12-10T00:06:55.847508-08:00","dependencies":[{"issue_id":"mlld-8d6","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.241807-08:00","created_by":"daemon"}]}
{"id":"mlld-8ie","title":"LSP: Update for rc78 grammar changes","description":"Update language server to support all rc78 grammar changes from CHANGELOG:\n\n## Syntax Changes to Support\n- **Block syntax**: `[...]` delimiters for exe/for/when blocks\n- **let keyword**: Block-scoped variables in exe/for/when\n- **while loops**: `/while`, `done`, `continue` keywords\n- **Streaming**: `stream` keyword, `/stream` directive\n- **Command working directories**: `cmd:/path`, `sh:/path`, etc.\n- **Template collections**: Import syntax for template directories\n- **When separators**: Semicolons in when arms\n- **For-when filter sugar**: `for ... when ...` syntax\n- **Comments in blocks**: `\u003e\u003e`/`\u003c\u003c` inside `[...]` bodies\n- **AST selector wildcards**: `*`, `?` patterns in selectors\n- **AST type filters**: `fn??`, `var??`, `class??` name listing\n- **Section listing**: `# ??`, `## ??` heading extraction\n- **Augmented assignment**: `+=` operator for let variables\n- **Import from @payload/@state**: Special import sources\n- **Regex literals**: `/pattern/` in when expressions\n- **Variable boundary escaping**: `@var\\.ext` syntax\n\n## Files to Update\n- `cli/commands/language-server-impl.ts` - Semantic token provider\n- `lsp/syntax/textmate.json` - TextMate grammar\n- `lsp/syntax/mlld.tmLanguage.json` - VSCode grammar\n\nSee CHANGELOG.md lines 7-199 for full details.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-11T20:12:18.008524-08:00","updated_at":"2025-12-11T20:12:18.008524-08:00","dependencies":[{"issue_id":"mlld-8ie","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:42.970143-08:00","created_by":"daemon"}]}
{"id":"mlld-8ml","title":"Pipeline state machine uses text channel instead of structured values","description":"PipelineExecutor loops state machine transitions on the .text string while stage inputs/outputs are StructuredValue. State machine START/STAGE_RESULT transitions only see text, so metadata/provenance/security are invisible to control flow and retries. Align state machine payloads with structured values (or dual channel) so pipeline retries and downstream guards use full data.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-08T19:40:41.102258-08:00","updated_at":"2025-12-10T23:07:34.419718-08:00","closed_at":"2025-12-10T23:07:34.419718-08:00"}
{"id":"mlld-8zi","title":"Grammar: @ in method string arguments incorrectly parsed as variable reference","description":"In when-expressions, method calls with double-quoted string arguments containing @ like `.startsWith(\"@\")` fail to parse because the @ is being interpreted as a variable reference instead of a literal character in the string.\n\nReproduction:\n```\n/exe @fn(msg) = when first [\n  @msg.body.startsWith(\"@\") =\u003e \"yes\"\n  * =\u003e \"no\"\n]\n```\n\nThis should parse successfully but fails with 'Invalid /exe syntax'.\n\nWorkaround: Use single quotes instead: `.startsWith('@')`","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T11:35:40.40568-08:00","updated_at":"2025-12-09T11:42:04.332574-08:00","closed_at":"2025-12-09T11:42:04.332574-08:00"}
{"id":"mlld-9id","title":"Phase 2.2: Interpreter - Add evaluateExeBlock() to exe.ts","description":"## Summary\n\nAdd exe block evaluation to the interpreter, reusing the exported let/augmented assignment functions from when.ts.\n\n## Key Insight\n\nExe blocks are ~80% the same as exe..when! An exe block is just a when expression without conditions (or with implicit `* =\u003e`). Massive reuse opportunity.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Return values should preserve wrappers\n\n## ‚ùå DON'T DO (Explicit Restrictions)\n\n1. **Field access mutation in +=**: `let @data[-1].field += value`\n   - Error: \"ETOOCOMPLEX: Augmented assignment only supports simple variables.\"\n   - Only support: `let @variable += value` (simple variable names)\n\n2. **Multiple return statements**: `=\u003e @x ... =\u003e @y`\n   - Error at parse time: \"Return statement must be last in exe block\"\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n- mlld-zeo (Export let functions)\n\n## Files to Modify\n\n- `interpreter/eval/exe.ts` - Add evaluateExeBlock() function\n\n## Implementation\n\nAdd after existing exe evaluation code (around line 50):\n\n```typescript\nimport { isLetAssignment, isAugmentedAssignment } from '@core/types/when';\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n\nasync function evaluateExeBlock(\n  block: ExeBlockNode,\n  env: Environment,\n  args: Record\u003cstring, unknown\u003e\n): Promise\u003cunknown\u003e {\n  // Create child environment for block scope\n  let blockEnv = env.createChild();\n\n  // Bind parameters to arguments\n  for (const [param, value] of Object.entries(args)) {\n    const importer = new VariableImporter();\n    const variable = importer.createVariableFromValue(\n      param, \n      value, \n      'exe-param', \n      undefined, \n      { env: blockEnv }\n    );\n    blockEnv.setVariable(param, variable);\n  }\n\n  // Execute statements sequentially\n  for (const stmt of block.values.statements) {\n    if (isLetAssignment(stmt)) {\n      blockEnv = await evaluateLetAssignment(stmt, blockEnv);\n    } else if (isAugmentedAssignment(stmt)) {\n      blockEnv = await evaluateAugmentedAssignment(stmt, blockEnv);\n    } else {\n      const result = await evaluate(stmt, blockEnv);\n      blockEnv = result.env || blockEnv;\n    }\n  }\n\n  // Handle return statement (required, must be last)\n  if (block.values.return) {\n    const returnResult = await evaluate(block.values.return, blockEnv);\n    return returnResult.value;\n  }\n\n  return undefined;\n}\n```\n\n## Wire into evaluateExe()\n\nUpdate around line 500 to detect and handle ExeBlock:\n\n```typescript\n// After checking for when expressions, add:\nif (content \u0026\u0026 content.type === 'ExeBlock') {\n  return await evaluateExeBlock(content, env, boundArgs);\n}\n```\n\n## Validation\n\n- [ ] Block creates child environment\n- [ ] Parameters bound correctly\n- [ ] Let assignments create scoped variables (as StructuredValue)\n- [ ] Augmented assignments work on arrays/strings/objects\n- [ ] Return statement evaluates and returns value (preserving wrapper)\n- [ ] Environment chaining preserved\n- [ ] Field access mutation throws helpful error","notes":"‚úÖ PREREQUISITE UPDATE: Type enums completed in mlld-b4f. ExeBlockNode interface verified in core/types/exe.ts. DirectiveSubtype includes 'exeBlock'. Type guard available: isExeBlockNode(). All AST structures validated. Ready for interpreter implementation once mlld-zeo (export let functions) is complete.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:17:46.580094-08:00","updated_at":"2025-12-10T14:00:49.063251-08:00","closed_at":"2025-12-10T14:00:49.063251-08:00","dependencies":[{"issue_id":"mlld-9id","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:51.917186-08:00","created_by":"daemon"},{"issue_id":"mlld-9id","depends_on_id":"mlld-zeo","type":"blocks","created_at":"2025-12-09T22:18:52.011176-08:00","created_by":"daemon"}]}
{"id":"mlld-9o7","title":"alias @base -\u003e @root, make @root default everywhere","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T13:18:31.724492-08:00","updated_at":"2025-12-09T13:18:31.724492-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-9pl","title":"Phase 1.1: Grammar - Add ExeStatementBlock and ForActionBlock patterns","description":"## Summary\n\nAdd `[...]` block patterns to exe and for directives, reusing existing when-block infrastructure.\n\n## üîë Critical Design Decision: `[...]` Not `{...}`\n\n**Why blocks use `[...]` instead of `{...}`:**\n- `{...}` is already used for code/commands/data objects\n- `[...]` is consistent with when blocks (already use this)\n- Zero ambiguity, no lookahead needed\n- LLM-friendly: clear visual separation from JS/shell\n\n**Array vs Block Disambiguation:**\n- In exe/for context, `[...]` is **ALWAYS** a block\n- Array literals only valid in `var` context\n- Context determines meaning - no grammar tricks needed\n\n**Examples:**\n```mlld\nexe @func() = [let @x = 1 =\u003e @x]    # Block (statements)\nexe @func() = [1, 2, 3]              # Also block (3 expressions - likely error)\nexe @arr() = {[1, 2, 3]}             # Escape hatch: object containing array\nvar @arr = [1, 2, 3]                 # Array literal (var context)\n```\n\n## ‚ö†Ô∏è IMPORTANT: Grammar Snippets Are Starting Points\n\nThe grammar snippets below are **starting points pending abstraction discovery findings** (mlld-cw9). The discovery phase may reveal better patterns to reuse. Don't copy these verbatim - use them as inspiration after understanding what already exists.\n\n## Strict vs Loose Mode Clarification\n\n- **Strict mode**: No slashes on directives (pure mlld)\n- **Loose mode**: Requires `/` on top-level directives (markdown-friendly)\n- **Inner statements**: Slashless in BOTH modes (inside blocks)\n\n## Prereq\n\nComplete abstraction discovery (mlld-cw9) first to understand what can be reused.\n\n## Files to Modify\n\n- `grammar/patterns/exe-rhs.peggy` - Add ExeBlockPattern\n- `grammar/directives/for.peggy` - Add ForActionVariant\n- `grammar/patterns/iteration.peggy` - Add ForBlockAction pattern\n\n## Grammar Implementation (Starting Points)\n\n### ExeBlockPattern (in exe-rhs.peggy)\n\nBased on discovery, likely reuses `WhenExpressionEntry` + return statement:\n\n```peggy\nExeStatementBlock \"exe statement block\"\n  = \"[\" _ statements:ExeBlockStatementList _ returnStmt:ExeReturnStatement? _ \"]\" {\n      return {\n        type: 'ExeBlock',\n        subtype: 'exeBlock',\n        source: 'block',\n        values: {\n          statements: statements,\n          ...(returnStmt ? { return: returnStmt } : {})\n        },\n        raw: {\n          statements: helpers.reconstructRawString(statements),\n          hasReturn: !!returnStmt\n        },\n        meta: {\n          statementCount: statements.length,\n          hasReturn: !!returnStmt\n        }\n      };\n    }\n```\n\n### ExeBlockStatementList\n\nLikely reuses existing patterns:\n\n```peggy\nExeBlockStatementList\n  = first:ExeBlockStatement rest:(_ stmt:ExeBlockStatement { return stmt; })* {\n      return [first, ...rest];\n    }\n\nExeBlockStatement \"exe block statement\"\n  = LetAssignment              // let @x = value\n  / AugmentedAssignment        // @x += value\n  / EffectAction               // show, log, output, append\n  / WhenRHSVarAssignment       // var @x = value (outer scope)\n  / WhenRHSCommandAction       // cmd {...}\n  / WhenRHSFunctionCall        // @func()\n  / VarRHSContent              // Any expression\n```\n\n### ForActionVariant\n\n```peggy\nForActionVariant\n  = \"=\u003e\" _ action:ForSingleAction {\n      return { type: 'single', action: Array.isArray(action) ? action : [action] };\n    }\n  / \"[\" _ statements:ForBlockStatementList _ \"]\" {\n      return { type: 'block', statements };\n    }\n```\n\n### Update ExeRHSContent ordering\n\n```peggy\nExeRHSContent \"exe assignment value\"\n  = WhenExpression              # when [...]\n  / ForExpressionExe            # for =\u003e [...]\n  / ExeCodePattern              # js {...}\n  / ExeCommandPattern           # cmd {...}\n  / ExeDataPattern              # {key: value}\n  / ExeStatementBlock           # NEW - [statements] (after data)\n  / ... rest\n```\n\n## Error Recovery\n\nAdd helpful error messages for:\n- Unterminated `[` - \"Unterminated block. Expected ']' to close block.\"\n- Comma separators - \"Use newlines between statements, not commas\"\n- Multiple returns - \"Only one return allowed as last statement\"\n\n## Statement Separator Rules\n\nUse whitespace separation like when blocks:\n- When.peggy lines 440-457 show the pattern\n- Error helpfully on commas\n\n## Testing\n\nAfter building grammar:\n```bash\nnpm run build:grammar\nnpm run ast -- 'exe @f() = [let @x = 1 =\u003e @x]'\nnpm run ast -- 'for @x in @xs =\u003e [show @x]'\n```\n\n## Validation\n\n- [ ] ExeStatementBlock parses correctly\n- [ ] ForActionBlock parses correctly  \n- [ ] Error recovery works for common mistakes\n- [ ] AST output matches type definitions\n- [ ] Strict mode works (no leading /)\n- [ ] Loose mode works (requires leading /)","notes":"Grammar: added exe statement blocks and for block actions with block separators, return handling, and error recovery; ForActionVariant handles block vs single; ExeRHSContent routes to blocks. build:grammar/build passed.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:14:45.573522-08:00","updated_at":"2025-12-10T02:36:55.739253-08:00","closed_at":"2025-12-10T02:36:55.739254-08:00","dependencies":[{"issue_id":"mlld-9pl","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.021026-08:00","created_by":"daemon"}]}
{"id":"mlld-9pv","title":"Epic: Block error reparse helper","description":"Add reparse-on-failure helper to surface inner-line parse errors for all [..] block constructs (exe blocks, for blocks, when blocks/match, guard blocks, foreach if applicable). Deliver: grammar-core helper + per-block wiring to reparse inner text with correct offsets, plus fixtures for improved diagnostics.","notes":"Block reparse helper landed across exe/for/when/guard, docs updated, changelog noted, targeted test added; grammar build passes.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-10T02:50:58.903344-08:00","updated_at":"2025-12-10T07:06:03.718621-08:00","closed_at":"2025-12-10T07:06:03.718623-08:00"}
{"id":"mlld-9pv.1","title":"Grammar-core: add reparseInner helper","description":"Add helpers.reparseInner(innerText, startRule, offset) in grammar/deps/grammar-core.ts to reparse block contents and rethrow mlldError with corrected locations. Should offset location() by block start and be safe for block contexts only.","notes":"Reparse helper implemented and wired; tests added.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:04.553133-08:00","updated_at":"2025-12-10T07:05:42.428859-08:00","closed_at":"2025-12-10T07:05:42.428861-08:00","dependencies":[{"issue_id":"mlld-9pv.1","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:04.553578-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.2","title":"Wire reparse helper for exe blocks","description":"Use grammar-core reparse helper in exe statement block parsing to re-run inner text on failure and surface inner-line errors; include unterminated block and return-last checks.","notes":"Exe block reparse wiring done; regression test covers block errors.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:11.017812-08:00","updated_at":"2025-12-10T07:05:48.053412-08:00","closed_at":"2025-12-10T07:05:48.053413-08:00","dependencies":[{"issue_id":"mlld-9pv.2","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:11.018285-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.3","title":"Wire reparse helper for for blocks","description":"Apply reparse helper to for block actions so inner errors point to the failing statement; handle unterminated block and comma/return diagnostics.","notes":"For block reparse wiring complete; included in shared block error test.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:15.726975-08:00","updated_at":"2025-12-10T07:05:53.976319-08:00","closed_at":"2025-12-10T07:05:53.97632-08:00","dependencies":[{"issue_id":"mlld-9pv.3","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:15.727462-08:00","created_by":"adam"}]}
{"id":"mlld-9pv.4","title":"Wire reparse helper for when/guard blocks","description":"Integrate reparse helper for when block/match and guard block parsing so inner condition/action errors report precise locations; ensure comma/unterminated handling remains.","notes":"When/guard block reparsing wired; block error test covers when/guard.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T02:51:22.663089-08:00","updated_at":"2025-12-10T07:05:59.402809-08:00","closed_at":"2025-12-10T07:05:59.40281-08:00","dependencies":[{"issue_id":"mlld-9pv.4","depends_on_id":"mlld-9pv","type":"parent-child","created_at":"2025-12-10T02:51:22.663541-08:00","created_by":"adam"}]}
{"id":"mlld-9qq","title":"Docs: audit strict vs markdown defaults","description":"Audit user/dev docs and examples to align with strict vs markdown modes. Scope:\\n- Default examples to strict unless prose semantics are needed.\\n- Identify docs needing mode updates and open individual cards per doc for edits.\\n- Ensure flags/CLI/SDK mode defaults are documented, with strict for modules and markdown for prose.\\n- Recommend keeping LOOSE_TESTMODE noted for test guidance.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:28:51.672034-08:00","updated_at":"2025-12-09T08:28:51.672034-08:00"}
{"id":"mlld-a03","title":"LSP: Comprehensive update for rc78 and editor support","description":"Epic tracking comprehensive LSP updates for:\n1. rc78 grammar changes (blocks, let, while, streaming, etc.)\n2. Strict mode support\n3. Outstanding editor-support GitHub issues\n\n## Scope\n- Update semantic tokens for all new syntax\n- Mode-aware highlighting (strict vs markdown)\n- Fix existing highlighting bugs\n- Improve error recovery\n\n## Child Issues\nSee dependencies for breakdown.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-11T20:12:45.617648-08:00","updated_at":"2025-12-11T20:12:45.617648-08:00"}
{"id":"mlld-a09","title":"LSP: Fix when block assignment highlighting (GH#327)","description":"Explicit assignment in when blocks shows 'Other' type instead of proper highlighting.\n\nSee: https://github.com/mlld-lang/mlld/issues/327\n\nSize: Small","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:37.357221-08:00","updated_at":"2025-12-11T20:12:37.357221-08:00","dependencies":[{"issue_id":"mlld-a09","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.386572-08:00","created_by":"daemon"}]}
{"id":"mlld-a2x","title":"mlld needs simple math operators and logic","description":"Math operators are ALREADY fully implemented in grammar and interpreter.\n\n**Current state (VERIFIED working)**:\n```mlld\n/var @sum = @x + @y\n/var @product = @x * @y\n/var @calc = (@a + @b) * @c / @d\n/when [@x + @y \u003e 10 =\u003e show \"sum exceeds 10\"]\n```\n\n**Operators supported**:\n- Arithmetic: `+`, `-`, `*`, `/`, `%`\n- Comparison: `==`, `\\!=`, `\u003c`, `\u003e`, `\u003c=`, `\u003e=`, `~=`\n- Logical: `\u0026\u0026`, `||`, `\\!`\n- Ternary: `condition ? true : false`\n\n**Grammar**: `UnifiedExpression` in `grammar/base/unified-expressions.peggy` (lines 41-49 for arithmetic)\n**Interpreter**: `evaluateBinaryExpression` in `interpreter/eval/expressions.ts` (lines 151-158)\n\n**Where they work NOW**:\n1. ‚úÖ `/var` assignments via `ExpressionWithOperator` pattern\n2. ‚úÖ `/when` conditions via `WhenConditionAdapter`\n3. ‚úÖ Array filters: `@items[?@price \u003e 100]`\n4. ‚ùå `/exe` blocks - NOT YET (exe blocks not implemented - see mlld-9id)\n5. ‚ùå `let` assignments - NOT YET (let not exported from when.ts - see mlld-zeo)\n\n**What's needed**:\nNOTHING for var/when. For exe blocks and let:\n- mlld-zeo exports let functions ‚Üí then math works in let automatically\n- mlld-9id implements exe blocks ‚Üí then math works in exe returns automatically\n\n**Close this card?** Math operators are done. The gaps are exe blocks/let implementation, not math support.","notes":"Fixed: Math operators now work everywhere including exe blocks and let assignments.\n\nFix applied: Changed interpreter/core/interpreter.ts line 672-674 to use evaluateUnifiedExpression (from expressions.ts) instead of evaluateExpression (from expression.ts). The OLD evaluator only supported comparison/logical operators; the NEW evaluator supports all operators including arithmetic (+, -, *, /, %).\n\nTest coverage added:\n- tests/cases/feat/arithmetic/exe-block-basic/ (addition in exe blocks)\n- tests/cases/feat/arithmetic/let-basic/ (multiplication in let)\n- tests/cases/feat/arithmetic/all-operators/ (all 5 operators)\n\nAll tests pass: 2419/2419 (100%)\n\nRefactoring issue created: mlld-xju (consolidate duplicate expression files)\n\nVerified working:\n- @a + @b in exe blocks ‚úÖ\n- @x * @y in let assignments ‚úÖ\n- All operators: +, -, *, /, % ‚úÖ\n- Existing var/when math still works ‚úÖ","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T16:37:38.005938-08:00","updated_at":"2025-12-10T18:33:07.58769-08:00","closed_at":"2025-12-10T18:33:07.587692-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-a4o","title":"Semicolon separator for single-line blocks","description":"Support semicolon as statement separator in exe/for blocks when written on single line.\n\n**Current**: Whitespace-separated works but hard to read\n```mlld\n/exe @func() = [let @x = 1  let @y = 2  =\u003e @x + @y]\n```\n\n**Target**: Semicolon separator for clarity\n```mlld\n/exe @func() = [let @x = 1; let @y = 2; =\u003e @x + @y]\n/for @item in @items [show @item; let @count += 1]\n```\n\n**Grammar changes needed**:\n- Update `BlockStatementSeparator` in `grammar/patterns/iteration.peggy` to accept `;` in addition to whitespace\n- Update `ExeBlockBody` in `grammar/patterns/exe-rhs.peggy` similarly\n- Ensure semicolon is optional (whitespace/newline still works)\n- AST unchanged - semicolon is purely syntactic sugar for readability\n\n**Test cases**:\n- Single-line with semicolons parses correctly\n- Multi-line without semicolons still works\n- Mixed: some semicolons, some newlines works\n- Error: comma rejected with helpful message (already implemented)\n\n**CHANGELOG**: Already documented in rc78 - this makes it real.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T10:45:20.704254-08:00","updated_at":"2025-12-10T23:08:09.182517-08:00","closed_at":"2025-12-10T23:08:09.182517-08:00","labels":["enhancement","grammar"]}
{"id":"mlld-ah5","title":"Cache: include mode in AST cache keys","description":"**Summary:**\nEnsure AST cache doesn't return wrong-mode cached AST.\n\n**Changes required:**\n\n1. **Locate AST cache** (likely in interpreter or execute flow):\n   - Find where parsed ASTs are cached by filepath\n\n2. **Update cache key**:\n   ```typescript\n   // Before\n   const cacheKey = filepath;\n   \n   // After\n   const cacheKey = `${filepath}:${mode}`;\n   ```\n   \n   Or use a composite key object if the cache supports it.\n\n3. **Cache invalidation**:\n   - Same file parsed with different mode = different cache entries\n   - mtime-based invalidation still applies per entry\n\n**Testing:**\n- Parse same file in strict mode, cache hit\n- Parse same file in markdown mode, cache miss (different key)\n- Modify file, both cache entries invalidate","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:57:52.664361-08:00","updated_at":"2025-12-11T17:39:52.611246-08:00","closed_at":"2025-12-11T17:39:52.611246-08:00","dependencies":[{"issue_id":"mlld-ah5","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.46839-08:00","created_by":"daemon"},{"issue_id":"mlld-ah5","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.797125-08:00","created_by":"daemon"}]}
{"id":"mlld-ait","title":"Phase 2.4: Interpreter - Add while loop evaluator","description":"## Summary\n\nAdd while loop evaluation for bounded iteration with done/continue control flow.\n\n## üìö Required Reading\n\nBefore starting this task:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- All values flow as StructuredValue with `.text`, `.data`, `.ctx`\n- Pipeline stages receive/return StructuredValue\n- State passed between iterations preserves wrappers\n- done/continue values should preserve wrappers\n\n## Prereq\n\n- mlld-0gd (Phase 1 verification)\n\n## Files to Create/Modify\n\n- `interpreter/eval/while.ts` (new file)\n- `interpreter/eval/pipeline/executor.ts` - Wire in while stage\n\n## Context Variables (@ctx.while.*)\n\nProcessors have access to iteration context:\n\n- `@ctx.while.iteration` (number) - Current iteration, **1-based**\n- `@ctx.while.limit` (number) - Configured cap\n- `@ctx.while.active` (boolean) - true when inside while loop\n\n```mlld\nexe @processor(state) = when [\n  @ctx.while.iteration \u003e 5 =\u003e done @state\n  @ctx.while.iteration == @ctx.while.limit =\u003e done \"hit cap\"\n  * =\u003e continue @state\n]\n```\n\n## Pacing Semantics\n\n- Parameter: `(cap, pacing)` e.g., `while(100, 1s)`\n- Pacing is minimum delay BETWEEN iterations\n- Applied after each iteration (except last)\n- Uses same TimeDuration format as other mlld features (ms, s, m, h)\n\n## Retry Interaction Rules (CRITICAL)\n\n- Processors **CANNOT** use `retry` keyword (use `continue` instead)\n- If processor returns `retry`, throw error: \"Use 'continue' instead of 'retry' in while processors\"\n- Downstream stages CAN retry the entire while stage\n- Example: `@initial | while(100) @iterate | @validate` (validate can retry the whole while)\n\n## Implementation\n\n### New File: while.ts\n\n```typescript\nimport { Environment } from '@interpreter/env/Environment';\nimport { isDoneLiteral, isContinueLiteral, isRetryLiteral, WhilePipelineStage } from '@core/types';\nimport { MlldWhileError } from '@core/errors';\nimport { evaluate } from '../evaluate';\n\ninterface WhileContext {\n  iteration: number;  // 1-based\n  limit: number;\n  active: boolean;\n}\n\nexport async function evaluateWhileStage(\n  stage: WhilePipelineStage,\n  input: unknown,\n  env: Environment\n): Promise\u003cunknown\u003e {\n  const cap = stage.values.cap;\n  const rate = stage.values.rate;\n  const processorRef = stage.values.processor;\n  \n  let state = input;\n  \n  for (let iteration = 1; iteration \u003c= cap; iteration++) {\n    // Create context for this iteration\n    const whileCtx: WhileContext = { \n      iteration,  // 1-based\n      limit: cap,\n      active: true \n    };\n    \n    // Set up iteration environment with @ctx.while\n    const iterEnv = env.createChild();\n    iterEnv.setContextValue('while', whileCtx);\n    \n    // Invoke processor with current state\n    const result = await invokeProcessor(processorRef, state, iterEnv);\n    \n    // Check for forbidden retry\n    if (isRetryLiteral(result)) {\n      throw new MlldWhileError(\n        \"Use 'continue' instead of 'retry' in while processors\",\n        { iteration, limit: cap }\n      );\n    }\n    \n    // Handle control flow\n    if (isDoneLiteral(result)) {\n      // Terminal - return the done value\n      return result.values.value.length \u003e 0 \n        ? await evaluate(result.values.value[0], iterEnv)\n        : state;\n    }\n    \n    if (isContinueLiteral(result)) {\n      // Continue with new state\n      state = result.values.value.length \u003e 0\n        ? await evaluate(result.values.value[0], iterEnv)\n        : state;\n    } else {\n      // Implicit continue with result as new state\n      state = result;\n    }\n    \n    // Apply pacing if specified (except on last iteration)\n    if (rate \u0026\u0026 iteration \u003c cap) {\n      await delay(rate);\n    }\n  }\n  \n  // Reached cap without done - throw error with hint\n  throw new MlldWhileError(\n    `While loop reached cap (${cap}) without 'done'. Consider increasing cap or check termination logic.`,\n    { iteration: cap, limit: cap }\n  );\n}\n```\n\n### Wire into Pipeline Executor\n\nIn `interpreter/eval/pipeline/executor.ts`, add handling for WhileStage:\n\n```typescript\nimport { evaluateWhileStage } from '../while';\n\n// In stage execution logic:\nif (stage.type === 'WhileStage') {\n  return await evaluateWhileStage(stage, input, env);\n}\n```\n\n## Control Flow Semantics\n\n- `done @value` - Terminate iteration, return value\n- `done` (no value) - Terminate, return current state\n- `continue @value` - Next iteration with value as new state\n- `continue` (no value) - Next iteration with current state\n- Implicit return - Treated as continue with result\n\n## Error Handling\n\n- **Cap exceeded**: `MlldWhileError` with hint to increase cap or check logic\n- **Retry used**: Error telling to use `continue` instead\n- **Invalid return**: Must return done/continue, error if neither recognized\n- **Processor errors**: Propagate normally with iteration number in stack\n\n## Validation\n\n- [ ] While stage executes bounded iterations\n- [ ] Done terminates and returns value (preserving StructuredValue)\n- [ ] Continue advances to next iteration (preserving StructuredValue)\n- [ ] Cap limit enforced with helpful error\n- [ ] Rate limiting (pacing) works\n- [ ] Context (@ctx.while.*) available in processor\n- [ ] Retry throws helpful error message\n- [ ] Iteration is 1-based (not 0-based)","notes":"‚úÖ PREREQUISITE UPDATE: Type enums completed in mlld-b4f. WhileDirective interface verified in core/types/while.ts (kind: 'while', subtype: 'while'). Pipeline stage type 'whileStage' validated in AST. DoneLiteralNode and ContinueLiteralNode interfaces exist in core/types/control.ts with type guards. DirectiveKind includes 'while', DirectiveSubtype includes 'while'. Ready for interpreter implementation.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:18:37.290469-08:00","updated_at":"2025-12-10T15:00:24.555534-08:00","closed_at":"2025-12-10T15:00:24.555534-08:00","dependencies":[{"issue_id":"mlld-ait","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:52.279935-08:00","created_by":"daemon"}]}
{"id":"mlld-ajm","title":"let statement doesn't support template RHS inside blocks","description":"**Repro:**\n```mlld\n/for @item in @items [\n  let @x = template \"alice.att\"\n  show @x\n]\n```\n\n**Error:**\n```\nParse error: Expected for block statement list but \"l\" found\n```\n\n**Expected:** `let` should accept `template \"path.att\"` as a valid RHS, same as `/exe` does.\n\nReported by @mllddev.1 in chat.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-10T20:21:29.989668-08:00","updated_at":"2025-12-11T11:27:33.036078-08:00","closed_at":"2025-12-11T11:27:33.036078-08:00","dependencies":[{"issue_id":"mlld-ajm","depends_on_id":"mlld-sus","type":"related","created_at":"2025-12-11T11:16:10.909589-08:00","created_by":"daemon"}]}
{"id":"mlld-atl","title":"Support template collections for registry modules","description":"**Current:** Template collections only work with local directories:\n```mlld\n‚úÖ /import templates from \"@base/agents\" as @agents(msg, ctx)\n‚úÖ /import templates from \"./agents\" as @agents(msg, ctx)\n‚ùå /import templates from @alice/templates as @tmp(msg, ctx)  # fails\n```\n\n**Desired:** Enable template collections for published registry modules:\n```mlld\n/import templates from @alice/agents as @agents(message, context)\n/show @agents[\"alice\"](@msg, @ctx)\n/show @agents.support[\"helper\"](@msg, @ctx)\n```\n\n**Implementation challenges:**\n1. **Packaging** - How to publish directory structures to registry?\n   - Option A: Zip archive in module metadata\n   - Option B: Manifest listing all template paths\n   - Option C: Multi-file gist (GitHub API supports this)\n\n2. **Resolution** - RegistryResolver needs to:\n   - Detect `importType === 'templates'`\n   - Fetch directory structure (not single file)\n   - Provide directory walker interface\n\n3. **Caching** - Template collections need directory-level cache invalidation\n\n**Workaround:** Publish individual template executables:\n```mlld\n\u003e\u003e In @alice/templates module\n/exe @alice(msg, ctx) = template \"alice.att\"\n/exe @bob(msg, ctx) = template \"bob.att\"\n/export { @alice, @bob }\n\n\u003e\u003e Usage\n/import { @alice, @bob } from @alice/templates\n```\n\n**Priority:** P3 - the workaround works, but UX would be better with collection syntax.\n\n**Related:** mlld-drq (local template collections)","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-10T22:32:56.758945-08:00","updated_at":"2025-12-10T22:32:56.758945-08:00"}
{"id":"mlld-b0e","title":"Grammar: Add WorkingDirPath pattern for :path suffix parsing","description":"## Context\nPart of implementing cmd:path/sh:path feature to allow setting working directory for command execution.\n\nExample syntax:\n```mlld\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n/run sh:@mypath {echo \"hello world\"}\n/run cmd:@base/scripts {./build.sh}\n/run sh:/Users/@username/dev/@dir {somecommand}\n```\n\n## Task\nCreate a new grammar pattern `WorkingDirPath` to parse the `:path` suffix that appears after `cmd` or language keywords (`sh`, `bash`, etc).\n\n## Requirements\n\n1. Path must be rooted (absolute) - starts with `/` or `@`\n2. Support variable interpolation: `@mypath`, `@base/subdir`, `/home/@user/dev`\n3. No relative paths allowed (no `./` or bare names)\n\n## Implementation\n\nLocation: `grammar/patterns/unified-run-content.peggy`\n\nAdd these patterns:\n\n```peggy\n// Working directory path suffix for cmd and sh\nWorkingDirPath \"working directory path\"\n  = \":\" path:WorkingDirPathContent {\n      return path;\n    }\n\n// Path content with variable interpolation\nWorkingDirPathContent\n  = parts:WorkingDirPathPart+ {\n      const flatParts = parts.flat();\n      const raw = helpers.reconstructRawString(flatParts);\n      \n      return {\n        type: 'workingDir',\n        parts: flatParts,\n        raw: raw,\n        meta: helpers.createPathMetadata(raw, flatParts)\n      };\n    }\n\n// Individual path parts - variables or literal path segments\nWorkingDirPathPart\n  = UnifiedVariableNoTail       // @mypath or @base etc.\n  / WorkingDirPathLiteral       // /path/segments\n\n// Literal path segments (no whitespace, not braces)\nWorkingDirPathLiteral\n  = chars:WorkingDirPathChar+ {\n      return helpers.createNode(NodeType.Text, { \n        content: chars.join(''), \n        location: location() \n      });\n    }\n\nWorkingDirPathChar\n  = [^\\s\\t\\n\\r\\{\\}@]  // Any char except whitespace, braces, @\n```\n\n## Key Points\n\n- Reuse `UnifiedVariableNoTail` for variable parsing (already exists)\n- Return structure with `parts` (AST nodes) and `raw` (string)\n- Use `helpers.createPathMetadata()` to create metadata\n- Must stop at whitespace or `{` (command block start)\n\n## Testing\n\nAfter implementation, test with `npm run ast`:\n```bash\nnpm run ast -- 'cmd:/absolute/path {ls}'\nnpm run ast -- 'cmd:@variable {ls}'\nnpm run ast -- 'cmd:@base/subdir {ls}'\n```","notes":"Grammar pattern should parse :path suffix for cmd/sh etc; path content allows absolute Unix paths only; no Windows or '~'; '/' valid.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:06.303866-08:00","updated_at":"2025-12-08T20:23:24.305345-08:00","closed_at":"2025-12-08T20:23:24.305345-08:00"}
{"id":"mlld-b4f","title":"Phase 1.7: Verify AST/Types alignment with design principles","description":"Comprehensive verification that all new grammar changes (exe blocks, for blocks, while loops, done/continue literals) produce ASTs that align with existing mlld design principles and type system.\n\n## Context\n\nPhase 1 grammar work is \"complete\" but we need thorough verification that:\n1. AST structure follows mlld conventions (docs/dev/AST.md, docs/dev/GRAMMAR.md)\n2. Types align with existing enums and interfaces (core/types/)\n3. StructuredValue patterns are correct (docs/dev/DATA.md)\n4. No regressions or inconsistencies introduced\n\n## Required Reading\n\n- **docs/dev/AST.md** - Context-aware AST design principles (may be slightly outdated but principles are sound)\n- **docs/dev/GRAMMAR.md** - Grammar architecture and abstraction patterns\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n\n## Verification Checklist\n\n### 1. AST Structure Verification\n\nFor each new construct, verify AST follows mlld conventions:\n\n**Exe Blocks** (`/exe @f() = [...]`):\n- [ ] `directive.kind === 'exe'`\n- [ ] `directive.subtype === 'exeBlock'`\n- [ ] `values.statements` is array of statement nodes\n- [ ] `values.return` has proper ExeReturn structure\n- [ ] `meta.statementCount`, `meta.hasReturn` set correctly\n- [ ] Location tracking includes block boundaries\n\n**For Blocks** (`for @x in @xs [...]`):\n- [ ] `directive.kind === 'for'`\n- [ ] `meta.actionType === 'block'` or `'single'`\n- [ ] `values.action` is array when actionType='block'\n- [ ] `meta.blockMeta.statementCount` set when block\n- [ ] Arrow form still parses (`for @x in @xs =\u003e [...]`)\n\n**While Loops** (`/while(100) @processor`):\n- [ ] Directive form: `kind === 'while'`, `subtype === 'whileDirective'`\n- [ ] Pipeline form: node type for pipeline stage\n- [ ] `values.cap` (number), `values.processor` (VariableReference)\n- [ ] Optional `values.rateMs` for pacing\n- [ ] Location tracking correct\n\n**Done/Continue Literals**:\n- [ ] `type === 'Literal'`\n- [ ] `valueType === 'done'` or `valueType === 'continue'`\n- [ ] `value` is array (may be empty or contain expression)\n- [ ] Works in return position, when expression actions\n- [ ] Proper location tracking for error messages\n\n### 2. Type System Verification\n\nCheck alignment with existing types:\n\n**DirectiveKind enum** (core/types/):\n- [ ] 'exe' already exists (verify exeBlock subtype)\n- [ ] 'for' already exists (verify block metadata)\n- [ ] 'while' added if new directive kind needed\n- [ ] No duplicate or conflicting enum values\n\n**Literal valueType** (core/types/):\n- [ ] 'done' added to valueType union\n- [ ] 'continue' added to valueType union\n- [ ] Literal node interface supports array value\n- [ ] No conflicts with existing literal types\n\n**Meta flags**:\n- [ ] `actionType: 'block' | 'single'` on ForDirective\n- [ ] `statementCount`, `hasReturn` on ExeBlock\n- [ ] `blockMeta` for nested block info\n- [ ] No namespace collisions with existing meta\n\n### 3. StructuredValue Patterns\n\nVerify alignment with DATA.md:\n\n**Let assignments**:\n- [ ] Store StructuredValue wrappers (not raw values)\n- [ ] Preserve .text, .data, .ctx through assignments\n- [ ] Augmented assignment (+=) works with StructuredValue\n\n**Block returns**:\n- [ ] Exe block return preserves StructuredValue wrapper\n- [ ] Done/continue values preserve wrappers\n- [ ] No unwrapping until boundaries (asData/asText)\n\n**Iteration values**:\n- [ ] For loop iterator values wrapped\n- [ ] While loop state values wrapped\n- [ ] Context (@ctx) values properly structured\n\n### 4. Regression Testing\n\nRun existing tests to ensure no breaks:\n\n```bash\nnpm run build:grammar\nnpm test grammar/\nnpm run ast -- '/exe @f() = when [* =\u003e \"test\"]'  # Existing exe..when\nnpm run ast -- '/for @x in @xs =\u003e show @x'        # Existing for single\nnpm run ast -- '/var @x = 1'                       # Basic directive\n```\n\nExpected: All existing syntax still parses correctly.\n\n### 5. AST Inspection\n\nUse ast tool to verify structure:\n\n```bash\n# Exe block\nnpm run ast -- '/exe @add(x, y) = [let @sum = @x + @y; =\u003e @sum]'\n\n# For block  \nnpm run ast -- '/for @item in @items [show @item; let @count += 1]'\n\n# While directive\nnpm run ast -- '/while(100, 1s) @processor'\n\n# Done/continue\nnpm run ast -- '/exe @f() = when [@x \u003e 5 =\u003e done @x]'\nnpm run ast -- '/exe @f() = when [* =\u003e continue (@x - 1)]'\n```\n\nInspect output for:\n- Correct node types\n- Proper nesting structure  \n- Meta flags set appropriately\n- No unexpected fields\n- Location data present\n\n### 6. Type Alignment Check\n\n```bash\n# Type check should pass\nnpm run build\n\n# Look for type errors in:\n# - core/types/directive.ts\n# - core/types/literal.ts  \n# - interpreter/eval/exe.ts\n# - interpreter/eval/for.ts\n# - interpreter/eval/while.ts\n```\n\n### 7. Documentation Updates\n\nIf AST.md or GRAMMAR.md are outdated:\n- [ ] Update AST.md with new node types/patterns\n- [ ] Update GRAMMAR.md if new abstractions added\n- [ ] Document any new meta flags\n- [ ] Add examples for new constructs\n\n## Common Issues to Check\n\n1. **Location offsets**: Block reparsing must have correct offsets\n2. **Meta consistency**: Same construct different contexts should have consistent meta\n3. **Array wrapping**: All directive values should be node arrays (except primitives in var)\n4. **Type discriminators**: Objects/arrays use type field, not structure alone\n5. **Context flags**: isDataValue, isRHSRef set correctly for embedded directives\n\n## Acceptance Criteria\n\n- [ ] All new constructs parse to valid AST\n- [ ] AST structure follows mlld conventions (AST.md)\n- [ ] Types compile without errors\n- [ ] No regressions in existing grammar tests\n- [ ] Meta flags consistent with patterns\n- [ ] StructuredValue patterns correct\n- [ ] Location tracking works for error messages\n\n## Deliverable\n\nCreate `tmp/phase1-ast-verification.md` documenting:\n1. AST samples for each new construct (pretty-printed JSON)\n2. Type alignment verification (enum values, interfaces)\n3. Any issues found and fixes applied\n4. Confirmation that all principles followed\n\n## Time Estimate\n\n60-90 minutes (thorough inspection, not quick pass)","notes":"Phase 1 AST verification complete. All constructs verified and aligned with design principles. See tmp/phase1-ast-verification.md for full report. Key findings: All tests pass (2391/2391), AST structures correct, types align. Minor action: add 'while' to DirectiveKind enum. Ready for Phase 2.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T11:26:55.803735-08:00","updated_at":"2025-12-10T11:47:25.491635-08:00","closed_at":"2025-12-10T11:47:25.491638-08:00","dependencies":[{"issue_id":"mlld-b4f","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-10T11:26:55.804511-08:00","created_by":"daemon"}]}
{"id":"mlld-bbu","title":"LSP: Highlight variable interpolation in /run blocks (GH#330)","description":"Variable interpolation not highlighted in /run command blocks.\n\nSee: https://github.com/mlld-lang/mlld/issues/330\n\nSize: Small","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:36.916573-08:00","updated_at":"2025-12-11T20:12:36.916573-08:00","dependencies":[{"issue_id":"mlld-bbu","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.268595-08:00","created_by":"daemon"}]}
{"id":"mlld-bgl","title":"Security: Policy-based working directory path restrictions","description":"Add security policy support for restricting working directory paths in cmd:path/sh:path syntax.\n\n## Background\nCurrently cmd:path and sh:path allow any absolute path the user has filesystem access to. We need policy-based restrictions to:\n- Define allowed path prefixes (e.g., only /Users/adam/dev/)\n- Prevent access to sensitive directories (/etc, /root, etc.)\n- Support guards that test path compliance before execution\n\n## Requirements\n1. Extend security policy to include working directory constraints\n2. Add path validation against policy in cwd-resolver\n3. Create guards that can inspect and approve/deny workingDir\n4. Clear error messages when path violates policy\n\n## Examples\nPolicy:\n```\n/needs cmd.cwd:/Users/adam/dev/**\n```\n\nGuard:\n```\n/guard [cmd.cwd =\u003e {\n  # Validate working directory is within allowed paths\n}]\n```\n\nThis issue should be tackled after the basic cmd:path/sh:path feature is implemented and working.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T12:53:10.831611-08:00","updated_at":"2025-12-08T12:53:10.831611-08:00","labels":["future","security"]}
{"id":"mlld-cgb","title":"LSP: update highlighting for strict and markdown modes","description":"Audit and update LSP semantic tokens and visitors to handle strict vs markdown modes. Ensure directive detection, template handling, and mode-sensitive tokenization stay accurate in both modes; add tests for each mode.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:30:21.961653-08:00","updated_at":"2025-12-09T08:30:21.961653-08:00","dependencies":[{"issue_id":"mlld-cgb","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.051024-08:00","created_by":"daemon"}]}
{"id":"mlld-cjt","title":"Consider removing prettyprint default","description":"We prettyprinted all JSON output early on because mlld was simplistic and also completely string based. I think it is probably unnecessary to prettyprint by default, but I'm not sure about it yet.\n\nIt's very nice to just have any JSON output be immediately readable which is very hard for humans dealing with compact JSON ‚Äî but given that most of the content is likely to be read by LLMs it's probably not necessary at all.\n\nWe could instead have a `| @pretty` built-in to allow that if the user wants it.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T09:02:59.292539-08:00","updated_at":"2025-12-11T09:02:59.292539-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-cu0","title":"Support semicolon separation for when arms (universal block separator)","description":"**Current:** When arms require newlines:\n```mlld\n/var @arr = for @x in @xs =\u003e when [\n  @x == 1 =\u003e @x\n  none =\u003e skip\n]\n```\n\n**Desired:** Semicolons should work as universal block separators:\n```mlld\n/var @arr = for @x in @xs [ when [ @x == 1 =\u003e @x; none =\u003e skip ] ]\n```\n\nCurrently fails with: \"Syntax error: Invalid variable syntax, but found \";\"\"\n\nOther blocks support semicolon separation - this should be universal for consistency and one-liner convenience.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T20:59:07.161018-08:00","updated_at":"2025-12-10T20:59:07.161018-08:00"}
{"id":"mlld-cw9","title":"Phase 0: Abstraction Discovery for Block Syntax Epic","description":"**CRITICAL: This must be done FIRST before any implementation!**\n\n## Purpose\n\nBefore writing any new grammar, systematically identify what already exists. The plan was created with \"late-context chaotic planning energy\" - a fresh implementer's brain will see patterns we missed.\n\n## Time Budget\n\n60-90 minutes of reading before writing code.\n\n## Required Reading\n\n### 1. Grammar Files to Review\n\n**`grammar/patterns/exe-rhs.peggy`**\n- What can `WhenExpression` currently contain? (lines 438-517)\n- What's in `WhenExpressionEntry`? (line 502-505)\n- What's `WhenRHSAction`? (references when-rhs-action.peggy)\n- Can we reuse `WhenExpressionConditionList` for exe blocks?\n\n**`grammar/patterns/when-rhs-action.peggy`**\n- What actions are supported? (line 8-17)\n- What directives can appear in when RHS?\n- Which of these should work in exe blocks?\n\n**`grammar/patterns/iteration.peggy`**\n- What's in `ForSingleAction`? (lines 55-101)\n- Does it already support everything for blocks need?\n- What's `WhenRHSAction` reused here?\n\n**`grammar/base/literals.peggy`**\n- How are `retry`, `skip`, `allow`, `denied` defined? (lines 50-74)\n- Follow exact same pattern for `done` and `continue`\n\n**`grammar/patterns/let-assignment.peggy`**\n- How do `LetAssignment` and `AugmentedAssignment` work?\n- Can we reuse directly or need exe-specific variants?\n\n### 2. Type Files to Review\n\n**`core/types/` for exe/for/when**\n- Understand `ExecutableDefinition` variants\n- How does dispatch work?\n- Where does `ExeBlockNode` fit in hierarchy?\n\n### 3. Data Handling (CRITICAL!)\n\n**`docs/dev/DATA.md`** - Required reading!\n- StructuredValue system (.text, .data, .ctx)\n- When to use asData() vs asText()\n- Boundary rules for unwrapping\n\n### 4. Files to AVOID\n\n**`grammar/directives/for-template.peggy`** - NOT reusable (text substitution)\n\n## Key Insight from Plan\n\nExe blocks are ~80% the same as exe..when! An exe block is just when expression without conditions (or with implicit `* =\u003e`). Massive reuse opportunity.\n\n## Critical Disambiguation (SOLVED in plan)\n\nIn exe/for contexts, `[...]` is **always a block**:\n```mlld\nexe @func() = [1, 2, 3]           # Block with 3 expressions (likely error)\nexe @func() = {[1, 2, 3]}         # Escape hatch: object with array\nexe @func() = @identity([1, 2, 3]) # Or use function\n\nfor @x in @xs =\u003e [statements]     # Always block\n```\n\n**No lookahead needed** - Context determines meaning.\n\n## Deliverable\n\nCreate `tmp/abstraction-reuse-findings.md` documenting:\n1. What patterns exist and can be reused (with line numbers)\n2. What needs creating (minimal list)\n3. Gap analysis: exe..when vs exe blocks\n4. Solution for array literal disambiguation\n5. Type hierarchy understanding\n6. StructuredValue usage patterns\n\n## Validation\n\n- [ ] Read all listed files\n- [ ] Created findings document\n- [ ] Identified reuse opportunities\n- [ ] Ready to start Phase 1\n\n## Warning\n\nThe plan shows test examples with BOTH `{...}` and `[...]` syntax due to iteration during planning. **The final decision is `[...]` for all mlld blocks**. When implementing, convert all block examples to use `[...]` brackets, not `{...}` curly braces.","notes":"Phase 0 reading done; documented reuse/gaps in tmp/abstraction-reuse-findings.md; ready to proceed to block grammar/AST work.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-09T22:14:05.424356-08:00","updated_at":"2025-12-09T23:42:33.072751-08:00","closed_at":"2025-12-09T23:42:33.072751-08:00"}
{"id":"mlld-d0p","title":"Use the SDK's analyze module function to extract the required base-level `/needs` and check them against the user's module when publishing","description":"If the user doesn't have required items listed, we should suggest `/needs` and suggest they break it up into `/wants` tiers if there is a requirement hierarchy.\n\nThis issue needs to be thought through in more depth.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-07T13:50:42.30443-08:00","updated_at":"2025-12-08T12:20:15.296359-08:00","labels":["creator:adamavenir@hey.com"]}
{"id":"mlld-drq","title":"Template collection import: /import templates from dir as @name","description":"**Problem:** Users can't dynamically load templates based on runtime values. The current `/exe @name() = template \"path.att\"` resolves the path at definition time, so parameters can't be used in paths.\n\n**Syntax:**\n```mlld\n/import templates from \"@base/agents\" as @agents(message, context)\n/import templates from \"@base/formatters\" as @formatters(data, format)\n\n\u003e\u003e All templates in agents/ share the (message, context) signature\n/show @agents[\"alice\"](@msg, @ctx)\n/show @agents[\"bob\"](@msg, @ctx)\n\n\u003e\u003e Nested directories via dot notation\n/show @agents.support[\"helper\"](@msg, @ctx)\n\n\u003e\u003e Dynamic in loops\n/for @agent in @agentList [\n  show @agents[@agent.name](@message, @context)\n]\n```\n\n**Key design: Explicit parameter contract**\n- Parameters declared in the import: `as @agents(message, context)`\n- ALL templates in that directory must accept those params\n- Different param signatures = different template groups\n- No inference needed - contract is explicit\n\n**Validation:**\n- Template uses `@message` ‚úì (in declared signature)\n- Template uses `@foo` ‚úó ‚Üí \"Template 'alice.att' references @foo but signature only declares (message, context)\"\n- Unused params are fine (template doesn't have to use all declared params)\n\n**Directory structure:**\n- `agents/alice.att` ‚Üí `@agents[\"alice\"]`\n- `agents/support/helper.att` ‚Üí `@agents.support[\"helper\"]`\n- Directories become dot segments, filenames stay in brackets\n\n**Errors:**\n- Template not found: \"Template 'unknown' not found in @agents. Available: alice, bob, support/helper\"\n- Param mismatch at parse time (template references undeclared var)\n\n**Implementation notes (via gpt5.1 analysis):**\n- Add `templates` import type to grammar\n- Detect `importType === 'templates'` and walk directory instead of blocking\n- Build nested moduleObject with `__executable` entries keyed by path\n- Parse each template with `parseSync(..., {startRule: 'TemplateBodyAtt'})`\n- Validate template AST against declared params at parse time\n- Keep single-file `.att` import banned - use `/exe @name() = template \"file.att\"` for that\n- Consider lazy loading (don't parse until first invocation) for performance\n- Security: ensure traversal stays under base dir, taint labels track each file\n\n**Security:** Base directory fixed at definition time, only filename/index varies at runtime. Provenance trackable. All templates get taint from their source file.\n\nReported by @partydev's use case in chat.","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-10T20:20:32.153268-08:00","updated_at":"2025-12-10T20:55:40.462412-08:00"}
{"id":"mlld-e0b","title":"Interpreter: Modify run evaluator to resolve and pass cwd","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task modifies the run evaluator to check for workingDir in the AST, resolve it, and pass it to command executors.\n\n## Prerequisites\n- mlld-1x2 complete (cwd-resolver exists)\n- mlld-u8r complete (workingDir types defined)\n- Grammar tasks complete (workingDir in AST)\n\n## Task\nModify `interpreter/eval/run.ts` to handle the optional `workingDir` field from the AST.\n\n## Implementation\n\nLocation: `interpreter/eval/run.ts`\n\n### Step 1: Import the resolver\n\nAdd import at top of file:\n```typescript\nimport { resolveCwd } from '../utils/cwd-resolver';\n```\n\n### Step 2: Find command execution locations\n\nLook for calls to:\n- `env.executeCommand()`\n- `env.executeCode()`\n\nThese are likely in functions like:\n- `evaluateRunCommand()` - for `cmd {...}`\n- `evaluateRunCode()` - for `sh {...}`, `bash {...}`, etc.\n\n### Step 3: Add cwd resolution before execution\n\nFor each execution point, add cwd resolution:\n\n```typescript\n// Check if workingDir is present in AST\nlet resolvedCwd: string | undefined;\nif (node.values?.workingDir) {\n  resolvedCwd = await resolveCwd(\n    node.values.workingDir,\n    env,\n    node.location\n  );\n}\n\n// Pass to executor\nconst result = await env.executeCommand(command, {\n  ...existingOptions,\n  cwd: resolvedCwd\n});\n```\n\n### Step 4: Handle both cmd and code execution\n\nMake sure both paths are covered:\n\n**For cmd execution:**\n```typescript\nconst result = await env.executeCommand(command, {\n  env: envVars,\n  cwd: resolvedCwd,  // NEW\n  // ... other options\n});\n```\n\n**For code execution (sh, bash, js, python):**\n```typescript\nconst result = await env.executeCode(language, code, {\n  args: resolvedArgs,\n  cwd: resolvedCwd,  // NEW\n  // ... other options\n});\n```\n\n## Edge Cases\n\n1. **workingDir is optional**: Only resolve if present in AST\n2. **Error propagation**: Let `resolveCwd` errors bubble up naturally\n3. **Pipeline context**: Each command gets its own cwd resolution\n\n## Testing\n\nAfter implementation, test with actual mlld scripts:\n\n```bash\necho '/var @mypath = \"/tmp\"\n/run cmd:@mypath {pwd}' | ./dist/cli.cjs\n\n# Should output: /tmp\n```\n\n```bash\necho '/run cmd:/nonexistent {ls}' | ./dist/cli.cjs\n\n# Should error: Working directory does not exist\n```","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:35.93044-08:00","updated_at":"2025-12-08T20:24:42.061534-08:00","closed_at":"2025-12-08T20:24:42.061534-08:00"}
{"id":"mlld-e4j","title":"Improve error message when .att parsed as field access","description":"When users write `@x.name.att` intending a path like `alice.att`, they get a confusing error:\n\n\"Cannot access field att on non-object value (string)\"\n\nThis is because the parser interprets `.att` as field access on `@x.name`.\n\n**Expected**: A helpful error message suggesting the user might need to escape the dot: `@x.name\\.att`\n\n**Current**: Generic field access error that doesn't hint at the likely cause.\n\nThis is a common gotcha for users working with .att template files in dynamic paths.\n\nReported by @partydev in chat.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-10T19:40:11.908742-08:00","updated_at":"2025-12-10T23:08:53.126333-08:00","closed_at":"2025-12-10T23:08:53.126333-08:00"}
{"id":"mlld-ecy","title":"Support comments (\u003e\u003e and \u003c\u003c) inside block bodies","description":"**Current:** Comments aren't allowed inside `[...]` blocks:\n```mlld\n/exe @func() = [\n  let @x = 1        \u003e\u003e this comment causes parse error\n  let @y = 2  \u003c\u003c so does this\n  =\u003e @x + @y\n]\n```\n\nParse error: \"Expected ... but '#' found\" or \"Invalid variable syntax, but found '\u003c'\"\n\n**Desired:** Comments should work inside blocks just like they work everywhere else:\n```mlld\n/exe @func() = [\n  let @x = 1        \u003e\u003e start-of-line comment\n  let @y = 2  \u003c\u003c end-of-line comment\n  =\u003e @x + @y  \u003c\u003c return value\n]\n\n/for @item in @items [\n  \u003e\u003e explain this step\n  let @processed = @transform(@item)\n  show @processed  \u003c\u003c debug output\n]\n\n/when [\n  let @check = @validate(@input)  \u003e\u003e validate first\n  @check.valid =\u003e @process(@input)  \u003c\u003c process if valid\n  * =\u003e show \"Invalid\"  \u003c\u003c fallback\n]\n```\n\n**Use case:** Documenting complex block logic, especially for multi-step orchestration patterns where each step needs explanation.\n\n**Grammar location:** Block statement parsing (exe blocks, for blocks, when blocks) needs to accept comment tokens.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-11T09:49:06.410873-08:00","updated_at":"2025-12-11T09:51:28.767535-08:00","closed_at":"2025-12-11T09:51:28.767535-08:00"}
{"id":"mlld-emu","title":"CLI: add --payload alias for --inject flag","description":"**Reported by:** partydev during SDK dogfooding\n\n**Request:**\nAdd `--payload` as an alias for `--inject` in the CLI for consistency with the SDK.\n\n**Rationale:**\n- SDK uses `execute(file, payload)`\n- CLI uses `--inject`\n- For consistency, `mlld file.mld --payload '{...}'` would be more intuitive\n\n**Implementation:**\nAdd alias in ArgumentParser - straightforward change.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-09T07:50:59.202687-08:00","updated_at":"2025-12-09T08:06:20.371517-08:00","closed_at":"2025-12-09T08:06:20.371517-08:00"}
{"id":"mlld-eyv","title":"LSP: Fix pipe transform highlighting parity bug (GH#328)","description":"Pipe transforms only highlight correctly with odd number of pipes in /var directives.\n\nSee: https://github.com/mlld-lang/mlld/issues/328\n\nSize: Small","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:37.208122-08:00","updated_at":"2025-12-11T20:12:37.208122-08:00","dependencies":[{"issue_id":"mlld-eyv","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.34824-08:00","created_by":"daemon"}]}
{"id":"mlld-f2q","title":"Harden path resolution story across the board for monorepo setups","description":"Inconsistent where various parts of the codebase think things are rooted\n\nWe need to find the way different parts of the codebase root paths and what assumptions and fallbacks they use\n\nThen we need to make sure these work completely consistently in cases where a dir is inside another dir that possesses qualities that might make other parts of the codebase infer paths differently.\n\nHaving `/monorepo/.git` seems to set where `mlld-config.json` gets written if `mlld setup` is run in `/monorepo/subproject` -- instead of writing/updating the new mlld-config.json in subproject, it writes/updates it at the root or at leaset SEEMS to.\n\nThis will be a research task first, then a discussion to decide how to reconcile and standardize for reasonably expected UX.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T04:11:07.083517-08:00","updated_at":"2025-12-11T04:41:01.81153-08:00","closed_at":"2025-12-11T04:41:01.811532-08:00","labels":["creator:adamavenir@hey.com","fizzy:maybe"]}
{"id":"mlld-fln","title":"Epic: Block Syntax, While Loops, and Grammar Error Handling","description":"A unified grammar epic that adds three major features to mlld:\n\n1. **Block syntax `[...]`** for exe/for directives with `let`/`+=` support\n2. **While loops** with `done`/`continue` keywords for bounded iteration\n3. **Unified when syntax** - one form: `when [condition =\u003e action]`\n4. **Improved error handling** - proper location tracking in blocks\n\n## Key Insight\n\nAll three features use `[...]` delimiter for mlld constructs, creating clear visual separation from JS/shell `{...}` syntax. This helps LLMs distinguish mlld from embedded languages.\n\n## Why Together\n\nSame files, same patterns, shared error infrastructure. More efficient as one epic than three separate PRs.\n\n## Block Syntax (CRITICAL)\n\n**For loops**:\n- Preferred: `for @x in @xs [...]` (no arrow)\n- Deprecated: `for @x in @xs =\u003e [...]` (arrow still works but deprecated)\n\n**Exe blocks**:\n- `exe @f() = [...]`\n\n**When**:\n- Block: `when [...]`\n- Simple: `when @condition =\u003e action`\n\n## Delimiter Rules\n\n- `{...}` ‚Üí code/command/data (requires prefix or property syntax)\n- `[...]` ‚Üí mlld blocks in exe/for/when contexts\n- `[...]` ‚Üí array literals in var/argument contexts\n- **Context determines meaning** - No ambiguity!\n\n## New Keywords\n\n- `done` and `continue` (for while loops)\n- `let` already exists for when blocks\n\n## Scope Restrictions (Pragmatic)\n\n**NOT Implementing:**\n- Field access mutation: `let @data[-1].field += value` ‚Üí ETOOCOMPLEX\n- Parallel for with blocks: `for parallel() @x [...]` ‚Üí Use exe wrapper\n- Batch pipelines with blocks: `for [...] =\u003e ||` ‚Üí Use simple expressions\n- When match form: `when @var: [...]` ‚Üí Use `when [@var == value =\u003e ...]`\n- **var +=**: No augmented assignment for var; use `let` in blocks\n\n**ARE Implementing:**\n- Block syntax `[...]` for multi-statement bodies (exe, for)\n- Simple let/+=: `let @var = value` and `let @var += value` (variable name only, no field access)\n- Nested control flow: for/when inside blocks\n- While loops: Bounded iteration with done/continue\n- Explicit returns: `=\u003e @value` (required in exe blocks, must be last)\n- Proper error handling: Location tracking, helpful messages\n- Strict/loose mode: No slashes in strict, top-level only in loose\n\n## Implementation Phases\n\n1. **Phase 0**: Abstraction Discovery (60-90 min reading before code) ‚úÖ\n2. **Phase 1**: Grammar + Types (all features, parse-only focus) ‚úÖ\n3. **Phase 2**: Interpreter (one construct at a time) - IN PROGRESS\n4. **Phase 3**: Core Tests (minimal golden set - 5 tests)\n5. **Phase 4**: Integration \u0026 Polish (optional)\n\n## Success Criteria\n\n1. All core test cases pass\n2. Exe blocks can have sequential statements with let/+=\n3. For blocks can have nested control flow\n4. Let variables properly scoped to blocks\n5. Augmented assignment works on arrays, strings, objects\n6. Return statements work in exe blocks\n7. Error messages clear and actionable\n8. Nested blocks maintain separate scopes\n\n## Estimate\n\n3-5 Claude sessions (grammar-first approach, abstraction reuse focus)\n\n## Reference\n\nSee `todo/plan-grammar-next.md` for full implementation details.","notes":"Epic complete! All features implemented, tested, and documented.\n\nCompleted:\n‚úÖ Block syntax for exe/for with [...]\n‚úÖ While loops with done/continue\n‚úÖ Let/+= in blocks\n‚úÖ All tests passing (2419 tests)\n‚úÖ Documentation updated (flow-control.md, reference.md, llms.txt, AST.md)\n‚úÖ Bonus: Math operators fixed (mlld-a2x)\n\nAll phases complete:\n- Phase 0: Abstraction Discovery ‚úÖ\n- Phase 1: Grammar + Types (6 tasks) ‚úÖ\n- Phase 2: Interpreter (4 tasks) ‚úÖ\n- Phase 3: Core Tests ‚úÖ\n- Phase 4: Integration Tests ‚úÖ\n\nReady for production!","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-09T22:13:32.943942-08:00","updated_at":"2025-12-10T18:38:54.293527-08:00","closed_at":"2025-12-10T18:38:54.293529-08:00","dependencies":[{"issue_id":"mlld-fln","depends_on_id":"mlld-cw9","type":"parent-child","created_at":"2025-12-09T22:14:11.122384-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-9pl","type":"parent-child","created_at":"2025-12-09T22:16:29.283436-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-1sh","type":"parent-child","created_at":"2025-12-09T22:16:29.35034-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-wrb","type":"parent-child","created_at":"2025-12-09T22:16:29.417501-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-8d6","type":"parent-child","created_at":"2025-12-09T22:16:29.524287-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-0gd","type":"parent-child","created_at":"2025-12-09T22:16:29.592885-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-zeo","type":"parent-child","created_at":"2025-12-09T22:18:43.391952-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-9id","type":"parent-child","created_at":"2025-12-09T22:18:43.463166-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-0ic","type":"parent-child","created_at":"2025-12-09T22:18:43.545022-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-ait","type":"parent-child","created_at":"2025-12-09T22:18:43.615165-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-jw7","type":"parent-child","created_at":"2025-12-09T22:19:32.661253-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-5ik","type":"parent-child","created_at":"2025-12-09T22:20:06.935882-08:00","created_by":"daemon"},{"issue_id":"mlld-fln","depends_on_id":"mlld-1iz","type":"parent-child","created_at":"2025-12-09T22:27:45.067721-08:00","created_by":"daemon"}]}
{"id":"mlld-fsa","title":"Add @root as alias for @base","description":"**Rationale:** `@root` is a more common/intuitive term for project root than `@base`. Should work as an alias.\n\n**Desired:**\n```mlld\n/var @readme = \u003c@root/README.md\u003e    # same as @base/README.md\n/import { @cfg } from \"@root/config.mld\"\n/import templates from \"@root/templates\" as @tmp(msg)\n```\n\n**Implementation:**\n1. Add `'root'` to reserved function resolvers list (Environment.ts:516)\n2. Update resolver checks to include `root`:\n   - ImportDirectiveEvaluator.ts:245 - static import validation\n   - ImportDirectiveEvaluator.ts:265 - templates import validation\n   - Any other places checking `resolverName === 'base'`\n3. Add `@root` to resolver config with same behavior as `@base`\n4. Update docs to mention `@root` as alias\n\n**Priority:** P3 - nice to have, `@base` works fine but `@root` is more intuitive for new users.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-10T22:48:01.085959-08:00","updated_at":"2025-12-10T23:08:24.861834-08:00"}
{"id":"mlld-fzr","title":"init incorrectly names files `.mlld.md` instead of `.mld.md`","description":"We don't want `.mlld` or `.mlld.md` to become standard -- just `.mld` and `.mld.md` ","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T05:17:57.376218-08:00","updated_at":"2025-12-08T12:18:32.986333-08:00","closed_at":"2025-12-08T12:18:32.986333-08:00","labels":["creator:adamavenir@hey.com"]}
{"id":"mlld-gj7","title":"Grammar: add mode flag and optional slash prefix","description":"**Summary:**\nAdd a `mode: 'strict' | 'markdown'` option to the parser and make the leading `/` optional on directives.\n\n**Changes required:**\n\n1. **Parser options** (`grammar/parser/index.ts` or entry point):\n   - Accept `mode` option, default to `'markdown'` for backward compat during transition\n   - Thread mode into grammar context\n\n2. **Grammar helper** (`grammar/deps/grammar-core.ts`):\n   - Replace `isSlashDirectiveContext` with `isDirectiveContext`\n   - In both modes, match optional `/` followed by directive keyword at line start\n   - The difference is handled at top-level line classification, not here\n\n3. **Directive rules** (`grammar/mlld.peggy` or modular files):\n   - Change directive prefix from `\"/\"` to `\"/\"?`\n   - All directives: var, exe, run, show, for, when, import, export, guard, output, log, append, stream, needs, wants\n   - Keep semantic actions unchanged\n\n4. **Top-level line rule**:\n   ```peggy\n   Line \n     = Directive\n     / BlankLine\n     / \u0026{ return options.mode === 'markdown' } TextLine\n     / \u0026{ return options.mode === 'strict' } StrictModeTextError\n   \n   StrictModeTextError = (!Directive .)+ { \n     error(\"Text content not allowed in strict mode (.mld). Use .mld.md for prose.\") \n   }\n   ```\n\n5. **Blank line handling**:\n   - Strict mode: blank lines are whitespace, produce no AST node\n   - Markdown mode: blank lines may become content nodes (current behavior)\n\n**Testing:**\n- Add grammar unit tests for optional slash parsing\n- Verify existing tests pass with mode='markdown'","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:57:33.602447-08:00","updated_at":"2025-12-11T17:17:42.628808-08:00","closed_at":"2025-12-11T17:17:42.628808-08:00","dependencies":[{"issue_id":"mlld-gj7","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.389438-08:00","created_by":"daemon"}]}
{"id":"mlld-jw7","title":"Phase 3: Core Tests - Minimal golden set for block syntax epic","description":"## Summary\n\nCreate 5 core test cases that validate each feature works in isolation. These are the minimal golden set before moving to integration tests.\n\n## Prereq\n\nAll Phase 2 interpreter issues must be complete:\n- mlld-zeo (Export let functions)\n- mlld-9id (Exe blocks)\n- mlld-0ic (For blocks)\n- mlld-ait (While loops)\n\n## Test Structure\n\n```\ntests/cases/feat/\n‚îú‚îÄ‚îÄ exe-block/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ for-block/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ when-unified/\n‚îÇ   ‚îî‚îÄ‚îÄ basic/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\n‚îú‚îÄ‚îÄ while/\n‚îÇ   ‚îî‚îÄ‚îÄ basic-done-continue/\n‚îÇ       ‚îú‚îÄ‚îÄ example.md\n‚îÇ       ‚îî‚îÄ‚îÄ expected.md\ntests/cases/exceptions/\n‚îî‚îÄ‚îÄ augmented-assignment/\n    ‚îî‚îÄ‚îÄ undefined-variable/\n        ‚îú‚îÄ‚îÄ example.md\n        ‚îî‚îÄ‚îÄ error.md\n```\n\n## Test 1: Exe Block Happy Path\n\nFile: `tests/cases/feat/exe-block/basic/example.md`\n```mlld\n/exe @greet(name) = [\n  let @greeting = \"Hello\"\n  let @punctuation = \"!\"\n  =\u003e \"@greeting @name@punctuation\"\n]\n\n/show @greet(\"World\")\n```\n\nExpected: `expected.md`\n```\nHello World!\n```\n\n**Purpose**: Exe block with let assignments and explicit return.\n\n---\n\n## Test 2: For Block Happy Path (UPDATED)\n\nFile: `tests/cases/feat/for-block/basic/example.md`\n```mlld\n/exe @countAndShow(items) = [\n  let @count = 0\n  for @item in @items [\n    show \"Item: @item\"\n    let @count += 1\n  ]\n  =\u003e @count\n]\n\n/show \"Total: @countAndShow([\"a\", \"b\", \"c\"])\"\n```\n\nExpected: `expected.md`\n```\nItem: a\nItem: b\nItem: c\nTotal: 3\n```\n\n**Purpose**: For block with let/let+= for accumulation (wrapped in exe block since let is block-scoped).\n\n**Note**: `var +=` is NOT supported. Use `let` for accumulation within exe blocks.\n\n---\n\n## Test 3: When Unified Syntax\n\nFile: `tests/cases/feat/when-unified/basic/example.md`\n```mlld\n/exe @classify(x) = when [\n  @x \u003e 100 =\u003e \"large\"\n  @x \u003e 10 =\u003e \"medium\"\n  * =\u003e \"small\"\n]\n\n/show @classify(150)\n/show @classify(50)\n/show @classify(5)\n```\n\nExpected: `expected.md`\n```\nlarge\nmedium\nsmall\n```\n\n**Purpose**: When expression with unified `[condition =\u003e action]` syntax.\n\n---\n\n## Test 4: While Loop Happy Path\n\nFile: `tests/cases/feat/while/basic-done-continue/example.md`\n```mlld\n/exe @countdown(n) = when [\n  @n \u003c= 0 =\u003e done \"finished\"\n  * =\u003e continue (@n - 1)\n]\n\n/var @result = 5 | while(10) @countdown\n/show @result\n```\n\nExpected: `expected.md`\n```\nfinished\n```\n\n**Purpose**: While loop with done/continue keywords.\n\n---\n\n## Test 5: Error - Augmented Assignment Without Let\n\nFile: `tests/cases/exceptions/augmented-assignment/undefined-variable/example.md`\n```mlld\n/exe @bad() = [\n  let @count += 1\n]\n/show @bad()\n```\n\nExpected: `error.md`\n```\nCannot use += on undefined variable @count. Use \"let @count = ...\" first.\n```\n\n**Purpose**: Runtime error for += without prior let.\n\n---\n\n## Running Tests\n\n```bash\n# Build fixtures first\nnpm run build:fixtures\n\n# Run all block syntax tests\nnpm run test:case -- feat/exe-block\nnpm run test:case -- feat/for-block\nnpm run test:case -- feat/when-unified\nnpm run test:case -- feat/while\n\n# Run exception tests\nnpm run test:case -- exceptions/augmented-assignment\n```\n\n## Validation\n\n- [ ] All 5 test cases created\n- [ ] Fixtures generated without errors\n- [ ] All tests pass\n- [ ] Edge cases identified for Phase 4","notes":"‚úÖ PREREQUISITE UPDATE: Phase 1 AST verification (mlld-b4f) complete. All grammar constructs parse correctly. Type enums updated. Test Results: 2391/2391 passed (100%). All AST structures validated and documented in tmp/phase1-ast-verification.md. Ready to implement Phase 3 core tests once Phase 2 interpreters are complete.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:19:25.090487-08:00","updated_at":"2025-12-10T17:37:42.175858-08:00","closed_at":"2025-12-10T17:37:42.175858-08:00","dependencies":[{"issue_id":"mlld-jw7","depends_on_id":"mlld-9id","type":"blocks","created_at":"2025-12-09T22:19:32.747661-08:00","created_by":"daemon"},{"issue_id":"mlld-jw7","depends_on_id":"mlld-0ic","type":"blocks","created_at":"2025-12-09T22:19:32.834833-08:00","created_by":"daemon"},{"issue_id":"mlld-jw7","depends_on_id":"mlld-ait","type":"blocks","created_at":"2025-12-09T22:19:32.960034-08:00","created_by":"daemon"}]}
{"id":"mlld-k4k","title":"Strict mode for .mld files","description":"Implement a strict execution mode for .mld files that eliminates LLM-unfriendly ambiguities:\n\n**Problem:**\n- Current mlld requires `/` prefix on directive lines, which creates ambiguity\n- Non-directive lines become implicit content output, which LLMs can accidentally trigger\n- This makes mlld harder for LLMs to generate correctly\n\n**Solution:**\nTwo modes based on file extension:\n- `.mld` ‚Üí strict mode: bare directives, text lines error, blank lines ignored\n- `.mld.md` ‚Üí markdown mode: `/` required, text becomes content (current behavior)\n\n**Key decisions:**\n- Optional `/` prefix in strict mode for backward compatibility\n- Blank lines are no-ops in strict mode (formatting whitespace)\n- Raw strings in SDK default to strict mode\n- Mode included in AST cache keys\n\n**Line handling by mode:**\n\n| Line Type          | Strict Mode   | Markdown Mode   |\n|--------------------|---------------|-----------------|\n| `/directive`       | ‚úì Execute     | ‚úì Execute       |\n| `directive` (bare) | ‚úì Execute     | Text content    |\n| Blank              | ‚úì Ignore      | Content         |\n| Text               | ‚úó Error       | Content         |\n\nSee child issues for implementation breakdown.\n\nIMPORTANT: Ensure compatibility with \n1. current .mld.md module format which mixes ```mlld``` and ```mlld-run``` in markdown + frontmatter files‚Äîthis should be valid.\n2. `/for`...`/end` loops in templates","status":"open","priority":0,"issue_type":"feature","created_at":"2025-12-08T19:57:11.921576-08:00","updated_at":"2025-12-10T18:42:27.801726-08:00","dependencies":[{"issue_id":"mlld-k4k","depends_on_id":"mlld-5jz","type":"blocks","created_at":"2025-12-09T08:28:34.440584-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-9qq","type":"blocks","created_at":"2025-12-09T08:29:07.286149-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-04k","type":"blocks","created_at":"2025-12-09T08:29:37.475238-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-4cw","type":"blocks","created_at":"2025-12-09T08:30:06.896625-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-cgb","type":"blocks","created_at":"2025-12-09T08:30:38.780886-08:00","created_by":"adam"},{"issue_id":"mlld-k4k","depends_on_id":"mlld-o2u","type":"blocks","created_at":"2025-12-09T08:31:10.514377-08:00","created_by":"adam"}]}
{"id":"mlld-k69","title":"Tests: Add comprehensive test coverage for cmd:path/sh:path","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task creates comprehensive test coverage for the new syntax.\n\n## Prerequisites\n- All implementation tasks complete (grammar, types, interpreter, executors)\n\n## Task\nCreate test cases covering valid syntax, invalid syntax, runtime exceptions, and edge cases.\n\n## Test Structure\n\nmlld uses a fixture-based test system:\n- `tests/cases/` - valid test cases\n- `tests/cases/invalid/` - syntax/parse errors\n- `tests/cases/exceptions/` - runtime errors\n- `tests/fixtures/` - generated fixture files (gitignored)\n\n### Test File Naming\n\n**CRITICAL**: Test names must be unique across ALL tests. Use prefixes like:\n- `cmd-path-absolute.md` \n- `cmd-path-variable.md`\n- `sh-path-interpolation.md`\n\nNOT just `path.md` or `test.md`!\n\n## Valid Test Cases\n\nLocation: `tests/cases/cmd-path/` (create new directory)\n\n### 1. cmd-path-absolute.md\n```markdown\n/run cmd:/tmp {pwd}\n```\n\nexpected.md:\n```\n/tmp\n```\n\n### 2. cmd-path-variable.md\n```markdown\n/var @mypath = \"/tmp\"\n/run cmd:@mypath {pwd}\n```\n\nexpected.md:\n```\n/tmp\n```\n\n### 3. cmd-path-interpolation.md\n```markdown\n/var @base = \"/tmp\"\n/var @subdir = \"test\"\n/run cmd:@base/@subdir {pwd}\n```\n\nexpected.md:\n```\n/tmp/test\n```\n\n### 4. sh-path-absolute.md\n```markdown\n/run sh:/tmp {pwd}\n```\n\n### 5. bash-path-variable.md\n```markdown\n/var @dir = \"/tmp\"\n/run bash:@dir {pwd}\n```\n\n### 6. cmd-path-loop-iteration.md\n```markdown\n/var @dirs = [\"/tmp\", \"/home\"]\n/for @dir in @dirs {\n  /run cmd:@dir {pwd}\n}\n```\n\nexpected.md:\n```\n/tmp\n/home\n```\n\n### 7. cmd-no-path-still-works.md\nTest that existing cmd without :path still works:\n```markdown\n/run cmd {pwd}\n```\n\n## Invalid Test Cases (Parse Errors)\n\nLocation: `tests/cases/invalid/cmd-path/`\n\n### 1. cmd-path-invalid-relative.md\n```markdown\n/run cmd:./relative {ls}\n```\n\nerror.md:\n```\nParse error: working directory must start with / or @\n```\n\n### 2. cmd-path-invalid-bare.md\n```markdown\n/run cmd:relative {ls}\n```\n\nNote: This might parse successfully but fail at runtime if it doesn't start with `/` or `@`. Adjust test category as needed.\n\n## Exception Test Cases (Runtime Errors)\n\nLocation: `tests/cases/exceptions/cmd-path/`\n\n### 1. cmd-path-exception-undefined-var.md\n```markdown\n/run cmd:@undefined {pwd}\n```\n\nerror.md:\n```\nVariable @undefined is not defined\n```\n\n### 2. cmd-path-exception-not-rooted.md\n```markdown\n/var @rel = \"relative\"\n/run cmd:@rel {pwd}\n```\n\nerror.md:\n```\nWorking directory must be an absolute path\n```\n\n### 3. cmd-path-exception-not-exists.md\n```markdown\n/run cmd:/does/not/exist/path {ls}\n```\n\nerror.md:\n```\nWorking directory does not exist\n```\n\n### 4. cmd-path-exception-not-directory.md\n```markdown\n/run cmd:/etc/hosts {ls}\n```\n\nerror.md:\n```\nWorking directory path is not a directory\n```\n\n## Grammar Tests\n\nLocation: `grammar/tests/run.test.ts`\n\nAdd test cases to verify AST structure:\n\n```typescript\ndescribe('cmd:path syntax', () =\u003e {\n  it('should parse cmd with absolute path', () =\u003e {\n    const result = parse('/run cmd:/tmp {ls}');\n    expect(result.values.workingDir).toBeDefined();\n    expect(result.raw.workingDir).toBe('/tmp');\n  });\n  \n  it('should parse cmd with variable path', () =\u003e {\n    const result = parse('/run cmd:@mypath {ls}');\n    expect(result.values.workingDir).toHaveLength(1);\n    expect(result.values.workingDir[0].type).toBe('VariableReference');\n  });\n  \n  it('should parse sh with interpolated path', () =\u003e {\n    const result = parse('/run sh:@base/subdir {pwd}');\n    expect(result.values.workingDir).toHaveLength(2); // variable + text\n    expect(result.meta.hasWorkingDir).toBe(true);\n  });\n});\n```\n\n## Running Tests\n\n```bash\n# Generate fixtures\nnpm run build:fixtures\n\n# Run specific test directory\nnpm run test:case -- cmd-path\n\n# Run all tests\nnpm test\n```\n\n## Acceptance Criteria\n\n- [ ] All valid syntax parses and executes correctly\n- [ ] Undefined variables produce clear errors\n- [ ] Non-rooted paths are rejected\n- [ ] Non-existent directories are detected\n- [ ] File paths (not directories) are rejected  \n- [ ] Loop iterations work with different paths\n- [ ] Existing cmd/sh without :path still works\n- [ ] Grammar tests verify AST structure","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:49.842606-08:00","updated_at":"2025-12-08T20:25:12.829395-08:00","closed_at":"2025-12-08T20:25:12.829395-08:00"}
{"id":"mlld-nlu","title":"LSP: Chunk-based parsing for error recovery (GH#335)","description":"Implement chunk-based parsing for better error recovery in the language server.\n\nSee: https://github.com/mlld-lang/mlld/issues/335\n\nSize: Medium\nMilestone: 2.1.1 LSP improvements","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T20:12:36.462075-08:00","updated_at":"2025-12-11T20:12:36.462075-08:00","dependencies":[{"issue_id":"mlld-nlu","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.13203-08:00","created_by":"daemon"}]}
{"id":"mlld-nwu","title":"sh/bash executor not emitting CHUNK events to StreamBus for format adapters","description":"When using 'stream sh { ... }' the FormatAdapterSink doesn't receive CHUNK events. Works with 'stream cmd { ... }'. FormatAdapterSink.handle never called for sh/bash executors.","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-07T20:51:28.696466-08:00","updated_at":"2025-12-07T20:51:28.696466-08:00"}
{"id":"mlld-o2u","title":"Regex syntax highlighting: strict vs markdown","description":"Review and update regex/textmate/grammar-based highlighting to handle strict and markdown modes consistently. Validate directive detection, template delimiters, and optional slashes in both modes.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T08:30:53.814723-08:00","updated_at":"2025-12-09T08:30:53.814723-08:00","dependencies":[{"issue_id":"mlld-o2u","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.013201-08:00","created_by":"daemon"}]}
{"id":"mlld-om1","title":"LSP: mode-aware syntax highlighting and errors","description":"**Summary:**\nUpdate LSP/language server to handle both modes correctly.\n\n**Changes required:**\n\n1. **File extension detection:**\n   - `.mld` ‚Üí strict mode tokenization\n   - `.mld.md` ‚Üí markdown mode tokenization\n\n2. **Syntax highlighting:**\n   - Strict mode: directive keywords without `/` are highlighted as keywords\n   - Markdown mode: only `/keyword` highlighted as directives\n   - Both: `/keyword` highlighted as directive\n\n3. **Error diagnostics:**\n   - Strict mode: text lines get error squiggles with message\n   - Strict mode: suggest \"rename to .mld.md if you want prose content\"\n   - Markdown mode: no change from current behavior\n\n4. **Hover/completion:**\n   - Directive completions in strict mode don't require `/` prefix\n   - Both modes accept `/` prefix in completions\n\n5. **Formatter:**\n   - Strict mode: optionally normalize to bare directives (no `/`)\n   - Markdown mode: preserve `/` prefix\n   - Config option for strict mode preference (with or without slash)\n\n**Files likely affected:**\n- `lsp/` directory\n- VS Code extension if separate\n- TextMate grammar files for syntax highlighting\n\n**Testing:**\n- Open `.mld` file, verify bare directives highlighted\n- Open `.mld.md` file, verify only `/` directives highlighted\n- Verify error squiggles on text in strict mode","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T19:58:27.625577-08:00","updated_at":"2025-12-08T19:58:27.625577-08:00","dependencies":[{"issue_id":"mlld-om1","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.595916-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T19:59:14.906243-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-ah5","type":"blocks","created_at":"2025-12-08T20:59:32.37355-08:00","created_by":"daemon"},{"issue_id":"mlld-om1","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.088821-08:00","created_by":"daemon"}]}
{"id":"mlld-qxb","title":"cmd:path / sh:path for rooted commands","description":"One thing that both `cmd` and `sh` often need is to set the path for their operation. \n\n`cmd` intentionally disallows chaining which makes it impossible to just do `cd /some/dir \u0026\u0026 mycommand`\n\nBut given this is a common use case‚Äîand one which enforces security and clarity‚Äîwe should allow a way to set the path for `cmd` and `sh`\n\n```\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n/run sh:@mypath {echo \"hello world\"}\n/run cmd:@base/path/to/file {mycommand param}\n/run sh:/Users/@username/dev/@dir {somecommand --flag}\n```\n\nthe `:path` would be an option everywhere `sh` and `cmd` are used; if not set the path would be set to whatever the system defaults to currently (which has its own rules)","design":"## Design Overview\n\nThis feature adds `:path` syntax to `cmd` and language executors (`sh`, `bash`, `js`, `python`, etc.) to set the working directory for command execution.\n\n## Motivation\n\nCurrently, `cmd` intentionally disallows chaining (no `\u0026\u0026` inside `cmd {...}`), which makes it impossible to do:\n```\n/run cmd {cd /some/dir \u0026\u0026 mycommand}  # NOT ALLOWED\n```\n\nThe `:path` syntax provides a clean, explicit alternative that:\n1. Enforces security through validation\n2. Makes working directory changes explicit in the syntax\n3. Supports variable interpolation\n4. Maintains cmd's no-chaining principle\n\n## Syntax Examples\n\n```mlld\n# Absolute path\n/run cmd:/Users/adam/dev/mlld {mlld setup}\n\n# Variable path\n/var @mypath = \"/tmp\"\n/run sh:@mypath {echo \"hello world\"}\n\n# Interpolated path\n/var @base = \"/Users/adam\"\n/run cmd:@base/dev/mlld {git status}\n\n# With multiple variables\n/run sh:/Users/@username/dev/@project {make test}\n\n# Works with all language executors\n/run bash:/tmp {pwd}\n/run js:/home/user/scripts {console.log(process.cwd())}\n/run python:@workspace {import os; print(os.getcwd())}\n```\n\n## Design Decisions\n\n### 1. Rooted Paths Only\n\nPaths MUST be rooted (absolute):\n- ‚úÖ `/tmp` - absolute path\n- ‚úÖ `@mypath` - variable (must resolve to absolute)\n- ‚úÖ `@base/subdir` - variable + path (variable must be absolute)\n- ‚ùå `./relative` - REJECTED\n- ‚ùå `relative` - REJECTED\n\n**Rationale**: Relative paths are ambiguous (relative to what?). Rooted paths are explicit and secure.\n\n### 2. Variable Interpolation\n\nVariables in paths are interpolated at runtime using existing `interpolate()` infrastructure:\n```mlld\n/var @user = \"alice\"\n/run cmd:/home/@user/work {ls}  # Resolves to /home/alice/work\n```\n\n**Rationale**: Consistent with how variables work elsewhere in mlld.\n\n### 3. Fail Fast Validation\n\nPath validation happens BEFORE command execution:\n1. Interpolate variables (error if undefined)\n2. Check path starts with `/` (error if not)\n3. Check directory exists (error if not)\n4. Check is directory not file (error if file)\n\n**Rationale**: Better error messages, prevents confusing command failures.\n\n### 4. No Security Policy (Yet)\n\nInitial implementation allows ANY absolute path the user has filesystem access to. Security policy integration is deferred to mlld-bgl.\n\n**Future**: Policy will allow restricting to specific path prefixes:\n```mlld\n/needs cmd.cwd:/Users/adam/dev/**  # Only allow paths under this\n```\n\n### 5. Scope is Per-Command\n\nThe `:path` only affects the specific command it's attached to, not global state:\n```mlld\n/run cmd:/tmp {pwd}        # runs in /tmp\n/run cmd {pwd}             # runs in default cwd\n/run @data | cmd:/app {process.sh}  # only process.sh runs in /app\n```\n\n**Rationale**: Explicit scope prevents action-at-a-distance bugs.\n\n## Implementation Order\n\nThe subtasks have dependencies:\n\n**Phase 1: Foundation (can be parallel)**\n1. mlld-u8r - Types (no dependencies)\n2. mlld-b0e - Grammar: WorkingDirPath pattern\n\n**Phase 2: Grammar Integration (depends on phase 1)**\n3. mlld-zgb - Grammar: cmd support (depends on mlld-b0e)\n4. mlld-rn5 - Grammar: sh/bash support (depends on mlld-b0e)\n\n**Phase 3: Runtime (depends on phase 1-2)**\n5. mlld-1x2 - cwd-resolver utility (depends on mlld-u8r)\n6. mlld-e0b - run evaluator (depends on mlld-1x2, mlld-u8r)\n7. mlld-7e7 - executors (depends on mlld-e0b)\n\n**Phase 4: Testing (depends on all)**\n8. mlld-k69 - comprehensive tests\n\n## Technical Architecture\n\n```\nGrammar Layer:\n  WorkingDirPath pattern ‚Üí parses :path syntax\n  ‚Üì\n  CmdCommandBrackets / RunLanguageCodeCore ‚Üí includes workingDir in AST\n  ‚Üì\nAST:\n  values.workingDir: ContentNodeArray (nodes with variables)\n  raw.workingDir: string (raw text)\n  meta.hasWorkingDir: boolean\n  meta.workingDirMeta: PathMeta\n  ‚Üì\nInterpreter:\n  run evaluator ‚Üí checks for workingDir in AST\n  ‚Üì\n  cwd-resolver ‚Üí interpolates variables, validates path\n  ‚Üì\n  executeCommand/executeCode ‚Üí passes cwd in options\n  ‚Üì\nExecutors:\n  ShellCommandExecutor / BashExecutor / etc ‚Üí use options.cwd || this.workingDirectory\n```\n\n## Error Handling\n\nClear, actionable error messages:\n\n```\nError: Cannot resolve working directory path\n  Path: /home/@username/dev\n  Reason: Variable @username is not defined\n  Location: example.mld:5:10\n```\n\n```\nError: Working directory must be an absolute path (start with /)\n  Provided: ./relative\n  Location: example.mld:8:15\n```\n\n```\nError: Working directory does not exist\n  Path: /nonexistent/directory\n  Location: example.mld:12:10\n```\n\n## Testing Strategy\n\n1. **Grammar tests**: Verify AST structure for various syntax forms\n2. **Valid cases**: Test execution with different path types\n3. **Invalid cases**: Test parse errors for unsupported syntax\n4. **Exception cases**: Test runtime errors for undefined vars, bad paths\n5. **Integration**: Test with loops, pipelines, different executors","notes":"Decisions: '/' allowed; paths must be absolute Unix; no Windows or '~'; reuse existing missing/non-dir path errors at runtime; :path applies to cmd/sh/etc including /exe forms like /exe @run(path, foo) = cmd:@path {...}.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T11:49:05.80685-08:00","updated_at":"2025-12-08T20:25:28.959279-08:00","closed_at":"2025-12-08T20:25:28.959279-08:00","labels":["creator:adamavenir@hey.com","epic","feature"],"dependencies":[{"issue_id":"mlld-qxb","depends_on_id":"mlld-b0e","type":"blocks","created_at":"2025-12-08T12:54:49.696952-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-zgb","type":"blocks","created_at":"2025-12-08T12:54:49.737084-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-rn5","type":"blocks","created_at":"2025-12-08T12:54:49.774931-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-u8r","type":"blocks","created_at":"2025-12-08T12:54:49.809626-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-1x2","type":"blocks","created_at":"2025-12-08T12:54:49.842686-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-e0b","type":"blocks","created_at":"2025-12-08T12:54:49.878847-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-7e7","type":"blocks","created_at":"2025-12-08T12:54:49.913983-08:00","created_by":"daemon"},{"issue_id":"mlld-qxb","depends_on_id":"mlld-k69","type":"blocks","created_at":"2025-12-08T12:54:49.949208-08:00","created_by":"daemon"}]}
{"id":"mlld-rn5","title":"Grammar: Extend RunLanguageCodeCore to support :path for sh/bash","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task extends language code execution (`sh`, `bash`, `js`, `python`, etc.) to support the `:path` suffix.\n\n## Prerequisites\n- mlld-b0e must be complete (WorkingDirPath pattern exists)\n\n## Task\nModify `RunLanguageCodeCore` to optionally parse and include working directory path for language executors.\n\n## Implementation\n\nLocation: `grammar/core/code.peggy`\n\n### Step 1: Add language with path pattern\n\n```peggy\n// Shared working directory pattern for language codes\nLanguageWorkingDirPath \"language working directory path\"\n  = \":\" path:WorkingDirPathContent {\n      return path;\n    }\n\n// Run language with optional working directory\nRunCodeLanguageWithPath\n  = language:RunCodeLanguage workingDir:LanguageWorkingDirPath? {\n      return {\n        language: language,\n        workingDir: workingDir || null\n      };\n    }\n```\n\n### Step 2: Modify RunLanguageCodeCore\n\nFind `RunLanguageCodeCore` pattern (around line 208) and update it to:\n1. Use `RunCodeLanguageWithPath` instead of `RunCodeLanguage`\n2. Extract `workingDir` from `langInfo`\n3. Add workingDir to values/raw/meta when present\n\n```peggy\nRunLanguageCodeCore\n  = streamPrefix:StreamKeyword? _ langInfo:RunCodeLanguageWithPath _ code:UnifiedCodeBrackets {\n      const language = langInfo.language;\n      const workingDir = langInfo.workingDir;\n      \n      // ... existing code to process language and code ...\n      \n      const values = {\n        lang: [langNode],\n        args: [],\n        code: [codeNode]\n      };\n      \n      if (workingDir) {\n        values.workingDir = workingDir.parts;\n      }\n      \n      const raw = {\n        lang: language,\n        args: [],\n        code: codeContent\n      };\n      \n      if (workingDir) {\n        raw.workingDir = workingDir.raw;\n      }\n      \n      const meta = {\n        isMultiLine: code.isMultiLine || codeContent.includes('\\n'),\n        language: language,\n        hasVariables: false,\n        hasWorkingDir: \\!\\!workingDir\n      };\n      \n      if (workingDir) {\n        meta.workingDirMeta = workingDir.meta;\n      }\n      \n      // ... rest of existing code ...\n    }\n```\n\n## Examples\n\n```mlld\n/run sh:/tmp {echo \"hello\"}\n/run bash:@mypath {pwd}\n/run js:/home/@user/scripts {console.log(process.cwd())}\n```\n\n## Testing\n\n```bash\nnpm run ast -- '/run sh:/tmp {echo hello}'\nnpm run ast -- '/run bash:@base {pwd}'\nnpm run ast -- '/run python:/scripts {print(1)}'\n```","notes":"RunLanguageCodeCore needs :path using WorkingDirPath; absolute Unix paths only ('/' ok); no Windows or '~'.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:18.829051-08:00","updated_at":"2025-12-08T20:23:54.14086-08:00","closed_at":"2025-12-08T20:23:54.14086-08:00"}
{"id":"mlld-s4a","title":"npm run test:case shows all tests skipped instead of running specified test","description":"**Repro:**\n```bash\nnpm run test:case -- feat/for-when-filter\n```\n\n**Expected:** Runs the specific test fixture\n\n**Actual:**\n```\nTest Files  1 skipped (1)\nTests  1012 skipped (1012)\n```\n\nAll tests show as skipped instead of running the specified test. This broke recently - the test:case runner should isolate and run only the matching fixture(s).\n\n**Impact:** Can't quickly test individual fixtures during development.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-10T22:57:01.302139-08:00","updated_at":"2025-12-10T23:08:36.644989-08:00"}
{"id":"mlld-slk","title":"Exe blocks with let statements return null in for loops","description":"**Critical regression - exe blocks with let statements broken.**\n\n**Repro 1 - In for loop:**\n```mlld\n/exe @wrap(agent, turnP) = [\n  let @turn = @turnP[@agent]\n  =\u003e { name: @agent, turn: @turn }\n]\n/var @results = for @a in [\"alice\"] [@wrap(@a, @turnP)]\n\u003e\u003e Returns: [null]\n```\n\n**Repro 2 - Direct call:**\n```mlld\n/exe @wrap(agent, turnP) = [\n  let @turn = @turnP[@agent]\n  =\u003e { name: @agent, turn: @turn }\n]\n/show @wrap(\"alice\", @turnP)\n\u003e\u003e Error: Variable not found for index: [object Object]\n```\n\n**Without let:**\n```mlld\n/exe @wrap(agent, turnP) = { name: @agent, turn: @turnP[@agent] }\n\u003e\u003e Works perfectly\n```\n\n**Impact:** \n- Blocking @partydev.1's proto-3.6/3.7 testing\n- Breaks all exe blocks that use let statements\n- Introduced with recent parallel for blocks changes\n\n**Priority:** P0 - critical regression in core functionality","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-11T10:46:49.078819-08:00","updated_at":"2025-12-11T11:05:22.235996-08:00","closed_at":"2025-12-11T11:05:22.235996-08:00"}
{"id":"mlld-sqt","title":"`log` folder should only be created if user sets a flag ","description":"Need to think about what the design for this is, but the current approach isn't great, and it's not even clear what is supposed to be going in `log` I just see them littering things whenever I run mlld files ‚Äî and the output that I've seen is empty!! ","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-07T13:44:47.291457-08:00","updated_at":"2025-12-08T12:17:37.089103-08:00","labels":["bug","creator:adamavenir@hey.com"]}
{"id":"mlld-sus","title":"let statements should support all /var RHS forms (cmd, sh, js, template, etc)","description":"**Issue:** `let` statements execute commands but variable interpolation broken for sh/js forms.\n\n**Working (executes AND interpolates):**\n```mlld\nlet @x = cmd { echo \"@item\" }  # ‚úÖ interpolates @item correctly\n```\n\n**Broken (executes but NO interpolation):**\n```mlld\nlet @x = sh { echo \"@item\" }   # ‚ùå outputs literal \"@item\"\nlet @x = js { return \"@item\" } # ‚ùå outputs literal \"@ITEM\"\n```\n\n**Test results:**\n```mlld\n/for @item in [\"alice\"] [\n  let @a = cmd { echo \"@item\" }  # \"alice\" ‚úÖ\n  let @b = sh { echo \"@item\" }   # \"@item\" ‚ùå\n  let @c = js { return \"@item\" } # \"@ITEM\" ‚ùå\n]\n```\n\n**Impact:** Limits @partydev.1 to `cmd` form only. Most use cases work with `cmd` for claude calls, but sh/js interpolation needed for complex orchestration.\n\n**Root cause:** sh/js code execution in let context missing interpolation step that cmd has.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-11T11:13:41.312532-08:00","updated_at":"2025-12-11T13:18:07.095675-08:00","closed_at":"2025-12-11T13:18:07.095675-08:00"}
{"id":"mlld-sxd","title":"for-when filter syntax with implicit skip","description":"**New syntax for filter-map in one step:**\n\n```mlld\n\u003e\u003e Dense block form\n/var @positive = for @x in @xs when [\n  @x \u003e 0 =\u003e @x\n  @x \u003e 10 =\u003e \"big\"\n]\n\n\u003e\u003e One-liner  \n/var @positive = for @x in @xs when @x \u003e 0 =\u003e @x\n\n\u003e\u003e With transform\n/var @labels = for @x in @xs when @x \u003e 0 =\u003e \"positive: @x\"\n```\n\n**Behavior changes:**\n1. `for...when` implicitly skips non-matches (no nulls in result)\n2. No need for `none =\u003e skip` boilerplate\n3. The one-liner form `for @x when @cond =\u003e expr` works naturally since bare `when` already supports it\n\n**Current behavior (to be changed):**\n```mlld\n/var @arr = for @x in @xs [\n  when [ @x \u003e 0 =\u003e @x ]  \n]\n\u003e\u003e Returns [1, null, 2, null, 3] - nulls for non-matches\n\n/var @arr = for @x in @xs [\n  when [ @x \u003e 0 =\u003e @x; none =\u003e skip ]\n]\n\u003e\u003e Returns [1, 2, 3] - requires explicit skip\n```\n\n**New behavior:**\n```mlld\n/var @arr = for @x in @xs when [ @x \u003e 0 =\u003e @x ]\n\u003e\u003e Returns [1, 2, 3] - implicit skip, no nulls\n```\n\nThis is the common case - nobody wants nulls in their collected array.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T21:10:55.463436-08:00","updated_at":"2025-12-10T23:02:10.11598-08:00","closed_at":"2025-12-10T23:02:10.11598-08:00"}
{"id":"mlld-tfb","title":"Tests: strict mode fixtures and regressions","description":"**Summary:**\nAdd comprehensive test coverage for strict mode parsing and execution.\n\n**New fixtures needed:**\n\n1. **Strict mode success cases** (`tests/cases/valid/strict/`):\n   - `bare-directives.mld` - directives without `/` prefix\n   - `optional-slash.mld` - directives WITH `/` prefix (backward compat)\n   - `mixed-slash.mld` - some with, some without `/`\n   - `blank-lines.mld` - blank lines as formatting (should be ignored)\n   - `all-directives.mld` - every directive type without slash\n\n2. **Strict mode error cases** (`tests/cases/invalid/strict/`):\n   - `text-line.mld` - plain text should error\n   - `prose-content.mld` - markdown prose should error\n   - `comment-looking-text.mld` - `# heading` (not a directive) should error\n\n3. **Markdown mode regressions** (`tests/cases/valid/markdown/`):\n   - Existing tests renamed to `.mld.md` to confirm they still work\n   - Or keep as `.mld` with explicit mode override for backward compat testing\n\n4. **Cross-mode imports** (`tests/cases/valid/imports/`):\n   - `strict-imports-markdown.mld` imports `helper.mld.md`\n   - `markdown-imports-strict.mld.md` imports `helper.mld`\n\n**Fixture structure:**\n```\ntests/cases/valid/strict/\n  bare-directives/\n    example.mld      # bare var, exe, show, etc.\n    expected.md      # output\ntests/cases/invalid/strict/\n  text-line/\n    example.mld      # \"This is text\"\n    error.md         # expected error pattern\n```\n\n**Testing approach:**\n- Run `npm run build:fixtures` to generate fixture JSON\n- Verify strict mode fixtures parse/execute correctly\n- Verify invalid strict cases produce clear errors","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:17.200221-08:00","updated_at":"2025-12-11T17:53:11.499329-08:00","closed_at":"2025-12-11T17:53:11.499329-08:00","dependencies":[{"issue_id":"mlld-tfb","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.543036-08:00","created_by":"daemon"},{"issue_id":"mlld-tfb","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.870957-08:00","created_by":"daemon"}]}
{"id":"mlld-u8r","title":"Types: Extend RunValues/RunRaw/RunMeta for workingDir","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task adds TypeScript type definitions for the new `workingDir` field in run directive AST nodes.\n\n## Prerequisites\nNone - this can be done independently, but grammar tasks (mlld-b0e, mlld-zgb, mlld-rn5) will reference these types.\n\n## Task\nExtend the run directive type definitions to include working directory fields.\n\n## Implementation\n\nLocation: `core/types/run.ts`\n\n### 1. Extend RunValues interface\n\nFind the `RunValues` interface and add:\n```typescript\nexport interface RunValues {\n  command?: ContentNodeArray;\n  lang?: TextNodeArray;\n  args?: VariableNodeArray;\n  code?: ContentNodeArray;\n  identifier?: VariableNodeArray;\n  withClause?: WithClause;\n  securityLabels?: DataLabel[];\n  workingDir?: ContentNodeArray;  // NEW: Working directory path parts\n}\n```\n\n### 2. Extend RunRaw interface\n\n```typescript\nexport interface RunRaw {\n  command?: string;\n  lang?: string;\n  args?: string[];\n  code?: string;\n  identifier?: string;\n  withClause?: WithClause;\n  securityLabels?: string;\n  workingDir?: string;  // NEW: Raw working directory string\n}\n```\n\n### 3. Extend RunMeta interface\n\n```typescript\nexport interface RunMeta {\n  isMultiLine?: boolean;\n  argumentCount?: number;\n  language?: string;\n  hasVariables?: boolean;\n  withClause?: WithClause;\n  securityLabels?: DataLabel[];\n  hasWorkingDir?: boolean;      // NEW: Flag indicating working dir is set\n  workingDirMeta?: PathMeta;    // NEW: Path metadata for working dir\n}\n```\n\n### 4. Check PathMeta import\n\nEnsure `PathMeta` is imported if not already:\n```typescript\nimport type { PathMeta } from './path'; // or wherever PathMeta is defined\n```\n\n## What These Fields Mean\n\n- `workingDir` in RunValues: Array of AST nodes (Text nodes and VariableReference nodes) that make up the path\n- `workingDir` in RunRaw: The raw string representation like \"/tmp\" or \"@base/scripts\"\n- `hasWorkingDir` in RunMeta: Boolean flag to quickly check if workingDir was specified\n- `workingDirMeta` in RunMeta: Metadata like `hasVariables: true`, `isAbsolute: true`, etc.\n\n## Testing\n\nAfter implementation:\n```bash\nnpm run build\n```\n\nShould compile without errors. The grammar implementation will use these types.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:23.658146-08:00","updated_at":"2025-12-08T20:24:10.118584-08:00","closed_at":"2025-12-08T20:24:10.118584-08:00"}
{"id":"mlld-vlw","title":"Docs: update for strict mode","description":"**Summary:**\nUpdate all documentation to reflect the two-mode system.\n\n**Files to update:**\n\n1. **llms.txt:**\n   - Add mode explanation at top\n   - Note that examples use strict mode (no `/` prefix)\n   - Reference `.mld.md` for prose-embedded scripts\n\n2. **docs/user/ files:**\n   - Add \"Execution Modes\" section to getting-started or new page\n   - Update examples to show both styles where relevant\n   - Clarify file extension semantics\n\n3. **docs/dev/GRAMMAR.md:**\n   - Document mode flag in parser options\n   - Explain optional slash parsing\n   - Document top-level line handling per mode\n\n4. **README.md:**\n   - Quick mention of file extensions and modes\n\n**Key messaging:**\n\n- `.mld` = code file, LLM-friendly, no implicit content\n- `.mld.md` = documentation file, prose becomes output\n- Optional `/` in strict mode for gradual migration\n- SDK raw strings default to strict\n\n**Example documentation:**\n\n```markdown\n## File Extensions\n\n| Extension | Mode     | Behavior |\n|-----------|----------|----------|\n| `.mld`    | strict   | Every line is a directive or blank. Text lines error. |\n| `.mld.md` | markdown | `/` required for directives. Text becomes content. |\n\n### Strict Mode (.mld)\n```mlld\nvar @name = \"World\"\nshow `Hello @name`\n```\n\n### Markdown Mode (.mld.md)\n```mlld\n# Welcome Script\n\nThis text becomes output.\n\n/var @name = \"World\"\n/show `Hello @name`\n```\n```","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:40.507851-08:00","updated_at":"2025-12-08T19:58:40.507851-08:00","dependencies":[{"issue_id":"mlld-vlw","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.647573-08:00","created_by":"daemon"},{"issue_id":"mlld-vlw","depends_on_id":"mlld-tfb","type":"blocks","created_at":"2025-12-08T19:59:14.957772-08:00","created_by":"daemon"}]}
{"id":"mlld-wrb","title":"Phase 1.3: Grammar - Simplify when oneliner syntax","description":"## Summary\n\nSimplify when oneliner syntax to not require brackets around the condition.\n\n## Current vs New Syntax\n\n```mlld\n# CURRENT (brackets around condition)\nwhen [@condition] =\u003e action\n\n# NEW (no brackets needed for oneliner)\nwhen @condition =\u003e action\n\n# Block form (unchanged)\nwhen [\n  @cond1 =\u003e action1\n  @cond2 =\u003e action2\n]\n```\n\n## Breaking Change\n\nThis simplifies the oneliner by removing unnecessary brackets. The block form remains unchanged.\n\n## Files to Modify\n\n- `grammar/directives/when.peggy` - Update oneliner pattern\n\n## Implementation\n\nThe oneliner should parse as:\n\n```peggy\nWhenOneliner \"when oneliner\"\n  = \"when\" _ condition:WhenCondition _ \"=\u003e\" _ action:WhenAction {\n      return {\n        type: 'WhenExpression',\n        subtype: 'oneliner',\n        values: {\n          conditions: [condition],\n          actions: [action]\n        },\n        // ... \n      };\n    }\n```\n\nKeep the block form parsing as-is.\n\n## Rationale\n\n- More concise syntax for simple conditionals\n- Consistent with other oneliners in the language\n- Block form still available for multi-condition cases\n\n## Testing\n\n```bash\nnpm run ast -- 'when @x \u003e 5 =\u003e \"big\"'      # oneliner (new)\nnpm run ast -- 'when [@x \u003e 5 =\u003e \"big\"]'    # block form (unchanged)\n```\n\n## Validation\n\n- [ ] Oneliner parses without brackets\n- [ ] Block form still works\n- [ ] Both forms produce correct AST","notes":"Simplified when simple form to accept bracketless oneliner. Grammar rebuild ok; block forms untouched.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:15:41.385926-08:00","updated_at":"2025-12-10T07:09:09.589955-08:00","closed_at":"2025-12-10T07:09:09.589956-08:00","dependencies":[{"issue_id":"mlld-wrb","depends_on_id":"mlld-cw9","type":"blocks","created_at":"2025-12-09T22:16:36.1699-08:00","created_by":"daemon"}]}
{"id":"mlld-wsm","title":"Resolvers: propagate mode through imports","description":"**Summary:**\nWhen resolving imports, ensure the imported module is parsed with the correct mode based on its extension.\n\n**Changes required:**\n\n1. **Import resolution** (resolvers, likely `LocalResolver`, `RegistryResolver`, etc.):\n   - When resolving a module path, determine mode from resolved filepath extension\n   - Pass mode to parser when loading the imported module\n\n2. **Mode inheritance rules:**\n   - `.mld` imports ‚Üí strict mode\n   - `.mld.md` imports ‚Üí markdown mode\n   - The importing file's mode does NOT affect the imported file's mode\n   - Each file's extension determines its own mode\n\n3. **Dynamic modules:**\n   - String dynamic modules: default to `'strict'` (or accept mode option)\n   - Object dynamic modules: N/A (no parsing)\n\n4. **Edge cases:**\n   - Circular imports: mode still derived from extension\n   - Re-exports: mode of original source file applies\n\n**Testing:**\n- `.mld` file imports `.mld.md` file - each parses in correct mode\n- `.mld.md` file imports `.mld` file - each parses in correct mode\n- Dynamic module string defaults to strict","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:58:02.459003-08:00","updated_at":"2025-12-11T17:45:16.657612-08:00","closed_at":"2025-12-11T17:45:16.657612-08:00","dependencies":[{"issue_id":"mlld-wsm","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T19:58:55.504019-08:00","created_by":"daemon"},{"issue_id":"mlld-wsm","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T19:59:14.8354-08:00","created_by":"daemon"}]}
{"id":"mlld-wzb","title":"Grammar bug: Second bare directive parsed as text in strict mode","description":"In strict mode, when two directives appear on consecutive lines, the second directive is incorrectly parsed as text content and triggers 'Text content not allowed in strict mode' error.\n\n## Reproduction\n```mlld\nrun {echo \"A\"}\nrun {echo \"B\"}\n```\n\nParse this with `{mode: 'strict'}` and it fails with:\n```\nParse error: Text content not allowed in strict mode (.mld). Use .mld.md for prose. at line 2, column 4\n```\n\n## Expected\nBoth directives should be parsed and executed.\n\n## Actual  \nSecond directive is treated as text and triggers strict mode error.\n\n## Root Cause\nThe Directive rule predicate checks `isLogicalLineStart()` which requires the previous character (skipping whitespace) to be a newline. After the first directive's newline is consumed, the second directive starts at a position where the previous character is `\\n`, which should satisfy `isLogicalLineStart()`. However, something in the parsing order causes the second directive to not match.\n\nHappens even with simple directives, no blank lines needed - just any two bare directives on consecutive lines.\n\n## Impact\n- ~80 new strict mode test fixtures cannot be used until this is fixed\n- Strict mode is essentially unusable for multi-line scripts\n- BLOCKING: Cannot enable strict mode as default until fixed\n\n## Workaround\nFor now, using slash prefix (`/run`, `/var`, etc.) works in strict mode since the Directive rule checks both `isStrictMode || hasSlash`.\n\n## Files\n- `grammar/mlld.peggy` - Directive rule line 216-246\n- `grammar/deps/grammar-core.ts` - isLogicalLineStart helper line 146-151\n- `grammar/base/whitespace.peggy` - may be related to newline handling","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-11T19:55:48.93822-08:00","updated_at":"2025-12-11T20:16:29.988601-08:00","closed_at":"2025-12-11T20:16:29.988601-08:00"}
{"id":"mlld-x41","title":"Field access on JS-returned objects fails in for-loop source","description":"## Reproduction\n\n```mlld\n/exe @getData() = js { return { all: ['a','b','c'] } }\n/var @result = @getData()\n/show \"All: @result.all\"           # Works: [\"a\",\"b\",\"c\"]\n/for @item in @result.all =\u003e show @item  # FAILS: undefined\n```\n\n## Issue\n\nField access `@result.all` works in string interpolation but returns `undefined` when used as a /for loop source.\n\n## Expected\n\n`@result.all` should return the array `['a','b','c']` consistently in all contexts.\n\n## Context\n\nJS function returns object, gets stored as StructuredValue. Field access works for display but not for iteration.\n\nReported by: partydev.1","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-09T17:09:42.728504-08:00","updated_at":"2025-12-10T19:22:41.178321-08:00","closed_at":"2025-12-10T19:22:41.178321-08:00"}
{"id":"mlld-xiw","title":"LSP: Fix array/object mlld value highlighting (GH#332)","description":"Arrays and objects with mlld values have inconsistent highlighting.\n\nSee: https://github.com/mlld-lang/mlld/issues/332\n\nSize: Small","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-11T20:12:36.61009-08:00","updated_at":"2025-12-11T20:12:36.61009-08:00","dependencies":[{"issue_id":"mlld-xiw","depends_on_id":"mlld-a03","type":"parent-child","created_at":"2025-12-11T20:13:43.182947-08:00","created_by":"daemon"}]}
{"id":"mlld-xju","title":"Refactor: Consolidate expression.ts and expressions.ts","description":"## Summary\n\nConsolidate duplicate expression evaluator files to eliminate confusion and technical debt.\n\n## Context\n\nWe have TWO files with overlapping functionality:\n1. `interpreter/eval/expression.ts` (OLD) - 347 lines\n2. `interpreter/eval/expressions.ts` (NEW) - ~350 lines\n\nThe OLD file contains useful helpers (isTruthy, isEqual, toNumber) but also a broken `evaluateExpression()` that doesn't support arithmetic operators. The NEW file has the working evaluator but imports helpers from the OLD file.\n\n**Current fix:** interpreter.ts now uses the NEW evaluator (mlld-a2x fix), but we should consolidate the files.\n\n## Current Usage\n\n**expression.ts (OLD):**\n- Exports: isTruthy, isEqual, toNumber, evaluateExpression\n- Used by: expressions.ts (helpers), value-combine.ts (toNumber)\n- evaluateExpression: UNUSED (was broken, replaced by evaluateUnifiedExpression)\n\n**expressions.ts (NEW):**\n- Exports: evaluateUnifiedExpression\n- Imports: isTruthy, isEqual, toNumber from expression.ts\n- Used by: interpreter.ts (as of mlld-a2x fix)\n\n## Consolidation Options\n\n### Option 1: Merge into expressions.ts (Recommended)\n\n**Steps:**\n1. Copy isTruthy, isEqual, toNumber into expressions.ts\n2. Remove import from expressions.ts\n3. Export helpers from expressions.ts\n4. Update value-combine.ts to import from expressions.ts\n5. Delete expression.ts entirely\n\n**Result:** Single file with all expression logic\n\n**Pros:** Clean, single source of truth\n**Cons:** Larger file (~650 lines)\n\n### Option 2: Rename to expression-helpers.ts\n\n**Steps:**\n1. Rename expression.ts ‚Üí expression-helpers.ts\n2. Remove evaluateExpression() from helpers file (keep only isTruthy, isEqual, toNumber)\n3. Update imports in expressions.ts and value-combine.ts\n\n**Result:** Clear separation (helpers vs evaluators)\n\n**Pros:** Explicit naming, smaller files\n**Cons:** Extra file\n\n## Files to Modify\n\nOption 1 (Merge):\n- interpreter/eval/expressions.ts (add helpers)\n- interpreter/utils/value-combine.ts (update import)\n- Delete interpreter/eval/expression.ts\n\nOption 2 (Rename):\n- Rename interpreter/eval/expression.ts ‚Üí expression-helpers.ts\n- Update interpreter/eval/expressions.ts import\n- Update interpreter/utils/value-combine.ts import\n- Remove evaluateExpression() from helpers\n\n## Validation\n\n- [ ] All tests pass after consolidation\n- [ ] No imports from expression.ts remain\n- [ ] Helpers (isTruthy, isEqual, toNumber) still work\n- [ ] evaluateUnifiedExpression still works\n- [ ] value-combine.ts still works\n\n## Effort\n\n**Option 1 (Merge):** 30-45 minutes\n**Option 2 (Rename):** 20-30 minutes\n\n## References\n\n- Fixed in: mlld-a2x (interpreter.ts now uses NEW evaluator)\n- Analysis: tmp/expression-consolidation-plan.md","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T18:32:55.307628-08:00","updated_at":"2025-12-10T19:09:19.073389-08:00","labels":["chore"]}
{"id":"mlld-ytz","title":"Dynamic modules: mode selection for injected content","description":"**Summary:**\nEnsure dynamically injected modules respect mode settings.\n\n**Changes required:**\n\n1. **String dynamic modules**:\n   - `dynamicModules: { '@foo': 'var @x = 1' }` - needs to parse\n   - Default: `'strict'` mode (programmatic injection = code, not docs)\n   - Add option: `dynamicModuleMode?: 'strict' | 'markdown'`\n\n2. **Object dynamic modules**:\n   - `dynamicModules: { '@state': { count: 0 } }` - no parsing, N/A\n   - These become direct value exports, mode irrelevant\n\n3. **Per-module mode** (optional enhancement):\n   - Could support: `dynamicModules: { '@foo': { source: '...', mode: 'markdown' } }`\n   - Lower priority, probably not needed\n\n4. **Documentation**:\n   - Document that string dynamic modules parse in strict mode by default\n   - Explain how to opt into markdown mode if needed\n\n**Testing:**\n- String dynamic module with bare directives - parses in strict\n- String dynamic module with text content - errors (strict default)\n- String dynamic module with explicit markdown mode - text becomes content","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:56:53.299196-08:00","updated_at":"2025-12-11T17:46:10.688649-08:00","closed_at":"2025-12-11T17:46:10.688649-08:00","dependencies":[{"issue_id":"mlld-ytz","depends_on_id":"mlld-k4k","type":"parent-child","created_at":"2025-12-08T20:59:12.446397-08:00","created_by":"daemon"},{"issue_id":"mlld-ytz","depends_on_id":"mlld-5n7","type":"blocks","created_at":"2025-12-08T20:59:32.25244-08:00","created_by":"daemon"}]}
{"id":"mlld-zce","title":"E2E smoke tests for Claude Code integration","description":"## Goal\n\nCreate E2E smoke tests that verify mlld works correctly when piping/passing data to Claude Code CLI, especially with complex escaping scenarios.\n\n## Requirements\n\n**Test location:** `tests/claude/` (separate from regular tests)\n**Run command:** `npm run test:claude` (NOT included in `npm test`)\n**Test type:** E2E using mlld SDK's `execute()` function (NOT unit tests with manual ExecInvocation construction)\n\n## Test Patterns to Cover\n\nFrom your list of escaping/piping scenarios:\n\n1. `/exe @func(value) = @value | cmd { claude -p --model haiku }`\n2. `/exe @func(value) = cmd { @value | claude -p --model haiku }`\n3. `/exe @func(value) = @other(value) | cmd { claude -p --model haiku }`\n4. `/exe @func(value) = js { return \"hi\" } | cmd { claude -p --model haiku }`\n5. `/exe @func(value) = cmd { echo \"hello\" } | cmd { claude -p --model haiku }`\n6. `/exe @func(value) = @value | cmd { claude -p } | cmd { claude -p \"wdyt?\" }`\n\n## Test Structure (E2E with SDK)\n\nWrite actual mlld files + TypeScript tests using SDK `execute()`:\n\n**tests/claude/scripts/pipe-value.mld:**\n```mlld\n/exe @claude(prompt) = @prompt | cmd { claude -p --model haiku }\n/var @response = @claude(\"Say only OK\")\n/show @response\n```\n\n**tests/claude/integration.test.ts:**\n```typescript\nimport { execute } from '@sdk/execute';\nimport path from 'node:path';\n\nconst shouldRun = process.env.MLLD_RUN_CLAUDE_TESTS === '1';\nconst describeTest = shouldRun ? describe : describe.skip;\n\ndescribeTest('Claude integration', () =\u003e {\n  it('pipes value through claude', async () =\u003e {\n    const script = path.join(__dirname, 'scripts/pipe-value.mld');\n    const result = await execute(script, {});\n    \n    expect(result.output.trim().length).toBeGreaterThan(0);\n    expect(result.output.toUpperCase()).toContain('OK');\n  }, 30000);\n});\n```\n\n## What gpt5.1 Got Wrong\n\nCreated unit tests with manual ExecInvocation construction instead of E2E tests using actual mlld files + SDK execute().","notes":"## Test Coverage\n\nCreated comprehensive E2E tests for Claude Code integration covering all 6 escaping/piping patterns:\n\n1. Pattern 1: @value | cmd { claude -p } - Pipes value through claude\n2. Pattern 2: cmd { claude -p \"@value\" } - Uses value inside cmd body\n3. Pattern 3: @other(value) | cmd { claude -p } - Pipes result from another function\n4. Pattern 4: js { return \"prompt\" } | cmd { claude -p } - Pipes js result through claude\n5. Pattern 5: cmd { echo \"prompt\" } | cmd { claude -p } - Pipes cmd result through claude\n6. Pattern 6: @value | cmd { claude -p } | cmd { claude -p \"followup\" } - Double pipe through claude\n\nAll tests use SDK execute() function (NOT manual ExecInvocation construction).\nAll 9 tests passing across 3 test files.\n\n## Files Created\n\n- tests/claude/escaping-patterns.test.ts (6 tests)\n- tmp/claude-test-*.mld (6 test scripts)\n- Fixed: tests/claude/exe-claude-pipeline.test.ts (corrected syntax)\n- Fixed: tests/claude/claude-sdk-smoke.mld (corrected model name)\n\n## Alias Resolution Behavior\n\nmlld resolves shell aliases for commands in cmd { } blocks via interpreter/utils/alias-resolver.ts.\n\nKey behavior:\n- ‚úÖ cmd { claude -p \"prompt\" } - Alias resolves (command at start of block)\n- ‚ùå cmd { echo \"x\" | claude -p } - Alias does NOT resolve (pipe INSIDE block)\n- ‚úÖ @value | cmd { claude -p } - Alias resolves (pipe OUTSIDE block)\n\nThe alias resolver runs on the top-level command of a cmd block, but not on commands after pipes within shell scripts. This is why pattern 2 uses cmd { claude -p \"@value\" } instead of cmd { echo \"@value\" | claude -p }.\n\n## Run Tests\n\nnpm run test:claude\nMLLD_RUN_CLAUDE_TESTS=1 CLAUDE_MODEL=haiku vitest run tests/claude","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-09T18:43:47.625059-08:00","updated_at":"2025-12-09T19:25:44.599803-08:00","closed_at":"2025-12-09T19:17:24.767804-08:00"}
{"id":"mlld-zeo","title":"Phase 2.1: Interpreter - Export let functions from when.ts","description":"## Summary\n\nExport the existing let/augmented assignment evaluation functions from when.ts so they can be reused by exe and for block evaluators.\n\n## üìö Required Reading\n\nBefore starting Phase 2 interpreter work:\n- **docs/dev/DATA.md** - StructuredValue system (.text, .data, .ctx)\n- **interpreter/utils/structured-value.ts** - asData/asText helpers\n\nKey patterns:\n- `asData()` for computation boundaries (JS args, comparisons)\n- `asText()` for display boundaries (templates, shell commands)\n- Let assignments store StructuredValue wrappers\n- Return values should preserve wrappers\n\n## Why This Matters\n\nThe plan identifies that exe blocks are ~80% the same as exe..when. The let/augmented assignment logic already exists and works - we just need to export it for reuse.\n\n## Files to Modify\n\n- `interpreter/eval/when.ts` - Export helper functions\n\n## Implementation\n\nChange from private to exported functions (around lines 31 and 66):\n\n```typescript\n// Change: async function evaluateLetAssignment(...)\n// To: export async function evaluateLetAssignment(...)\n\nexport async function evaluateLetAssignment(\n  entry: LetAssignmentNode,\n  env: Environment\n): Promise\u003cEnvironment\u003e {\n  // ... existing implementation unchanged\n}\n\nexport async function evaluateAugmentedAssignment(\n  entry: AugmentedAssignmentNode,\n  env: Environment\n): Promise\u003cEnvironment\u003e {\n  // ... existing implementation unchanged\n}\n```\n\n## Key Implementation Details\n\nFrom when.ts (lines 31-112):\n- `evaluateLetAssignment()` creates child environment with new binding\n- `evaluateAugmentedAssignment()` finds existing let variable and mutates\n- Both return new Environment (immutable pattern)\n\n## Augmented Assignment Semantics (lines 66-112)\n\n- Arrays: concat (`[1, 2] += 3` ‚Üí `[1, 2, 3]`, `[1] += [2, 3]` ‚Üí `[1, 2, 3]`)\n- Strings: append (`\"hello\" += \" world\"` ‚Üí `\"hello world\"`)\n- Objects: shallow merge (`{a: 1} += {b: 2}` ‚Üí `{a: 1, b: 2}`)\n- Only works with local `let` bindings (not global variables)\n\n## Testing\n\nAfter export, verify imports work:\n\n```typescript\nimport { evaluateLetAssignment, evaluateAugmentedAssignment } from './when';\n```\n\n## Validation\n\n- [ ] Functions exported without breaking existing when evaluation\n- [ ] Type signatures remain unchanged\n- [ ] All existing when tests still pass","notes":"‚úÖ PREREQUISITE UPDATE: Type enums completed in mlld-b4f. DirectiveKind now includes 'while' and 'for'. DirectiveSubtype now includes 'exeBlock', 'while', and 'for'. All types compile successfully. Ready to proceed with exporting let functions.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T22:16:54.131728-08:00","updated_at":"2025-12-10T14:00:43.452905-08:00","closed_at":"2025-12-10T14:00:43.452905-08:00","dependencies":[{"issue_id":"mlld-zeo","depends_on_id":"mlld-0gd","type":"blocks","created_at":"2025-12-09T22:18:51.792231-08:00","created_by":"daemon"},{"issue_id":"mlld-zeo","depends_on_id":"mlld-b4f","type":"blocks","created_at":"2025-12-10T11:27:19.185199-08:00","created_by":"daemon"}]}
{"id":"mlld-zgb","title":"Grammar: Extend CmdCommandBrackets to support optional :path","description":"## Context\nPart of implementing cmd:path/sh:path feature. This task extends the `CmdCommandBrackets` pattern to accept the optional `:path` suffix.\n\n## Prerequisites\n- mlld-b0e must be complete (WorkingDirPath pattern exists)\n\n## Task\nModify `CmdCommandBrackets` to optionally parse and include working directory path.\n\n## Implementation\n\nLocation: `grammar/patterns/unified-run-content.peggy`\n\nCurrent code (around line 84-87):\n```peggy\nCmdCommandBrackets \"cmd command brackets\"\n  = \"cmd\" _ content:UnifiedCommandBrackets {\n      return content;\n    }\n```\n\nChange to:\n```peggy\nCmdCommandBrackets \"cmd command brackets\"\n  = \"cmd\" workingDir:WorkingDirPath? _ content:UnifiedCommandBrackets {\n      const result = content;\n      if (workingDir) {\n        result.values.workingDir = workingDir.parts;\n        result.raw.workingDir = workingDir.raw;\n        result.meta.hasWorkingDir = true;\n        result.meta.workingDirMeta = workingDir.meta;\n      }\n      return result;\n    }\n```\n\n## What This Does\n\n1. Optionally matches `WorkingDirPath` after `cmd` keyword\n2. If present, adds to the result node:\n   - `values.workingDir` - AST node array for interpreter\n   - `raw.workingDir` - raw string for debugging/display\n   - `meta.hasWorkingDir` - boolean flag\n   - `meta.workingDirMeta` - path metadata (hasVariables, etc)\n\n## Testing\n\nAfter implementation:\n```bash\nnpm run ast -- '/run cmd:/tmp {ls}'\nnpm run ast -- '/run cmd:@mypath {pwd}'\nnpm run ast -- '/run cmd {ls}'  # without path still works\n```\n\nCheck the AST output has `workingDir` field in values/raw/meta when path is present.","notes":"Cmd :path grammar uses WorkingDirPath pattern; accepts absolute Unix paths only ('/' ok); no Windows or '~'.","status":"closed","priority":2,"issue_type":"task","assignee":"codex","created_at":"2025-12-08T12:52:13.204118-08:00","updated_at":"2025-12-08T20:23:39.467487-08:00","closed_at":"2025-12-08T20:23:39.467487-08:00"}
