# Plan: Add Unique Node IDs to AST

## Goal
Enhance the Meld Abstract Syntax Tree (AST) by adding a unique `nodeId` to every node generated by the parser. This provides a stable identifier for tracking, referencing, and transforming specific nodes throughout the pipeline, independent of array indices or source location.

## Context
- Current AST Structure: `docs/dev/AST.md`
- Advice for Grammar Changes: `core/ast/docs/ADVICE.md`
- Parser Debugging: `core/ast/docs/DEBUG.md`
- Related State Refactor: `_plans/STATE-UPDATES.md`

## Detailed Steps

**1. Define `NodeId` Type:**
   *   **File:** `core/types/common.ts` (or a new `core/types/ast.ts`)
   *   **Action:** Define a simple type alias: `export type NodeId = string;`

**2. Update AST Node Interfaces:**
   *   **File:** `@core/syntax/types/interfaces/INode.ts` (or the base `MeldNode` type definition, likely in `@core/syntax/types/nodes.js`)
   *   **Action:** Add the mandatory, read-only property `readonly nodeId: NodeId;` to the base node interface. Ensure all specific node type interfaces (`ITextNode`, `IDirectiveNode`, etc.) correctly inherit this.
   *   **File:** `@core/syntax/types/nodes.js` (and related files if interfaces are separate)
   *   **Action:** Ensure concrete type definitions (`TextNode`, `DirectiveNode`, etc.) include the `nodeId` property.

**3. Modify Parser Grammar (`core/ast/grammar/meld.pegjs`):**
   *   **Action:** Systematically update **every action block** (`{...}`) that constructs and returns a node object (`{ type: '...', ... }`).
   *   **Details:**
       *   **Import UUID:** Ensure a UUID generation function (e.g., `randomUUID` from Node's `crypto` module) is available within the parser's execution context. This might involve adding `const crypto = require('crypto');` or similar to the *initial* `{...}` block at the top of the grammar file, and potentially passing it via `options` if direct `require` isn't standard practice in Peggy actions. A simpler alternative might be to use a basic timestamp + random number approach if strict UUIDv4 isn't required: `const generateId = () => \`node-\${Date.now()}-\${Math.random().toString(36).substring(2, 9)}\`;` defined in the top block.
       *   **Add Property:** In each action block returning a node, add the line: `nodeId: generateId(), // or crypto.randomUUID()` before the final `return` statement or as part of the returned object literal. Example:
         ```pegjs
         RuleName = parts:SubRule+ { 
             const nodeId = generateId(); // Or crypto.randomUUID()
             // ... other processing ...
             return { type: "RuleName", parts: parts, nodeId: nodeId }; 
         }
         ```
   *   **Caution:** Modify carefully, following advice in `core/ast/docs/ADVICE.md`. Make small changes and run the build script often. Refer to `core/ast/docs/DEBUG.md` if encountering parser generation errors.

**4. Rebuild Grammar:**
   *   **Action:** Run `npm run build:grammar` (or the equivalent command).
   *   **Action:** Fix any syntax or build errors arising from the modifications.

**5. Update AST Tests:**
   *   **Files:** All test files that interact with or assert on the structure of AST nodes (e.g., `ParserService.test.ts`, snapshot tests, potentially some handler tests).
   *   **Action:** Update assertions and snapshots.
   *   **Details:**
       *   For snapshot tests, regenerate snapshots.
       *   For deep equality checks (`.toEqual`), update the expected object structure to include `nodeId: expect.any(String)`.
       *   For specific `nodeId` checks (unlikely but possible), adjust accordingly.

**6. (Future) Leverage `NodeId`:**
   *   Consider refactoring `StateService.transformNode` and potentially `InterpreterService` logic to use `nodeId` for finding/replacing nodes instead of array index or location comparison, which would be more robust. This is outside the scope of *this* immediate plan but is the primary benefit.
