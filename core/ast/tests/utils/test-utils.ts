import type { MeldNode, NodeType, SourceLocation, ParserTestCase } from '@core/syntax/types';
import type { Parser } from 'peggy';
import { MeldAstError, ParseErrorCode, ParseResult } from '@core/ast/types';
import { vi, expect } from 'vitest';
import { parse } from '@core/ast';

// Define interfaces needed for validation tests
interface ValidationError {
  message: string;
  location?: SourceLocation;
}

interface ValidationContext {
  parser: Parser;
  errors: ValidationError[];
  hasErrors: () => boolean;
  getErrors: () => ValidationError[];
  addError: (error: ValidationError) => void;
}

// Create a mock SyntaxError class that matches peggy's interface
class MockSyntaxError extends Error {
  location: any;
  expected: any;
  found: any;
  name: string;
  message: string;
  code = 'SYNTAX_ERROR';
  line = 1;
  column = 1;

  constructor(message: string, location?: any, expected?: any, found?: any) {
    super(message);
    this.name = 'SyntaxError';
    this.message = message;
    this.location = location;
    this.expected = expected;
    this.found = found;
  }

  format(options?: any): string {
    return this.message;
  }
}

// Add static properties to match peggy's SyntaxError
Object.assign(MockSyntaxError, {
  location: undefined,
  expected: undefined,
  found: undefined,
  message: '',
  format: (options?: any) => ''
});

/**
 * Creates a mock parser for testing purposes.
 * Allows controlling the parser's behavior without actual parsing.
 * 
 * @returns A mock parser object with configurable behavior
 */
export function createMockParser(options: {
  returnValue?: MeldNode[];
  throwError?: boolean;
  errorMessage?: string;
  location?: SourceLocation;
} = {}): Parser {
  return {
    parse: vi.fn().mockImplementation((input: string) => {
      if (options.throwError) {
        throw new MeldAstError(
          options.errorMessage || 'Mock parse error',
          options.location,
          undefined,
          ParseErrorCode.SYNTAX_ERROR
        );
      }
      return options.returnValue || [];
    }),
    SyntaxError: MockSyntaxError as any // Type assertion needed since peggy's types are a bit unusual
  };
}

/**
 * Creates a mock node for testing purposes.
 * Provides type-safe node creation with default values.
 * 
 * @param type - The type of node to create
 * @param data - Additional node data
 * @param location - Optional source location
 * @returns A properly typed mock node
 */
export function createMockNode<T extends NodeType>(
  type: T,
  data: object = {},
  location?: SourceLocation
): MeldNode {
  return {
    type,
    ...data,
    location: location || {
      start: { line: 1, column: 1 },
      end: { line: 1, column: 1 }
    },
    nodeId: `mock-node-${Math.random()}`
  };
}

/**
 * Creates a mock validation context for testing validation functions.
 * 
 * @returns A mock validation context with tracking capabilities
 */
export function createMockValidationContext(): ValidationContext {
  const errors: ValidationError[] = [];
  const parser = createMockParser({});
  const context = {
    parser,
    errors,
    hasErrors: () => errors.length > 0,
    getErrors: () => errors,
    addError: (error: ValidationError) => {
      errors.push(error);
    }
  };
  return context;
}

/**
 * Type guard to check if a parse result contains errors
 * 
 * @param result - The parse result to check
 * @returns True if the result contains errors
 */
export function hasErrors(result: ParseResult): result is ParseResult & { errors: MeldAstError[] } {
  return 'errors' in result && Array.isArray(result.errors);
}

/**
 * Creates a mock location for testing
 * 
 * @param start - Start position (line and column)
 * @param end - End position (line and column)
 * @returns A SourceLocation object
 */
export function createMockLocation(
  start: { line: number; column: number } = { line: 1, column: 1 },
  end: { line: number; column: number } = { line: 1, column: 1 }
): SourceLocation {
  return { start, end };
}

/**
 * Recursively synchronizes the nodeId and location from the actual AST node to the expected fixture node.
 * This allows fixtures to use placeholder IDs and locations while still verifying the full structure,
 * including the presence of a nodeId and location generated by the parser.
 */
function syncNodeIds(actual: any, expected: any): void {
  if (
    !actual ||
    !expected ||
    typeof actual !== 'object' ||
    typeof expected !== 'object'
  ) {
    return;
  }

  // Sync nodeId, location, and source if both nodes have them
  if ('nodeId' in actual && 'nodeId' in expected) {
    expected.nodeId = actual.nodeId;
  }
  if ('location' in actual && 'location' in expected) {
    // Deep copy location to avoid potential shared object references if needed
    expected.location = JSON.parse(JSON.stringify(actual.location));
    // If actual has source property, add it to expected
    if ('source' in actual.location) {
      expected.location.source = actual.location.source;
    }
  }

  // Recurse into arrays
  if (Array.isArray(actual) && Array.isArray(expected)) {
    const length = Math.min(actual.length, expected.length);
    for (let i = 0; i < length; i++) {
      syncNodeIds(actual[i], expected[i]);
    }
  }
  // Recurse into object properties
  else if (!Array.isArray(actual) && !Array.isArray(expected)) {
    for (const key in expected) {
      // Avoid recursing into properties we just synced
      if (key === 'nodeId' || key === 'location') continue;
      if (key in actual) {
        syncNodeIds(actual[key], expected[key]);
      }
    }
  }
}

/**
 * Helper function to test valid parser test cases
 */
export async function testValidCase(test: ParserTestCase) {
  // Parse the input
  const result = await parse(test.input);

  // Deep copy the expected result to avoid modifying the original
  const expected = JSON.parse(JSON.stringify(test.expected));

  if (!result.ast || result.ast.length === 0) {
    throw new Error('Parser returned no nodes for a supposed valid case');
  }

  // Get the actual node from the parser result
  const actualNode = result.ast[0];

  // Synchronize the dynamically generated nodeId and location from the actual node to the expected node
  // This allows the deep equality check to pass while still verifying structure
  syncNodeIds(actualNode, expected);

  try {
    // Compare the actual node directly with the expected fixture
    expect(actualNode).toEqual(expected);
  } catch (error) {
    console.error('Test failed for input:', test.input);
    console.error('Actual:', JSON.stringify(actualNode, null, 2));
    console.error('Expected:', JSON.stringify(expected, null, 2));
    throw error;
  }
}

/**
 * Helper function to test invalid parser test cases
 */
export async function testInvalidCase(test: ParserTestCase) {
  try {
    await parse(test.input);
    throw new MeldAstError('Expected parse to throw an error', undefined, undefined, ParseErrorCode.SYNTAX_ERROR);
  } catch (err: any) {
    if (err instanceof MeldAstError) {
      const expectedError = test.expected as { type: 'Error', error: string };
      expect(err.code).toBe(ParseErrorCode.SYNTAX_ERROR);
      expect(err.message).toBeTruthy();
    } else {
      throw new MeldAstError(err.message, undefined, undefined, ParseErrorCode.SYNTAX_ERROR);
    }
  }
}