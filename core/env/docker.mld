exe @execute(opts, command) = node {
  const { spawnSync } = require('child_process');

  const image = typeof opts?.image === 'string' && opts.image.trim().length > 0
    ? opts.image.trim()
    : 'node:18';

  const requestedName = typeof opts?.name === 'string' && opts.name.trim().length > 0
    ? opts.name.trim()
    : null;
  const keep = Boolean(opts?.keep) || Boolean(requestedName);
  const handle = keep
    ? (requestedName || `mlld-env-${Date.now()}-${Math.random().toString(16).slice(2, 10)}`)
    : null;

  const args = ['run', '--rm', '-i'];
  if (keep && args.includes('--rm')) {
    args.splice(args.indexOf('--rm'), 1);
  }
  if (handle) {
    args.push('--name', handle);
  }

  if (opts?.memory) {
    args.push('--memory', String(opts.memory));
  }

  if (opts?.net === 'none' || opts?.net === 'host' || opts?.net === 'bridge') {
    args.push('--network', String(opts.net));
  }

  if (command?.cwd) {
    args.push('-w', String(command.cwd));
  }

  const env = {
    ...(command?.vars || {}),
    ...(command?.secrets || {})
  };

  for (const [key, value] of Object.entries(env)) {
    if (value === undefined || value === null) {
      continue;
    }
    args.push('-e', `${key}=${String(value)}`);
  }

  const addMounts = (mounts, readOnly) => {
    if (!Array.isArray(mounts)) {
      return;
    }
    for (const mount of mounts) {
      if (!mount) {
        continue;
      }
      let spec = String(mount);
      if (readOnly && !spec.endsWith(':ro')) {
        spec += ':ro';
      }
      args.push('-v', spec);
    }
  };

  const fsConfig = opts?.fs || {};
  addMounts(fsConfig.read, true);
  addMounts(fsConfig.write, false);

  args.push(image);

  const argv = Array.isArray(command?.argv) && command.argv.length > 0
    ? command.argv.map(value => String(value))
    : ['sh', '-lc', ''];
  args.push(...argv);

  const input = command?.stdin ?? '';
  const result = spawnSync('docker', args, { encoding: 'utf8', input });

  if (result.error) {
    return {
      stdout: '',
      stderr: result.error.message,
      exitCode: typeof result.status === 'number' ? result.status : 1,
      ...(handle ? { handle } : {})
    };
  }

  return {
    stdout: result.stdout || '',
    stderr: result.stderr || '',
    exitCode: typeof result.status === 'number' ? result.status : 1,
    ...(handle ? { handle } : {})
  };
}

exe @release(handle) = node {
  const { spawnSync } = require('child_process');

  if (!handle) {
    return '';
  }

  spawnSync('docker', ['rm', '-f', String(handle)], { encoding: 'utf8' });
  return '';
}

export { @execute, @release }
