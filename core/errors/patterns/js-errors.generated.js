/**
 * Generated JavaScript Error Patterns v1
 * 
 * Pattern count: 2
 * Last updated: 2025-08-13
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * Edit the source patterns in errors/js/
 */

// Pattern definitions
const patterns = [
  {
    name: 'at-sign-in-js',
    template: `Cannot use @\${VARNAME} syntax inside JavaScript code blocks

JavaScript blocks use regular variable names, not @ syntax:
  ✗ js { const x = @\${VARNAME}; }
  ✅ js { const x = \${VARNAME}; }

To use mlld variables in JavaScript:
1. Pass them as parameters to the function
2. Reference them by name (without @) inside the JS block

Found: \${USAGE}`,

    test(error, ctx) {
        // Check if this is a JS syntax error with @ symbol
        if (!error.message || !error.message.includes('Invalid or unexpected token')) {
          return false;
        }
        
        // Check if the code contains @ symbol (mlld variable syntax)
        if (!ctx.code || !ctx.code.includes('@')) {
          return false;
        }
        
        // Look for @variable pattern in the code
        return /@\w+/.test(ctx.code);
      },
      
      enhance(error, ctx) {
        // Extract the variable name after @
        const varMatch = ctx.code.match(/@(\w+)/);
        const varName = varMatch ? varMatch[1] : 'variable';
        
        // Find the specific @ usage context - get the line with @
        const lines = ctx.code.split('\n');
        let usage = '';
        for (const line of lines) {
          if (line.includes('@')) {
            usage = line.trim();
            break;
          }
        }
        
        if (usage.length > 50) {
          usage = usage.substring(0, 47) + '...';
        }
        
        return {
          VARNAME: varName,
          USAGE: usage
        };
      }
  },

  {
    name: 'js-mutation-attempt',
    template: `Cannot use mutation syntax @\${VARNAME}\${OPERATION} in JavaScript blocks

Variables are immutable in mlld. Return new values instead:
  ✗ @\${VARNAME}\${OPERATION}
  ✅ \${SUGGESTION}

In mlld, variables are values that flow through pipelines.
To update a variable, assign a new value at the mlld level:
  /var @\${VARNAME} = @increment(@\${VARNAME})`,

    test(error, ctx) {
        // Check for syntax error in JS context
        if (!error.message || !error.message.includes('Invalid or unexpected token')) {
          return false;
        }
        
        if (!ctx.code) {
          return false;
        }
        
        // Look for mutation patterns like @var++ or @var += 
        const mutationPatterns = [
          /@\w+\+\+/,        // @var++
          /@\w+--/,          // @var--
          /@\w+\s*\+=/,      // @var +=
          /@\w+\s*-=/,       // @var -=
          /@\w+\s*\*=/,      // @var *=
          /@\w+\s*\/=/       // @var /=
        ];
        
        return mutationPatterns.some(pattern => pattern.test(ctx.code));
      },
      
      enhance(error, ctx) {
        // Extract the variable and operation
        const varMatch = ctx.code.match(/@(\w+)(\+\+|--|[+\-*/]=)/);
        const varName = varMatch ? varMatch[1] : 'variable';
        const operation = varMatch ? varMatch[2] : '++';
        
        // Determine the suggested fix
        let suggestion = `return ${varName} + 1`;
        if (operation === '--') {
          suggestion = `return ${varName} - 1`;
        } else if (operation.includes('=')) {
          const op = operation[0];
          suggestion = `return ${varName} ${op} value`;
        }
        
        return {
          VARNAME: varName,
          OPERATION: operation,
          SUGGESTION: suggestion
        };
      }
  }
];

/**
 * Interpolate variables into template
 */
function interpolateTemplate(template, variables) {
  return template.replace(/\$\{(\w+)\}/g, (match, varName) => {
    return variables[varName] !== undefined ? variables[varName] : match;
  });
}

/**
 * Enhance JavaScript execution error with pattern matching
 */
export function enhanceJSError(error, code, params, metadata) {
  const ctx = {
    code: code || '',
    error: error,
    params: params || {},
    metadata: metadata || {}
  };
  
  // Try each pattern
  for (const pattern of patterns) {
    try {
      if (pattern.test(error, ctx)) {
        const variables = pattern.enhance(error, ctx);
        const message = interpolateTemplate(pattern.template, variables);
        
        // Return enhanced error details
        return {
          type: 'js-execution',
          pattern: pattern.name,
          message,
          originalError: error.message,
          code: code
        };
      }
    } catch (e) {
      // Pattern failed, try next one
      continue;
    }
  }
  
  // No pattern matched
  return null;
}
