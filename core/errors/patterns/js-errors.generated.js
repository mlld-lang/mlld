/**
 * Generated JavaScript Error Patterns v1
 * 
 * Pattern count: 3
 * Last updated: 2025-08-24
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * Edit the source patterns in errors/js/
 */

// Pattern definitions
const patterns = [
  {
    name: 'at-sign-in-js',
    template: `Cannot use @\${VARNAME} syntax inside JavaScript code blocks

JavaScript blocks use regular variable names, not @ syntax:
  ✗ js { const x = @\${VARNAME}; }
  ✅ js { const x = \${VARNAME}; }

To use mlld variables in JavaScript:
1. Pass them as parameters to the function
2. Reference them by name (without @) inside the JS block

Found: \${USAGE}`,

    test(error, ctx) {
        // Check if this is a JS syntax error with @ symbol
        if (!error.message || !error.message.includes('Invalid or unexpected token')) {
          return false;
        }
        
        // Check if the code contains @ symbol (mlld variable syntax)
        if (!ctx.code || !ctx.code.includes('@')) {
          return false;
        }
        
        // Look for @variable pattern in the code
        return /@\w+/.test(ctx.code);
      },
      
      enhance(error, ctx) {
        // Extract the variable name after @
        const varMatch = ctx.code.match(/@(\w+)/);
        const varName = varMatch ? varMatch[1] : 'variable';
        
        // Find the specific @ usage context - get the line with @
        const lines = ctx.code.split('\n');
        let usage = '';
        for (const line of lines) {
          if (line.includes('@')) {
            usage = line.trim();
            break;
          }
        }
        
        if (usage.length > 50) {
          usage = usage.substring(0, 47) + '...';
        }
        
        return {
          VARNAME: varName,
          USAGE: usage
        };
      }
  },

  {
    name: 'field-access-array',
    template: `## Cannot access field '\${FIELD}' on array of files

You're trying to access '\${FIELD}' directly on an array of loaded files: \${CONTEXT}

Arrays of loaded files don't have a '\${FIELD}' property at the array level.
Each individual file in the array has this property.

### Solution

Use a /for loop to access properties of individual items:

\`\`\`mlld
\${SUGGESTION}
\`\`\`

### Available properties

**On the array itself:**
- \`.content\` - Concatenates all file contents
- \`.length\` - Number of files

**On individual items:**
- \`.filename\` - File name (e.g., "README.md")
- \`.relative\` - Relative path
- \`.absolute\` - Full path
- \`.content\` - File contents
- \`.tokest\` - Estimated token count
- \`.tokens\` - Exact token count
- \`.fm\` - Frontmatter (markdown files)
- \`.json\` - Parsed JSON (JSON files)`,

    test(error, ctx) {
        // Match errors about field access on LoadContentResultArray
        return error.message && error.message.includes('not found in LoadContentResultArray');
      },
      
      enhance(error, ctx) {
        // Extract the field name being accessed
        const fieldMatch = error.message.match(/Field "([^"]+)" not found/);
        const fieldName = fieldMatch ? fieldMatch[1] : 'unknown';
        
        // Check if the code shows the problematic access pattern
        let contextLine = '';
        let suggestion = '';
        
        if (ctx.code) {
          // Look for patterns like @files.filename
          const accessPattern = new RegExp(`@\\w+\\.${fieldName}`, 'g');
          const matches = ctx.code.match(accessPattern);
          if (matches && matches.length > 0) {
            contextLine = matches[0];
            const varName = contextLine.split('.')[0];
            suggestion = `/for @file in ${varName} => @file.${fieldName}`;
          }
        }
        
        return {
          FIELD: fieldName,
          CONTEXT: contextLine || `@array.${fieldName}`,
          SUGGESTION: suggestion || `/for @item in @array => @item.${fieldName}`
        };
      }
  },

  {
    name: 'js-mutation-attempt',
    template: `Cannot use mutation syntax @\${VARNAME}\${OPERATION} in JavaScript blocks

Variables are immutable in mlld. Return new values instead:
  ✗ @\${VARNAME}\${OPERATION}
  ✅ \${SUGGESTION}

In mlld, variables are values that flow through pipelines.
To update a variable, assign a new value at the mlld level:
  /var @\${VARNAME} = @increment(@\${VARNAME})`,

    test(error, ctx) {
        // Check for syntax error in JS context
        if (!error.message || !error.message.includes('Invalid or unexpected token')) {
          return false;
        }
        
        if (!ctx.code) {
          return false;
        }
        
        // Look for mutation patterns like @var++ or @var += 
        const mutationPatterns = [
          /@\w+\+\+/,        // @var++
          /@\w+--/,          // @var--
          /@\w+\s*\+=/,      // @var +=
          /@\w+\s*-=/,       // @var -=
          /@\w+\s*\*=/,      // @var *=
          /@\w+\s*\/=/       // @var /=
        ];
        
        return mutationPatterns.some(pattern => pattern.test(ctx.code));
      },
      
      enhance(error, ctx) {
        // Extract the variable and operation
        const varMatch = ctx.code.match(/@(\w+)(\+\+|--|[+\-*/]=)/);
        const varName = varMatch ? varMatch[1] : 'variable';
        const operation = varMatch ? varMatch[2] : '++';
        
        // Determine the suggested fix
        let suggestion = `return ${varName} + 1`;
        if (operation === '--') {
          suggestion = `return ${varName} - 1`;
        } else if (operation.includes('=')) {
          const op = operation[0];
          suggestion = `return ${varName} ${op} value`;
        }
        
        return {
          VARNAME: varName,
          OPERATION: operation,
          SUGGESTION: suggestion
        };
      }
  }
];

/**
 * Interpolate variables into template
 */
function interpolateTemplate(template, variables) {
  return template.replace(/\$\{(\w+)\}/g, (match, varName) => {
    return variables[varName] !== undefined ? variables[varName] : match;
  });
}

/**
 * Enhance JavaScript execution error with pattern matching
 */
export function enhanceJSError(error, code, params, metadata) {
  const ctx = {
    code: code || '',
    error: error,
    params: params || {},
    metadata: metadata || {}
  };
  
  // Try each pattern
  for (const pattern of patterns) {
    try {
      if (pattern.test(error, ctx)) {
        const variables = pattern.enhance(error, ctx);
        const message = interpolateTemplate(pattern.template, variables);
        
        // Return enhanced error details
        return {
          type: 'js-execution',
          pattern: pattern.name,
          message,
          originalError: error.message,
          code: code
        };
      }
    } catch (e) {
      // Pattern failed, try next one
      continue;
    }
  }
  
  // No pattern matched
  return null;
}
