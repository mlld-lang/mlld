>> j2bd/security/index.mld
>> Iterate on security docs + features until plan is complete

import { @claudePollEvent } from @mlld/claude-poll

>> Run directory for this session
var @runDir = `@base/j2bd/security/runs/@now.split("T")[0]`
run cmd { mkdir -p "@runDir" } with { ok: true }
var @eventsFile = `@runDir/events.jsonl`

log `=== J2BD Security Loop ===`
log `Run directory: @runDir`
log `Events file: @eventsFile`

>> The spec is the destination
var @spec = <@base/todo/spec-security-2026-v4.md>
log `Loaded spec: @spec.mx.tokens tokens`

>> Agent notes capture learnings across iterations
var @agentNotes = <./agent.md>

>> Jobs define what we're trying to accomplish
var @jobs = <./jobs/*.md>
log `Loaded @jobs.length jobs`

>> Task builder (template requires exe)
exe @buildTask(spec, atoms, plan, agentNotes, jobs, eventsFile, iterationId) = template "./task.att"

>> Log an event
exe @logEvent(eventsFile, event) = [
  let @eventWithTs = { ts: @now, ...@event }
  let @_ = @eventWithTs | append "@eventsFile"
  => @eventWithTs
]

>> State for loop control
var @state = { stop: false }

log `Starting loop...`

loop(endless) until @state.stop [
  >> Fresh state each iteration
  var @atoms = <@base/docs/src/atoms/security/*.md>
  var @plan = <./plan.md>

  log ``
  log `=== Iteration @mx.loop.iteration ===`
  log `Current atoms: @atoms.length`

  >> Check if we're done
  when @plan.match(/## Status: Complete/) => done "Security docs complete"

  >> Generate iteration ID
  var @iterationId = `iter-@mx.loop.iteration`

  >> Log iteration start
  let @_ = @logEvent(@eventsFile, { event: "iteration_start", id: @iterationId })
  log `Started: @iterationId`

  >> Build task from template
  var @task = @buildTask(@spec, @atoms, @plan, @agentNotes, @jobs, @eventsFile, @iterationId)
  log `Task built, spawning agent...`

  >> Do the work using poll pattern (works around claude -p hang bug)
  var @result = @claudePollEvent(
    @task,
    "opus",
    @base,
    "Read,Write,Edit,Glob,Grep,Bash",
    @eventsFile,
    "iteration_done",
    @iterationId
  ) | log

  log `Agent completed: @iterationId`

  >> Backpressure: validate atoms parse correctly
  log `Validating atoms...`
  var @validation = for parallel(5) @atom in @atoms [
    let @check = run cmd { mlld validate "@atom.mx.path" } with { ok: true }
    => { file: @atom.mx.filename, valid: @check.exitCode == 0, error: @check.stderr }
  ]

  >> Report validation results
  var @failures = for @v in @validation when !@v.valid => @v
  var @passed = @validation.length - @failures.length
  log `Validation: @passed/@validation.length passed`

  if @failures.length > 0 [
    log `Validation failures:`
    for @f in @failures => log `  @f.file: @f.error`
    let @_ = @logEvent(@eventsFile, { event: "validation_failed", id: @iterationId, failures: @failures.length })
  ]

  >> Commit if all atoms are valid
  if @failures.length == 0 [
    log `Committing changes...`
    run cmd { git add @base/docs/src/atoms/security/ @base/j2bd/security/ }
    run cmd { git commit -m "j2bd security: iteration @mx.loop.iteration" } with { ok: true }
    let @_ = @logEvent(@eventsFile, { event: "commit", id: @iterationId })
    log `Committed iteration @mx.loop.iteration`
  ]

  log `--- Iteration @mx.loop.iteration complete ---`
  continue
]
