{
  "status": "completed",
  "work_done": {
    "description": "Created sign-verify.md atom documenting the sign and verify directives for template integrity",
    "files": {
      "docs/src/atoms/security/sign-verify.md": "---\nid: sign-verify\ntitle: Sign and Verify\nbrief: Sign templates and verify their integrity\ncategory: security\nparent: security\ntags: [signing, verification, security, cryptography, templates]\nrelated: [signing-overview, labels-overview, guards-basics]\nrelated-code: [core/security/SignatureStore.ts, interpreter/eval/sign-verify.ts, cli/commands/verify.ts]\nupdated: 2026-02-01\nqa_tier: 2\n---\n\nThe `sign` and `verify` directives provide cryptographic integrity for templates. Sign a template to create a verifiable record of your original instructions. Verify retrieves that signed content, enabling detection of tampering or injection.\n\n**Sign directive syntax:**\n\n```mlld\nsign @variable with sha256\nsign @variable by \"signer\" with sha256\n```\n\n**Parameters:**\n\n- `@variable` - The variable to sign (typically a template)\n- `by \"signer\"` - Optional identity of who signed it\n- `with sha256` - Hash algorithm (currently only sha256 is supported)\n\n**What gets signed:**\n\nFor templates, the signature covers the template text with placeholders intact (not the interpolated result). For other variables, the signature covers the stringified value.\n\n```mlld\nvar @auditPrompt = ::Review @input and reject if unsafe::\nsign @auditPrompt by \"security-team\" with sha256\n```\n\nThis signs `Review @input and reject if unsafe` - the template with `@input` as a placeholder.\n\n**Verify directive syntax:**\n\n```mlld\nverify @variable\n```\n\nThe verify directive outputs a verification result object to stdout:\n\n```json\n{\n  \"verified\": true,\n  \"template\": \"Review @input and reject if unsafe\",\n  \"hash\": \"sha256:abc123...\",\n  \"signedby\": \"security-team\",\n  \"signedat\": \"2026-02-01T10:30:00Z\"\n}\n```\n\n**Verification fields:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `verified` | boolean | True if signature matches content |\n| `template` | string | Original signed content |\n| `hash` | string | Signature hash with algorithm prefix |\n| `signedby` | string | Optional signer identity |\n| `signedat` | string | ISO 8601 timestamp |\n\n**Signature storage:**\n\nSignatures are stored in `.mlld/sec/sigs/`:\n\n- `{varname}.sig` - Signature metadata (hash, method, signer, timestamp)\n- `{varname}.content` - Signed content\n\nThese files are created automatically when you sign a variable.\n\n**Verification failure:**\n\nWhen content changes after signing, `verified` is `false`. The `template` field still contains the ORIGINAL signed content, so you can detect what changed.\n\n```mlld\nvar @prompt = ::Review @input::\nsign @prompt by \"alice\" with sha256\nverify @prompt\n```\n\nOutput shows `\"verified\": true` because content matches signature.\n\nIf the template is modified after signing, verify detects the mismatch and outputs `\"verified\": false` while still showing the original signed template content.\n\n**The audit pattern:**\n\nSigning enables cryptographically verified audit workflows. Sign your audit criteria before use:\n\n```mlld\nvar @auditCriteria = ::\nReview @findings and approve only if:\n1. No secrets are exposed\n2. No destructive operations are performed\n3. All data sources are trusted\n::\n\nsign @auditCriteria by \"security-team\" with sha256\n```\n\nThe signed template can be passed to an LLM with instructions to verify authenticity via `mlld verify auditCriteria`. The CLI reads `MLLD_VERIFY_VARS` from the environment to know what to verify.\n\n**CLI verification:**\n\nThe `mlld verify` command checks signatures from the environment variable `MLLD_VERIFY_VARS`:\n\n```bash\nMLLD_VERIFY_VARS=auditCriteria mlld verify\n```\n\nOr pass variable names directly:\n\n```bash\nmlld verify auditCriteria\nmlld verify prompt instructions\n```\n\nOutput is JSON with verification results.\n\n**Autosign and autoverify:**\n\nPolicy can automatically sign templates and inject verification. With `autosign: [\"templates\"]`, templates are automatically signed when created. With `autoverify: true`, mlld automatically injects verify instructions and sets `MLLD_VERIFY_VARS` in the command environment.\n\n```mlld\nvar @policyConfig = {\n  defaults: {\n    autosign: [\"templates\"]\n  }\n}\npolicy @p = union(@policyConfig)\n\nvar @auditPrompt = ::Review @input::\n```\n\nThe `@auditPrompt` template is automatically signed when created because of `autosign: [\"templates\"]`.\n\nSee `signing-overview` for the conceptual foundation and threat model.\n"
    },
    "commit_message": "Add sign-verify security atom"
  },
  "friction_points": [
    {
      "type": "doc_gap",
      "description": "The 'llm' label syntax for exe functions causes validation errors in current build",
      "urgency": "low",
      "suggested_fix": "Either fix the validation for 'exe llm @name' syntax or update test cases that use it",
      "chestertons_fence": {
        "current_behavior": "Test cases exist with 'exe llm @audit()' syntax but validation fails with 'Cannot use 'in' operator to search for 'body' in llm'",
        "possible_reason": "The llm label implementation may be incomplete or there's a runtime vs validation difference",
        "change_impact": "Examples in signing-overview.md and test cases use this syntax but can't be validated"
      }
    }
  ],
  "standup": {
    "progress": "Created sign-verify.md atom documenting sign and verify directives with syntax, parameters, verification flow, signature storage, CLI usage, and autosign/autoverify configuration. All code examples validated successfully.",
    "blockers": "None - work completed",
    "next": "Ticket m-e4d6 can be closed"
  }
}
