# mlld Language Guide for LLMs

## The mlld Mindset: Orchestration, Not Programming

mlld is NOT a programming language - it's an **orchestration language embedded in Markdown**. This fundamental distinction drives everything about how you should use mlld.

### Think Like a Conductor, Not a Programmer
- You're orchestrating tools and data, not implementing algorithms
- Each directive is a clear, simple instruction
- Complexity belongs in modules and external tools
- If you're writing complex logic, you're using mlld wrong

### The mlld Way
❌ WRONG: Trying to concatenate strings procedurally
✅ RIGHT: Define templates and use them

❌ WRONG: Nested function calls in commands
✅ RIGHT: Call functions at directive level, pass results

❌ WRONG: Complex conditionals and loops
✅ RIGHT: Simple foreach over data with clear transformations

## Critical Understanding: mlld is NOT a Template Language

mlld (pronounced "meld") only executes lines that start with `@` directives. Everything else is treated as literal Markdown. Unlike template languages that process variables anywhere in text, mlld has clear boundaries between content and code.

## Core Mental Model

Think of mlld as having two distinct modes:
1. **Markdown mode** (default): Any line not starting with `@` is plain Markdown
2. **mlld mode**: Lines starting with `@` are interpreted as mlld commands

This design keeps documents readable as regular Markdown while enabling programmatic capabilities where needed.

## The 10 Commandments of mlld

### 1. Directives Must Start Lines
```mlld
❌ WRONG: Hello @name! Let me @add some text.
✅ RIGHT: 
@text greeting = [[Hello {{name}}!]]
@add @greeting
```

### 2. Variable Creation vs Reference
```mlld
@text name = "Alice"        # Create without @
@add [[Hello {{name}}!]]    # Reference with {{}} in templates
@run [echo "@name"]         # Reference with @ in commands
```

### 3. Commands Require Brackets
```mlld
❌ WRONG: @run echo "hello"
✅ RIGHT: @run [echo "hello"]
✅ RIGHT: @run js [console.log("hello")]  # Language outside brackets
✅ RIGHT: @run javascript [console.log("hello")]  # 'js' is shorthand for 'javascript'
```

### 4. Only @add and @run Produce Output
```mlld
@text secret = "hidden"     # No output
@data config = {"x": 1}     # No output
@add [[Visible text]]       # This appears!
@run [echo "Also visible"]  # This appears!
```

### 5. Context-Specific Variable Syntax
Remember: "Double brackets, double braces"
- String literals: `@text msg = "Hello @name"` - @name is NOT interpolated (literal text)
- Command context: `[echo "Hello @name"]` - @name IS interpolated (variable value)
- Template context: `[[Hello {{name}}]]` - {{name}} is interpolated

### 6. Field Access Rules
```mlld
@data user = { "name": "Alice", "scores": [10, 20, 30] }

# In directives:
@add @user.name           # "Alice"
@add @user.scores.1       # 20 (array access with dot notation)

# In templates:
@add [[{{user.name}} scored {{user.scores.0}}]]
```

### 7. Parameterized Content
```mlld
# For commands, use @exec:
@exec greet(name) = @run [(echo "Hello @name")]
@run @greet("Alice")

# For templates, use @text:
@text welcome(name, role) = [[Welcome {{name}}, our new {{role}}!]]
@add @welcome("Bob", "developer")
```

### 8. Import Patterns
```mlld
# Local files (with quotes and .mld extension):
@import { helper, config } from "./utils.mld"

# Registry modules (no quotes, @ prefix):
@import { parallel, retry } from @mlld/core
```

### 9. Conditional Logic
```mlld
# Simple conditional:
@when @isProduction => @import { * } from "./prod-config.mld"

# Multiple conditions with strategies:
# Note: Conditions must be variables or command results, not comparisons
@exec checkExcellent(score) = @run js [score > 90 ? "true" : ""]
@exec checkGood(score) = @run js [score > 70 ? "true" : ""]

@when first: [
  @checkExcellent(@score) => @add "Excellent!"
  @checkGood(@score) => @add "Good job!"
  true => @add "Keep trying!"
]

# Important: @when does NOT support comparison operators like >, <, ==
# Use boolean variables or commands that return truthy/falsy values

# Also note: @when any: requires a block action, not individual actions
# ❌ WRONG:
# @when @var any: [
#   @cond1 => @add "Action 1"
#   @cond2 => @add "Action 2"
# ]
# ✅ RIGHT:
# @when @var any: [...conditions...] => @add "Block action for any match"
```

### 10. Iteration with foreach
```mlld
@data names = ["Alice", "Bob", "Charlie"]
@text greetTemplate(name) = [[Hello, {{name}}!]]
@data greetings = foreach @greetTemplate(@names)
>> greetings = ["Hello, Alice!", "Hello, Bob!", "Hello, Charlie!"]
```

## Creating Helper Functions

When you need utility functions, create them with @exec instead of trying to work around mlld's constraints:

```mlld
# String manipulation helpers
@exec join(array, separator) = @run js [(array.join(separator))]
@exec capitalize(text) = @run js [(text.charAt(0).toUpperCase() + text.slice(1))]
@exec fileList(paths) = @run js [(paths.map(p => `${p}/**/*.md`).join(' '))]

# Using the helpers
@data names = ["alice", "bob", "charlie"]
@text formatted = @join(@names, ", ")
@add [[Team members: {{formatted}}]]

# For bash operations
@exec countFiles(dir) = @run [(find @dir -type f | wc -l)]
@data fileCount = @countFiles("./src")
```

Remember: If you're wishing mlld had a feature, you can probably create it as a helper function!

## Additional Essential Features

### Comments
```mlld
>> This is a comment (starts with two > and a space)
>> Comments must start at the beginning of a line
```

### Reserved Variables
```mlld
@add [[Current time: {{TIME}}]]        # Current timestamp
@add [[Input data: {{INPUT.config}}]]  # Access stdin/env vars
@add [[Project root: {{PROJECTPATH}}]] # Project directory
```


### Frontmatter Metadata
```mlld
---
description: Pipeline description
version: 1.0.0
author: Your Name
---

# Your mlld Document
```

### URL Support
```mlld
# Add content from URLs directly:
@add [https://raw.githubusercontent.com/example/repo/main/README.md]

# Assign URL content to variables:
@path docs = "https://example.com/api-docs.md"
@text readme = [https://example.com/README.md]
```

## Philosophy: Simplicity in Files, Complexity in Modules

mlld's design philosophy centers on keeping `.mld` files simple and readable while abstracting complexity into reusable modules. Instead of adding language features, we encourage using modules:

```mlld
# Don't try to implement complex logic in mlld
# Instead, import capabilities from modules:

@import { parallel, retry, cache, pipeline } from @mlld/core
@import { validateSchema, transform } from @myorg/data-utils

# Simple, readable mlld:
@data results = @parallel(@tasks, { concurrency: 5 })
@data validated = @validateSchema(@results, @schema)
```

## Common Pitfalls to Avoid

### 1. Treating mlld as a Template Language
```mlld
❌ This is {{name}}'s document     # Won't work - no @ directive
✅ @add [[This is {{name}}'s document]]
```

### 2. Forgetting Command Brackets
```mlld
❌ @run npm install
✅ @run [npm install]
❌ @run js console.log("hello")
✅ @run js [(console.log("hello"))]
```

### 3. Using @ When Creating Variables
```mlld
❌ @text @myvar = "value"
✅ @text myvar = "value"
```

### 4. Mixing Variable Syntaxes
```mlld
❌ @add [[Hello @name]]           # Wrong syntax in template
❌ @run [echo "{{message}}"]      # Wrong syntax in command
✅ @add [[Hello {{name}}]]        # Correct template syntax
✅ @run [echo "@message"]         # Correct command syntax

# String literal vs command context example:
@text name = "Alice"
@text literal = "Hello @name"     # Result: "Hello @name" (literal)
@run [echo "Hello @name"]         # Result: "Hello Alice" (interpolated)
```

### 5. Trying to Nest Function Calls
```mlld
❌ WRONG: Trying to call mlld functions inside commands
@exec helper(x) = @run [(echo "@x")]
@run [(
  RESULT=$(@helper("test"))  # This doesn't work!
  echo $RESULT
)]

✅ RIGHT: Call functions at directive level
@text result = @helper("test")
@run [(echo "@result")]

✅ BETTER: Use foreach for multiple operations
@data results = foreach @helper(@items)
```

### 6. String Concatenation Instead of Templates
```mlld
❌ WRONG: Trying to concatenate procedurally
# Attempting to build strings piece by piece

✅ RIGHT: Use templates
@text greeting(name, time) = [[Good {{time}}, {{name}}!]]
@add @greeting("Alice", "morning")
```

### 7. Complex Logic in mlld
```mlld
❌ WRONG: Implementing algorithms in mlld
# Don't try to write sorting algorithms or complex data manipulation

✅ RIGHT: Use helper functions or modules
@exec sortData(data) = @run js [(data.sort((a, b) => a.name.localeCompare(b.name)))]
@data sorted = @sortData(@users)
```

### 8. JavaScript Confusion
While you CAN write JavaScript in mlld, it's best kept simple:
```mlld
# Okay for simple cases:
@run js [(console.log("Debug: " + @count))]

# For complex logic - create a helper:
@exec processData(data) = @run js [(
  // Your complex logic here
  return data.map(d => ({...d, processed: true}))
)]

# Or better yet - create a module:
@import { processData } from @myorg/utils
@data result = @processData(@rawData)
```

## Orchestration Patterns

mlld shines when orchestrating external tools and data. Here are patterns that showcase its strengths:

### Pattern 1: Tool Orchestration
```mlld
# Orchestrating multiple Claude sessions for QA
@data testAreas = [
  { "name": "auth", "files": ["auth/*.ts"], "tests": ["test/auth/*"] },
  { "name": "api", "files": ["api/*.ts"], "tests": ["test/api/*"] }
]

@exec runQA(area) = @run [(
  echo "Testing {{area.name}} module"
  claude -p "Test the {{area.name}} functionality" \
    --allowedTools "Bash,Read,Write"
)]

@data results = foreach @runQA(@testAreas)
```

### Pattern 2: Data Pipeline
```mlld
# Processing data through multiple stages
@import { fetchData, validate, transform } from @data/pipeline

@data raw = @fetchData("https://api.example.com/users")
@data valid = @validate(@raw, { schema: "user" })
@data transformed = @transform(@valid, { format: "report" })

@add [[Processed {{transformed.count}} records successfully]]
```

### Pattern 3: Conditional Workflows
```mlld
# Different actions based on environment
@data env = @run [(echo $NODE_ENV)]

@exec loadConfig(env) = @run [(cat "./config/@env.json")]
@data config = @loadConfig(@env)

@when @config.debug => @add [[Debug mode enabled]]
```

## Best Practices

1. **Keep .mld files readable**: They should make sense as Markdown documents
2. **Use modules for complexity**: Don't try to implement algorithms in mlld
3. **Explicit over implicit**: Always be clear about what produces output
4. **Test incrementally**: Use `@add` to verify variable values during development
5. **Think orchestration**: mlld excels at coordinating tools and data flows
6. **Create helpers liberally**: If you need it twice, make it a helper function
7. **Embrace constraints**: Working with mlld's design leads to cleaner solutions

## Example: Well-Structured mlld File

```mlld
---
description: Data processing pipeline for user analytics
version: 1.0.0
---

# User Analytics Pipeline

This document processes user data and generates insights.

@import { fetchData, validateUsers } from @analytics/core
@import { generateReport } from @company/reporting

## Configuration

@data config = {
  "apiEndpoint": "https://api.example.com",
  "batchSize": 100,
  "outputFormat": "markdown"
}

## Data Processing

@text status(phase) = [[✓ Completed: {{phase}}]]

### 1. Fetch User Data
@data users = @fetchData(@config.apiEndpoint)
@add @status("Data fetching")

### 2. Validate and Clean
@data validUsers = @validateUsers(@users)
@add @status("Validation")

### 3. Generate Report
@data report = @generateReport(@validUsers, @config)
@add @report

## Summary

@add [[Processed {{validUsers.length}} valid users out of {{users.length}} total.]]
```

## Execution Context Reference

Understanding where different variable syntaxes work is crucial:

| Context | Syntax | Example | Notes |
|---------|--------|---------|-------|
| Templates `[[...]]` | `{{variable}}` | `[[Hello {{name}}!]]` | Double brackets, double braces |
| Commands `[...]` | `@variable` | `[echo "@message"]` | @ prefix for interpolation |
| JavaScript | Plain names | `[(array.join(sep))]` | Parameters are JS variables |
| String literals | No interpolation | `"Hello @name"` | @name is literal text |
| Directive level | `@variable` | `@add @greeting` | Direct variable reference |

### Key Rules:
- **In templates**: Always use `{{variable}}` or `{{object.field}}`
- **In commands**: Always use `@variable` or `@object.field`
- **In JavaScript**: Parameters become plain JavaScript variables
- **String assignments**: Variables are NOT interpolated (they're literals)

## Remember

mlld empowers everyone to create versionable, collaborative "pipelines of thought." It achieves this by being an orchestration language that looks and reads like a document, not by being a template system or programming language.

When writing mlld:
- Think in terms of discrete processing steps, not text interpolation
- Embrace the constraints - they lead to cleaner solutions
- Use helpers and modules for complexity
- Keep your .mld files simple and readable

The power comes from composition: simple directives in your files, powerful capabilities in your modules.