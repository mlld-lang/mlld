<MLLD_GUIDE version="2.0.0-rc43">
<TOC>
<OVERVIEW> ......................... Purpose, two execution modes, "What mlld IS/ISN'T," mental model shift.
<CORE_RULES>
  <RULE_1_SLASHES_START_LINES> ..... Only lines beginning with `/` are mlld; everything else is text.
  <RULE_2_VARIABLE_SYNTAX> ......... Create with /var @x = ‚Ä¶ ; reference with @x in templates/commands.
  <RULE_3_COMMANDS_NEED_BRACES> .... All commands use braces; language specifiers; /exe shortcuts.
  <RULE_4_OUTPUT_SOURCES> .......... Only /show, /run, /output emit output.
  <RULE_5_INTERPOLATION_CONTEXTS> .. Backticks/double-colon/triple-colon, quotes, and command contexts.
  <RULE_6_FIELD_ACCESS> ............ Dot + index access for objects/arrays; array slicing [start:end].
  <RULE_7_PARAMETERIZED_CONTENT> ... Reusable templates and functions via /exe.
  <RULE_8_FILE_LOADING> ............ Angle brackets load file contents; globs; metadata fields; safety.
  <RULE_9_IMPORTS> ................. Modules, paths, registries; "as namespace."
  <RULE_10_WHEN_OVERVIEW> .......... When forms (bare, first, simple) ‚Äì full detail in CONTROL_FLOW.
  <RULE_11_ITERATION_OVERVIEW> ..... foreach and /for ‚Äì full detail in CONTROL_FLOW.
  <RULE_12_OPERATORS> .............. Logical, comparison, ternary operators for expressions.
</CORE_RULES>
<SYNTAX>
  <VARIABLES> ...................... Types, primitives, command results, code execution.
  <TEMPLATES> ...................... Backticks, ::‚Ä¶::, :::‚Ä¶:::; interpolation rules.
  <FILE_LOADING> ................... Angle brackets, metadata fields, globs, "as" templates, detection rules.
  <BUILTIN_METHODS> ................ Array and string methods: includes, indexOf, join, split, etc.
  <PIPELINES> ...................... Operator |, transformers, @ctx/@p context, retry/hints, inline effects, parallel groups with ||.
  <COMMENTS> ....................... ">>" and "<<" comments (start/end-of-line).
  <RESERVED_VARIABLES> ............. @now, @input, @base, @debug.
</SYNTAX>
<COMMANDS>
  <RUN_VS_RUN_SH> .................. Decision tree, security & syntax differences, param passing.
  <EXE_EXECUTABLES> ................ Defining shell/js/node/template/section executables; shadow env intro.
  <OUTPUT_DIRECTIVE> ............... Write to files/stdout/stderr with optional formats.
  <LOG_DIRECTIVE> .................. Syntactic sugar for /output to stdout; works in action contexts.
</COMMANDS>
<CONTROL_FLOW>
  <WHEN_DECISIONS> ................. Bare/first/simple forms, /exe...when patterns, wildcard (*), none keyword.
  <ITERATION> ...................... foreach vs /for; nested loops; objects with _key; collection form.
  <NO_EARLY_EXIT> .................. Design flows instead of exits; patterns.
</CONTROL_FLOW>
<MODULES> .......................... Module-first philosophy; imports; helpers; shadow environments; isolation.
<PATTERNS> ......................... Tool orchestration; data pipelines; conditional workflows; guarded/step-by-step.
<CONFIGURATION>
  <ENVIRONMENT_VARIABLES> .......... Allow-list, @input import.
  <FRONTMATTER> .................... Document metadata block.
  <PATHS_AND_URLS> ................. Quoted/unquoted paths, dynamic paths, URL loading.
  <RESOLVERS> ...................... Prefixes, LOCAL/HTTP/GITHUB/REGISTRY; quick CLI setup.
  <PUBLISHING_PRIVATE_MODULES> ..... Auth, repo layout, commands.
</CONFIGURATION>
<COMMON_MISTAKES>
  <MISTAKE_MISSING_AT> ............. Create variables with @; directives use /.
  <MISTAKE_USING_AT_FOR> ........... @run is invalid; use /run on LHS and run / implicit RHS.
  <MISTAKE_INTERPOLATION> .......... Interpolation only in directive/template contexts.
  <MISTAKE_NOT_TEMPLATE_LANG> ...... mlld ‚â† template engine; use /show or /exe.
  <MISTAKE_FILE_VS_STRING> ......... Angle brackets load content; quotes hold literal filenames.
  <MISTAKE_XML_VS_FILE_TAGS> ....... <thinking> is plain text; <file.txt> is a file ref (has ./*/@).
  <MISTAKE_NESTED_FUNC_CALLS> ...... Don't shell-call @func inside commands; assign then use.
  <MISTAKE_STRING_CONCAT> .......... Prefer templates over procedural concatenation.
  <MISTAKE_COMPLEX_LOGIC> .......... Move algorithms into helpers/modules.
  <MISTAKE_IMPORT_BRACKETS> ........ Know when to use angle brackets for path resolvers.
  <MISTAKE_NO_EARLY_EXIT> .......... Model flows via /when rather than exits.
</COMMON_MISTAKES>
<REFERENCE> ........................ Execution context table, syntax summary, quick transforms list.
<SEE_ALSO> ......................... Documentation, examples repository, source code.
</TOC>

<OVERVIEW>
mlld is a modular prompt scripting language for dynamically assembling context and orchestrating LLMs‚Äîthink Make + npm for the LLM era, or a Unix pipe for chaining discrete AI/tool steps. It's designed to be written directly in Markdown: readable as docs, executable as workflows.

Two modes:

1. Markdown mode (default): any line not starting with `/`
2. mlld mode: lines starting with `/` (directives)

What mlld IS:

* üìã A workflow orchestrator (like Make + npm for the AI era)
* üé≠ A conductor's baton (you conduct, tools play)
* üìù Executable documentation (reads like a guide, runs like a script)
* üö¶ A logical router (route data and actions based on conditions)

What mlld ISN'T:

* ‚ùå A template engine (not Jinja/Handlebars)
* ‚ùå A shell script replacement (it orchestrates shells; doesn't replace them)

Mental model shift:

* ‚ùå "How do I implement this?" ‚Üí ‚úÖ "What tool/module handles this?"
* ‚ùå "I need an if-statement" ‚Üí ‚úÖ "I need a decision point"
* ‚ùå "Let me concatenate strings" ‚Üí ‚úÖ "Let me create a template"

Think Docker Compose or GitHub Actions: declare what happens, don't program how. </OVERVIEW>

<CORE_RULES>
<RULE_1_DIRECTIVES_START_LINES>
Only directives on lines beginning with `/` are executed.

```mlld
‚ùå Hello @name! Let me /show something.
‚úÖ
/var @greeting = `Hello @name!`
/show @greeting
```

</RULE_1_DIRECTIVES_START_LINES>

<RULE_2_VARIABLE_SYNTAX>
Create with `/var @name = "Alice"`. Reference with `@name` in templates/commands.

```mlld
/var @name = "Alice"
/show `Hello @name!`
/run {echo "User: @name"}
/run js (@name) { console.log("Hi", name) }
```

</RULE_2_VARIABLE_SYNTAX>

<RULE_3_COMMANDS_NEED_BRACES>
Every command needs braces. Use language specifiers when needed. Define executables with `/exe`.

```mlld
‚ùå /run echo "hello"
‚úÖ /run {echo "hello"}

# Language specifiers.
/run js {console.log("hi")}
# Executables
/exe @hi() = run {echo hi}
/exe @block() = run sh {
  echo "multi"; ls -la
}
/exe @calc(x) = js { return @x * 2 }
```

</RULE_3_COMMANDS_NEED_BRACES>

<RULE_4_OUTPUT_SOURCES>
Only these produce output: `/show`, `/run`, `/output`. Everything else mutates state.

```mlld
/var @secret = "hidden"      # no output
/show `Visible`
/run {echo "Also visible"}
```

</RULE_4_OUTPUT_SOURCES>

<RULE_5_INTERPOLATION_CONTEXTS>
Prefer backticks for templates; use `::‚Ä¶::` to escape backticks; use `:::‚Ä¶:::` when many `@` appear (e.g., social).

* Backticks interpolate `@var`
* Double quotes interpolate `@var`
* Single quotes are literal (no interpolation)
* Braced commands `{‚Ä¶}` interpolate `@var`

```mlld
/var @msg = `Hello @user!`
/var @note = ::Run `npm test` before deploy::
/var @tweet = :::Hey @{{handle}}‚Äîship it!:::
```

</RULE_5_INTERPOLATION_CONTEXTS>

<RULE_6_FIELD_ACCESS>
Objects/arrays use dot+index in directives and `{{ }}` in ::: templates only. Arrays support slicing with `[start:end]` and builtin methods.

```mlld
/var @user = {"name":"Alice","scores":[10,20,30]}
# Directives:
/show @user.name            # Alice
/show @user.scores.1        # 20

# Array slicing:
/var @arr = [1,2,3,4,5]
/show @arr[0:3]             # [1,2,3]
/show @arr[-2:]             # [4,5] - last 2
/show @arr[:-1]             # [1,2,3,4] - all except last
/show @arr[2:]              # [3,4,5] - from index 2

# Builtin methods on arrays/strings:
/var @list = ["apple", "banana", "cherry"]
/var @text = "Hello World"
/show @list.includes("banana")      # true
/show @list.indexOf("cherry")       # 2
/show @list.join(", ")              # "apple, banana, cherry"
/show @text.toLowerCase()           # "hello world"
/show @text.split(" ")              # ["Hello", "World"]
/show @text.includes("World")       # true

# Double-colon templates:
/show ::@user.name has @user.scores.0::
```

</RULE_6_FIELD_ACCESS>

<RULE_7_PARAMETERIZED_CONTENT>
Use `/exe` for parameterized templates or commands.

```mlld
/exe @greet(name) = run {echo "Hello @name"}
/run @greet("Bob")

/exe @welcome(name, role) = ::Welcome @name, our new @role!::
/show @welcome("Rae","developer")
```

</RULE_7_PARAMETERIZED_CONTENT>

<RULE_8_FILE_LOADING>
Angle brackets load file contents (not filenames). Works in variables, templates, commands, and with globs. Only `<‚Ä¶>` containing `.`, `/`, `*`, or `@` are treated as file references‚Äîso pseudo-XML tags like `<OVERVIEW>` are safe, plain text.

```mlld
/var @content = <README.md>                 # file contents
/show <config.json>                         # prints file contents
/var @filesTxt = ["a.md","b.md"]            # literal names
/var @contents = [<a.md>, <b.md>]           # loaded contents

# Field access on loaded JSON
/var @authorEmail = <package.json>.author.email

# Globs + "as" templates
/var @toc = <docs/*.md> as "- [<>.fm.title](<>.relative)"
```

Inline transforms (pipes):

```mlld
/var @pretty = <data.json> | @json
/var @summary = `User data: @data|@json`
```

Security: By default, restricts to project root. Use `--allow-absolute` flag to permit absolute paths outside project.

</RULE_8_FILE_LOADING>

<RULE_9_IMPORTS>
Module imports and path imports.

```mlld
# Modules (no quotes)
/import { parallel, retry } from @mlld/core
/import @corp/utils as corp

# Paths (quote & resolver via <> when needed)
/import { readme } from "@base/README.md"
/import { helper } from "./utils.mld"
```

</RULE_9_IMPORTS>

<RULE_10_WHEN_OVERVIEW>
/when drives decisions (bare, first, simple). Full details in <CONTROL_FLOW>.

```mlld
/when @isProd => show "Prod"
/when first [
  @role=="admin" => show "Admin"
  * => show "Guest"
]
```

</RULE_10_WHEN_OVERVIEW>

<RULE_11_ITERATION_OVERVIEW>
Use `foreach` to transform collections; use `/for` to execute/collect. Full details in <CONTROL_FLOW>.

```mlld
/var @names = ["Alice","Bob"]
/exe @greet(name) = ::Hi @name!::
/var @gs = foreach @greet(@names)
/for @n in @names => show `Name: @n`

# Optional parallel forms
/for parallel @n in @names => show @n              # uses MLLD_PARALLEL_LIMIT (default 4)
/var @caps = for 2 parallel @n in @names => @greet(@n)  # per-loop cap override
/for (3, 1s) parallel @n in @names => show @n      # cap 3 with 1s pacing between starts
```

</RULE_11_ITERATION_OVERVIEW>

<RULE_12_OPERATORS>
Logical, comparison, and ternary operators for expressions and conditions.

Comparison: `<`, `>`, `<=`, `>=`, `==`, `!=`
Logical: `&&`, `||`, `!`
Ternary: `condition ? trueVal : falseVal`

```mlld
# Expressions
/var @isValid = @score > 80 && @submitted
/var @status = @isPro ? "premium" : "basic"
/var @canEdit = @isOwner || (@role == "editor" && !@isLocked)
/var @opposite = !@condition

# Parentheses for precedence
/var @complex = (@a || @b) && (@c != @d)

# In /when conditions
/when @tokens > 1000 && @mode == "production" => show "High usage"
/when (@role == "admin" || @role == "mod") && @active => show "Privileged"
```

Type coercion: `"true" == true`, `"false" == false`, `null == undefined`
Precedence: `!` ‚Üí comparison ‚Üí `&&` ‚Üí `||` ‚Üí `?:`
</RULE_12_OPERATORS>
</CORE_RULES>

<SYNTAX>
<VARIABLES>
Create primitives, arrays, objects, or assign from command/code results. Primitives preserve JS types in `/exe js`.

```mlld
/var @n = 42
/var @price = 19.99
/var @ok = true
/var @arr = [1,2,3]
/var @obj = {"key":"value"}

/exe @add(a,b) = js { return a + b }
/var @sum = @add(@n, 8)         # 50 (number)

/var @date = run "date"         # result of command
/var @readme = <README.md>      # file contents
```

</VARIABLES>

<TEMPLATES>
Prefer backticks; use :: for backticks-in-text; ::: when many @mentions.

```mlld
/var @message = `Hello @name, welcome!`
/var @doc = ::Use `mlld` to orchestrate::
/var @tweet = :::Hey @{{handle}}‚Äî{{msg}}:::

When-expressions are first-class:

```mlld
# Direct assignment
/var @status = when [ @score > 90 => "A" * => "F" ]

# In array literals
/var @arr = [ 1, when [ @flag => 2 ], 3 ]

# As function arguments
/exe @fmt(x) = `val:@x`
/show @fmt(when [ @cond => "yes" * => "no" ])
```
```

Inline template control:

- `/for ‚Ä¶ /end` is available in backticks and `::‚Ä¶::` templates.
- `:::‚Ä¶:::` templates do not support loops; they support `{{var}}` interpolation and inline `/show` only.

Examples:

```mlld
# Backtick wrapper
/var @tpl = `
/for @x in ["A","B"]
- @x
/end
`
/show @tpl

# Double-colon wrapper
/var @items = ["A","B"]
/var @msg = ::
/for @x in @items
- @x
/end
::
/show @msg
```

Notes:
- Line-start only: `/for` and `/end` must begin at a line start inside the template body.
- No loops in `[[...]]` or `:::...:::` templates.

</TEMPLATES>

<FILE_LOADING>
Angle brackets load, quotes store literal paths. Field access and globs are supported.

```mlld
/var @author = <package.json>.author
/var @firstEmail = <data.json>.users[0].email
/var @md = <docs/*.md> as "# <>.filename"
```

AST selection: add `{ ... }` inside the angle brackets to pull specific definitions or usages.

```mlld
/var @handlers = <src/service.ts { handleRequest, (logger.warn) }>
/var @templated = <src/**/*.py { fetch_user }> as "## <>.name\n<>.code"
```

- Bare identifiers return matching definitions; parentheses return definitions that reference the name.
- Supported extensions: `.js`, `.ts`, `.jsx`, `.tsx`, `.mjs`, `.py`, `.pyi`, `.rb`, `.go`, `.rs`, `.sol`, `.java`, `.cs`, `.c`, `.cpp`, `.h`, `.hpp`.
- Glob matches add a `file` property so you can trace the source path.
- Patterns that miss return `null`, preserving the request order.

Detection rule: only `<‚Ä¶>` with `.`, `/`, `*`, or `@` are treated as file refs. XML-like `<TAG>` is plain text.

File metadata fields: `content` (default), `filename`, `relative`, `absolute`, `tokens`, `tokest`, `fm` (frontmatter), `json` (for .json files)

URL metadata fields: All file fields plus: `url`, `domain`, `title`, `description`, `html`, `text`, `md`, `headers`, `status`, `contentType`
</FILE_LOADING>

<BUILTIN_METHODS>
Variables support builtin methods for common operations. Methods are called with parentheses and can accept arguments.

**Array Methods:**
- `@array.includes(value)` - Returns true if array contains value
- `@array.indexOf(value)` - Returns index of value, or -1 if not found
- `@array.length()` - Returns array length
- `@array.join(separator)` - Joins array elements into string

**String Methods:**
- `@string.includes(substring)` - Returns true if string contains substring
- `@string.indexOf(substring)` - Returns index of substring, or -1
- `@string.length()` - Returns string length
- `@string.toLowerCase()` - Converts to lowercase
- `@string.toUpperCase()` - Converts to uppercase
- `@string.trim()` - Removes leading/trailing whitespace
- `@string.startsWith(prefix)` - Returns true if starts with prefix
- `@string.endsWith(suffix)` - Returns true if ends with suffix
- `@string.split(separator)` - Splits into array

```mlld
/var @fruits = ["apple", "banana", "cherry"]
/var @message = "Hello World"

# Array operations
/show @fruits.includes("banana")    # true
/show @fruits.indexOf("cherry")     # 2
/show @fruits.join(" and ")         # "apple and banana and cherry"

# String operations
/show @message.toLowerCase()        # "hello world"
/show @message.split(" ")          # ["Hello", "World"]
/show @message.includes("World")    # true

# With variable arguments
/var @search = "banana"
/show @fruits.includes(@search)     # true
```

Note: Methods are parsed as field access exec patterns (`@obj.method(args)`) and executed as ExecInvocations internally.
</BUILTIN_METHODS>

<PIPELINES>
Chain stages with `|`. Built-ins: @json, @xml, @csv, @md (upper/lower accepted). Stages access context via `@ctx` and pipeline history via `@p`.

```mlld
/var @users = run {cat users.json} | @json | @csv
/exe @double(n) = js {(@n*2)}
/var @x = run {echo "5"} | @double

# Retry with hints
/exe @validator(input) = when [
  @input.valid => @input
  @ctx.try < 3 => retry "need more detail"
  * => "fallback"
]
/var @res = @raw | @validator

# Best-of-N pattern
/exe @selectBest(response) = when [
  @response.score > 8 => @response
  @ctx.try < 5 => retry { temperature: 0.9 }
  * => @selectHighestScore(@p.retries.all)
]
```

Context object (@ctx): `try` (attempt #), `tries` (array), `stage`, `input`, `hint` (from retry), `lastOutput`, `isPipeline`

Pipeline array (@p): `@p[0]` (input), `@p[-1]` (previous output), `@p.retries.all` (full history)

Inline effects: `@data | @transform | log` (stderr), `@data | output to "file.txt"` (inline write)

Formats (`with { format: "json|csv|xml|text" }`): guide parsing for pipeline stages.

Parallel groups (`||`): run multiple commands as one stage in parallel.

```mlld
# Two transforms run concurrently; outputs are collected in order
/exe @left(input) = `L:@input`
/exe @right(input) = `R:@input`
/exe @combine(input) = js {
  const arr = JSON.parse(input); // parallel stage returns a JSON array string
  return arr.join(' + ');
}

/var @out = "x" with { pipeline: [ @left || @right, @combine ] }
/show @out   # ‚Üí "L:x + R:x"
```

Semantics:
* Grouping: `A || B || C` forms a single stage executed concurrently with a global cap.
* Ordering: Results preserve command order; next stage receives a JSON array string.
* Concurrency: Limited by `MLLD_PARALLEL_LIMIT` (default `4`).
* Retries: Returning `retry` inside a parallel group is not supported and aborts the pipeline. If you need retries, run validation after the group and request a retry of the previous (non-parallel) stage.
* Rate limits: 429/‚Äúrate limit‚Äù errors trigger per-command exponential backoff.
* Inline effects: Effects attached to commands in the group run after each command succeeds.

</PIPELINES>

<COMMENTS>
Use `>>` or `<<` for comments at start or end of lines.

```mlld
>> start-of-line
/show "Hello"  >> end-of-line
/var @x = 5    << end-of-line
```

</COMMENTS>

<RESERVED_VARIABLES>

* `@now` ‚Äì current timestamp
* `@input` ‚Äì stdin/env (must be allowed)
* `@base` ‚Äì project root
* `@debug` ‚Äì environment info
  </RESERVED_VARIABLES>

  </SYNTAX>

<COMMANDS>
<RUN_VS_RUN_SH>
Decision tree:

* Single line + pipes only (`|`) ‚Üí `run { ‚Ä¶ }`
* Needs `&&`, `||`, control flow, or multi-line ‚Üí `run sh { ‚Ä¶ }`
* JavaScript (no shell) ‚Üí `js { ‚Ä¶ }` (or `/exe ‚Ä¶ = js { ‚Ä¶ }`)

Parameter syntax:

* `run` / commands: interpolate with `@param`
* `run sh`: shell variables as `$param`

```mlld
# run (pipes only)
/run {echo Hello | tr '[:lower:]' '[:upper:]'}

# run sh (multi-line/conditionals)
/run sh {
  npm test && npm run build || echo "Build failed"
}

# Executable wrappers
/exe @safeDeploy(env) = run sh {
  npm test && npm run deploy:$env
}
```

Security: `run` forbids `&&`/`||` to reduce injection risk; escalate to `run sh` when necessary.

Large variables: For bash/sh executables, variables >128KB are automatically handled via heredocs (when `MLLD_BASH_HEREDOC=1`). For `/run` commands exceeding limits, use `/exe` with bash/sh instead.
</RUN_VS_RUN_SH>

<EXE_EXECUTABLES>
Define reusable commands/code/templates/sections.

```mlld
# Shell (single vs multi)
/exe @list(dir) = run {ls -la @dir | head -5}
/exe @script() = run sh {
  echo "Start"; ls -la
}

# JavaScript
/exe @add(a,b) = js { return a + b }

# Templates
/exe @greet(name) = `Hello @name!`

# Section extractor
/exe @intro(file) = <@file # Introduction>
```

Shadow environments (JS/Node):
Expose JS helpers across `js {}` blocks in the same module:

```mlld
/exe @double(n) = js { return n*2 }
/exe @cap(s) = js { return s[0].toUpperCase()+s.slice(1) }
/exe js = { double, cap }  # expose

/var @out = js { cap("hello") + ": " + double(5) }  # "Hello: 10"
```

</EXE_EXECUTABLES>

<OUTPUT_DIRECTIVE>
Write data to files or streams, with optional format.

```mlld
/output @content to "out.txt"
/output @data to "config.json"
/output @html to "page.html" as html
/output @message to stdout
/output @error to stderr
/output @config to "settings.yaml" as yaml
```

</OUTPUT_DIRECTIVE>

<LOG_DIRECTIVE>
Syntactic sugar for `/output to stdout`. Works in action contexts.

```mlld
/log @message                        # same as /output @message to stdout
/log `Processing: @item`

# In action contexts
/for @item in @items => log @item
/when @debug => log "Debug info"
/when [
  @valid => log "Success"
  none => log "Failed validation"
]
```

</LOG_DIRECTIVE> </COMMANDS>

<CONTROL_FLOW>
<WHEN_DECISIONS>
Forms:

* Simple: `/when @cond => action`
* Bare (evaluate all matches):

  ```mlld
  /when [
    @score > 90 => show "Excellent!"
    @isBonus => show "Bonus!"
    none => show "No matches"
  ]
  ```
* Switch (`first` stops at first match):

  ```mlld
  /when first [
    @role=="admin" => show "Admin"
    @role=="user"  => show "User"
    * => show "Guest"
  ]
  ```

`/exe...when` patterns (value-returning):

```mlld
# Basic handler with fallback
/exe @handler(input) = when [
  @input.valid => @input.value
  @ctx.try < 3 => retry "validation failed"
  none => "default"
]

# Switch-style with first
/exe @parser(type, data) = when first [
  @type == "json" => @parseJSON(@data)
  @type == "xml" => @parseXML(@data)
  @type == "csv" => @parseCSV(@data)
  * => @data
]

# Conditional transformer
/exe @process(item) = when [
  @item.priority > 5 => @urgent(@item)
  @item.archived => null
  * => @standard(@item)
]
```

Notes:

* RHS uses action words (no `/show` slash): `show`, `@func()`, `@var = "x"`
* `*` wildcard matches anything (catch-all)
* `none` executes only if no conditions matched (must appear after all regular conditions, incompatible with `*`)
* One action per line (repeat condition for multiple actions)
* Parentheses & `&&`/`||` supported in conditions
  </WHEN_DECISIONS>

<ITERATION>
`foreach` returns a transformed array; `/for` executes an action per item or collects results.

```mlld
# foreach (transform)
/var @names = ["alice","bob","charlie"]
/exe @greet(name) = ::Hi @name!::
/var @greetings = foreach @greet(@names)

# /for (execute)
/for @n in @names => show `Name: @n`

# collection form
/var @nums = [1,2,3]
/var @doubled = for @x in @nums => js { return @x * 2 }  # [2,4,6]

# objects and keys
/var @cfg = {"host":"localhost","port":3000}
/for @v in @cfg => show `@v_key: @v`

# nested for loops
/for @x in ["A","B"] => for @y in [1,2] => show `@x-@y`
# Output: A-1, A-2, B-1, B-2

# triple nesting
/for @x in @outer => for @y in @middle => for @z in @inner => show `@x/@y/@z`
```

When-expressions in for RHS:

```mlld
/var @xs = [1, null, 2, null, 3]
# Keep only non-null values
/var @filtered = for @x in @xs => when [
  @x != null => @x
  none => skip
]
# @filtered => ["1","2","3"]
```

Define foreach in /exe RHS and invoke:

```mlld
/exe @wrap(x) = `[@x]`
/exe @wrapAll(items) = foreach @wrap(@items)
/show @wrapAll(["a","b"]) | @join(',')
# => [a],[b]
```

Use /show foreach with options:

```mlld
/var @names = ["Ann","Ben"]
/exe @greet(n) = `Hello @n`
/show foreach @greet(@names) with { separator: " | ", template: "{{index}}={{result}}" }
# => 0=Hello Ann | 1=Hello Ben
```

Empty arrays are safe: `/for` emits nothing; `for ‚Ä¶ =>` returns `[]`. </ITERATION>

Parallel /for (optional):

```mlld
# Default cap from env (MLLD_PARALLEL_LIMIT, default 4)
/for parallel @x in @items => show @x

# Cap override and pacing between starts (units: s, m, h, d, w)
/for (2, 1s) parallel @x in @items => show @x

# Collection form preserves input order
/var @out = for 3 parallel @x in ["a","b","c"] => @upper(@x)
```

Notes:
- Directive form streams results as iterations finish (order not guaranteed); expression form returns results in input order.
- Concurrency capped by `MLLD_PARALLEL_LIMIT` unless overridden per loop.
- Pacing: optional minimum delay between iteration starts via `/for (n, interval) parallel ...` (units: ms, s, m, h).
- Rate limits: per‚Äëiteration 429/"rate limit" errors use exponential backoff.

<NO_EARLY_EXIT>
mlld has no `return/exit`. Model outcomes with `/when` and flags.

```mlld
/var @check = @validate(@input)
/when [
  @check.valid => @process(@input)
  !@check.valid => show `Error: @check.message`
]
```

</NO_EARLY_EXIT>
</CONTROL_FLOW>

<MODULES>
Module-first philosophy: keep `.mld` files readable; move complexity into focused modules that expose capabilities (like microservices). Avoid "kitchen sink" modules or side effects on import.

* Use `/import` to compose capabilities
* Create helpers via `/exe`, expose with shadow envs (per language, per module)
* JS and Node have separate shadow environments; no cross-pollution
* Prefer clear namespaces: `/import @corp/utils as utils`
* Declare module APIs explicitly: `/export { publicFn, helper }`; auto-export sticks around only as a compatibility fallback for modules that have not been updated yet

```mlld
---
module: @myorg/github-utils
description: GitHub operations
---

/export { getPR, listIssues, createRelease }
/exe @getPR(number, repo) = run {gh pr view ...}
/exe @listIssues(repo) = run {gh issue list ...}
/exe @createRelease(tag, notes) = run {gh release create ...}
/exe js = {}  # expose JS helpers if any
```

</MODULES>

<PATTERNS>
Tool orchestration:

```mlld
/var @areas = [
  {"name":"auth","files":["auth/*.ts"],"tests":["test/auth/*"]},
  {"name":"api","files":["api/*.ts"],"tests":["test/api/*"]}
]
/exe @runQA(area) = run {echo "Testing @area.name" | cat}
/var @results = foreach @runQA(@areas)
```

Data pipeline:

```mlld
/import { fetchData, validate, transform } from @data/pipeline
/var @raw = @fetchData("https://api.example.com/users")
/var @valid = @validate(@raw, { schema: "user" })
/var @report = @transform(@valid, { format: "report" })
/show `Processed @report.count users`
```

Conditional workflows:

```mlld
/import { getPR, commentOnPR } from @company/github
/var @pr = @getPR(@MLLD_PR_NUMBER)
/when first [
  @pr.mergeable => @status = "ready"
  * => @status = "blocked"
]
/when [
  @status=="ready"   => @commentOnPR(@MLLD_PR_NUMBER,"Ready to merge")
  @status=="blocked" => show "Needs attention"
]
```

Step-by-step & guarded execution:

```mlld
/var @processed = @data | @validate | @normalize | @analyze
/when [
  @processed.ok => @emitReport(@processed)
  !@processed.ok => show "‚ùå Validation failed"
]
```

</PATTERNS>

<CONFIGURATION>
<ENVIRONMENT_VARIABLES>
Allow environment variables in `mlld.lock.json` (prefix `MLLD_`), then import via `@input`.

```json
{
  "security": {
    "allowedEnv": ["MLLD_NODE_ENV","MLLD_API_KEY","MLLD_GITHUB_TOKEN"]
  }
}
```

```mlld
/import { MLLD_NODE_ENV, MLLD_API_KEY } from @input
/show `Running in @MLLD_NODE_ENV`
```

</ENVIRONMENT_VARIABLES>

<FRONTMATTER>
Use frontmatter to describe the pipeline:

```yaml
---
description: Pipeline description
version: 1.0.0
author: Your Name
---
```

</FRONTMATTER>

<PATHS_AND_URLS>
Paths may be literal (single quotes), interpolated (double), or bare resolver names; URLs are supported as sources.

```mlld
/var @dir = "./docs"
/var @userFile = "data/@username/profile.json"
/var @template = 'templates/@var.html'  # literal '@'

/show <https://raw.githubusercontent.com/org/repo/main/README.md>
/var @remote = <https://example.com/README.md>
```

</PATHS_AND_URLS>

<RESOLVERS>
Configure prefixes that map to resolvers (LOCAL/HTTP/GITHUB/REGISTRY). Add via CLI or `mlld.lock.json`.

CLI quick setup:

```bash
mlld setup
mlld setup --github
mlld alias --name shared --path ../shared-modules
mlld alias --name desktop --path ~/Desktop --global
```

Manual config:

```json
{
  "version": "1.0",
  "config": {
    "resolvers": {
      "prefixes": [
        {"prefix":"@lib/","resolver":"LOCAL","config":{"basePath":"./src/lib"}},
        {"prefix":"@shared/","resolver":"LOCAL","config":{"basePath":"../shared-modules"}}
      ]
    }
  },
  "modules": {}
}
```

GitHub (private):

```json
{
  "version": "1.0",
  "config": {
    "resolvers": {
      "prefixes": [
        {
          "prefix":"@myorg/",
          "resolver":"GITHUB",
          "config":{"repository":"myorg/private-mlld-modules","branch":"main","basePath":"modules"}
        }
      ]
    }
  }
}
```

</RESOLVERS>

<PUBLISHING_PRIVATE_MODULES>
Authenticate and publish to your private repo.

```bash
mlld auth login
mlld auth status
mlld publish my-module.mld.md --private --path lib/modules --pr
```

</PUBLISHING_PRIVATE_MODULES> </CONFIGURATION>

<COMMON_MISTAKES>
<MISTAKE_MISSING_AT>

```mlld
‚ùå /var greeting = "Hello"
‚úÖ /var @greeting = "Hello"
```

</MISTAKE_MISSING_AT>

<MISTAKE_USING_AT>

```mlld
‚ùå /var @result = @run {echo "hello"}
‚úÖ /var @result = run {echo "hello"}
```

</MISTAKE_USING_AT>

<MISTAKE_INTERPOLATION>

```mlld
‚ùå Hello @name!             # plain Markdown, no interp
‚úÖ /show "Hello @name!"
```

</MISTAKE_INTERPOLATION>

<MISTAKE_NOT_TEMPLATE_LANG>

```mlld
‚ùå This is {{name}}'s doc
‚úÖ /show ::This is @name's doc::
```

</MISTAKE_NOT_TEMPLATE_LANG>

<MISTAKE_FILE_VS_STRING>

```mlld
/var @content = <README.md>     # loads contents
/var @path = "README.md"        # literal string
```

</MISTAKE_FILE_VS_STRING>

<MISTAKE_XML_VS_FILE_TAGS>
`<thinking>` is plain text; `<file.txt>` (has `.`) is a file ref.
</MISTAKE_XML_VS_FILE_TAGS>

<MISTAKE_NESTED_FUNC_CALLS>

```mlld
‚ùå # inside shell trying to call @func
/run {
  RESULT=$(@helper("x"))   # won't work
  echo $RESULT
}

‚úÖ /var @r = @helper("x")
/run @r | { cat }
```

</MISTAKE_NESTED_FUNC_CALLS>

<MISTAKE_STRING_CONCAT>
Prefer templates over manual concatenation.
</MISTAKE_STRING_CONCAT>

<MISTAKE_COMPLEX_LOGIC>
Move heavy logic to `/exe` helpers or modules; keep `.mld` orchestration simple.
</MISTAKE_COMPLEX_LOGIC>

<MISTAKE_IMPORT_BRACKETS>
Know when to use angle brackets for resolver paths; modules don‚Äôt use them.
</MISTAKE_IMPORT_BRACKETS>

<MISTAKE_NO_EARLY_EXIT>
Model alternative outcomes with `/when` and flags rather than aborting.
</MISTAKE_NO_EARLY_EXIT>
</COMMON_MISTAKES>

<REFERENCE>
Execution Context ‚Äì where interpolation applies:

| Context                | Syntax    | Example                  | Notes              |
| ---------------------- | --------- | ------------------------ | ------------------ |
| Backticks              | `@var`    | `` `Hello @name` ``      | Primary template   |
| Double-colon `::‚Ä¶::`   | `@var`    | `::Use \`cmd\` @name::\` | Escape backticks   |
| Triple-colon `:::‚Ä¶:::` | `{{var}}` | `:::Hi @{{handle}}:::`   | Escape lots of `@` |
| Commands `{‚Ä¶}`         | `@var`    | `{echo "@msg"}`          | Interpolates       |
| Double quotes          | `@var`    | `"Hi @name"`             | Interpolates       |
| Single quotes          | '@var'    | `'Hi @name'`             | Literal            |
| Directive level        | `@var`    | `/show @greeting`        | Direct reference   |

Transforms (built-in): `@json`, `@xml`, `@csv`, `@md`
Aliases: `@p` ‚â° `@pipeline` inside pipeline stages
Globs: use `<path/*.ext>` and `as "template"` with `<>` placeholder for each matched file 
</REFERENCE>

<SEE_ALSO>
Documentation: https://mlld.ai/docs

Examples: https://github.com/mlld-lang/mlld/tree/main/tests/cases/valid/feat (comprehensive test cases demonstrating features)

Source: https://github.com/mlld-lang/mlld
</SEE_ALSO>
</MLLD_GUIDE>
