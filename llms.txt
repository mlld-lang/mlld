>> mlld syntax reference

mlld is a modular prompt scripting language for dynamically assemble context and orchestrating LLMs. Think of it as Make + npm for the LLM era or a unix pipe for chaining discrete LLM tasks. mlld is made to be written directly in markdown files. It has its own public/private/local module system and can treat markdown sections as modules.

## What mlld IS and ISN'T

### mlld IS:
- üìã A workflow orchestrator (like Make + npm for the AI era)
- üé≠ A conductor's baton (you conduct, tools play)
- üìù Executable documentation (reads like a guide, runs like a script)

### mlld ISN'T:
- ‚ùå A programming language (no loops, no recursion, no algorithms)
- ‚ùå A template engine (it's not Jinja or Handlebars)
- ‚ùå A shell script replacement (it orchestrates shells, doesn't replace them)

If you find yourself wanting programming features, you're thinking about the problem wrong. Step back and ask: "What tool or module could handle this complexity for me?"

### Mental Model Shift

Coming from programming? Think like a conductor, not a coder:
- ‚ùå "How do I implement this?" ‚Üí ‚úÖ "What tool handles this best?"
- ‚ùå "I need an if-statement" ‚Üí ‚úÖ "I need a decision point"
- ‚ùå "Let me concatenate strings" ‚Üí ‚úÖ "Let me create a template"

Think of mlld like Docker Compose or GitHub Actions - you're declaring what should happen, not programming how it happens.

## Core Mental Model

Think of mlld as having two distinct modes:
1. **Markdown mode** (default): Any line not starting with `/` is plain Markdown
2. **mlld mode**: Lines starting with `/` are interpreted as mlld commands

This design keeps documents readable as regular Markdown while enabling programmatic capabilities where needed.

## The 11 Commandments of mlld

### 1. Directives Must Start Lines
```mlld
‚ùå WRONG: Hello @name! Let me /show some text.
‚úÖ RIGHT: 
/var @greeting = `Hello @name!`
/show @greeting
```

### 2. Variable Creation vs Reference
```mlld
/var @name = "Alice"                            << Create with @name
/show `Hello @name!`                << Reference with @ in templates
/run {echo "@name"}                  << Reference with @ in commands
/run js (@name) {console.log("Hi", name)}  << Pass vars to native JS
```

### 3. Commands Require Braces or Quotes
```mlld
‚ùå WRONG: /run echo "hello"
‚ùå WRONG: /run [echo "hello"]
‚úÖ RIGHT: /run {echo "hello"}
‚úÖ RIGHT: /run "echo hello"

>> CRITICAL: 'run' vs 'sh' for shell commands
‚úÖ /run "echo hello"            << Single-line, pipes only (|)
‚úÖ /run {echo "hello" | cat}    << Single-line with pipe
‚ùå /run {cmd1 && cmd2}          << WRONG - && not allowed with 'run'
‚úÖ /sh {cmd1 && cmd2}           << RIGHT - use 'sh' for && or ||
‚úÖ /sh {                        << Use 'sh' for multi-line scripts
  if [ -f "file.txt" ]; then
    cat file.txt
  fi
}

>> Language specifiers
‚úÖ /run js {console.log("hi")}  << JavaScript execution
‚úÖ /exe @fn = run "echo hi"     << Single-line shell executable
‚úÖ /exe @fn = sh {echo hi}      << Multi-line shell executable
‚úÖ /exe @fn = js {return 42}    << JavaScript executable (no 'run')
```

### 4. Only /show, /run, and /output Produce Output
```mlld
/var @secret = "hidden"     << No output
/var @config = {"x": 1}     << No output
/show `Visible text`        << This appears!
/run {echo "Also visible"}  << This appears!
```

### 5. Context-Specific Variable Syntax
**Primary template syntax**: Use single backtick templates with @ interpolation
- Backtick templates: `` `Hello @name!` `` - @name IS interpolated (PREFERRED)
- String literals: `/var @msg = "Hello @name"` - @name is NOT interpolated (literal text)
- Command context: `{echo "Hello @name"}` - @name IS interpolated (variable value)
- Double-bracket escape hatch: `::Hello {{name}}::` - For social media with many @ symbols

### 6. Field Access Rules
```mlld
/var @user = { "name": "Alice", "scores": [10, 20, 30] }

>> In directives:
/show @user.name           << "Alice"
/show @user.scores.1       << 20 (array access with dot notation)

>> In templates:
/show ::{{user.name}} scored {{user.scores.0}}::
```

### 7. Parameterized Content
```mlld
>> For commands, use /exe:
/exe @greet(name) = run {echo "Hello @name"}
/run @greet("Alice")

>> For templates, use /exe:
/exe @welcome(name, role) = ::Welcome {{name}}, our new {{role}}!::
/show @welcome("Bob", "developer")
```

### 8. File Dereferencing with Brackets

**Key Concept**: Brackets `[...]` mean "give me the contents of this file", not the filename itself.

```mlld
/var @content = [README.md]      << Loads file contents into @content
/var @path = "README.md"         << Stores the string "README.md" in @path

/show [config.json]              << Shows contents of config.json
/show "config.json"              << Shows the text "config.json"

>> Same principle applies everywhere:
/import { data } from [local/data.json]    << Imports from file contents
/exe @docs = [./documentation.md]          << Loads documentation content
```

### 9. Import Patterns

**CRITICAL DISTINCTION**: mlld has two different import syntaxes - one for modules and one for paths.

```mlld
>> MODULE imports (no brackets, @ prefix):
/import { parallel, retry } from @mlld/core
/import { utils } from @company/utils

>> PATH imports (WITH BRACKETS for resolver paths):
/import { readme } from [@./README.md]
/import { config } from [@PROJECTPATH/config.mld]
/import { shared } from [@local/utils.mld]

>> Regular path imports (quotes, no @ prefix):
/import { helper, config } from "./utils.mld"
```

**Why brackets matter:**
- `[@./file.md]` - Brackets tell mlld "resolve this path and read the file"
- `@author/module` - No brackets means "resolve this as a module reference"

Without brackets, `@./file` would be treated as trying to import from a user named "." - which is why you might see errors like "User '.' not found in registry".

### 10. Conditional Logic with /when

/when is mlld's decision-making directive. It's NOT an if-statement - it's a routing table.

**Quick Reference:**
- **`/when @var: [...]`** - Evaluates ALL conditions independently, fires action for each true condition
- **`/when @var first: [...]`** - Classic switch (stops at first match)
- **`/when @var all: [...] => action`** - Executes action if ALL conditions are true
- **`/when @var any: [...] => action`** - Executes action if ANY condition is true

```mlld
>> Simple routing: condition => action
/when @isProduction => /import { * } from "./prod-config.mld"

>> Switch-style branching with first: (stops at first match)
/when @hasLicense first: [
  true  => /show `‚úÖ License verified`
  false => /show `‚ùå No license found`
]

>> Bare form: ALL matching conditions execute (powerful feature!)
/when @status: [
  @hasTests     => /show `‚úì Tests present`
  @hasDocuments => /show `‚úì Docs present`
  @hasExamples  => /show `‚úì Examples present`
]

>> First-match-wins routing
/when first: [
  @isWeekend      => /show `üèñÔ∏è Out of office`
  @isPastDeadline => /show `‚è∞ Working overtime`
  true            => /show `üíº Regular hours`
]

>> ALL conditions must be true (single action)
/when all: [
  @hasTests
  @hasDocuments
  @hasExamples
] => /show `‚úÖ All quality checks passed!`

>> ANY condition is true (single action)
/when any: [
  @isEmergency
  @isUrgent
  @isPriority
] => /run {send-alert "@message"}
```

Important: /when doesn't support inline comparisons. Create helper functions:
```mlld
>> ‚ùå WRONG: /when @score > 90 => ...
>> ‚úÖ RIGHT: 
/exe @isHighScore(score) = js {(@score > 90 ? "true" : "")}
/when @isHighScore(@score) => /show `üèÜ High score!`
```

### 11. Iteration with foreach
```mlld
/var @names = ["Alice", "Bob", "Charlie"]
/exe @greetTemplate(name) = ::Hello, {{name}}!::
/var @greetings = foreach @greetTemplate(@names)
>> greetings = ["Hello, Alice!", "Hello, Bob!", "Hello, Charlie!"]
```

## Basic Examples

```mlld
>> Simple variable assignment
/var @author = "Alice"
/var @greeting = "Hello, world!"

>> Comments go at start or end of lines only
>> Output content
/show @greeting
/show "Welcome to mlld!"  >> Inline comments too!

>> Run commands (quotes for single lines)
/run "echo System info:"
/run "date"

>> IMPORTANT: Single-line commands with 'run' can only use pipes (|)
>> For multi-line shell scripts or commands with && or ||, use 'sh'
/run "echo Hello | tr '[:lower:]' '[:upper:]'"  >> Pipes allowed

>> Use 'sh' for multi-line shell scripts
/sh {
  echo "Multiple commands"
  ls -la
}

>> Use 'sh' for conditional execution (|| and &&)
/exe @safeDeploy(@env) = sh {
  npm test && npm run deploy:$env || echo "Deployment failed"
}

>> Data structures
/var @config = {
  "name": "my-app",
  "version": "1.0.0",
  "debug": true
}

>> Access nested data
/show "App: {{config.name}} v{{config.version}}"
```

## Variables (/var)

The unified `/var` directive creates variables with types inferred from syntax:

```mlld
>> Text variables
/var @simple = 'Single quotes = no interpolation'
/var @interpolated = "Hello @name!"
/var @template = `Hello @user, welcome!`

>> Data structures
/var @array = [1, 2, 3]
/var @object = {"key": "value"}

>> Primitive values (mlld 2.0+)
/var @count = 42                    << Number
/var @price = 19.99                 << Decimal
/var @active = true                 << Boolean
/var @disabled = false              << Boolean
/var @empty = null                  << Null

>> Type preservation - primitives keep their JavaScript types
/var @num = 42
/var @bool = true
/exe @add(a, b) = js { return a + b; }
/var @result = @add(@num, 8)        << Result is 50 (number)
/var @concat = @add("text", 5)      << Result is "text5" (JS coercion)

>> Command results (no @ before run!)
/var @date = run "date"
/var @files = run {ls -la | head -5}

>> File content - brackets dereference (load file contents)
/var @readme = [README.md]              << Gets file contents
/var @section = [docs.md # Installation]  << Gets specific section
/var @filename = "README.md"            << Gets literal string "README.md"

>> Code execution
/var @result = js { return Math.random() * 100; }
```

## Templates and Interpolation

### Backtick templates (PRIMARY - use this!)
```mlld
/var @message = `Hello @name, welcome to @place!`
/var @link = `[@title](@url)`
/var @result = `The answer is @calculate(42)`  << Can call executables!

>> Backticks support:
>> - @ variable interpolation
>> - @ executable calls
>> - Clean, simple syntax

>> Important: All values become strings in templates
/var @count = 42
/show `Count: @count`  << Shows "Count: 42" (number ‚Üí string)
```

### Double-bracket templates (ESCAPE HATCH ONLY)
```mlld
>> ONLY use ::...:: when you have many @ symbols to escape (social media)
/var @tweet = ::Hey @{{handle}}, check out @{{otherHandle}}'s post!::

>> Limitations of ::...:: templates:
>> - Cannot call @executables
>> - More verbose {{variable}} syntax
>> - Only for avoiding @ symbol conflicts
```

### @ interpolation in double quotes
```mlld
/var @greeting = "Hello @name!"    >> @ variables work in double quotes
/run "echo User: @username"         >> Works in quoted commands
/run {echo "Welcome @user.name"}    >> And in brace commands
```

## Exe - Defining Reusable Commands

```mlld
>> Command executable
/exe @deploy(@env) = run "deploy.sh $env"      >> Single line with quotes
/exe @build(@type) = sh {                      >> Multi-line requires 'sh'
  npm run build:$type
  npm test
}
/exe @checkFile(@path) = sh {                  >> 'sh' for if/then/else
  if [ -f "$path" ]; then
    echo "File exists"
  else
    echo "File not found"
  fi
}

>> Code executable (js/node without 'run' prefix)
/exe @calculate(x) = js {return @x * 2}

>> Type preservation in code executables
/exe @add(a, b) = js { return a + b; }
/var @result = @add(42, 8)          << Result is 50 (number) 
/var @concat = @add("text", 5)      << Result is "text5" (JS coercion)
/exe @isActive(val) = js { return val === true; }
/var @check = @isActive(true)       << Result is true (boolean preserved)

>> Template executable
/exe @greet(name) = `Hello @name!`

>> Section executable
/exe @getIntro(file) = [@file # Introduction]
```

## Conditional Logic (/when)

```mlld
>> Simple condition
/when @isProduction => /deploy() trust always

>> Multiple conditions
/when @env first: [
  "prod" => /show "‚ö†Ô∏è Production Environment"
  "dev" => /show "üîß Development Environment"
  _ => /show "Unknown environment"
]
```

## Import System

```mlld
>> Namespace imports (NEW - prevents variable collisions)
/import "shared.mld"              << Creates @shared namespace
/import "./config.mld"            << Creates @config namespace
/import "data/users.mld" as db    << Creates @db namespace

>> Selected imports (when you know what you need)
/import { greeting, config } from "shared.mld"

>> Module imports (no quotes)
/import { fetchData, parseJSON } from @corp/utils
/import @corp/utils               << Creates @utils namespace
/import @corp/utils as corpUtils  << Custom namespace

>> Environment variables (must be in mlld.lock.json)
/import { API_KEY, NODE_ENV } from @INPUT
```

## Paths

```mlld
>> Simple paths (quoted strings)
/path @docs = "./documentation"
/path @output = "results/output.txt"

>> Paths with interpolation (double quotes)
/path @userFile = "data/@username/profile.json"

>> Literal paths (single quotes - no interpolation)
/path @template = 'templates/@var-template.html'  // @var is literal text

>> Bare resolvers (no quotes)
/import { utils } from @corp/shared-lib

>> URLs with caching
/path @api = https://api.example.com/data (5m)
```

## Output Directive

```mlld
>> Output to files
/output @content to "output.txt"
/output @data to "config.json"
/output @html to "page.html" as html

>> Output to stdout/stderr
/output @message to stdout
/output @error to stderr

>> With format specification
/output @config to "settings.yaml" as yaml
```

## Shell Commands: run vs sh

Understanding when to use `run` vs `sh` is critical for shell commands:

### Use 'run' for:
- **Single-line commands** that only use pipes (`|`)
- **Simple command execution** without conditionals
- **Security**: `run` is restricted to prevent command injection

```mlld
/run "echo Hello World"                    >> Simple command
/run {cat file.txt | grep "pattern"}      >> Pipes are allowed
/run "ls -la | head -10"                   >> Single line with pipe

>> These will FAIL with 'run':
‚ùå /run {cmd1 && cmd2}                     >> && not allowed
‚ùå /run {cmd1 || cmd2}                     >> || not allowed
‚ùå /run {if [ -f "file" ]; then ...; fi}   >> Multi-line not allowed
```

### Use 'sh' for:
- **Multi-line shell scripts**
- **Conditional execution** with `&&` or `||`
- **Control structures** like if/then/else, loops
- **Complex shell operations**

```mlld
/sh {
  echo "Starting deployment"
  npm test && npm build && npm deploy
}

/exe @safeDelete(@file) = sh {
  if [ -f "$file" ]; then
    rm "$file"
    echo "Deleted $file"
  else
    echo "File not found: $file"
  fi
}

/exe @tryCommand(@cmd) = sh {
  $cmd || echo "Command failed with exit code $?"
}
```

### Parameter Syntax Differences:
- In `run`: Use `@param` for mlld interpolation
- In `sh`: Use `$param` for shell variable interpolation

```mlld
/exe @greet(@name) = run "echo Hello @name"     >> @name in run
/exe @greet(@name) = sh { echo "Hello $name" }  >> $name in sh
```

## Common Patterns

### Running scripts with parameters
```mlld
/exe @test(suite) = run {npm test -- @suite}
/run @test("integration")
```

### Template with many @ symbols
```mlld
>> Use ::...:: when you have many @ symbols to escape
/var @twitterTemplate = ::
  Hey @{{handle}}, love your work!
  @{{otherHandle}} you should check this out.
  Reply to this tweet @{{originalAuthor}}
::
```

### Field access
```mlld
/var @user = { "name": "Alice", "scores": [95, 87, 92] }
/show "Name: @user.name"
/show "First score: @user.scores.0"
```

## Common Mistakes

### ‚ùå Forgetting braces or quotes in commands
```mlld
/run echo "hello"     << WRONG - needs braces or quotes
/run {echo "hello"}   << CORRECT - braces
/run "echo hello"     << CORRECT - quotes for single line
```

### ‚ùå Missing @ when creating variables
```mlld
/var greeting = "Hello"  << WRONG - missing @
/var @greeting = "Hello"  << CORRECT
```

### ‚ùå Using @ for directives
```mlld
@var @greeting = "Hello"  << WRONG - directives use /
/var @greeting = "Hello"  << CORRECT
```

### ‚ùå Trying to interpolate everywhere
```mlld
Hello @name!  << WRONG - plain text, not interpreted
/show "Hello @name!"  << CORRECT - in directive
/var @msg = `Hello @name!`  << CORRECT - in template
```

## Module-First Philosophy

For complex operations, create modules instead of inline scripts:

### ‚ùå Overly complex inline mlld
```mlld
/var @results = foreach @processData(@items) | @validate @transform
/when @results.length > 0: [
  true => /var @filtered = foreach @filter(@results)
]
```

### ‚úÖ Better: Use a module
```mlld
/import { processItems } from @myteam/data-utils
/var @results = @processItems(@items)
```

## Common Mistakes with New Syntax

### ‚ùå Using @run instead of run
```mlld
/var @result = @run {echo "hello"}  << WRONG - no @ before run
/var @result = run {echo "hello"}   << CORRECT
```

### ‚ùå Using old directive names
```mlld
/text @name = "Alice"     << WRONG - old syntax
/data @config = {}        << WRONG - old syntax
/add @content            << WRONG - old syntax
/exec @cmd = run {ls}    << WRONG - old syntax

/var @name = "Alice"      << CORRECT - unified /var
/var @config = {}         << CORRECT - unified /var
/show @content           << CORRECT - new name
/exe @cmd = run {ls}     << CORRECT - shortened name
```

## Creating Helper Functions

When you need utility functions, create them with /exe instead of trying to work around mlld's constraints:

```mlld
>> String manipulation helpers (using js, not run js)
/exe @join(array, separator) = js {(@array.join(@separator))}
/exe @capitalize(text) = js {(@text.charAt(0).toUpperCase() + @text.slice(1))}
/exe @fileList(paths) = js {(@paths.map(p => `${p}/**/*.md`).join(' '))}

>> Using the helpers
/var @names = ["alice", "bob", "charlie"]
/var @formatted = @join(@names, ", ")
/show `Team members: @formatted`

>> For bash operations
/exe @countFiles(dir) = run {find @dir -type f | wc -l}
/var @fileCount = @countFiles("./src")
```

### Shadow Environments: Making JavaScript Functions Available to Each Other

Shadow environments are a powerful feature that lets JavaScript functions and variables defined in `/exe` blocks become available inside other `js {}` blocks. This solves the common need for utility functions to work together.

**Key Concepts:**
- Each language (`js` and `node`) has its own separate shadow environment
- Each module has its own isolated shadow environment (no cross-module pollution)
- You explicitly declare which functions/variables to expose using `/exe js = { ... }`

**Basic Example:**
```mlld
>> Step 1: Define your functions
/exe @double(n) = js { return n * 2; }
/exe @triple(n) = js { return n * 3; }
/exe @capitalize(s) = js { return s.charAt(0).toUpperCase() + s.slice(1); }

>> Step 2: Add them to the shadow environment
/exe js = { double, triple, capitalize }

>> Step 3: Now they're available in all js blocks in this module!
/var @result = js {
  // All three functions are available here
  const doubled = double(5);        // 10
  const tripled = triple(doubled);  // 30
  const text = capitalize("hello"); // "Hello"
  return `${text}: ${tripled}`;    // "Hello: 30"
}
```

**Advanced Pattern - Functions Calling Each Other:**
```mlld
>> Define interdependent functions
/exe @formatName(first, last) = js { return `${first} ${last}`; }
/exe @greetUser(first, last) = js { 
  // This will only work after we add formatName to shadow env
  return `Hello, ${formatName(first, last)}!`; 
}

>> Add both to shadow environment
/exe js = { formatName, greetUser }

>> Now greetUser can call formatName
/var @greeting = js { greetUser("Jane", "Doe") }  // "Hello, Jane Doe!"
```

**Module Isolation Example:**
```mlld
>> In module A
/exe @secretHelper() = js { return "Module A secret"; }
/exe js = { secretHelper }

>> In module B  
/exe @secretHelper() = js { return "Module B secret"; }
/exe js = { secretHelper }

>> Each module's js blocks see their own secretHelper - no conflicts!
```

**Node.js Has Its Own Environment:**
```mlld
>> JavaScript environment
/exe @parseData(json) = js { return JSON.parse(json); }
/exe js = { parseData }

>> Node.js environment (completely separate)
/exe @readConfig() = node { 
  const fs = require('fs');
  return fs.readFileSync('config.json', 'utf8');
}
/exe node = { readConfig }

>> js blocks can't see node functions and vice versa
```

Remember: If you're wishing mlld had a feature, you can probably create it as a helper function and add it to the shadow environment!

## Additional Essential Features

### Comments
```mlld
>> Comments can use >> or << at the start of a line
<< You can also start comments with <<
/show "Hello!"  >> End-of-line comments work with >>
/var @x = 5     << End-of-line comments also work with <<
>> Mix and match as you prefer - both >> and << work in both positions
<< No other comment syntax is supported (no # or //)
```

### Reserved Variables
```mlld
/show `Current time: @NOW`         # Current timestamp
/show `Input data: @INPUT.config`  # Access stdin/env vars  
/show `Project root: @PROJECTPATH` # Project directory
/show @DEBUG                       # Show extensive debug info
```

### Environment Variables
Environment variables require explicit permission in `mlld.lock.json`:
```json
{
  "security": {
    "allowedEnv": ["NODE_ENV", "API_KEY", "GITHUB_TOKEN"]
  }
}
```

Then access them via @INPUT:
```mlld
/import { NODE_ENV, API_KEY } from @INPUT
/show `Running in @NODE_ENV mode with API access`
```

### Frontmatter Metadata
```mlld
---
description: Pipeline description
version: 1.0.0
author: Your Name
---

>> Your mlld Document
```

### URL Support
```mlld
>> Add content from URLs directly:
/show [https://raw.githubusercontent.com/example/repo/main/README.md]

>> Assign URL content to variables:
/path @docs = "https://example.com/api-docs.md"
/var @readme = [https://example.com/README.md]
```

## Pipelines and Transformers

### Pipeline Operator |

mlld supports Unix-style pipelines for chaining commands:

```mlld
>> Basic pipeline
/var @result = run {echo "hello world"} | @uppercase
/show @result  # HELLO WORLD

>> Multi-step pipeline  
/var @data = run {cat data.json} | @json | @uppercase | @csv
```

### How Pipelines Work
- Output flows left to right (stdin)
- Each step gets an @INPUT variable with the piped data
- Functions without arguments get smart parameter handling
- Each step runs in a child environment
- Use `with { format: "json|csv|xml|text" }` to specify parsing

### Smart Parameter Handling

Single parameter functions automatically receive @INPUT:
```mlld
/exe @double(n) = js {(@n * 2)}
/var @result = run {echo "5"} | @double  # n = "5"
```

Multi-parameter functions with JSON get automatic destructuring:
```mlld
/exe @greet(name, age) = ::{{name}} is {{age}} years old::
/var @result = run {echo '{"name":"Alice","age":30}'} | @greet
>> name = "Alice", age = 30
```

### Built-in Transformers

mlld includes transformers for common formats (both UPPERCASE and lowercase):

- **@XML / @xml** - Convert to SCREAMING_SNAKE_CASE XML (using llmxml)
- **@JSON / @json** - Format/validate JSON with proper indentation  
- **@CSV / @csv** - Convert JSON arrays to CSV format
- **@MD / @md** - Format markdown using prettier

```mlld
>> API to CSV pipeline
/var @users = run {curl api.com/users} | @json | @csv

>> Chain with custom functions
/exe @addTotal(data) = ::Total: {{data.length}} items\n{{INPUT}}::
/var @report = run {cat data.json} | @json | @addTotal | @md
```

### Pipeline Format Feature

Specify how data should be parsed in pipelines using `format`:

```mlld
/exe @processJSON(input) = js {(
  // input.text - raw text
  // input.type - format type
  // input.data - parsed JSON (lazy)
  // input.csv - parsed CSV array (lazy)
  // input.xml - XML string (lazy)
  return @input.data.users.map(u => u.name);
)}

/var @names = @getData() with { format: "json", pipeline: [@processJSON] }
```

Formats: `json` (default), `csv`, `xml`, `text`

## Philosophy: Simplicity in Files, Complexity in Modules

mlld's design philosophy centers on keeping `.mld` files simple and readable while abstracting complexity into reusable modules. Instead of adding language features, we encourage using modules:

```mlld
>> Don't try to implement complex logic in mlld
>> Instead, import capabilities from modules:

/import { parallel, retry, cache, pipeline } from @mlld/core
/import { validateSchema, transform } from @myorg/data-utils

>> Simple, readable mlld:
/var @results = @parallel(@tasks, { concurrency: 5 })
/var @validated = @validateSchema(@results, @schema)
```

## Common Pitfalls to Avoid

### 1. Treating mlld as a Template Language
```mlld
‚ùå This is {{name}}'s document     # Won't work - no / directive
‚úÖ /show ::This is {{name}}'s document::
```

### 2. Forgetting Command Braces
```mlld
‚ùå /run npm install
‚úÖ /run {npm install}
‚ùå /run echo "hello"           # Missing braces
‚úÖ /run {echo "hello"}         # Shell command
‚ùå js console.log("hello")     # Missing braces  
‚úÖ js {console.log("hello")}   # JavaScript code
```

### 3. Using @ When Creating Variables
```mlld
‚ùå /var greeting = "value"
‚úÖ /var @greeting = "value"
```

### 4. Mixing Variable Syntaxes
```mlld
‚ùå /show ::Hello @name::           # Wrong syntax in template
‚ùå /run {echo "{{message}}"}       # Wrong syntax in command
‚úÖ /show ::Hello {{name}}::        # Correct template syntax
‚úÖ /run {echo "@message"}          # Correct command syntax

>> String literal vs command context example:
/var @name = "Alice"
/var @literal = "Hello @name"     # Result: "Hello @name" (literal)
/run {echo "Hello @name"}         # Result: "Hello Alice" (interpolated)
```

### 5. Trying to Nest Function Calls
```mlld
‚ùå WRONG: Trying to call mlld functions inside commands
/exe @helper(x) = run {echo "@x"}
/run {
  RESULT=$(@helper("test"))  # This doesn't work!
  echo $RESULT
}

‚úÖ RIGHT: Call functions at directive level
/var @result = @helper("test")
/run {echo "@result"}

‚úÖ BETTER: Use foreach for multiple operations
/var @results = foreach @helper(@items)
```

### 6. String Concatenation Instead of Templates
```mlld
‚ùå WRONG: Trying to concatenate procedurally
>> Attempting to build strings piece by piece

‚úÖ RIGHT: Use templates
/exe @greeting(name, time) = ::Good {{time}}, {{name}}!::
/show @greeting("Alice", "morning")
```

### 7. Complex Logic in mlld
```mlld
‚ùå WRONG: Implementing algorithms in mlld
>> Don't try to write sorting algorithms or complex data manipulation

‚úÖ RIGHT: Use helper functions or modules
/exe @sortData(data) = js {(@data.sort((a, b) => a.name.localeCompare(b.name)))}
/var @sorted = @sortData(@users)
```

### 8. Import Bracket Confusion
```mlld
‚ùå WRONG: Forgetting brackets for path imports
/import { readme } from @./README.md      # Error: "User '.' not found in registry"
/import { config } from @PROJECTPATH/config.mld  # Error: "User 'PROJECTPATH' not found"

‚úÖ RIGHT: Use brackets for resolver paths
/import { readme } from [@./README.md]          # Path import needs brackets
/import { config } from [@PROJECTPATH/config.mld]  # Resolver path needs brackets
/import { utils } from @company/utils           # Module import - NO brackets
```

### 9. JavaScript Confusion
While you CAN write JavaScript in mlld, it's best kept simple:
```mlld
>> Okay for simple cases:
js {console.log("Debug: " + @count)}

>> For complex logic - create a helper:
/exe @processData(data) = js {(
  // Your complex logic here
  return @data.map(d => ({...d, processed: true}))
)}

>> Or better yet - create a module:
/import { processData } from @myorg/utils
/var @result = @processData(@rawData)
```

### 10. No Early Exit
mlld doesn't have `return` or `exit` - design your flow instead:

```mlld
>> ‚ùå WRONG: Trying to exit early
/when @error: [
  true => /run {exit 1}  # This won't work!
]

>> ‚úÖ RIGHT: Use conditional flow
/when @isValid: [
  true  => /var @continue = true
  false => /show `‚ùå Validation failed`
]

/when @continue: [
  true => @runMainProcess()
]

>> ‚úÖ BETTER: Let the workflow complete naturally
/var @validation = @validate(@input)
/when @validation.valid: [
  true  => @processData(@input)
  false => /show `Error: @validation.message`
]
>> Workflow ends naturally - no forced exit needed
```

## Key Concepts

1. **mlld is NOT a template language** - It's a scripting language that only processes lines starting with directives
2. **Everything is explicit** - No magic, no hidden behavior
3. **Markdown-first** - The document should be readable without executing mlld
4. **Module-first for complexity** - Use modules for complex logic
5. **Clear visual distinction** - `/` for commands (directives), `@` for data (variables)
6. **Comments use >>** - Double angle brackets, visually distinct from directives

## Orchestration Patterns

mlld shines when orchestrating external tools and data. Here are patterns that showcase its strengths:

### Pattern 1: Tool Orchestration
```mlld
>> Orchestrating multiple Claude sessions for QA
/var @testAreas = [
  { "name": "auth", "files": ["auth/*.ts"], "tests": ["test/auth/*"] },
  { "name": "api", "files": ["api/*.ts"], "tests": ["test/api/*"] }
]

/exe @runQA(area) = run {(
  echo "Testing @area.name module"
  claude -p "Test the @area.name functionality" \
    --allowedTools "Bash,Read,Write"
)}

/var @results = foreach @runQA(@testAreas)
```

### Pattern 2: Data Pipeline
```mlld
>> Processing data through multiple stages
/import { fetchData, validate, transform } from @data/pipeline

/var @raw = @fetchData("https://api.example.com/users")
/var @valid = @validate(@raw, { schema: "user" })
/var @transformed = @transform(@valid, { format: "report" })

/show `Processed @transformed.count records successfully`
```

### Pattern 3: Conditional Workflows
```mlld
>> Environment variables via @INPUT (requires mlld.lock.json allowedEnv)
/import { NODE_ENV, API_KEY } from @INPUT

/exe @loadConfig(env) = run {cat "./config/@env.json"}
/var @config = @loadConfig(@NODE_ENV)

/when @config.debug => /show `Debug mode enabled`
```

## Workflow Patterns

### Pattern: Step-by-Step Processing
```mlld
>> Each step produces data for the next
/var @raw = @fetchData(@source)
/var @validated = @validateData(@raw)
/var @processed = @processData(@validated)
/var @report = @generateReport(@processed)
/show @report
```

### Pattern: Guarded Execution
```mlld
>> Only proceed if previous steps succeed
/var @envCheck = @validateEnvironment(["API_KEY", "DB_URL"])

/when @envCheck.valid: [
  true  => /var @canProceed = true
  false => /show `‚ùå @envCheck.summary`
]

/when @canProceed: [
  true => /var @results = @runMainProcess()
]
```

### Pattern: Module-First Design
```mlld
>> Don't implement logic - import it
/import { validateEmail, sanitizeInput } from @company/validators
/import { sendNotification } from @company/notifications

>> Your workflow just orchestrates
/var @cleanEmail = @sanitizeInput(@userEmail)
/when @validateEmail(@cleanEmail) => @sendNotification(@cleanEmail, @message)
```

## The Module Philosophy

mlld modules aren't libraries - they're capability providers. Design them like microservices:

### Good Module Design
```mlld
---
module: @myorg/github-utils
description: GitHub API operations
---

>> Single responsibility: GitHub operations
/exe @getPR(number, repo) = run {gh pr view...}
/exe @listIssues(repo) = run {gh issue list...}
/exe @createRelease(tag, notes) = run {gh release create...}

/var @module = {
  "getPR": @getPR,
  "listIssues": @listIssues,
  "createRelease": @createRelease
}
```

### Module Anti-Patterns
```mlld
>> ‚ùå Kitchen sink module with unrelated functions
>> ‚ùå Modules that try to be frameworks
>> ‚ùå Modules with side effects on import
>> ‚úÖ Focused modules that do one thing well
```

## Reading mlld Code

When reading mlld, look for these patterns:

1. **Section Headers** = Major workflow phases
   ```
   ## üìä Data Collection
   ## üîç Validation  
   ## üì§ Output Generation
   ```

2. **/when chains** = Decision trees
   - Read them like a flowchart
   - Each branch is a possible path

3. **/var flow** = Follow the data
   - Each /var assignment transforms or enriches
   - Variable names tell the story

4. **Module imports** = Available capabilities
   - Like looking at package.json
   - Tells you what the workflow can do

Example workflow reading:
```mlld
>> Looking at imports tells you: "This workflow works with GitHub and sends emails"
/import { getPR, commentOnPR } from @company/github
/import { sendAlert } from @company/notifications

>> Section headers show the flow: Check ‚Üí Validate ‚Üí Notify
## üîç Check PR Status
/var @pr = @getPR(@PR_NUMBER)

## ‚úÖ Validate Changes  
/when @pr.mergeable: [
  true  => /var @status = "ready"
  false => /var @status = "blocked"
]

## üìß Send Notifications
/when @status: [
  "ready"   => @commentOnPR(@PR_NUMBER, "Ready to merge!")
  "blocked" => @sendAlert("PR @PR_NUMBER needs attention")
]
```

## Configuring Prefixes and Resolvers

mlld 1.4+ introduces a resolver system with customizable prefixes that "open doors" to different data sources.

### Key Concepts
- **Prefix**: An @ symbol that opens access to data (e.g., `@lib/`, `@company/`)
- **Resolver**: The data provider that handles requests for a prefix (e.g., LOCAL, GITHUB, REGISTRY)
- **Built-in Resolvers**: Special resolvers like @NOW, @DEBUG that don't need prefixes
- **Registry**: The REGISTRY resolver that ONLY provides validated modules from registries

### Quick Setup with CLI Commands

The easiest way to configure resolvers is using mlld's setup commands:

```bash
>> Complete interactive setup wizard
mlld setup

>> Set up GitHub private modules only
mlld setup --github

>> Set up path aliases only  
mlld setup --local

>> Create a specific path alias
mlld alias --name shared --path ../shared-modules

>> Create a global alias (available to all projects)
mlld alias --name desktop --path ~/Desktop --global
```

### Manual Prefix Configuration

You can configure custom prefixes manually in your `mlld.lock.json`:

```json
// mlld.lock.json
{
  "version": "1.0",
  "config": {
    "resolvers": {
      "prefixes": [          // Maps prefixes to resolvers
        {
          "prefix": "@lib/",      // The door to open
          "resolver": "LOCAL",     // The provider behind the door
          "config": {
            "basePath": "./src/lib"
          }
        },
        {
          "prefix": "@shared/",
          "resolver": "LOCAL",    // Same resolver, different prefix
          "config": {
            "basePath": "../shared-modules"
          }
        }
      ]
    }
  },
  "modules": {},
  "cache": {}
}
```

Now you can import using these prefixes:
```mlld
/import { utils } from @lib/string-utils
/import { validate } from @shared/validators
```

### Private GitHub Module Configuration

Set up private modules using GitHub repositories. First authenticate:

```bash
>> Authenticate with GitHub (uses OAuth device flow)
mlld auth login

>> Check authentication status
mlld auth status
```

Then configure your private repository:

```json
// mlld.lock.json
{
  "version": "1.0",
  "config": {
    "resolvers": {
      "prefixes": [
        {
          "prefix": "@myorg/",    // Your organization's prefix
          "resolver": "GITHUB",   // Uses GitHub resolver for this prefix
          "config": {
            "repository": "myorg/private-mlld-modules",
            "branch": "main",
            "basePath": "modules"
          }
        }
      ]
    }
  },
  "modules": {},
  "cache": {}
}
```

Usage:
```mlld
>> This resolves to: https://github.com/myorg/private-mlld-modules/blob/main/modules/auth/login.mld
/import { authenticate } from @myorg/auth/login

>> Import from specific paths
/import { helper } from @myorg/utils/strings
```

### Resolver Types

**Configurable with prefixes**:
- **LOCAL**: File system paths (used for "path aliases")
- **HTTP**: Remote URLs (with caching support)
- **GITHUB**: GitHub repositories (public or private)
- **REGISTRY**: Special - ONLY provides validated modules from registries

**Built-in resolvers (no prefix needed)**:
- **NOW**: Dynamic timestamps (`@NOW`, not `@now/`)
- **DEBUG**: Environment info (`@DEBUG`, not `@debug/`)
- **INPUT**: Stdin/env data (`@INPUT`, not `@input/`)
- **PROJECTPATH**: Project root (`@PROJECTPATH` or `@.`)

### Configuration Files

- **Project config**: `mlld.lock.json` in project root
- **Global config**: `~/.config/mlld/mlld.lock.json` (for global aliases and settings)
- **Old location**: `~/.config/mlld.json` (deprecated)

### Publishing Private Modules

When working with private repositories:

```bash
>> Publish to private repository (interactive prompt)
mlld publish my-module.mld.md

>> Skip prompt, publish directly to private repo
mlld publish my-module.mld.md --private

>> Publish to custom directory in repo
mlld publish my-module.mld.md --private --path lib/modules

>> Also create registry PR for future public release
mlld publish my-module.mld.md --private --pr
```

Private modules are stored in your repository and accessed via file paths or GitHub resolver configuration.

## Best Practices

1. **Keep .mld files readable**: They should make sense as Markdown documents
2. **Use modules for complexity**: Don't try to implement algorithms in mlld
3. **Explicit over implicit**: Always be clear about what produces output
4. **Test incrementally**: Use `/show` to verify variable values during development
5. **Think orchestration**: mlld excels at coordinating tools and data flows
6. **Create helpers liberally**: If you need it twice, make it a helper function
7. **Embrace constraints**: Working with mlld's design leads to cleaner solutions
8. **Configure resolvers for teams**: Use custom resolvers for shared private modules

## Example: Well-Structured mlld File

```mlld
---
description: Data processing pipeline for user analytics
version: 1.0.0
---

>> User Analytics Pipeline

This document processes user data and generates insights.

/import { fetchData, validateUsers } from @analytics/core
/import { generateReport } from @company/reporting

## Configuration

/var @config = {
  "apiEndpoint": "https://api.example.com",
  "batchSize": 100,
  "outputFormat": "markdown"
}

## Data Processing

/exe @status(phase) = `‚úì Completed: @phase`

### 1. Fetch User Data
/var @users = @fetchData(@config.apiEndpoint)
/show @status("Data fetching")

### 2. Validate and Clean
/var @validUsers = @validateUsers(@users)
/show @status("Validation")

### 3. Generate Report
/var @report = @generateReport(@validUsers, @config)
/show @report

### 4. You can use /output to target specific locations and to handle conditional output:
/output @mydefinedcommand(@var, @othervar) to "@path/to/file.md"
/when @variable: [ @contains("hi") ] => /output /show "Hello" to "@path/to/file.md"
Read more about output in docs/output.md

## Summary

/show `Processed @validUsers.length valid users out of @users.length total.`
```

## Execution Context Reference

Understanding where different variable syntaxes work is crucial:

| Context | Syntax | Example | Notes |
|---------|--------|---------|-------|
| Templates `::...::` | `{{variable}}` | `::Hello {{name}}!::` | Double brackets, double braces |
| Backtick templates | `@variable` | `` `Hello @name!` `` | Simpler template syntax |
| Commands `{...}` | `@variable` | `{echo "@message"}` | @ prefix for interpolation |
| JavaScript | Plain names | `{(@array.join(@sep))}` | Parameters are JS variables |
| String literals | No interpolation | `"Hello @name"` | @name is literal text |
| Directive level | `@variable` | `/show @greeting` | Direct variable reference |

### Key Rules:
- **In templates**: Always use `{{variable}}` or `{{object.field}}`
- **In backtick templates**: Use `@variable` or `@object.field`
- **In commands**: Always use `@variable` or `@object.field`
- **In JavaScript**: Parameters become plain JavaScript variables
- **String assignments**: Variables are NOT interpolated (they're literals)

## Remember

mlld empowers everyone to create versionable, collaborative "pipelines of thought." It achieves this by being an orchestration language that looks and reads like a document, not by being a template system or programming language.

When writing mlld:
- Think in terms of discrete processing steps, not text interpolation
- Embrace the constraints - they lead to cleaner solutions
- Use helpers and modules for complexity
- Keep your .mld files simple and readable

The power comes from composition: simple directives in your files, powerful capabilities in your modules.

## Summary of New Syntax

| Old Syntax | New Syntax | Purpose |
|------------|------------|---------|
| `/text @x = "..."` | `/var @x = "..."` | Create any variable |
| `/data @x = {...}` | `/var @x = {...}` | Type inferred from value |
| `/add @content` | `/show @content` | Display content |
| `/exec @cmd(p) = ...` | `/exe @cmd(p) = ...` | Define executable |
| `@run {cmd}` | `run {cmd}` | Run command (no @ in RHS) |
