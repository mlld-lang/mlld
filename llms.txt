# mlld Language Guide for LLMs

## What mlld IS and ISN'T

### mlld IS:
- ðŸ“‹ A workflow orchestrator (like Make, but for the AI era)
- ðŸŽ­ A conductor's baton (you conduct, tools play)
- ðŸ“ Executable documentation (reads like a guide, runs like a script)

### mlld ISN'T:
- âŒ A programming language (no loops, no recursion, no algorithms)
- âŒ A template engine (it's not Jinja or Handlebars)
- âŒ A shell script replacement (it orchestrates shells, doesn't replace them)

If you find yourself wanting programming features, you're thinking about the problem wrong. Step back and ask: "What tool or module could handle this complexity for me?"

## The mlld Mindset: Orchestration, Not Programming

mlld is NOT a programming language - it's an **orchestration language embedded in Markdown**. This fundamental distinction drives everything about how you should use mlld.

### Think Like a Conductor, Not a Programmer
- You're orchestrating tools and data, not implementing algorithms
- Each directive is a clear, simple instruction
- Complexity belongs in modules and external tools
- If you're writing complex logic, you're using mlld wrong

### The mlld Way
âŒ WRONG: Trying to concatenate strings procedurally
âœ… RIGHT: Define templates and use them

âŒ WRONG: Nested function calls in commands
âœ… RIGHT: Call functions at directive level, pass results

âŒ WRONG: Complex conditionals and loops
âœ… RIGHT: Simple foreach over data with clear transformations

### The Mental Model Shift

If you're coming from programming, you need to unlearn these reflexes:
- âŒ "How do I implement this logic?" â†’ âœ… "What tool handles this?"
- âŒ "I need an if-statement" â†’ âœ… "I need a decision point"
- âŒ "Let me concatenate these strings" â†’ âœ… "Let me create a template"
- âŒ "I'll handle the error here" â†’ âœ… "I'll design the flow to handle failures"

Think of mlld like Docker Compose or GitHub Actions - you're declaring what should happen, not programming how it happens.

## Critical Understanding: mlld is NOT a Template Language

mlld (pronounced "meld") only executes lines that start with `@` directives. Everything else is treated as literal Markdown. Unlike template languages that process variables anywhere in text, mlld has clear boundaries between content and code.

## Core Mental Model

Think of mlld as having two distinct modes:
1. **Markdown mode** (default): Any line not starting with `@` is plain Markdown
2. **mlld mode**: Lines starting with `@` are interpreted as mlld commands

This design keeps documents readable as regular Markdown while enabling programmatic capabilities where needed.

## The 10 Commandments of mlld

### 1. Directives Must Start Lines
```mlld
âŒ WRONG: Hello @name! Let me @add some text.
âœ… RIGHT: 
@text greeting = [[Hello {{name}}!]]
@add @greeting
```

### 2. Variable Creation vs Reference
```mlld
@text name = "Alice"        # Create without @
@add [[Hello {{name}}!]]    # Reference with {{}} in templates
@run [(echo "@name")]       # Reference with @ in commands
```

### 3. Commands Require Brackets [(...))]
```mlld
âŒ WRONG: @run echo "hello"
âŒ WRONG: @run [echo "hello"]
âœ… RIGHT: @run [(echo "hello")]
âœ… RIGHT: @run js [(console.log("hello"))]  # Language outside brackets
âœ… RIGHT: @run javascript [(console.log("hello"))]  # 'js' is shorthand for 'javascript'
```

### 4. Only @add and @run Produce Output
```mlld
@text secret = "hidden"     # No output
@data config = {"x": 1}     # No output
@add [[Visible text]]       # This appears!
@run [(echo "Also visible")]  # This appears!
```

### 5. Context-Specific Variable Syntax
Remember: "Double brackets, double braces"
- String literals: `@text msg = "Hello @name"` - @name is NOT interpolated (literal text)
- Command context: `[(echo "Hello @name")]` - @name IS interpolated (variable value)
- Template context: `[[Hello {{name}}]]` - {{name}} is interpolated
- Backtick templates: `` `Hello @name!` `` - @name IS interpolated (simpler syntax)

### 6. Field Access Rules
```mlld
@data user = { "name": "Alice", "scores": [10, 20, 30] }

# In directives:
@add @user.name           # "Alice"
@add @user.scores.1       # 20 (array access with dot notation)

# In templates:
@add [[{{user.name}} scored {{user.scores.0}}]]
```

### 7. Parameterized Content
```mlld
# For commands, use @exec:
@exec greet(name) = @run [(echo "Hello @name")]
@run @greet("Alice")

# For templates, use @text:
@text welcome(name, role) = [[Welcome {{name}}, our new {{role}}!]]
@add @welcome("Bob", "developer")
```

### 8. Import Patterns
```mlld
# Local files (with quotes and .mld extension):
@import { helper, config } from "./utils.mld"

# Registry modules (no quotes, @ prefix):
@import { parallel, retry } from @mlld/core
```

### 9. Conditional Logic with @when

@when is mlld's decision-making directive. It's NOT an if-statement - it's a routing table.

```mlld
# Simple routing: condition => action
@when @isProduction => @import { * } from "./prod-config.mld"

# True/false branching (explicit is better than implicit)
@when @hasLicense: [
  true  => @add [[âœ… License verified]]
  false => @add [[âŒ No license found]]
]

# Multiple conditions - each evaluated independently
@when [
  @hasTests     => @add [[âœ“ Tests present]]
  @hasDocuments => @add [[âœ“ Docs present]]
  @hasExamples  => @add [[âœ“ Examples present]]
]

# First-match-wins routing
@when first: [
  @isWeekend      => @add [[ðŸ–ï¸ Out of office]]
  @isPastDeadline => @add [[â° Working overtime]]
  true            => @add [[ðŸ’¼ Regular hours]]
]

# ALL conditions must be true (single action)
@when all: [
  @hasTests
  @hasDocuments
  @hasExamples
] => @add [[âœ… All quality checks passed!]]

# ANY condition is true (single action)
@when any: [
  @isEmergency
  @isUrgent
  @isPriority
] => @run [(send-alert "@message")]
```

Important: @when doesn't support inline comparisons. Create helper functions:
```mlld
# âŒ WRONG: @when @score > 90 => ...
# âœ… RIGHT: 
@exec isHighScore(score) = @run js [(score > 90 ? "true" : "")]
@when @isHighScore(@score) => @add [[ðŸ† High score!]]
```

### 10. Iteration with foreach
```mlld
@data names = ["Alice", "Bob", "Charlie"]
@text greetTemplate(name) = [[Hello, {{name}}!]]
@data greetings = foreach @greetTemplate(@names)
>> greetings = ["Hello, Alice!", "Hello, Bob!", "Hello, Charlie!"]
```

## Creating Helper Functions

When you need utility functions, create them with @exec instead of trying to work around mlld's constraints:

```mlld
# String manipulation helpers
@exec join(array, separator) = @run js [(array.join(separator))]
@exec capitalize(text) = @run js [(text.charAt(0).toUpperCase() + text.slice(1))]
@exec fileList(paths) = @run js [(paths.map(p => `${p}/**/*.md`).join(' '))]

# Using the helpers
@data names = ["alice", "bob", "charlie"]
@text formatted = @join(@names, ", ")
@add [[Team members: {{formatted}}]]

# For bash operations
@exec countFiles(dir) = @run [(find @dir -type f | wc -l)]
@data fileCount = @countFiles("./src")

# Shadow Environment: Make functions available to each other (JavaScript/Node.js only)
@exec js = { join, capitalize, fileList }  # These can now call each other!
@run js [(  
  // Now join() and capitalize() are available here
  capitalize(join(["hello", "world"], " "))
)]  # Returns: "Hello world"
```

Remember: If you're wishing mlld had a feature, you can probably create it as a helper function!

## Additional Essential Features

### Comments
```mlld
>> This is a comment (starts with two > and a space)
>> Comments must start at the beginning of a line
```

### Reserved Variables
```mlld
@add [[Current time: {{TIME}}]]        # Current timestamp
@add [[Input data: {{INPUT.config}}]]  # Access stdin/env vars  
@add [[Project root: {{PROJECTPATH}}]] # Project directory
@add @DEBUG                            # Show extensive debug info
```

### Environment Variables
Environment variables require explicit permission in `mlld.lock.json`:
```json
{
  "security": {
    "allowedEnv": ["NODE_ENV", "API_KEY", "GITHUB_TOKEN"]
  }
}
```

Then access them via @INPUT:
```mlld
@import { NODE_ENV, API_KEY } from @INPUT
@add [[Running in {{NODE_ENV}} mode with API access]]
```


### Frontmatter Metadata
```mlld
---
description: Pipeline description
version: 1.0.0
author: Your Name
---

# Your mlld Document
```

### URL Support
```mlld
# Add content from URLs directly:
@add [https://raw.githubusercontent.com/example/repo/main/README.md]

# Assign URL content to variables:
@path docs = "https://example.com/api-docs.md"
@text readme = [https://example.com/README.md]
```

## Philosophy: Simplicity in Files, Complexity in Modules

mlld's design philosophy centers on keeping `.mld` files simple and readable while abstracting complexity into reusable modules. Instead of adding language features, we encourage using modules:

```mlld
# Don't try to implement complex logic in mlld
# Instead, import capabilities from modules:

@import { parallel, retry, cache, pipeline } from @mlld/core
@import { validateSchema, transform } from @myorg/data-utils

# Simple, readable mlld:
@data results = @parallel(@tasks, { concurrency: 5 })
@data validated = @validateSchema(@results, @schema)
```

## Common Pitfalls to Avoid

### 1. Treating mlld as a Template Language
```mlld
âŒ This is {{name}}'s document     # Won't work - no @ directive
âœ… @add [[This is {{name}}'s document]]
```

### 2. Forgetting Command Brackets
```mlld
âŒ @run npm install
âœ… @run [(npm install)]
âŒ @run js console.log("hello")
âœ… @run js [(console.log("hello"))]
```

### 3. Using @ When Creating Variables
```mlld
âŒ @text @myvar = "value"
âœ… @text myvar = "value"
```

### 4. Mixing Variable Syntaxes
```mlld
âŒ @add [[Hello @name]]           # Wrong syntax in template
âŒ @run [(echo "{{message}}")]    # Wrong syntax in command
âœ… @add [[Hello {{name}}]]        # Correct template syntax
âœ… @run [(echo "@message")]        # Correct command syntax

# String literal vs command context example:
@text name = "Alice"
@text literal = "Hello @name"     # Result: "Hello @name" (literal)
@run [(echo "Hello @name")]       # Result: "Hello Alice" (interpolated)
```

### 5. Trying to Nest Function Calls
```mlld
âŒ WRONG: Trying to call mlld functions inside commands
@exec helper(x) = @run [(echo "@x")]
@run [(
  RESULT=$(@helper("test"))  # This doesn't work!
  echo $RESULT
)]

âœ… RIGHT: Call functions at directive level
@text result = @helper("test")
@run [(echo "@result")]

âœ… BETTER: Use foreach for multiple operations
@data results = foreach @helper(@items)
```

### 6. String Concatenation Instead of Templates
```mlld
âŒ WRONG: Trying to concatenate procedurally
# Attempting to build strings piece by piece

âœ… RIGHT: Use templates
@text greeting(name, time) = [[Good {{time}}, {{name}}!]]
@add @greeting("Alice", "morning")
```

### 7. Complex Logic in mlld
```mlld
âŒ WRONG: Implementing algorithms in mlld
# Don't try to write sorting algorithms or complex data manipulation

âœ… RIGHT: Use helper functions or modules
@exec sortData(data) = @run js [(data.sort((a, b) => a.name.localeCompare(b.name)))]
@data sorted = @sortData(@users)
```

### 8. JavaScript Confusion
While you CAN write JavaScript in mlld, it's best kept simple:
```mlld
# Okay for simple cases:
@run js [(console.log("Debug: " + @count))]

# For complex logic - create a helper:
@exec processData(data) = @run js [(
  // Your complex logic here
  return data.map(d => ({...d, processed: true}))
)]

# Or better yet - create a module:
@import { processData } from @myorg/utils
@data result = @processData(@rawData)
```

### 9. No Early Exit
mlld doesn't have `return` or `exit` - design your flow instead:

```mlld
# âŒ WRONG: Trying to exit early
@when @error: [
  true => @run [(exit 1)]  # This won't work!
]

# âœ… RIGHT: Use conditional flow
@when @isValid: [
  true  => @data continue = true
  false => @add [[âŒ Validation failed]]
]

@when @continue: [
  true => @runMainProcess()
]

# âœ… BETTER: Let the workflow complete naturally
@data validation = @validate(@input)
@when @validation.valid: [
  true  => @processData(@input)
  false => @add [[Error: {{validation.message}}]]
]
# Workflow ends naturally - no forced exit needed
```

## Orchestration Patterns

mlld shines when orchestrating external tools and data. Here are patterns that showcase its strengths:

### Pattern 1: Tool Orchestration
```mlld
# Orchestrating multiple Claude sessions for QA
@data testAreas = [
  { "name": "auth", "files": ["auth/*.ts"], "tests": ["test/auth/*"] },
  { "name": "api", "files": ["api/*.ts"], "tests": ["test/api/*"] }
]

@exec runQA(area) = @run [(
  echo "Testing {{area.name}} module"
  claude -p "Test the {{area.name}} functionality" \
    --allowedTools "Bash,Read,Write"
)]

@data results = foreach @runQA(@testAreas)
```

### Pattern 2: Data Pipeline
```mlld
# Processing data through multiple stages
@import { fetchData, validate, transform } from @data/pipeline

@data raw = @fetchData("https://api.example.com/users")
@data valid = @validate(@raw, { schema: "user" })
@data transformed = @transform(@valid, { format: "report" })

@add [[Processed {{transformed.count}} records successfully]]
```

### Pattern 3: Conditional Workflows
```mlld
# Environment variables via @INPUT (requires mlld.lock.json allowedEnv)
@import { NODE_ENV, API_KEY } from @INPUT

@exec loadConfig(env) = @run [(cat "./config/@env.json")]
@data config = @loadConfig(@NODE_ENV)

@when @config.debug => @add [[Debug mode enabled]]
```

## Workflow Patterns

### Pattern: Step-by-Step Processing
```mlld
# Each step produces data for the next
@data raw = @fetchData(@source)
@data validated = @validateData(@raw)
@data processed = @processData(@validated)
@data report = @generateReport(@processed)
@add @report
```

### Pattern: Guarded Execution
```mlld
# Only proceed if previous steps succeed
@data envCheck = @validateEnvironment(["API_KEY", "DB_URL"])

@when @envCheck.valid: [
  true  => @data canProceed = true
  false => @add [[âŒ {{envCheck.summary}}]]
]

@when @canProceed: [
  true => @data results = @runMainProcess()
]
```

### Pattern: Module-First Design
```mlld
# Don't implement logic - import it
@import { validateEmail, sanitizeInput } from @company/validators
@import { sendNotification } from @company/notifications

# Your workflow just orchestrates
@data cleanEmail = @sanitizeInput(@userEmail)
@when @validateEmail(@cleanEmail) => @sendNotification(@cleanEmail, @message)
```

## The Module Philosophy

mlld modules aren't libraries - they're capability providers. Design them like microservices:

### Good Module Design
```mlld
---
module: @myorg/github-utils
description: GitHub API operations
---

# Single responsibility: GitHub operations
@exec getPR(number, repo) = @run [(gh pr view...)]
@exec listIssues(repo) = @run [(gh issue list...)]
@exec createRelease(tag, notes) = @run [(gh release create...)]

@data module = {
  "getPR": @getPR,
  "listIssues": @listIssues,
  "createRelease": @createRelease
}
```

### Module Anti-Patterns
```mlld
# âŒ Kitchen sink module with unrelated functions
# âŒ Modules that try to be frameworks
# âŒ Modules with side effects on import
# âœ… Focused modules that do one thing well
```

## Reading mlld Code

When reading mlld, look for these patterns:

1. **Section Headers** = Major workflow phases
   ```
   ## ðŸ“Š Data Collection
   ## ðŸ” Validation  
   ## ðŸ“¤ Output Generation
   ```

2. **@when chains** = Decision trees
   - Read them like a flowchart
   - Each branch is a possible path

3. **@data flow** = Follow the data
   - Each @data assignment transforms or enriches
   - Variable names tell the story

4. **Module imports** = Available capabilities
   - Like looking at package.json
   - Tells you what the workflow can do

Example workflow reading:
```mlld
# Looking at imports tells you: "This workflow works with GitHub and sends emails"
@import { getPR, commentOnPR } from @company/github
@import { sendAlert } from @company/notifications

# Section headers show the flow: Check â†’ Validate â†’ Notify
## ðŸ” Check PR Status
@data pr = @getPR(@PR_NUMBER)

## âœ… Validate Changes  
@when @pr.mergeable: [
  true  => @data status = "ready"
  false => @data status = "blocked"
]

## ðŸ“§ Send Notifications
@when @status: [
  "ready"   => @commentOnPR(@PR_NUMBER, "Ready to merge!")
  "blocked" => @sendAlert("PR {{PR_NUMBER}} needs attention")
]
```

## Best Practices

1. **Keep .mld files readable**: They should make sense as Markdown documents
2. **Use modules for complexity**: Don't try to implement algorithms in mlld
3. **Explicit over implicit**: Always be clear about what produces output
4. **Test incrementally**: Use `@add` to verify variable values during development
5. **Think orchestration**: mlld excels at coordinating tools and data flows
6. **Create helpers liberally**: If you need it twice, make it a helper function
7. **Embrace constraints**: Working with mlld's design leads to cleaner solutions

## Example: Well-Structured mlld File

```mlld
---
description: Data processing pipeline for user analytics
version: 1.0.0
---

# User Analytics Pipeline

This document processes user data and generates insights.

@import { fetchData, validateUsers } from @analytics/core
@import { generateReport } from @company/reporting

## Configuration

@data config = {
  "apiEndpoint": "https://api.example.com",
  "batchSize": 100,
  "outputFormat": "markdown"
}

## Data Processing

@text status(phase) = [[âœ“ Completed: {{phase}}]]

### 1. Fetch User Data
@data users = @fetchData(@config.apiEndpoint)
@add @status("Data fetching")

### 2. Validate and Clean
@data validUsers = @validateUsers(@users)
@add @status("Validation")

### 3. Generate Report
@data report = @generateReport(@validUsers, @config)
@add @report

### 4. You can use @output to target specific locations and to handle conditional output:
@output @mydefinedcommand(var,othervar) [path/to/file.md]
@when @variable [ @contains("hi") ] => @output @add "Hello" [path/to/file.md]
Read more about output in docs/output.md

## Summary

@add [[Processed {{validUsers.length}} valid users out of {{users.length}} total.]]
```

## Execution Context Reference

Understanding where different variable syntaxes work is crucial:

| Context | Syntax | Example | Notes |
|---------|--------|---------|-------|
| Templates `[[...]]` | `{{variable}}` | `[[Hello {{name}}!]]` | Double brackets, double braces |
| Backtick templates | `@variable` | `` `Hello @name!` `` | Simpler template syntax |
| Commands `[...]` | `@variable` | `[echo "@message"]` | @ prefix for interpolation |
| JavaScript | Plain names | `[(array.join(sep))]` | Parameters are JS variables |
| String literals | No interpolation | `"Hello @name"` | @name is literal text |
| Directive level | `@variable` | `@add @greeting` | Direct variable reference |

### Key Rules:
- **In templates**: Always use `{{variable}}` or `{{object.field}}`
- **In backtick templates**: Use `@variable` or `@object.field`
- **In commands**: Always use `@variable` or `@object.field`
- **In JavaScript**: Parameters become plain JavaScript variables
- **String assignments**: Variables are NOT interpolated (they're literals)

## Remember

mlld empowers everyone to create versionable, collaborative "pipelines of thought." It achieves this by being an orchestration language that looks and reads like a document, not by being a template system or programming language.

When writing mlld:
- Think in terms of discrete processing steps, not text interpolation
- Embrace the constraints - they lead to cleaner solutions
- Use helpers and modules for complexity
- Keep your .mld files simple and readable

The power comes from composition: simple directives in your files, powerful capabilities in your modules.
