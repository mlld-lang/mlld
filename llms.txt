<MLLD_GUIDE version="2.0.0-rc63">
<TOC>
<OVERVIEW> ......................... Purpose, two execution modes, "What mlld IS/ISN'T," mental model shift.
<CORE_RULES>
  <RULE_1_SLASHES_START_LINES> ..... Only lines beginning with `/` are mlld; everything else is text.
  <RULE_2_VARIABLE_SYNTAX> ......... Create with /var @x = ‚Ä¶ ; reference with @x in templates/commands.
  <RULE_3_COMMANDS_NEED_BRACES> .... All commands use braces; language specifiers; /exe shortcuts.
  <RULE_4_OUTPUT_SOURCES> .......... Only /show, /run, /output emit output.
  <RULE_5_INTERPOLATION_CONTEXTS> .. Backticks/double-colon/triple-colon, quotes, and command contexts.
  <RULE_6_FIELD_ACCESS> ............ Dot + index access for objects/arrays; array slicing [start:end]; .data/.json parse JSON strings.
  <RULE_7_PARAMETERIZED_CONTENT> ... Reusable templates and functions via /exe.
  <RULE_8_FILE_LOADING> ............ Angle brackets load file contents; globs; metadata fields; safety.
  <RULE_9_IMPORTS> ................. Modules, paths, registries; "as namespace."
  <RULE_10_WHEN_OVERVIEW> .......... When forms (bare, first, simple) ‚Äì full detail in CONTROL_FLOW.
  <RULE_11_ITERATION_OVERVIEW> ..... foreach and /for ‚Äì full detail in CONTROL_FLOW.
  <RULE_12_OPERATORS> .............. Logical, comparison, ternary operators for expressions.
</CORE_RULES>
<SYNTAX>
  <VARIABLES> ...................... Types, primitives, command results, code execution.
  <TEMPLATES> ...................... Backticks, ::‚Ä¶::, :::‚Ä¶:::; interpolation rules.
  <FILE_LOADING> ................... Angle brackets, metadata fields, globs, "as" templates, detection rules.
  <BUILTIN_METHODS> ................ Array and string methods: includes, indexOf, join, split, etc.
  <PIPELINES> ...................... Operator |, transformers, @ctx/@p context, retry/hints, inline effects, parallel groups with ||.
  <COMMENTS> ....................... ">>" and "<<" comments (start/end-of-line).
  <RESERVED_VARIABLES> ............. @now, @input, @base, @debug.
</SYNTAX>
<COMMANDS>
  <RUN_VS_RUN_SH> .................. Decision tree, security & syntax differences, param passing.
  <EXE_EXECUTABLES> ................ Defining shell/js/node/template/section executables; shadow env intro.
  <OUTPUT_DIRECTIVE> ............... Write to files/stdout/stderr with optional formats.
  <LOG_DIRECTIVE> .................. Syntactic sugar for /output to stdout; works in action contexts.
</COMMANDS>
<CONTROL_FLOW>
  <WHEN_DECISIONS> ................. Bare/first/simple forms, /exe...when patterns, wildcard (*), none keyword.
  <ITERATION> ...................... foreach vs /for; nested loops; objects with _key; collection form.
  <NO_EARLY_EXIT> .................. Design flows instead of exits; patterns.
</CONTROL_FLOW>
<MODULES> .......................... Module-first philosophy; imports; helpers; shadow environments; isolation.
<PATTERNS> ......................... Tool orchestration; data pipelines; conditional workflows; guarded/step-by-step.
<CONFIGURATION>
  <ENVIRONMENT_VARIABLES> .......... Allow-list, @input import.
  <FRONTMATTER> .................... Document metadata block.
  <PATHS_AND_URLS> ................. Quoted/unquoted paths, dynamic paths, URL loading.
  <RESOLVERS> ...................... Prefixes, resolution priority, import type modifiers, custom config.
  <REGISTRY> ....................... Publishing workflow, version management, required frontmatter, commands.
  <PUBLISHING_PRIVATE_MODULES> ..... Auth, repo layout, commands.
</CONFIGURATION>
<COMMON_MISTAKES>
  <MISTAKE_MISSING_AT> ............. Create variables with @; directives use /.
  <MISTAKE_USING_AT_FOR> ........... @run is invalid; use /run on LHS and run / implicit RHS.
  <MISTAKE_INTERPOLATION> .......... Interpolation only in directive/template contexts.
  <MISTAKE_NOT_TEMPLATE_LANG> ...... mlld ‚â† template engine; use /show or /exe.
  <MISTAKE_FILE_VS_STRING> ......... Angle brackets load content; quotes hold literal filenames.
  <MISTAKE_XML_VS_FILE_TAGS> ....... <thinking> is plain text; <file.txt> is a file ref (has ./*/@).
  <MISTAKE_NESTED_FUNC_CALLS> ...... Don't shell-call @func inside commands; assign then use.
  <MISTAKE_STRING_CONCAT> .......... Prefer templates over procedural concatenation.
  <MISTAKE_COMPLEX_LOGIC> .......... Move algorithms into helpers/modules.
  <MISTAKE_IMPORT_BRACKETS> ........ Know when to use angle brackets for path resolvers.
  <MISTAKE_NO_EARLY_EXIT> .......... Model flows via /when rather than exits.
</COMMON_MISTAKES>
<REFERENCE> ........................ Execution context table, syntax summary, quick transforms list.
<SEE_ALSO> ......................... Documentation, examples repository, source code.
</TOC>

<OVERVIEW>
mlld is a modular prompt scripting language for dynamically assembling context and orchestrating LLMs‚Äîthink Make + npm for the LLM era, or a Unix pipe for chaining discrete AI/tool steps. It's designed to be written directly in Markdown: readable as docs, executable as workflows.

Two modes:

1. Markdown mode (default): any line not starting with `/`
2. mlld mode: lines starting with `/` (directives)

What mlld IS:

* üìã A workflow orchestrator (like Make + npm for the AI era)
* üé≠ A conductor's baton (you conduct, tools play)
* üìù Executable documentation (reads like a guide, runs like a script)
* üö¶ A logical router (route data and actions based on conditions)

What mlld ISN'T:

* ‚ùå A template engine (not Jinja/Handlebars)
* ‚ùå A shell script replacement (it orchestrates shells; doesn't replace them)

Mental model shift:

* ‚ùå "How do I implement this?" ‚Üí ‚úÖ "What tool/module handles this?"
* ‚ùå "I need an if-statement" ‚Üí ‚úÖ "I need a decision point"
* ‚ùå "Let me concatenate strings" ‚Üí ‚úÖ "Let me create a template"

Think Docker Compose or GitHub Actions: declare what happens, don't program how. </OVERVIEW>

<CORE_RULES>
<RULE_1_DIRECTIVES_START_LINES>
Only directives on lines beginning with `/` are executed.

```mlld
‚ùå Hello @name! Let me /show something.
‚úÖ
/var @greeting = `Hello @name!`
/show @greeting
```

</RULE_1_DIRECTIVES_START_LINES>

<RULE_2_VARIABLE_SYNTAX>
Create with `/var @name = "Alice"`. Reference with `@name` in templates/commands.

```mlld
/var @name = "Alice"
/show `Hello @name!`
/run {echo "User: @name"}
/run js (@name) { console.log("Hi", name) }
```

</RULE_2_VARIABLE_SYNTAX>

<RULE_3_COMMANDS_NEED_BRACES>
Every command needs braces. Use language specifiers when needed. Define executables with `/exe`.

```mlld
‚ùå /run echo "hello"
‚úÖ /run {echo "hello"}

# Language specifiers.
/run js {console.log("hi")}
# Executables
/exe @hi() = run {echo hi}
/exe @block() = run sh {
  echo "multi"; ls -la
}
/exe @calc(x) = js { return @x * 2 }
```

</RULE_3_COMMANDS_NEED_BRACES>

<RULE_4_OUTPUT_SOURCES>
Only these produce output: `/show`, `/run`, `/output`. Everything else mutates state.

```mlld
/var @secret = "hidden"      # no output
/show `Visible`
/run {echo "Also visible"}
```

</RULE_4_OUTPUT_SOURCES>

<RULE_5_INTERPOLATION_CONTEXTS>
Default to `::...::` for inline templates, `.att` files for external templates (5+ lines). Switch to `:::...:::` or `.mtt` ONLY for Discord `<@userid>` mentions or heavy social media `@handle` usage.

**Quick Reference:**

| Syntax | Interpolation | Pipes | Loops | Use For |
|--------|---------------|-------|-------|---------|
| `::...::` | `@var` `<file>` `@exe()` | ‚úì | ‚úì | **Default inline** |
| `.att` | `@var` `<file>` `@exe()` | ‚úì | ‚úì | **Default external (5+ lines)** |
| `` `...` `` | `@var` `<file>` `@exe()` | ‚úì | ‚úì | Same as `::...::` (preference) |
| `"..."` | `@var` `<file>` `@exe()` | ‚úì | ‚úó | Single-line only |
| `:::...:::` | `{{var}}` only | ‚úó | ‚úó | Discord/social escape hatch |
| `.mtt` | `{{var}}` only | ‚úó | ‚úó | Discord/social external |
| `'...'` | None (literal) | ‚úó | ‚úó | Literal text |
| `{...}` | `@var` `<file>` | ‚úó | ‚úó | Commands/code |

**Inline templates:**

```mlld
>> Double-colon (default)
/var @msg = ::Hello @name!::
/var @doc = ::Use `npm test` before @env::
/var @report = ::
Status: @status
Config: <@base/config.json>
Data: @data|@json
::

>> Backticks (alternative)
/var @msg = `Hello @name!`
/var @multi = `
Line 1: @var
Line 2: @other
`

>> Double quotes (single-line only)
/var @path = "@base/files/@filename"
/run {echo "Processing @file"}

>> Triple-colon (Discord/social only)
/var @alert = :::Alert <@{{adminId}}>! Issue from <@{{userId}}>:::
/var @tweet = :::Hey @{{user}}, check this! cc: @{{team1}} @{{team2}}:::

>> Single quotes (literal)
/var @literal = '@name stays literal'
```

**External templates:**

```mlld
>> .att files (default for 5+ lines)
>> file: templates/deploy.att
# Deployment: @env
Status: @status
Config: <@base/config/@env.json>

>> usage
/exe @deploy(env, status) = template "templates/deploy.att"
/show @deploy("prod", "success")

>> .mtt files (Discord/social only)
>> file: templates/discord.mtt
üö® Alert <@{{adminId}}>!
Reporter: <@{{reporterId}}>
Severity: {{severity}}

>> usage
/exe @alert(adminId, reporterId, severity) = template "templates/discord.mtt"
```

**Loops (::, backticks, .att only):**

```mlld
/var @list = ::
/for @item in @items
- @item.name: @item.value
/end
::

>> Requirements: /for and /end at line start
>> NOT supported in :::...:::, .mtt, or "..."
```

**Trade-offs when using Discord/social escape hatch:**

| Feature | `::...::` / `.att` | `:::...:::` / `.mtt` |
|---------|-------------------|----------------------|
| `@var` interpolation | ‚úì | ‚úó Use `{{var}}` |
| `<file.md>` loading | ‚úì | ‚úó |
| `@exe()` calls | ‚úì | ‚úó |
| Pipes `\|` | ‚úì | ‚úó |
| Loops | ‚úì | ‚úó |
| Discord `<@id>` | Escape `\<@id\>` | ‚úì Natural |
| Many `@handles` | Works | ‚úì Cleaner |

**Common mistakes:**

```mlld
>> ‚úó Using {{}} in ::...::
/var @msg = ::Hello {{name}}::        >> {{name}} is literal
/var @msg = ::Hello @name::           >> ‚úì

>> ‚úó Using @var in :::...:::
/var @msg = :::Hello @name:::         >> @name is literal
/var @msg = :::Hello {{name}}:::      >> ‚úì

>> ‚úó Using ::: without Discord/social need
/var @msg = :::Status: {{status}}:::  >> Loses all features
/var @msg = ::Status: @status::       >> ‚úì Full features

>> ‚úó Importing template files
/import { @tpl } from "./file.att"    >> Error
/exe @tpl(x) = template "./file.att"  >> ‚úì
```

</RULE_5_INTERPOLATION_CONTEXTS>

<RULE_6_FIELD_ACCESS>
Objects/arrays use dot+index in directives and `{{ }}` in ::: templates only. Arrays support slicing with `[start:end]` and builtin methods.

```mlld
/var @user = {"name":"Alice","scores":[10,20,30]}
# Directives:
/show @user.name            # Alice
/show @user.scores.1        # 20

# Array slicing:
/var @arr = [1,2,3,4,5]
/show @arr[0:3]             # [1,2,3]
/show @arr[-2:]             # [4,5] - last 2
/show @arr[:-1]             # [1,2,3,4] - all except last
/show @arr[2:]              # [3,4,5] - from index 2

>> JSON string accessors:
/var @jsonStr = '[{"name":"Alice"},{"name":"Bob"}]'
/exe @process(items) = js { return items.filter(u => u.name === "Alice") }
/var @result = @process(@jsonStr.data)    << .data/.json parse JSON
/var @length = @jsonStr.text.length       << .text/.content preserve strings

>> Builtin methods on arrays/strings:
/var @list = ["apple", "banana", "cherry"]
/var @text = "Hello World"
/show @list.includes("banana")      << true
/show @list.indexOf("cherry")       << 2
/show @list.join(", ")              << "apple, banana, cherry"
/show @text.toLowerCase()           << "hello world"
/show @text.split(" ")              << ["Hello", "World"]
/show @text.includes("World")       << true

>> Double-colon templates:
/show ::@user.name has @user.scores.0::
```

</RULE_6_FIELD_ACCESS>

<RULE_7_PARAMETERIZED_CONTENT>
Use `/exe` for parameterized templates or commands.

```mlld
/exe @greet(name) = run {echo "Hello @name"}
/run @greet("Bob")

/exe @welcome(name, role) = ::Welcome @name, our new @role!::
/show @welcome("Rae","developer")
```

</RULE_7_PARAMETERIZED_CONTENT>

<RULE_8_FILE_LOADING>
Angle brackets load file contents (not filenames). Works in variables, templates, commands, and with globs. Only `<‚Ä¶>` containing `.`, `/`, `*`, or `@` are treated as file references‚Äîso pseudo-XML tags like `<OVERVIEW>` are safe, plain text.

```mlld
/var @content = <README.md>                 # file contents
/show <config.json>                         # prints file contents
/var @filesTxt = ["a.md","b.md"]            # literal names
/var @contents = [<a.md>, <b.md>]           # loaded contents

# Field access on loaded JSON
/var @authorEmail = <package.json>.author.email

# Globs + "as" templates
/var @toc = <docs/*.md> as "- [<>.fm.title](<>.relative)"
```

Data flows as native types:

```mlld
/var @cfg = <config.json>           # object, not JSON string
/var @users = @cfg.users            # array access works directly
/var @text = @cfg.text              # stringified JSON when needed
/var @parsed = @text.data           # parse JSON string to object
```

Inline transforms (pipes):

```mlld
/var @pretty = <data.json> | @json
/var @summary = `User data: @data|@json`
```

Security: By default, restricts to project root. Use `--allow-absolute` flag to permit absolute paths outside project.

</RULE_8_FILE_LOADING>

<RULE_9_IMPORTS>
Module imports and path imports. Import type keywords control resolution behavior.

```mlld
# Modules (no quotes)
/import { @parallel, @retry } from @mlld/core
/import @corp/utils as @corp

# Paths (quote & resolver via <> when needed)
/import { @readme } from "@base/README.md"
/import { @helper } from "./utils.mld"

# Import types (optional, auto-inferred when omitted)
/import module { @api } from @corp/tools        # pre-installed registry module
/import static { @config } from "./config.json"  # embedded at parse time
/import live <https://status.api.io> as @status  # fresh every execution
/import cached(30m) <https://feed.xml> as @feed  # cached with TTL (5m, 1h, 7d)
/import local { @helper } from @me/dev-module    # llm/modules/ during dev
```

- Prefix identifiers in the braces with `@` so imported names match runtime variable syntax (e.g., `{ @helper }`).
- Aliases after `as` must include `@` (e.g., `as @utils`), and wildcard imports require `* as @alias`.
- Import types: `module` (offline after install), `static` (zero runtime cost), `live` (always fresh), `cached(TTL)` (smart caching), `local` (dev modules).
- When omitted, mlld infers the safest option.

</RULE_9_IMPORTS>

<RULE_10_WHEN_OVERVIEW>
/when drives decisions (bare, first, simple). Full details in <CONTROL_FLOW>.

```mlld
/when @isProd => show "Prod"
/when first [
  @role=="admin" => show "Admin"
  * => show "Guest"
]
```

</RULE_10_WHEN_OVERVIEW>

<RULE_11_ITERATION_OVERVIEW>
Use `foreach` to transform collections; use `/for` to execute/collect. Batch pipelines (`=> |`) run after iteration completes. Full details in <CONTROL_FLOW>.

```mlld
/var @names = ["Alice","Bob"]
/exe @greet(name) = ::Hi @name!::
/var @gs = foreach @greet(@names)
/for @n in @names => show `Name: @n`

# Batch pipelines - process collected results
/var @numbers = for @n in [1,2,3,4] => @n => | @sum
/var @pairs = foreach @duplicate(@data) => | @flatten

# Optional parallel forms
/for parallel @n in @names => show @n              # uses MLLD_PARALLEL_LIMIT (default 4)
/var @caps = for 2 parallel @n in @names => @greet(@n)  # per-loop cap override
/for (3, 1s) parallel @n in @names => show @n      # cap 3 with 1s pacing between starts
```

</RULE_11_ITERATION_OVERVIEW>

<RULE_12_OPERATORS>
Logical, comparison, and ternary operators for expressions and conditions.

Comparison: `<`, `>`, `<=`, `>=`, `==`, `!=`
Logical: `&&`, `||`, `!`
Ternary: `condition ? trueVal : falseVal`

```mlld
# Expressions
/var @isValid = @score > 80 && @submitted
/var @status = @isPro ? "premium" : "basic"
/var @canEdit = @isOwner || (@role == "editor" && !@isLocked)
/var @opposite = !@condition

# Parentheses for precedence
/var @complex = (@a || @b) && (@c != @d)

# In /when conditions
/when @tokens > 1000 && @mode == "production" => show "High usage"
/when (@role == "admin" || @role == "mod") && @active => show "Privileged"
```

Type coercion: `"true" == true`, `"false" == false`, `null == undefined`
Precedence: `!` ‚Üí comparison ‚Üí `&&` ‚Üí `||` ‚Üí `?:`
</RULE_12_OPERATORS>
</CORE_RULES>

<SYNTAX>
<VARIABLES>
Create primitives, arrays, objects, or assign from command/code results. Primitives preserve JS types in `/exe js`.

```mlld
/var @n = 42
/var @price = 19.99
/var @ok = true
/var @arr = [1,2,3]
/var @obj = {"key":"value"}

/exe @add(a,b) = js { return a + b }
/var @sum = @add(@n, 8)         # 50 (number)

/var @date = run "date"         # result of command
/var @readme = <README.md>      # file contents
```

</VARIABLES>

<TEMPLATES>
Prefer backticks; use :: for backticks-in-text; ::: when many @mentions.

```mlld
/var @message = `Hello @name, welcome!`
/var @doc = ::Use `mlld` to orchestrate::
/var @tweet = :::Hey @{{handle}}‚Äî{{msg}}:::

When-expressions are first-class:

```mlld
# Direct assignment
/var @status = when [ @score > 90 => "A" * => "F" ]

# In array literals
/var @arr = [ 1, when [ @flag => 2 ], 3 ]

# As function arguments
/exe @fmt(x) = `val:@x`
/show @fmt(when [ @cond => "yes" * => "no" ])
```
```

Inline template control:

- `/for ‚Ä¶ /end` is available in backticks and `::‚Ä¶::` templates.
- `:::‚Ä¶:::` templates do not support loops; they support `{{var}}` interpolation and inline `/show` only.

Examples:

```mlld
# Backtick wrapper
/var @tpl = `
/for @x in ["A","B"]
- @x
/end
`
/show @tpl

# Double-colon wrapper
/var @items = ["A","B"]
/var @msg = ::
/for @x in @items
- @x
/end
::
/show @msg
```

Notes:
- Line-start only: `/for` and `/end` must begin at a line start inside the template body.
- No loops in `[[...]]` or `:::...:::` templates.

</TEMPLATES>

<FILE_LOADING>
Angle brackets load, quotes store literal paths. Field access and globs are supported.

```mlld
/var @author = <package.json>.author
/var @firstEmail = <data.json>.users[0].email
/var @md = <docs/*.md> as "# <>.filename"
```

AST selection: add `{ ... }` inside the angle brackets to pull specific definitions or usages.

```mlld
/var @handlers = <src/service.ts { handleRequest, (logger.warn) }>
/var @templated = <src/**/*.py { fetch_user }> as "## <>.name\n<>.code"
```

- Bare identifiers return matching definitions; parentheses return definitions that reference the name.
- Supported extensions: `.js`, `.ts`, `.jsx`, `.tsx`, `.mjs`, `.py`, `.pyi`, `.rb`, `.go`, `.rs`, `.sol`, `.java`, `.cs`, `.c`, `.cpp`, `.h`, `.hpp`.
- Glob matches add a `file` property so you can trace the source path.
- Patterns that miss return `null`, preserving the request order.

Detection rule: only `<‚Ä¶>` with `.`, `/`, `*`, or `@` are treated as file refs. XML-like `<TAG>` is plain text.

File metadata fields: `content` (default), `filename`, `relative`, `absolute`, `tokens`, `tokest`, `fm` (frontmatter), `json` (for .json files)

URL metadata fields: All file fields plus: `url`, `domain`, `title`, `description`, `html`, `text`, `md`, `headers`, `status`, `contentType`
</FILE_LOADING>

<BUILTIN_METHODS>
Variables support builtin methods for common operations. Methods are called with parentheses and can accept arguments.

**Array Methods:**
- `@array.includes(value)` - Returns true if array contains value
- `@array.indexOf(value)` - Returns index of value, or -1 if not found
- `@array.length()` - Returns array length
- `@array.join(separator)` - Joins array elements into string

**String Methods:**
- `@string.includes(substring)` - Returns true if string contains substring
- `@string.indexOf(substring)` - Returns index of substring, or -1
- `@string.length()` - Returns string length
- `@string.toLowerCase()` - Converts to lowercase
- `@string.toUpperCase()` - Converts to uppercase
- `@string.trim()` - Removes leading/trailing whitespace
- `@string.startsWith(prefix)` - Returns true if starts with prefix
- `@string.endsWith(suffix)` - Returns true if ends with suffix
- `@string.split(separator)` - Splits into array

```mlld
/var @fruits = ["apple", "banana", "cherry"]
/var @message = "Hello World"

# Array operations
/show @fruits.includes("banana")    # true
/show @fruits.indexOf("cherry")     # 2
/show @fruits.join(" and ")         # "apple and banana and cherry"

# String operations
/show @message.toLowerCase()        # "hello world"
/show @message.split(" ")          # ["Hello", "World"]
/show @message.includes("World")    # true

# With variable arguments
/var @search = "banana"
/show @fruits.includes(@search)     # true
```

Note: Methods are parsed as field access exec patterns (`@obj.method(args)`) and executed as ExecInvocations internally.
</BUILTIN_METHODS>

<PIPELINES>
Chain stages with `|`. Built-ins: @json, @xml, @csv, @md (upper/lower accepted). All `/exe` functions work in pipelines (native mlld, JS, shell). Stages access context via `@ctx` and pipeline history via `@p`.

JSON parsing modes: `@json` (loose by default), `@json.strict` (enforce strict JSON), `@json.loose` (explicit relaxed parsing with single quotes, trailing commas, comments).

```mlld
/var @users = run {cat users.json} | @json | @csv
/exe @double(n) = js {(@n*2)}
/var @x = run {echo "5"} | @double

# JSON parsing variants
/var @relaxed = @input | @json.loose   # JSON5: single quotes, trailing commas, comments
/var @strict = @input | @json.strict   # strict JSON only
/var @auto = @input | @json            # loose mode with helpful errors

# Native mlld functions in pipelines
/exe @filterHigh(items) = for @item in @items => when [
  @item.priority == "high" => @item
  none => skip
]
/var @data = '[{"priority":"high"},{"priority":"low"}]'
/var @filtered = @data.data | @filterHigh | @json

# Retry with hints
/exe @validator(input) = when [
  @input.valid => @input
  @ctx.try < 3 => retry "need more detail"
  * => "fallback"
]
/var @res = @raw | @validator

# Best-of-N pattern
/exe @selectBest(response) = when [
  @response.score > 8 => @response
  @ctx.try < 5 => retry { temperature: 0.9 }
  * => @selectHighestScore(@p.retries.all)
]
```

Context object (@ctx): `try` (attempt #), `tries` (array), `stage`, `input`, `hint` (from retry), `lastOutput`, `isPipeline`

Pipeline array (@p): `@p[0]` (input), `@p[-1]` (previous output), `@p.retries.all` (full history)

Inline effects: `@data | @transform | log` (stderr), `@data | output to "file.txt"` (inline write)

Formats (`with { format: "json|csv|xml|text" }`): guide parsing for pipeline stages.

Parallel groups (`||`): run multiple commands as one stage in parallel.

```mlld
# Two transforms run concurrently; outputs are collected in order
/exe @left(input) = `L:@input`
/exe @right(input) = `R:@input`
/exe @combine(input) = js {
  const arr = JSON.parse(input); // parallel stage returns a JSON array string
  return arr.join(' + ');
}

/var @out = "x" with { pipeline: [ @left || @right, @combine ] }
/show @out   # ‚Üí "L:x + R:x"

# Leading || runs parallel stages immediately
/var @results = || @fetchA() || @fetchB() || @fetchC()
/run || @fetchA() || @fetchB() || @fetchC()  # also works in /run
/exe @parallel() = || @helper1() || @helper2() | @combine  # and /exe

# With concurrency caps: (n, delay)
/var @capped = || @a() || @b() || @c() || @d() (2, 100ms)  # cap=2, 100ms pacing
```

Data flows as native types:
- Loaders return parsed data: `<file.json>` yields object, not JSON string
- Pipeline stages (including batch `=> |`) receive native types: `@data | @process` passes arrays/objects
- JavaScript functions get parsed values (no `JSON.parse()` needed)
- Use `.text` for stringified form, `.data` for structured access

Semantics:
* Grouping: `A || B || C` forms a single stage executed concurrently with a global cap.
* Leading `||`: Start pipeline with parallel execution. Syntax: `|| @a() || @b() || @c()` runs all three immediately.
* Equivalence: `|| @a() || @b()` produces same AST as `"" with { pipeline: [[@a, @b]] }`
* Ordering: Results preserve command order; next stage receives native array/object.
* Concurrency: Limited by `MLLD_PARALLEL_LIMIT` (default `4`).
* Retries: Returning `retry` inside a parallel group is not supported and aborts the pipeline. If you need retries, run validation after the group and request a retry of the previous (non-parallel) stage.
* Rate limits: 429/"rate limit" errors trigger per-command exponential backoff.
* Inline effects: Effects attached to commands in the group run after each command succeeds.

</PIPELINES>

<COMMENTS>
Use `>>` or `<<` for comments at start or end of lines.

```mlld
>> start-of-line
/show "Hello"  >> end-of-line
/var @x = 5    << end-of-line
```

</COMMENTS>

<RESERVED_VARIABLES>

* `@now` ‚Äì current timestamp
* `@input` ‚Äì stdin/env (must be allowed)
* `@base` ‚Äì project root
* `@debug` ‚Äì environment info
  </RESERVED_VARIABLES>

  </SYNTAX>

<COMMANDS>
<RUN_VS_RUN_SH>
Decision tree:

* Single line + pipes only (`|`) ‚Üí `run { ‚Ä¶ }`
* Needs `&&`, `||`, control flow, or multi-line ‚Üí `run sh { ‚Ä¶ }`
* JavaScript (no shell) ‚Üí `js { ‚Ä¶ }` (or `/exe ‚Ä¶ = js { ‚Ä¶ }`)

Parameter syntax:

* `run` / commands: interpolate with `@param`
* `run sh`: shell variables as `$param`

```mlld
# run (pipes only)
/run {echo Hello | tr '[:lower:]' '[:upper:]'}

# run with stdin (avoids shell escaping)
/var @data = '[{"name":"Alice"},{"name":"Bob"}]'
/run { cat | jq '.[] | select(.name == "Alice")' } with { stdin: @data }
>> OR pipe sugar:
/run @data | { cat | jq '.[] | select(.name == "Alice")' }

# run sh (multi-line/conditionals)
/run sh {
  npm test && npm run build || echo "Build failed"
}

# Executable wrappers (with stdin support)
/exe @safeDeploy(env) = run sh {
  npm test && npm run deploy:$env
}
/exe @processJson(data) = run @data | { cat | jq '.[]' }
```

Security: `run` forbids `&&`/`||` to reduce injection risk; escalate to `run sh` when necessary.

Large variables: For bash/sh executables, variables >128KB are automatically handled via heredocs (when `MLLD_BASH_HEREDOC=1`). For `/run` commands exceeding limits, use `/exe` with bash/sh instead.
</RUN_VS_RUN_SH>

<EXE_EXECUTABLES>
Define reusable commands/code/templates/sections.

```mlld
# Shell (single vs multi)
/exe @list(dir) = run {ls -la @dir | head -5}
/exe @script() = run sh {
  echo "Start"; ls -la
}

# JavaScript
/exe @add(a,b) = js { return a + b }

# Templates
/exe @greet(name) = `Hello @name!`

# Section extractor
/exe @intro(file) = <@file # Introduction>
```

Shadow environments (JS/Node):
Expose JS helpers across `js {}` blocks in the same module:

```mlld
/exe @double(n) = js { return n*2 }
/exe @cap(s) = js { return s[0].toUpperCase()+s.slice(1) }
/exe js = { double, cap }  # expose

/var @out = js { cap("hello") + ": " + double(5) }  # "Hello: 10"
```

</EXE_EXECUTABLES>

<OUTPUT_DIRECTIVE>
Write data to files or streams, with optional format.

```mlld
/output @content to "out.txt"
/output @data to "config.json"
/output @html to "page.html" as html
/output @message to stdout
/output @error to stderr
/output @config to "settings.yaml" as yaml
```

</OUTPUT_DIRECTIVE>

<LOG_DIRECTIVE>
Syntactic sugar for `/output to stdout`. Works in action contexts.

```mlld
/log @message                        # same as /output @message to stdout
/log `Processing: @item`

# In action contexts
/for @item in @items => log @item
/when @debug => log "Debug info"
/when [
  @valid => log "Success"
  none => log "Failed validation"
]
```

</LOG_DIRECTIVE> </COMMANDS>

<CONTROL_FLOW>
<WHEN_DECISIONS>
Forms:

* Simple: `/when @cond => action`
* Bare (evaluate all matches):

  ```mlld
  /when [
    @score > 90 => show "Excellent!"
    @isBonus => show "Bonus!"
    none => show "No matches"
  ]
  ```
* Switch (`first` stops at first match):

  ```mlld
  /when first [
    @role=="admin" => show "Admin"
    @role=="user"  => show "User"
    * => show "Guest"
  ]
  ```

`/exe...when` patterns (value-returning):

```mlld
# Basic handler with fallback
/exe @handler(input) = when [
  @input.valid => @input.value
  @ctx.try < 3 => retry "validation failed"
  none => "default"
]

# Switch-style with first
/exe @parser(type, data) = when first [
  @type == "json" => @parseJSON(@data)
  @type == "xml" => @parseXML(@data)
  @type == "csv" => @parseCSV(@data)
  * => @data
]

# Conditional transformer
/exe @process(item) = when [
  @item.priority > 5 => @urgent(@item)
  @item.archived => null
  * => @standard(@item)
]
```

Notes:

* RHS uses action words (no `/show` slash): `show`, `@func()`, `@var = "x"`
* `*` wildcard matches anything (catch-all)
* `none` executes only if no conditions matched (must appear after all regular conditions, incompatible with `*`)
* One action per line (repeat condition for multiple actions)
* Parentheses & `&&`/`||` supported in conditions
  </WHEN_DECISIONS>

<ITERATION>
`foreach` returns a transformed array; `/for` executes an action per item or collects results.

```mlld
# foreach (transform)
/var @names = ["alice","bob","charlie"]
/exe @greet(name) = ::Hi @name!::
/var @greetings = foreach @greet(@names)

# /for (execute)
/for @n in @names => show `Name: @n`

# collection form
/var @nums = [1,2,3]
/var @doubled = for @x in @nums => js { return @x * 2 }  # [2,4,6]

# objects and keys
/var @cfg = {"host":"localhost","port":3000}
/for @v in @cfg => show `@v_key: @v`

# nested for loops
/for @x in ["A","B"] => for @y in [1,2] => show `@x-@y`
# Output: A-1, A-2, B-1, B-2

# triple nesting
/for @x in @outer => for @y in @middle => for @z in @inner => show `@x/@y/@z`
```

When-expressions in for RHS:

```mlld
/var @xs = [1, null, 2, null, 3]
# Keep only non-null values
/var @filtered = for @x in @xs => when [
  @x != null => @x
  none => skip
]
# @filtered => ["1","2","3"]
```

Define foreach in /exe RHS and invoke:

```mlld
/exe @wrap(x) = `[@x]`
/exe @wrapAll(items) = foreach @wrap(@items)
/show @wrapAll(["a","b"]) | @join(',')
# => [a],[b]
```

Use /show foreach with options:

```mlld
/var @names = ["Ann","Ben"]
/exe @greet(n) = `Hello @n`
/show foreach @greet(@names) with { separator: " | ", template: "{{index}}={{result}}" }
# => 0=Hello Ann | 1=Hello Ben
```

Empty arrays are safe: `/for` emits nothing; `for ‚Ä¶ =>` returns `[]`.

Batch pipelines - process collected results after iteration:

```mlld
/var @numbers = for @n in [1,2,3,4] => @n => | @sum
/var @pairs = foreach @duplicate(@data) => | @flatten
/var @sorted = for @item in @items => @process(@item) => | @sortBy("priority")
```

Batch stage receives the collected array (or object) directly, so helpers work with native arrays/objects without manual parsing.

</ITERATION>

Parallel /for (optional):

```mlld
# Default cap from env (MLLD_PARALLEL_LIMIT, default 4)
/for parallel @x in @items => show @x

# Cap override and pacing between starts (units: s, m, h, d, w)
/for (2, 1s) parallel @x in @items => show @x

# Collection form preserves input order
/var @out = for 3 parallel @x in ["a","b","c"] => @upper(@x)
```

Notes:
- Directive form streams results as iterations finish (order not guaranteed); expression form returns results in input order.
- Concurrency capped by `MLLD_PARALLEL_LIMIT` unless overridden per loop.
- Pacing: optional minimum delay between iteration starts via `/for (n, interval) parallel ...` (units: ms, s, m, h).
- Rate limits: per‚Äëiteration 429/"rate limit" errors use exponential backoff.

<NO_EARLY_EXIT>
mlld has no `return/exit`. Model outcomes with `/when` and flags.

```mlld
/var @check = @validate(@input)
/when [
  @check.valid => @process(@input)
  !@check.valid => show `Error: @check.message`
]
```

</NO_EARLY_EXIT>
</CONTROL_FLOW>

<MODULES>
Module-first philosophy: keep `.mld` files readable; move complexity into focused modules that expose capabilities (like microservices). Avoid "kitchen sink" modules or side effects on import.

**Core patterns:**
* `/export { @func }` required (auto-export is legacy)
* Import types: `module` (registry), `static` (embedded), `live` (fresh), `cached(TTL)`, `local` (dev)
* Namespace imports avoid collisions: `as @alias`
* Executables preserve module scope (sibling variables always accessible)

**Creating modules:**

```mlld
---
name: text-utils
author: alice
version: 1.0.0
about: String helpers
needs: [js]
license: CC0
---

/exe @upper(s) = js { return s.toUpperCase() }
/exe @trim(s) = js { return s.trim() }
/export { @upper, @trim }
```

**Import patterns:**

```mlld
# Registry (offline after install)
/import { @helper } from @alice/utils
/import { @helper } from @alice/utils@1.0.0     # version
/import { @helper } from @alice/utils@beta      # tag

# Local files
/import { @config } from "./config.mld"
/import { @config } from <@base/config.mld>

# Namespace (avoid collisions)
/import @alice/utils as @alice
/import @bob/utils as @bob

# Import types (control caching)
/import module { @api } from @corp/tools         # cached
/import static { @prompt } from "./prompt.md"    # embedded
/import live <https://status.io> as @status      # always fresh
/import cached(1h) <https://feed> as @feed       # TTL cache
/import local { @dev } from @alice/experimental  # llm/modules/
```

**Local development:**

```bash
mlld install @alice/utils              # install from registry
mlld update @alice/utils               # update to latest
mlld ls                                # list installed
```

Dev modules in `llm/modules/` (flat structure, matched by frontmatter):

```
llm/modules/
‚îú‚îÄ‚îÄ my-utils.mld.md    # author: alice, name: experimental
‚îî‚îÄ‚îÄ helpers.mld        # author: bob, name: tools
```

```mlld
/import local { @helper } from @alice/experimental  # finds my-utils.mld.md
```

**Lock files (mlld-lock.json):**
* Auto-generated, tracks versions/hashes
* Commit to version control
* Only registry modules validated

</MODULES>

<PATTERNS>
Tool orchestration:

```mlld
/var @areas = [
  {"name":"auth","files":["auth/*.ts"],"tests":["test/auth/*"]},
  {"name":"api","files":["api/*.ts"],"tests":["test/api/*"]}
]
/exe @runQA(area) = run {echo "Testing @area.name" | cat}
/var @results = foreach @runQA(@areas)
```

Data pipeline:

```mlld
/import { @fetchData, @validate, @transform } from @data/pipeline
/var @raw = @fetchData("https://api.example.com/users")
/var @valid = @validate(@raw, { schema: "user" })
/var @report = @transform(@valid, { format: "report" })
/show `Processed @report.count users`
```

Conditional workflows:

```mlld
/import { @getPR, @commentOnPR } from @company/github
/var @pr = @getPR(@MLLD_PR_NUMBER)
/when first [
  @pr.mergeable => @status = "ready"
  * => @status = "blocked"
]
/when [
  @status=="ready"   => @commentOnPR(@MLLD_PR_NUMBER,"Ready to merge")
  @status=="blocked" => show "Needs attention"
]
```

Step-by-step & guarded execution:

```mlld
/var @processed = @data | @validate | @normalize | @analyze
/when [
  @processed.ok => @emitReport(@processed)
  !@processed.ok => show "‚ùå Validation failed"
]
```

</PATTERNS>

<CONFIGURATION>

mlld uses dual configuration:
- `mlld-config.json`: Your project settings (dependencies, preferences, resolver config)
- `mlld-lock.json`: Auto-generated locks (versions, hashes, sources)

Edit `mlld-config.json` manually; `mlld-lock.json` updates automatically.

<ENVIRONMENT_VARIABLES>
Allow environment variables in `mlld-lock.json` (prefix `MLLD_`), then import via `@input`.

```json
{
  "security": {
    "allowedEnv": ["MLLD_NODE_ENV","MLLD_API_KEY","MLLD_GITHUB_TOKEN"]
  }
}
```

```mlld
/import { @MLLD_NODE_ENV, @MLLD_API_KEY } from @input
/show `Running in @MLLD_NODE_ENV`
```

</ENVIRONMENT_VARIABLES>

<FRONTMATTER>
Use frontmatter to describe the pipeline:

```yaml
---
description: Pipeline description
version: 1.0.0
author: Your Name
---
```

</FRONTMATTER>

<PATHS_AND_URLS>
Paths may be literal (single quotes), interpolated (double), or bare resolver names; URLs are supported as sources.

```mlld
/var @dir = "./docs"
/var @userFile = "data/@username/profile.json"
/var @template = 'templates/@var.html'  # literal '@'

/show <https://raw.githubusercontent.com/org/repo/main/README.md>
/var @remote = <https://example.com/README.md>
```

</PATHS_AND_URLS>

<RESOLVERS>
Prefixes map @ references to content sources. Built-in types: LOCAL, HTTP, GITHUB, REGISTRY.

**Built-in resolvers (no config needed):**
* `@author/module` ‚Üí RegistryResolver (mlld-lang/registry)
* `@base/file` ‚Üí ProjectPathResolver (project root)
* Local paths `./file.mld` ‚Üí LocalResolver (fuzzy extension matching: .mld, .mld.md, .md)

**Quick setup:**

```bash
mlld alias --name notes --path ~/notes              # local prefix
mlld alias --name shared --path ../shared --global  # global prefix
mlld setup --github                                 # private repo wizard
```

**Custom prefixes (mlld-config.json):**

```json
{
  "resolvers": {
    "prefixes": [
      {
        "prefix": "@lib/",
        "resolver": "LOCAL",
        "config": { "basePath": "./src/lib" }
      },
      {
        "prefix": "@company/",
        "resolver": "GITHUB",
        "config": {
          "repository": "company/private-modules",
          "branch": "main",
          "basePath": "modules"
        }
      },
      {
        "prefix": "@cdn/",
        "resolver": "HTTP",
        "config": {
          "baseUrl": "https://cdn.example.com",
          "cacheTTL": "1h"
        }
      }
    ]
  }
}
```

**Resolution priority:**
1. Longest prefix match (`@company/auth/` beats `@company/`)
2. Resolver priority values: ProjectPath (10) ‚Üí Registry (15) ‚Üí Local/HTTP/GitHub (20)
3. Import types modify caching behavior, NOT which resolver is selected

**Import type modifiers:**
* Control caching/timing after resolver selects the source
* Resolver chosen by prefix/pattern; import type adjusts caching semantics
* `module` ‚Üí content-addressed cache
* `static` ‚Üí embedded in AST
* `live` ‚Üí always fresh
* `cached(TTL)` ‚Üí time-based cache
* `local` ‚Üí dev mode (llm/modules/)

</RESOLVERS>

<REGISTRY>
Public registry at github.com/mlld-lang/registry. First module requires PR review; updates publish directly.

**Publishing workflow:**

```bash
# First time (creates PR)
mlld publish my-tool.mld.md

# Updates (direct publish after first merge)
mlld publish my-tool.mld.md  # prompts for version bump

# Force PR workflow
mlld publish --pr my-tool.mld.md
```

**Required frontmatter:**

```yaml
---
name: my-tool
author: alice          # must match GitHub username
version: 1.0.0
about: Brief description
needs: [js, sh]        # runtime dependencies
needs-js: lodash       # package deps (legacy format)
needs-sh: git, curl    # command deps (legacy format)
license: CC0           # required
---
```

**Version management:**

```mlld
/import { @helper } from @alice/utils           # latest
/import { @helper } from @alice/utils@1.0.0     # exact version
/import { @helper } from @alice/utils@^1.0.0    # semver range
/import { @helper } from @alice/utils@beta      # tag
```

**Commands:**

```bash
mlld install @alice/utils              # install module
mlld install @alice/utils@1.0.0        # specific version
mlld update @alice/utils               # update to latest
mlld outdated                          # check for updates
mlld ls                                # list installed

# Publishing
mlld publish my-tool.mld.md            # publish/update
mlld publish --tag beta my-tool.mld.md # publish with tag
mlld publish --dry-run my-tool.mld.md  # validate without publishing

# Auto-detect dependencies
mlld add-needs my-tool.mld.md
```

**Module source:**
* GitHub repo ‚Üí references commit SHA (immutable)
* Gist ‚Üí automatic creation if not in repo
* Version locked in mlld-lock.json

</REGISTRY>

<PUBLISHING_PRIVATE_MODULES>
Authenticate and publish to your private repo.

```bash
mlld auth login
mlld auth status
mlld publish my-module.mld.md --private --path lib/modules --pr
```

</PUBLISHING_PRIVATE_MODULES> </CONFIGURATION>

<COMMON_MISTAKES>
<MISTAKE_MISSING_AT>

```mlld
‚ùå /var greeting = "Hello"
‚úÖ /var @greeting = "Hello"
```

</MISTAKE_MISSING_AT>

<MISTAKE_USING_AT>

```mlld
‚ùå /var @result = @run {echo "hello"}
‚úÖ /var @result = run {echo "hello"}
```

</MISTAKE_USING_AT>

<MISTAKE_INTERPOLATION>

```mlld
‚ùå Hello @name!             # plain Markdown, no interp
‚úÖ /show "Hello @name!"
```

</MISTAKE_INTERPOLATION>

<MISTAKE_NOT_TEMPLATE_LANG>

```mlld
‚ùå This is {{name}}'s doc
‚úÖ /show ::This is @name's doc::
```

</MISTAKE_NOT_TEMPLATE_LANG>

<MISTAKE_FILE_VS_STRING>

```mlld
/var @content = <README.md>     # loads contents
/var @path = "README.md"        # literal string
```

</MISTAKE_FILE_VS_STRING>

<MISTAKE_XML_VS_FILE_TAGS>
`<thinking>` is plain text; `<file.txt>` (has `.`) is a file ref.
</MISTAKE_XML_VS_FILE_TAGS>

<MISTAKE_NESTED_FUNC_CALLS>

```mlld
‚ùå # inside shell trying to call @func
/run {
  RESULT=$(@helper("x"))   # won't work
  echo $RESULT
}

‚úÖ /var @r = @helper("x")
/run @r | { cat }
```

</MISTAKE_NESTED_FUNC_CALLS>

<MISTAKE_STRING_CONCAT>
Prefer templates over manual concatenation.
</MISTAKE_STRING_CONCAT>

<MISTAKE_COMPLEX_LOGIC>
Move heavy logic to `/exe` helpers or modules; keep `.mld` orchestration simple.
</MISTAKE_COMPLEX_LOGIC>

<MISTAKE_IMPORT_BRACKETS>
Know when to use angle brackets for resolver paths; modules don‚Äôt use them.
</MISTAKE_IMPORT_BRACKETS>

<MISTAKE_NO_EARLY_EXIT>
Model alternative outcomes with `/when` and flags rather than aborting.
</MISTAKE_NO_EARLY_EXIT>
</COMMON_MISTAKES>

<REFERENCE>
Execution Context ‚Äì where interpolation applies:

| Context                | Syntax    | Example                  | Notes              |
| ---------------------- | --------- | ------------------------ | ------------------ |
| Backticks              | `@var`    | `` `Hello @name` ``      | Primary template   |
| Double-colon `::‚Ä¶::`   | `@var`    | `::Use \`cmd\` @name::\` | Escape backticks   |
| Triple-colon `:::‚Ä¶:::` | `{{var}}` | `:::Hi @{{handle}}:::`   | Escape lots of `@` |
| Commands `{‚Ä¶}`         | `@var`    | `{echo "@msg"}`          | Interpolates       |
| Double quotes          | `@var`    | `"Hi @name"`             | Interpolates       |
| Single quotes          | '@var'    | `'Hi @name'`             | Literal            |
| Directive level        | `@var`    | `/show @greeting`        | Direct reference   |

Transforms (built-in): `@json`, `@xml`, `@csv`, `@md`
Aliases: `@p` ‚â° `@pipeline` inside pipeline stages
Globs: use `<path/*.ext>` and `as "template"` with `<>` placeholder for each matched file 
</REFERENCE>

<SEE_ALSO>
Documentation: https://mlld.ai/docs

Examples: https://github.com/mlld-lang/mlld/tree/main/tests/cases/valid/feat (comprehensive test cases demonstrating features)

Source: https://github.com/mlld-lang/mlld
</SEE_ALSO>
</MLLD_GUIDE>
