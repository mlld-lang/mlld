<MLLD_GUIDE>
<TOC>
<OVERVIEW>Purpose, two execution modes, "What mlld IS/ISN'T," mental model shift.</OVERVIEW>
<CORE_RULES>
  <RULE_1_DIRECTIVES_START_LINES>Only lines beginning with / are mlld; everything else is Markdown.</RULE_1_DIRECTIVES_START_LINES>
  <RULE_2_VARIABLE_SYNTAX>Create with /var @x = ‚Ä¶ ; reference with @x in templates/commands.</RULE_2_VARIABLE_SYNTAX>
  <RULE_3_COMMANDS_NEED_BRACES>All commands use braces; language specifiers; /exe shortcuts.</RULE_3_COMMANDS_NEED_BRACES>
  <RULE_4_OUTPUT_SOURCES>Only /show, /run, /output emit output.</RULE_4_OUTPUT_SOURCES>
  <RULE_5_INTERPOLATION_CONTEXTS>Backticks/double-colon/triple-colon, quotes, and command contexts.</RULE_5_INTERPOLATION_CONTEXTS>
  <RULE_6_FIELD_ACCESS>Dot + index access for objects/arrays; array slicing [start:end].</RULE_6_FIELD_ACCESS>
  <RULE_7_PARAMETERIZED_CONTENT>Reusable templates and functions via /exe.</RULE_7_PARAMETERIZED_CONTENT>
  <RULE_8_FILE_LOADING>Angle brackets load file contents; globs; metadata fields; safety.</RULE_8_FILE_LOADING>
  <RULE_9_IMPORTS>Modules, paths, registries; "as namespace."</RULE_9_IMPORTS>
  <RULE_10_WHEN_OVERVIEW>/when forms (bare, first, simple) ‚Äì full detail in CONTROL_FLOW.</RULE_10_WHEN_OVERVIEW>
  <RULE_11_ITERATION_OVERVIEW>foreach and /for ‚Äì full detail in CONTROL_FLOW.</RULE_11_ITERATION_OVERVIEW>
  <RULE_12_OPERATORS>Logical, comparison, ternary operators for expressions.</RULE_12_OPERATORS>
</CORE_RULES>
<SYNTAX>
  <VARIABLES>Types, primitives, command results, code execution.</VARIABLES>
  <TEMPLATES>Backticks, ::‚Ä¶::, :::‚Ä¶:::; interpolation rules.</TEMPLATES>
  <FILE_LOADING>Angle brackets, metadata fields, globs, "as" templates, detection rules.</FILE_LOADING>
  <PIPELINES>Operator |, transformers, @ctx/@p context, retry/hints, inline effects.</PIPELINES>
  <COMMENTS>">>" and "<<" comments (start/end-of-line).</COMMENTS>
  <RESERVED_VARIABLES>@now, @input, @base, @debug.</RESERVED_VARIABLES>
</SYNTAX>
<COMMANDS>
  <RUN_VS_RUN_SH>Decision tree, security & syntax differences, param passing.</RUN_VS_RUN_SH>
  <EXE_EXECUTABLES>Defining shell/js/node/template/section executables; shadow env intro.</EXE_EXECUTABLES>
  <OUTPUT_DIRECTIVE>Write to files/stdout/stderr with optional formats.</OUTPUT_DIRECTIVE>
  <LOG_DIRECTIVE>Syntactic sugar for /output to stdout; works in action contexts.</LOG_DIRECTIVE>
</COMMANDS>
<CONTROL_FLOW>
  <WHEN_DECISIONS>Bare/first/simple forms, /exe...when patterns, wildcard (*), none keyword.</WHEN_DECISIONS>
  <ITERATION>foreach vs /for; nested loops; objects with _key; collection form.</ITERATION>
  <NO_EARLY_EXIT>Design flows instead of exits; patterns.</NO_EARLY_EXIT>
</CONTROL_FLOW>
<MODULES>Module-first philosophy; imports; helpers; shadow environments; isolation.</MODULES>
<PATTERNS>Tool orchestration; data pipelines; conditional workflows; guarded/step-by-step.</PATTERNS>
<CONFIGURATION>
  <ENVIRONMENT_VARIABLES>Allow-list, @input import.</ENVIRONMENT_VARIABLES>
  <FRONTMATTER>Document metadata block.</FRONTMATTER>
  <PATHS_AND_URLS>Quoted/unquoted paths, dynamic paths, URL loading.</PATHS_AND_URLS>
  <RESOLVERS>Prefixes, LOCAL/HTTP/GITHUB/REGISTRY; quick CLI setup.</RESOLVERS>
  <PUBLISHING_PRIVATE_MODULES>Auth, repo layout, commands.</PUBLISHING_PRIVATE_MODULES>
</CONFIGURATION>
<COMMON_MISTAKES>
  <MISTAKE_MISSING_AT>Create variables with @; directives use /.</MISTAKE_MISSING_AT>
  <MISTAKE_USING_AT_FOR_DIRECTIVE>@run is invalid; use /run on LHS and run / implicit RHS.</MISTAKE_USING_AT_FOR_DIRECTIVE>
  <MISTAKE_PLAIN_TEXT_INTERPOLATION>Interpolation only in directive/template contexts.</MISTAKE_PLAIN_TEXT_INTERPOLATION>
  <MISTAKE_TEMPLATE_LANGUAGE_CONFUSION>mlld ‚â† template engine; use /show or /exe.</MISTAKE_TEMPLATE_LANGUAGE_CONFUSION>
  <MISTAKE_FILE_VS_STRING>Angle brackets load content; quotes hold literal filenames.</MISTAKE_FILE_VS_STRING>
  <MISTAKE_XML_VS_FILE_TAGS><thinking> is plain text; <file.txt> is a file ref (has ./*/@).</MISTAKE_XML_VS_FILE_TAGS>
  <MISTAKE_NESTED_FUNC_CALLS>Don't shell-call @func inside commands; assign then use.</MISTAKE_NESTED_FUNC_CALLS>
  <MISTAKE_STRING_CONCAT>Prefer templates over procedural concatenation.</MISTAKE_STRING_CONCAT>
  <MISTAKE_COMPLEX_LOGIC>Move algorithms into helpers/modules.</MISTAKE_COMPLEX_LOGIC>
  <MISTAKE_IMPORT_BRACKETS>Know when to use angle brackets for path resolvers.</MISTAKE_IMPORT_BRACKETS>
  <MISTAKE_NO_EARLY_EXIT>Model flows via /when rather than exits.</MISTAKE_NO_EARLY_EXIT>
</COMMON_MISTAKES>
<REFERENCE>Execution context table, syntax summary, quick transforms list.</REFERENCE>
<SEE_ALSO>Documentation, examples repository, source code.</SEE_ALSO>
</TOC>

<OVERVIEW>
mlld is a modular prompt scripting language for dynamically assembling context and orchestrating LLMs‚Äîthink Make + npm for the LLM era, or a Unix pipe for chaining discrete AI/tool steps. It's designed to be written directly in Markdown: readable as docs, executable as workflows.

Two modes:

1. Markdown mode (default): any line not starting with `/`
2. mlld mode: lines starting with `/` (directives)

What mlld IS:

* üìã A workflow orchestrator (like Make + npm for the AI era)
* üé≠ A conductor's baton (you conduct, tools play)
* üìù Executable documentation (reads like a guide, runs like a script)
* üö¶ A logical router (route data and actions based on conditions)

What mlld ISN'T:

* ‚ùå A template engine (not Jinja/Handlebars)
* ‚ùå A shell script replacement (it orchestrates shells; doesn't replace them)

Mental model shift:

* ‚ùå "How do I implement this?" ‚Üí ‚úÖ "What tool/module handles this?"
* ‚ùå "I need an if-statement" ‚Üí ‚úÖ "I need a decision point"
* ‚ùå "Let me concatenate strings" ‚Üí ‚úÖ "Let me create a template"

Think Docker Compose or GitHub Actions: declare what happens, don't program how. </OVERVIEW>

<CORE_RULES>
<RULE_1_DIRECTIVES_START_LINES>
Only directives on lines beginning with `/` are executed.

```mlld
‚ùå Hello @name! Let me /show something.
‚úÖ
/var @greeting = `Hello @name!`
/show @greeting
```

</RULE_1_DIRECTIVES_START_LINES>

<RULE_2_VARIABLE_SYNTAX>
Create with `/var @name = "Alice"`. Reference with `@name` in templates/commands.

```mlld
/var @name = "Alice"
/show `Hello @name!`
/run {echo "User: @name"}
/run js (@name) { console.log("Hi", name) }
```

</RULE_2_VARIABLE_SYNTAX>

<RULE_3_COMMANDS_NEED_BRACES>
Every command needs braces. Use language specifiers when needed. Define executables with `/exe`.

```mlld
‚ùå /run echo "hello"
‚úÖ /run {echo "hello"}

# Language specifiers.
/run js {console.log("hi")}
# Executables
/exe @hi() = run {echo hi}
/exe @block() = run sh {
  echo "multi"; ls -la
}
/exe @calc(x) = js { return @x * 2 }
```

</RULE_3_COMMANDS_NEED_BRACES>

<RULE_4_OUTPUT_SOURCES>
Only these produce output: `/show`, `/run`, `/output`. Everything else mutates state.

```mlld
/var @secret = "hidden"      # no output
/show `Visible`
/run {echo "Also visible"}
```

</RULE_4_OUTPUT_SOURCES>

<RULE_5_INTERPOLATION_CONTEXTS>
Prefer backticks for templates; use `::‚Ä¶::` to escape backticks; use `:::‚Ä¶:::` when many `@` appear (e.g., social).

* Backticks interpolate `@var`
* Double quotes interpolate `@var`
* Single quotes are literal (no interpolation)
* Braced commands `{‚Ä¶}` interpolate `@var`

```mlld
/var @msg = `Hello @user!`
/var @note = ::Run `npm test` before deploy::
/var @tweet = :::Hey @{{handle}}‚Äîship it!:::
```

</RULE_5_INTERPOLATION_CONTEXTS>

<RULE_6_FIELD_ACCESS>
Objects/arrays use dot+index in directives and `{{ }}` in ::/::: templates. Arrays support slicing with `[start:end]`.

```mlld
/var @user = {"name":"Alice","scores":[10,20,30]}
# Directives:
/show @user.name            # Alice
/show @user.scores.1        # 20

# Array slicing:
/var @arr = [1,2,3,4,5]
/show @arr[0:3]             # [1,2,3]
/show @arr[-2:]             # [4,5] - last 2
/show @arr[:-1]             # [1,2,3,4] - all except last
/show @arr[2:]              # [3,4,5] - from index 2

# Double-colon templates:
/show ::{{user.name}} has {{user.scores.0}}::
```

</RULE_6_FIELD_ACCESS>

<RULE_7_PARAMETERIZED_CONTENT>
Use `/exe` for parameterized templates or commands.

```mlld
/exe @greet(name) = run {echo "Hello @name"}
/run @greet("Bob")

/exe @welcome(name, role) = ::Welcome {{name}}, our new {{role}}!::
/show @welcome("Rae","developer")
```

</RULE_7_PARAMETERIZED_CONTENT>

<RULE_8_FILE_LOADING>
Angle brackets load file contents (not filenames). Works in variables, templates, commands, and with globs. Only `<‚Ä¶>` containing `.`, `/`, `*`, or `@` are treated as file references‚Äîso pseudo-XML tags like `<OVERVIEW>` are safe, plain text.

```mlld
/var @content = <README.md>                 # file contents
/show <config.json>                         # prints file contents
/var @filesTxt = ["a.md","b.md"]            # literal names
/var @contents = [<a.md>, <b.md>]           # loaded contents

# Field access on loaded JSON
/var @authorEmail = <package.json>.author.email

# Globs + ‚Äúas‚Äù templates
/var @toc = <docs/*.md> as "- [<>.fm.title](<>.relative)"
```

Inline transforms (pipes):

```mlld
/var @pretty = <data.json> | @json
/var @summary = `User data: @data|@json`
```

</RULE_8_FILE_LOADING>

<RULE_9_IMPORTS>
Module imports and path imports.

```mlld
# Modules (no quotes)
/import { parallel, retry } from @mlld/core
/import @corp/utils as corp

# Paths (quote & resolver via <> when needed)
/import { readme } from "@base/README.md"
/import { helper } from "./utils.mld"
```

</RULE_9_IMPORTS>

<RULE_10_WHEN_OVERVIEW>
/when drives decisions (bare, first, simple). Full details in <CONTROL_FLOW>.

```mlld
/when @isProd => show "Prod"
/when first [
  @role=="admin" => show "Admin"
  * => show "Guest"
]
```

</RULE_10_WHEN_OVERVIEW>

<RULE_11_ITERATION_OVERVIEW>
Use `foreach` to transform collections; use `/for` to execute/collect. Full details in <CONTROL_FLOW>.

```mlld
/var @names = ["Alice","Bob"]
/exe @greet(name) = ::Hi {{name}}!::
/var @gs = foreach @greet(@names)
/for @n in @names => show `Name: @n`
```

</RULE_11_ITERATION_OVERVIEW>

<RULE_12_OPERATORS>
Logical, comparison, and ternary operators for expressions and conditions.

Comparison: `<`, `>`, `<=`, `>=`, `==`, `!=`
Logical: `&&`, `||`, `!`
Ternary: `condition ? trueVal : falseVal`

```mlld
# Expressions
/var @isValid = @score > 80 && @submitted
/var @status = @isPro ? "premium" : "basic"
/var @canEdit = @isOwner || (@role == "editor" && !@isLocked)
/var @opposite = !@condition

# Parentheses for precedence
/var @complex = (@a || @b) && (@c != @d)

# In /when conditions
/when @tokens > 1000 && @mode == "production" => show "High usage"
/when (@role == "admin" || @role == "mod") && @active => show "Privileged"
```

Type coercion: `"true" == true`, `"false" == false`, `null == undefined`
Precedence: `!` ‚Üí comparison ‚Üí `&&` ‚Üí `||` ‚Üí `?:`
</RULE_12_OPERATORS>
</CORE_RULES>

<SYNTAX>
<VARIABLES>
Create primitives, arrays, objects, or assign from command/code results. Primitives preserve JS types in `/exe js`.

```mlld
/var @n = 42
/var @price = 19.99
/var @ok = true
/var @arr = [1,2,3]
/var @obj = {"key":"value"}

/exe @add(a,b) = js { return a + b }
/var @sum = @add(@n, 8)         # 50 (number)

/var @date = run "date"         # result of command
/var @readme = <README.md>      # file contents
```

</VARIABLES>

<TEMPLATES>
Prefer backticks; use :: for backticks-in-text; ::: when many @mentions.

```mlld
/var @message = `Hello @name, welcome!`
/var @doc = ::Use `mlld` to orchestrate::
/var @tweet = :::Hey @{{handle}}‚Äî{{msg}}:::
```

</TEMPLATES>

<FILE_LOADING>
Angle brackets load, quotes store literal paths. Field access and globs are supported.

```mlld
/var @author = <package.json>.author
/var @firstEmail = <data.json>.users[0].email
/var @md = <docs/*.md> as "# <>.filename"
```

Detection rule: only `<‚Ä¶>` with `.`, `/`, `*`, or `@` are treated as file refs. XML-like `<TAG>` is plain text.

File metadata fields: `content` (default), `filename`, `relative`, `absolute`, `tokens`, `tokest`, `fm` (frontmatter), `json` (for .json files)

URL metadata fields: All file fields plus: `url`, `domain`, `title`, `description`, `html`, `text`, `md`, `headers`, `status`, `contentType`
</FILE_LOADING>

<PIPELINES>
Chain stages with `|`. Built-ins: @json, @xml, @csv, @md (upper/lower accepted). Stages access context via `@ctx` and pipeline history via `@p`.

```mlld
/var @users = run {cat users.json} | @json | @csv
/exe @double(n) = js {(@n*2)}
/var @x = run {echo "5"} | @double

# Retry with hints
/exe @validator(input) = when [
  @input.valid => @input
  @ctx.try < 3 => retry "need more detail"
  * => "fallback"
]
/var @res = @raw | @validator

# Best-of-N pattern
/exe @selectBest(response) = when [
  @response.score > 8 => @response
  @ctx.try < 5 => retry { temperature: 0.9 }
  * => @selectHighestScore(@p.retries.all)
]
```

Context object (@ctx): `try` (attempt #), `tries` (array), `stage`, `input`, `hint` (from retry), `lastOutput`, `isPipeline`

Pipeline array (@p): `@p[0]` (input), `@p[-1]` (previous output), `@p.retries.all` (full history)

Inline effects: `@data | @transform | log` (stderr), `@data | output to "file.txt"` (inline write)

Formats (`with { format: "json|csv|xml|text" }`): guide parsing for pipeline stages.

</PIPELINES>

<COMMENTS>
Use `>>` or `<<` for comments at start or end of lines.

```mlld
>> start-of-line
/show "Hello"  >> end-of-line
/var @x = 5    << end-of-line
```

</COMMENTS>

<RESERVED_VARIABLES>

* `@now` ‚Äì current timestamp
* `@input` ‚Äì stdin/env (must be allowed)
* `@base` ‚Äì project root
* `@debug` ‚Äì environment info
  </RESERVED_VARIABLES>

  </SYNTAX>

<COMMANDS>
<RUN_VS_RUN_SH>
Decision tree:

* Single line + pipes only (`|`) ‚Üí `run { ‚Ä¶ }`
* Needs `&&`, `||`, control flow, or multi-line ‚Üí `run sh { ‚Ä¶ }`
* JavaScript (no shell) ‚Üí `js { ‚Ä¶ }` (or `/exe ‚Ä¶ = js { ‚Ä¶ }`)

Parameter syntax:

* `run` / commands: interpolate with `@param`
* `run sh`: shell variables as `$param`

```mlld
# run (pipes only)
/run {echo Hello | tr '[:lower:]' '[:upper:]'}

# run sh (multi-line/conditionals)
/run sh {
  npm test && npm run build || echo "Build failed"
}

# Executable wrappers
/exe @safeDeploy(env) = run sh {
  npm test && npm run deploy:$env
}
```

Security: `run` forbids `&&`/`||` to reduce injection risk; escalate to `run sh` when necessary.
</RUN_VS_RUN_SH>

<EXE_EXECUTABLES>
Define reusable commands/code/templates/sections.

```mlld
# Shell (single vs multi)
/exe @list(dir) = run {ls -la @dir | head -5}
/exe @script() = run sh {
  echo "Start"; ls -la
}

# JavaScript
/exe @add(a,b) = js { return a + b }

# Templates
/exe @greet(name) = `Hello @name!`

# Section extractor
/exe @intro(file) = <@file # Introduction>
```

Shadow environments (JS/Node):
Expose JS helpers across `js {}` blocks in the same module:

```mlld
/exe @double(n) = js { return n*2 }
/exe @cap(s) = js { return s[0].toUpperCase()+s.slice(1) }
/exe js = { double, cap }  # expose

/var @out = js { cap("hello") + ": " + double(5) }  # "Hello: 10"
```

</EXE_EXECUTABLES>

<OUTPUT_DIRECTIVE>
Write data to files or streams, with optional format.

```mlld
/output @content to "out.txt"
/output @data to "config.json"
/output @html to "page.html" as html
/output @message to stdout
/output @error to stderr
/output @config to "settings.yaml" as yaml
```

</OUTPUT_DIRECTIVE>

<LOG_DIRECTIVE>
Syntactic sugar for `/output to stdout`. Works in action contexts.

```mlld
/log @message                        # same as /output @message to stdout
/log `Processing: @item`

# In action contexts
/for @item in @items => log @item
/when @debug => log "Debug info"
/when [
  @valid => log "Success"
  none => log "Failed validation"
]
```

</LOG_DIRECTIVE> </COMMANDS>

<CONTROL_FLOW>
<WHEN_DECISIONS>
Forms:

* Simple: `/when @cond => action`
* Bare (evaluate all matches):

  ```mlld
  /when [
    @score > 90 => show "Excellent!"
    @isBonus => show "Bonus!"
    none => show "No matches"
  ]
  ```
* Switch (`first` stops at first match):

  ```mlld
  /when first [
    @role=="admin" => show "Admin"
    @role=="user"  => show "User"
    * => show "Guest"
  ]
  ```

`/exe...when` patterns (value-returning):

```mlld
# Basic handler with fallback
/exe @handler(input) = when [
  @input.valid => @input.value
  @ctx.try < 3 => retry "validation failed"
  none => "default"
]

# Switch-style with first
/exe @parser(type, data) = when first [
  @type == "json" => @parseJSON(@data)
  @type == "xml" => @parseXML(@data)
  @type == "csv" => @parseCSV(@data)
  * => @data
]

# Conditional transformer
/exe @process(item) = when [
  @item.priority > 5 => @urgent(@item)
  @item.archived => null
  * => @standard(@item)
]
```

Notes:

* RHS uses action words (no `/show` slash): `show`, `@func()`, `@var = "x"`
* `*` wildcard matches anything (catch-all)
* `none` executes only if no conditions matched (must appear after all regular conditions, incompatible with `*`)
* One action per line (repeat condition for multiple actions)
* Parentheses & `&&`/`||` supported in conditions
  </WHEN_DECISIONS>

<ITERATION>
`foreach` returns a transformed array; `/for` executes an action per item or collects results.

```mlld
# foreach (transform)
/var @names = ["alice","bob","charlie"]
/exe @greet(name) = ::Hi {{name}}!::
/var @greetings = foreach @greet(@names)

# /for (execute)
/for @n in @names => show `Name: @n`

# collection form
/var @nums = [1,2,3]
/var @doubled = for @x in @nums => js { return @x * 2 }  # [2,4,6]

# objects and keys
/var @cfg = {"host":"localhost","port":3000}
/for @v in @cfg => show `@v_key: @v`

# nested for loops
/for @x in ["A","B"] => for @y in [1,2] => show `@x-@y`
# Output: A-1, A-2, B-1, B-2

# triple nesting
/for @x in @outer => for @y in @middle => for @z in @inner => show `@x/@y/@z`
```

Empty arrays are safe: `/for` emits nothing; `for ‚Ä¶ =>` returns `[]`. </ITERATION>

<NO_EARLY_EXIT>
mlld has no `return/exit`. Model outcomes with `/when` and flags.

```mlld
/var @check = @validate(@input)
/when [
  @check.valid => @process(@input)
  !@check.valid => show `Error: @check.message`
]
```

</NO_EARLY_EXIT>
</CONTROL_FLOW>

<MODULES>
Module-first philosophy: keep `.mld` files readable; move complexity into focused modules that expose capabilities (like microservices). Avoid "kitchen sink" modules or side effects on import.

* Use `/import` to compose capabilities
* Create helpers via `/exe`, expose with shadow envs (per language, per module)
* JS and Node have separate shadow environments; no cross-pollution
* Prefer clear namespaces: `/import @corp/utils as utils`

```mlld
---
module: @myorg/github-utils
description: GitHub operations
---

/exe @getPR(number, repo) = run {gh pr view ...}
/exe @listIssues(repo) = run {gh issue list ...}
/exe @createRelease(tag, notes) = run {gh release create ...}
/exe js = {}  # expose JS helpers if any
```

</MODULES>

<PATTERNS>
Tool orchestration:

```mlld
/var @areas = [
  {"name":"auth","files":["auth/*.ts"],"tests":["test/auth/*"]},
  {"name":"api","files":["api/*.ts"],"tests":["test/api/*"]}
]
/exe @runQA(area) = run {echo "Testing @area.name" | cat}
/var @results = foreach @runQA(@areas)
```

Data pipeline:

```mlld
/import { fetchData, validate, transform } from @data/pipeline
/var @raw = @fetchData("https://api.example.com/users")
/var @valid = @validate(@raw, { schema: "user" })
/var @report = @transform(@valid, { format: "report" })
/show `Processed @report.count users`
```

Conditional workflows:

```mlld
/import { getPR, commentOnPR } from @company/github
/var @pr = @getPR(@MLLD_PR_NUMBER)
/when first [
  @pr.mergeable => @status = "ready"
  * => @status = "blocked"
]
/when [
  @status=="ready"   => @commentOnPR(@MLLD_PR_NUMBER,"Ready to merge")
  @status=="blocked" => show "Needs attention"
]
```

Step-by-step & guarded execution:

```mlld
/var @processed = @data | @validate | @normalize | @analyze
/when [
  @processed.ok => @emitReport(@processed)
  !@processed.ok => show "‚ùå Validation failed"
]
```

</PATTERNS>

<CONFIGURATION>
<ENVIRONMENT_VARIABLES>
Allow environment variables in `mlld.lock.json` (prefix `MLLD_`), then import via `@input`.

```json
{
  "security": {
    "allowedEnv": ["MLLD_NODE_ENV","MLLD_API_KEY","MLLD_GITHUB_TOKEN"]
  }
}
```

```mlld
/import { MLLD_NODE_ENV, MLLD_API_KEY } from @input
/show `Running in @MLLD_NODE_ENV`
```

</ENVIRONMENT_VARIABLES>

<FRONTMATTER>
Use frontmatter to describe the pipeline:

```yaml
---
description: Pipeline description
version: 1.0.0
author: Your Name
---
```

</FRONTMATTER>

<PATHS_AND_URLS>
Paths may be literal (single quotes), interpolated (double), or bare resolver names; URLs are supported as sources.

```mlld
/var @dir = "./docs"
/var @userFile = "data/@username/profile.json"
/var @template = 'templates/@var.html'  # literal '@'

/show <https://raw.githubusercontent.com/org/repo/main/README.md>
/var @remote = <https://example.com/README.md>
```

</PATHS_AND_URLS>

<RESOLVERS>
Configure prefixes that map to resolvers (LOCAL/HTTP/GITHUB/REGISTRY). Add via CLI or `mlld.lock.json`.

CLI quick setup:

```bash
mlld setup
mlld setup --github
mlld alias --name shared --path ../shared-modules
mlld alias --name desktop --path ~/Desktop --global
```

Manual config:

```json
{
  "version": "1.0",
  "config": {
    "resolvers": {
      "prefixes": [
        {"prefix":"@lib/","resolver":"LOCAL","config":{"basePath":"./src/lib"}},
        {"prefix":"@shared/","resolver":"LOCAL","config":{"basePath":"../shared-modules"}}
      ]
    }
  },
  "modules": {}
}
```

GitHub (private):

```json
{
  "version": "1.0",
  "config": {
    "resolvers": {
      "prefixes": [
        {
          "prefix":"@myorg/",
          "resolver":"GITHUB",
          "config":{"repository":"myorg/private-mlld-modules","branch":"main","basePath":"modules"}
        }
      ]
    }
  }
}
```

</RESOLVERS>

<PUBLISHING_PRIVATE_MODULES>
Authenticate and publish to your private repo.

```bash
mlld auth login
mlld auth status
mlld publish my-module.mld.md --private --path lib/modules --pr
```

</PUBLISHING_PRIVATE_MODULES> </CONFIGURATION>

<COMMON_MISTAKES>
<MISTAKE_MISSING_AT>

```mlld
‚ùå /var greeting = "Hello"
‚úÖ /var @greeting = "Hello"
```

</MISTAKE_MISSING_AT>

<MISTAKE_USING_AT_FOR_DIRECTIVE>

```mlld
‚ùå /var @result = @run {echo "hello"}
‚úÖ /var @result = run {echo "hello"}
```

</MISTAKE_USING_AT_FOR_DIRECTIVE>

<MISTAKE_PLAIN_TEXT_INTERPOLATION>

```mlld
‚ùå Hello @name!             # plain Markdown, no interp
‚úÖ /show "Hello @name!"
```

</MISTAKE_PLAIN_TEXT_INTERPOLATION>

<MISTAKE_TEMPLATE_LANGUAGE_CONFUSION>

```mlld
‚ùå This is {{name}}'s doc
‚úÖ /show ::This is {{name}}'s doc::
```

</MISTAKE_TEMPLATE_LANGUAGE_CONFUSION>

<MISTAKE_FILE_VS_STRING>

```mlld
/var @content = <README.md>     # loads contents
/var @path = "README.md"        # literal string
```

</MISTAKE_FILE_VS_STRING>

<MISTAKE_XML_VS_FILE_TAGS>
`<thinking>` is plain text; `<file.txt>` (has `.`) is a file ref.
</MISTAKE_XML_VS_FILE_TAGS>

<MISTAKE_NESTED_FUNC_CALLS>

```mlld
‚ùå # inside shell trying to call @func
/run {
  RESULT=$(@helper("x"))   # won't work
  echo $RESULT
}

‚úÖ /var @r = @helper("x")
/run {echo "@r"}
```

</MISTAKE_NESTED_FUNC_CALLS>

<MISTAKE_STRING_CONCAT>
Prefer templates over manual concatenation.
</MISTAKE_STRING_CONCAT>

<MISTAKE_COMPLEX_LOGIC>
Move heavy logic to `/exe` helpers or modules; keep `.mld` orchestration simple.
</MISTAKE_COMPLEX_LOGIC>

<MISTAKE_IMPORT_BRACKETS>
Know when to use angle brackets for resolver paths; modules don‚Äôt use them.
</MISTAKE_IMPORT_BRACKETS>

<MISTAKE_NO_EARLY_EXIT>
Model alternative outcomes with `/when` and flags rather than aborting.
</MISTAKE_NO_EARLY_EXIT>
</COMMON_MISTAKES>

<REFERENCE>
Execution Context ‚Äì where interpolation applies:

| Context                | Syntax    | Example                  | Notes              |
| ---------------------- | --------- | ------------------------ | ------------------ |
| Backticks              | `@var`    | `` `Hello @name` ``      | Primary template   |
| Double-colon `::‚Ä¶::`   | `@var`    | `::Use \`cmd\` @name::\` | Escape backticks   |
| Triple-colon `:::‚Ä¶:::` | `{{var}}` | `:::Hi @{{handle}}:::`   | Escape lots of `@` |
| Commands `{‚Ä¶}`         | `@var`    | `{echo "@msg"}`          | Interpolates       |
| Double quotes          | `@var`    | `"Hi @name"`             | Interpolates       |
| Single quotes          | '@var'    | `'Hi @name'`             | Literal            |
| Directive level        | `@var`    | `/show @greeting`        | Direct reference   |

Transforms (built-in): `@json`, `@xml`, `@csv`, `@md`
Aliases: `@p` ‚â° `@pipeline` inside pipeline stages
Globs: use `<path/*.ext>` and `as "template"` with `<>` placeholder for each matched file 
</REFERENCE>

<SEE_ALSO>
Documentation: https://mlld.ai/docs

Examples: https://github.com/mlld-lang/mlld/tree/main/tests/cases/valid/feat (comprehensive test cases demonstrating features)

Source: https://github.com/mlld-lang/mlld
</SEE_ALSO>
</MLLD_GUIDE>
